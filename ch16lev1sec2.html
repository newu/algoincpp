<html><head><title>16.2. Indexed Sequential Access</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch16lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch16lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch16lev1sec2"></a>
<h3 id="title-IDAMZJ5G" class="docSection1Title">16.2. Indexed Sequential Access</h3>
<p class="docText"><a name="iddle1120"></a><a name="iddle1467"></a><a name="iddle1647"></a><a name="iddle1710"></a><a name="iddle1985"></a><a name="iddle2341"></a>A straightforward approach to building an index is to keep an array with keys and item references, in order of the keys, then to use binary search (see <a class="docLink" href="ch12lev1sec4.html#ch12lev1sec4">Section 12.4</a>) to implement <span class="docEmphasis">search</span>. For <span class="docEmphasis">N</span> items, this method would require <tt>lg</tt> <span class="docEmphasis"><tt>N</tt></span> probes&mdash;even for a huge file. Our basic model leads us immediately to consider two modifications to this simple method. First, the index itself is huge and will not fit on a single page, in general. Since we can access pages only through page references, we can build, instead, an explicit fully balanced binary tree with keys and page pointers in internal nodes, and with keys and item pointers in external nodes. Second, the cost of accessing <span class="docEmphasis">M</span> table entries is the same as the the cost of accessing 2, so we can use an <span class="docEmphasis">M</span>-ary tree for about the same cost per node as a binary tree. This improvement reduces the number of probes to be proportional to about <tt>log</tt><span class="docEmphasis"><tt><sub>M</sub></tt></span> <span class="docEmphasis"><tt>N</tt></span>. As we saw in <a class="docLink" href="ch10.html#ch10">Chapters 10</a> and <a class="docLink" href="ch15.html#ch15">15</a>, we can regard this quantity to be constant for practical purposes. For example, if <span class="docEmphasis">M</span> is 1000, then <tt>log</tt><span class="docEmphasis"><tt><sub>M</sub></tt></span> <span class="docEmphasis">N</span> is less than 5 if <span class="docEmphasis">N</span> is less than 1 trillion.</p>
<p class="docText"><a class="docLink" href="#ch16fig01">Figure 16.1</a> gives a sample set of keys, and <a class="docLink" href="#ch16fig02">Figure 16.2</a> depicts an example of such a tree structure for those keys. We need to use relatively small values of <span class="docEmphasis">M</span> and <span class="docEmphasis">N</span> to keep our examples manageable; nevertheless, they illustrate that the trees for large <span class="docEmphasis">M</span> will be flat.</p>
<a name="ch16fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 16.1. Binary representation of octal keys</h5>
<h5></h5><h5></h5></center></p><p class="docText">The keys (left) that we use in the examples in this chapter are 3-digit octal numbers, which we also interpret as 9-bit binary values (right).</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="100" height="399" src="16fig01.gif" /></p>
<br />
<a name="ch16fig02"></a><p><center>
<h5 class="docFigureTitle">Figure 16.2. Indexed sequential file structure</h5>
<h5></h5><h5></h5></center></p><p class="docText">In a sequential index, we keep the keys in sequential order in full pages (right), with an index directing us to the smallest key in each page (left). To add a key, we need to rebuild the data structure.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="175" height="372" src="16fig02.gif" /></p>
<br />
<p class="docText">The tree depicted in <a class="docLink" href="#ch16fig02">Figure 16.2</a> is an abstract device-independent representation of an index that is similar to many other data structures that we have considered. Note that, in addition, it is not far removed from device- <span class="docEmphasis">dependent</span> indexes that might be found in low-level disk access software. For example, some early systems used a two-level scheme, where the bottom level corresponded to the items on the <a name="iddle1358"></a><a name="iddle1366"></a><a name="iddle1465"></a><a name="iddle1469"></a><a name="iddle1490"></a><a name="iddle1635"></a>pages for a particular disk device, and the second level corresponded to a master index to the individual devices. In such systems, the master index was kept in main memory, so accessing an item with such an index required two disk accesses: one to get the index, and one to get the page containing the item. As disk capacity increases, so increases the size of the index, and several pages might be required to store the index, eventually leading to a hierarchical scheme like the one depicted in <a class="docLink" href="#ch16fig02">Figure 16.2</a>. We shall continue working with an abstract representation, secure in the knowledge that it can be implemented directly with typical low-level system hardware and software.</p>
<p class="docText">Many modern systems use a similar tree structure to organize huge files as a sequence of disk pages. Such trees contain no keys, but they can efficiently support the commonly used operations of accessing the file in sequential order, and, if each node contains a count of its tree size, of finding the page containing the kth item in the file.</p>
<p class="docText">Historically, because it combines a sequential key organization with indexed access, the indexing method depicted in <a class="docLink" href="#ch16fig02">Figure 16.2</a> is called <span class="docEmphasis">indexed sequential access</span>. It is the method of choice for applications in which changes to the database are rare. We sometimes refer to the index itself as a <span class="docEmphasis">directory</span>. The disadvantage of using indexed sequential access is that modifying the directory is an expensive operation. For example, adding a single key can require rebuilding virtually the whole database, with new positions for many of the keys and new values for the indexes. To combat this defect and to provide for modest growth, early systems provided for overflow pages on disks and overflow space in pages, but such techniques ultimately were not very effective in dynamic situations (see <a class="docLink" href="#ch16qa1q3">Exercise 16.3</a>). The methods that we consider in <a class="docLink" href="ch16lev1sec3.html#ch16lev1sec3">Sections 16.3</a> and <a class="docLink" href="ch16lev1sec4.html#ch16lev1sec4">16.4</a> provide systematic and efficient alternatives to such ad hoc schemes.</p>
<a name="ch16ex02"></a><h5 id="title-IDASCY0B" class="docExampleTitle">Property 16.1. <span class="docEmphasis">A search in an indexed sequential file requires only a constant number of probes, but an insertion can involve rebuilding the entire index</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We use the term <span class="docEmphasis">constant</span> loosely here (and throughout this chapter) to refer to a quantity that is proportional to <tt>log</tt><span class="docEmphasis"><tt><sub>M</sub></tt></span> <span class="docEmphasis">N</span> for large <span class="docEmphasis">M</span>. As we have discussed, this usage is justified for practical file sizes. <a class="docLink" href="#ch16fig03">Figure 16.3</a> gives more examples. Even if we were to have a 128-bit search key, capable of specifying the impossibly large number of <tt>2<sup>128</sup></tt> different items, we could find an item with a given key in 13 probes, with 1000-way branching.</p>
</td></tr></table></p>
<a name="ch16fig03"></a><p><center>
<h5 class="docFigureTitle">Figure 16.3. Examples of data set sizes</h5>
<h5></h5><h5></h5></center></p><p class="docText">These generous upper bounds indicate that we can assume safely, for practical purposes, that we will never have a symbol table with more than <tt>10</tt><sup>30</sup> items. Even in such an unrealistically huge database, we could find an item with a given key with less than 10 probes, if we did 1000-way branching. Even if we somehow found a way to store information on each electron in the universe, 1000-way branching would give us access to any particular item with less than 27 probes.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="175" height="197" src="16fig03.gif" /></p>
<br />
<p class="docText"><a name="iddle1107"></a><a name="iddle1135"></a><a name="iddle1456"></a><a name="iddle1843"></a><a name="iddle2537"></a>We will not consider implementations that search and construct indexes of this type, because they are special cases of the more general mechanisms that we consider in <a class="docLink" href="ch16lev1sec3.html#ch16lev1sec3">Section 16.3</a> (see <a class="docLink" href="ch16lev1sec3.html#ch16qa2q13">Exercise 16.17</a> and <a class="docLink" href="ch16lev1sec3.html#ch16ex05">Program 16.2</a>).</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa1q1"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">16.1</span> Tabulate the values of <tt>log</tt> <span class="docEmphasis"><tt><sub>M</sub></tt></span> <span class="docEmphasis"><tt>N</tt></span>, for <span class="docEmphasis"><tt>M</tt></span> <tt>= 10, 100</tt>, and <tt>1000</tt> and <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa1q2"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">16.2</span> Draw an indexed sequential file structure for the keys <tt>516, 177, 143, 632, 572, 161, 774, 470, 411, 706, 461, 612, 761, 474, 774, 635, 343, 461, 351, 430, 664, 127, 345, 171</tt>, and <tt>357</tt>, for <span class="docEmphasis"><tt>M</tt></span> <tt>= 5</tt> and <span class="docEmphasis"><tt>M</tt></span> <tt>= 6</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa1q3"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">16.3</span> Suppose that we build an indexed sequential file structure for <span class="docEmphasis">N</span> items in pages of capacity <span class="docEmphasis">M</span>, but leave <span class="docEmphasis">k</span> empty spaces in each page for expansion. Give a formula for the number of probes needed for a search, as a function of <span class="docEmphasis">N</span>, <span class="docEmphasis">M</span>, and <span class="docEmphasis">k</span>. Use the formula to determine the number of probes needed for a search when <span class="docEmphasis"><tt>k</tt></span> <tt>=</tt> <span class="docEmphasis"><tt>M</tt></span><tt>/10</tt>, for <span class="docEmphasis"><tt>M</tt></span> <tt>= 10, 100</tt>, and <tt>1000</tt> and <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt></p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa1q4"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">16.4</span> Suppose that the cost of a probe is about &#945;time units, and that the average cost of finding an item in a page is about <span class="docEmphasis">&#946; M</span> time units. Find the value of <span class="docEmphasis">M</span> that minimizes the cost for a search in an indexed sequential file structure, for <span class="docEmphasis"><tt>&#945;/&#946;</tt></span> <tt>= 10, 100</tt>, and <tt>1000</tt> and <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch16lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch16lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>