<html><head><title>6.8. Index and Pointer Sorting</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch06lev1sec7.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch06lev1sec9.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch06lev1sec8"></a>
<h3 id="title-IDACEIVM" class="docSection1Title">6.8. Index and Pointer Sorting</h3>
<p class="docText">The development of a string data type implementation similar to <a class="docLink" href="ch06lev1sec7.html#ch06ex22">Programs 6.9</a> and <a class="docLink" href="ch06lev1sec7.html#ch06ex23">6.10</a> is of particular interest, because character strings are widely used as sort keys. Moreover, since strings are variable-length and can be very long, constructing, deleting, and comparing strings can be very expensive, so we have to take particular care to ensure that our implementation does not lead to excessive and unneccesary use of these operations.</p>
<p class="docText">To this end, we use a data representation that consists of a pointer (to an array of characters), the standard C-style string representation. Then, we can change the first line in <a class="docLink" href="ch06lev1sec7.html#ch06ex22">Program 6.9</a> to</p>
<div class="docText"><pre>typedef struct { char *str; } Item;</pre></div><br />
<p class="docText">to convert it to an interface for strings. We put the pointer in a <tt>struct</tt> because C++ does not allow us to overload <tt>operator&lt;</tt> for built-in types such as pointers. This kind of situation is not unusual in C++: A class (or <tt>struct</tt>) that adjusts the interface to another data type is called a <span class="docEmphasis">wrapper class</span>. Even though we are asking very little of the wrapper class in this case, a more complicated implementation might be worthwhile in some situations. We will consider another example soon.</p>
<p class="docText"><a name="iddle1642"></a><a name="iddle1874"></a><a name="iddle2382"></a><a name="iddle2397"></a><a class="docLink" href="#ch06ex24">Program 6.11</a> is an implementation for string items. The overloaded <tt>operator&lt;</tt> is easily implemented with the C library string-comparison function, but the implementation of <tt>scan</tt> (and <tt>rand</tt>) is more challenging because we must be aware of the allocation of memory for the strings. <a class="docLink" href="#ch06ex24">Program 6.11</a> uses the method that we examined in <a class="docLink" href="ch03.html#ch03">Chapter 3</a> (<a class="docLink" href="ch03lev1sec7.html#ch03ex20">Program 3.17</a>), maintaining a buffer in the data-type implementation. Other options are to allocate memory dynamically for each string, to use a class implementation like <tt>String</tt> in the Standard Template Library, or to keep the buffer in the client program. We can use any of these approaches (with corresponding interfaces) to sort strings of characters, using any of the sort implementations that we have been considering.</p>
<p class="docText">We are faced with memory-management choices of this kind any time that we modularize a program. Who should be responsible for managing the memory corresponding to the concrete realization of some type of object: the client, the data-type implementation, or the system? There is no hard-and-fast answer to this question (some programming-language designers become evangelical when the question is raised). Some modern programming systems (including some C++ implementations) have general mechanisms for dealing with memory management automatically. We will revisit this issue in <a class="docLink" href="ch09.html#ch09">Chapter 9</a>, when we discuss the implementation of a more sophisticated abstract data type.</p>
<p class="docText"><a class="docLink" href="#ch06ex24">Program 6.11</a> is an example of a <span class="docEmphasis">pointer sort</span>, which we shall consider in more generality shortly. Another simple approach for sorting without (intermediate) moves of items is to maintain an <span class="docEmphasis">index array</span> with keys in the items accessed only for comparisons. Suppose that the items to be sorted are in an array <tt>data[0]</tt>, . . ., <tt>data[N-1]</tt>, and that we do not wish to move them around, for some reason (perhaps they are huge). To get the effect of sorting, we use a <span class="docEmphasis">second</span>array <span class="docEmphasis">a</span> of item indices. We begin by initializing <tt>a[i]</tt> to <span class="docEmphasis">i</span> for <tt>i = 0</tt>, . . ., <tt>N-1</tt>. That is, we begin with <tt>a[0]</tt> having the index of the first data item, <tt>a[1]</tt> having the index of the second data item, and so on. The goal of the sort is to rearrange the index array <span class="docEmphasis">a</span> such that <tt>a[0]</tt> gives the index of the data item with the smallest key, <tt>a[1]</tt> gives the index of the data item with the second smallest key, and so on. Then we can achieve the effect of sorting by accessing the keys through the <a name="iddle1772"></a><a name="iddle2439"></a>indices&mdash;for example, we could print out the array in sorted order in this way.</p>
<a name="ch06ex24"></a><h5 id="title-IDAHKIVM" class="docExampleTitle">Program 6.11. Data-type implementation for string items</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This implementation allows us to use our sorting programs to sort C strings. For the data representation, we use a structure that contains a pointer to a character (<span class="docEmphasis">see text</span>), so a sort will process an array of pointers to characters, rearranging them so the indicated strings are in alphanumeric order. To clearly illustrate the memory management process, we define a storage buffer of a fixed size containing the string characters in this module; dynamic allocation is perhaps more appropriate. The implementation of <tt>rand</tt> is omitted.</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "Item.h"
static char buf[100000];
static int cnt = 0;
int operator&lt;(const Item&amp; a, const Item&amp; b)
  { return strcmp(a.str, b.str) &lt; 0; }
void show(const Item&amp; x)
  { cout &lt;&lt; x.str &lt;&lt; " "; }
int scan(Item&amp; x)
  { int flag = (cin &gt;&gt; (x.str = &amp;buf[cnt])) != 0;
    cnt += strlen(x.str)+1;
    return flag;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">We need to specify that our sorts will be processing array indices, not just ordinary integers. Our goal is to define a type <tt>Index</tt> so that we can overload <tt>operator&lt;</tt>, as follows:</p>
<div class="docText"><pre>
int operator&lt;(const Index&amp; i, const Index&amp; j)
  { return data[i] &lt; data[j]; }</pre></div><br />
<p class="docText">If we have an array <span class="docEmphasis">a</span> of objects of type <tt>Index</tt>, then any of our sort functions will rearrange the indices in <span class="docEmphasis">a</span> to make <tt>a[i]</tt> specify the number of keys that are smaller than <tt>data[i]</tt> (the index of <tt>a[i]</tt> in the sorted array). (For simplicity, this discussion assumes that the data are keys, rather than full items&mdash;we can use the same principle <a name="iddle1524"></a><a name="iddle1708"></a><a name="iddle1769"></a><a name="iddle2072"></a><a name="iddle2147"></a><a name="iddle2404"></a>for larger, more complicated items, by modifying <tt>operator&lt;</tt> to access specific keys in the items, or to use a class member function to compute the key.) To define <tt>Index</tt>, we use a wrapper class:</p>
<div class="docText"><pre>
struct intWrappper
  {
    int item;
    intWrapper(int i = 0)
      { item = i; }
    operator int() const
      { return item; }
  };
typedef intWrapper Index;</pre></div><br />
<p class="docText">The constructor in this <tt>struct</tt> converts any <tt>int</tt> to an <tt>Index</tt> and the cast <tt>operator int()</tt> converts any <tt>Index</tt> back to an <tt>int</tt>, so we can use objects of type <tt>Index</tt> anywhere that we can use objects of built-in type <tt>int</tt>.</p>
<p class="docText">An example of indexing, with the same items sorted by two different keys, is shown in <a class="docLink" href="#ch06fig14">Figure 6.14</a>. One client program can define <tt>operator&lt;</tt> to use one key and another client program can define <tt>operator&lt;</tt> to use another key, but both can use the same sort program to produce an index array that allows them to access the items in order of their respective keys.</p>
<a name="ch06fig14"></a><p><center>
<h5 class="docFigureTitle">Figure 6.14. Index sorting example</h5>
<h5></h5><h5></h5></center></p><p class="docText">By manipulating indices, rather than the records themselves, we can sort an array simultaneously on several keys. For this sample data that might represent students'names and grades, the second column is the result of an index sort on the name, and the third column is the result of an index sort on the grade. For example, Wilson is last in alphabetic order and has the tenth highest grade, while Adams is first in alphabetic order and has the sixth highest grade.</p><h5></h5><p class="docText">A rearrangement of the N distinct nonnegative integers less than <span class="docEmphasis">N</span> is called a <span class="docEmphasis">permutation</span> in mathematics: an index sort computes a permutation. In mathematics, permutations are normally defined as rearrangements of the integers <tt>1</tt> tHRough <span class="docEmphasis">N</span>; we shall use <tt>0</tt> through <span class="docEmphasis">N</span> &ndash; 1 to emphasize the direct relationship between permutations and C++ array indices.</p>
<p class="docText">
<img border="0" alt="" width="175" height="154" src="06fig14.gif" /></p>
<br />
<p class="docText">This index-array approach to indirection will work in any programming language that supports arrays. Another possibility is to use pointers, as in the string data-type implementation that we just considered (<a class="docLink" href="#ch06ex24">Program 6.11</a>). For sorting an array of fixed-size items, a pointer sort is essentially equivalent to an index sort, but with the address of the array added to each index. But a pointer sort is much more general than an index sort, because the pointers could point anywhere, and the items being sorted do not need to be fixed in size. As is true in index sorting, if <span class="docEmphasis">a</span> is an array of pointers to keys, then a call to <tt>sort</tt> will result in the pointers being rearranged such that accessing them sequentially will access the keys in order. We implement comparisons by following pointers; we implement exchanges by exchanging the pointers.</p>
<p class="docText">The standard C library sort function <tt>qsort</tt> is a pointer sort (see <a class="docLink" href="ch03lev1sec7.html#ch03ex20">Program 3.17</a>) which takes its comparison function as an argument (rather than relying on overloaded <tt>operator&lt;</tt>, as we have been doing). The function takes four arguments: the array; the number of items <a name="iddle1716"></a><a name="iddle1773"></a><a name="iddle2440"></a>to be sorted; the size of the items; and a pointer to a function that compares two items, given pointers to them. For example, if <tt>Item</tt> is <tt>char*</tt>, then the following code implements a string sort that adheres to our conventions:</p>
<div class="docText"><pre>int compare(void *i, void *j)
  { return strcmp(*(Item *)i, *(Item *)j); }
void sort(Item a[], int l, int r)
  { qsort(a, r-l+1, sizeof(Item), compare); }</pre></div><br />
<a name="ch06ex25"></a><h5 id="title-IDANC0WD" class="docExampleTitle">Program 6.12. Data-type interface for record items</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The records have two keys: a string key (for example, a name) in the first field, and an integer key (for example, a grade) in the second field. We consider these records too large to copy, so we define <tt>Item</tt> to be a <tt>struct</tt> containing a pointer to a record.</p>
<div class="docText"><pre>struct record { char name[30]; int num; };
typedef struct { record *r; } Item;
int operator&lt;(const Item&amp;, const Item&amp;);
void rand(Item&amp;);
void show(const Item&amp;);
int scan(Item&amp;);</pre></div><br />
</td></tr></table></p>
<p class="docText">The underlying algorithm is not specified in the interface, but quicksort (see <a class="docLink" href="ch07.html#ch07">Chapter 7</a>) is widely used. In <a class="docLink" href="ch07.html#ch07">Chapter 7</a> we shall consider many of the reasons why this is true. We also, in this chapter and in <a class="docLink" href="ch07.html#ch07">Chapters 7</a> through <a class="docLink" href="ch11.html#ch11">11</a>, develop an understanding of why other methods might be more appropriate for some specific applications, and we explore approaches for speeding up the computation when the sort time is a critical factor in an application.</p>
<p class="docText">In typical applications, the pointers are used to access records that may contain several possible keys. For example, records consisting of students' names and grades or people's names and ages might be defined by</p>
<div class="docText"><pre>struct record { char[30] name; int num; }</pre></div><br />
<p class="docText">and we might wish to sort them using either of the fields as key. <a class="docLink" href="#ch06ex25">Programs 6.12</a> and <a class="docLink" href="#ch06ex26">6.13</a> provide an example of a pointer sort interface and implementation that can allow us to do so. We use an array of pointers to records and provide different implementations of <tt>operator&lt;</tt> for <a name="iddle1643"></a><a name="iddle1709"></a><a name="iddle2383"></a>different sort applications. For example, if we compile <a class="docLink" href="#ch06ex26">Program 6.13</a> together with a file containing</p>
<div class="docText"><pre>#include "Item.h"
int operator&lt;(const Item &amp;a, const Item &amp;b)
{ return a.r-&gt;num &lt; b.r-&gt;num; }</pre></div><br />
<p class="docText">then we get a data type for the items for which any of our <tt>sort</tt> implementations will do a pointer sort on the integer field; and if we compile <a class="docLink" href="#ch06ex26">Program 6.13</a> together with a file containing</p>
<div class="docText"><pre>#include "Item.h"
#include &lt;string.h&gt;
int operator&lt;(const Item &amp;a, const Item &amp;b)
  { return strcmp(a.r-&gt;name, b.r-&gt;name) &lt; 0; }</pre></div><br />
<p class="docText">then we get a data type for the items for which any of our <tt>sort</tt> implementations will do a pointer sort on the string field.</p>
<a name="ch06ex26"></a><h5 id="title-IDADH0WD" class="docExampleTitle">Program 6.13. Data-type implementation for record items</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">These implementations of the <tt>scan</tt> and <tt>show</tt> functions for records operate in a manner similar to the string data-type implementation of <a class="docLink" href="#ch06ex24">Program 6.11</a>, in that they allocate and maintain the memory for the records. We keep the implementation of <tt>operator&lt;</tt> in a separate file, so that we can substitute different implementations, and therefore change sort keys, without changing any other code.</p>
<div class="docText"><pre>static record data[maxN];
static int cnt = 0;
void show(const Item&amp; x)
  { cout &lt;&lt; x.r-&gt;name &lt;&lt; " " &lt;&lt; x.r-&gt;num &lt;&lt; endl; }
int scan(Item&amp; x)
  {
    x.r = &amp;data[cnt++];
    return (cin &gt;&gt; x.r-&gt;name &gt;&gt; x.r-&gt;num) != 0;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">The primary reason to use indices or pointers is to avoid intruding on the data being sorted. We can &quot;sort&quot; a file even if read-only access is all that is available. Moreover, with multiple index or pointer arrays, we can sort one file on multiple keys (see <a class="docLink" href="#ch06fig14">Figure 6.14</a>). This flexibility to manipulate the data without actually changing them is useful in many applications.</p>
<p class="docText"><a name="iddle1661"></a><a name="iddle2386"></a>A second reason for manipulating indices is that we can avoid the cost of moving full records. The cost savings is significant for files with large records (and small keys), because the comparison needs to access just a small part of the record, and most of the record is not even touched during the sort. The indirect approach makes the cost of an exchange roughly equal to the cost of a comparison for general situations involving arbitrarily large records (at the cost of the extra space for the indices or pointers). Indeed, if the keys are long, the exchanges might even wind up being less costly than the comparisons. When we estimate the running times of methods that sort files of integers, we are often making the assumption that the costs of comparisons and exchanges are not much different. Conclusions based on this assumption are likely to apply to a broad class of applications, if we use pointer or index sorts.</p>
<p class="docText">For many applications, the data never need to be rearranged physically to match the order indicated by the indices, and we can simply access them in order using the index array. If this approach is not satisfactory for some reason, we are led to a classic programming exercise: How do we rearrange a file that has been sorted with an index sort? The code</p>
<div class="docText"><pre>for (i = 0; i &lt; N; i++) datasorted[i] = data[a[i]];</pre></div><br />
<p class="docText">is trivial, but requires extra memory sufficient for another copy of the array. What about the situation when there is not enough room for another copy of the file? We cannot blindly set <tt>data[i] = data[a[i]]</tt>, because that would overwrite the previous value of <tt>data[i]</tt>, perhaps prematurely.</p>
<p class="docText"><a class="docLink" href="#ch06fig15">Figure 6.15</a> illustrates how we can solve this problem, still using a single pass through the file. To move the first element where it belongs, we move the element at that position to where it belongs, and so forth. Continuing this reasoning, we eventually find an element to move to the first position, at which point we have shifted a cycle of elements into position. Then, we move to the second element and perform the same operation for its cycle, and so forth (any elements that we encounter that are already in position (<tt>a[i]=i</tt>) are on a cycle of length 1 and are not moved).</p>
<a name="ch06fig15"></a><p><center>
<h5 class="docFigureTitle">Figure 6.15. In-place sort</h5>
<h5></h5><h5></h5></center></p><p class="docText">To rearrange an array in place, we move from left to right, moving elements that need to be moved in cycles. Here, there are four cycles: The first and last are single-element degenerate cases. The second cycle starts at 1. The S goes into a temporary variable, leaving a hole at 1. Moving the second A there leaves a hole at 10. This hole is filled by P, which leaves a hole at 12. That hole is to be filled by the element at position 1, so the reserved S goes into that hole, completing the cycle 1 10 12 that puts those elements in position. Similarly, the cycle 2 8 6 13 4 7 11 3 14 9 completes the sort.</p>
<p class="docText">
<img border="0" alt="" width="200" height="260" src="06fig15.gif" /></p>
<br />
<p class="docText">Specifically, for each value of <tt>i</tt>, we save the value of <tt>data[i]</tt> and initialize an index variable <tt>k</tt> to <tt>i</tt>. Now, we think of a hole in the array at <tt>i</tt>, and seek an element to fill the hole. That element is <a name="iddle1649"></a><a name="iddle2385"></a><tt>data[a[k]]</tt>&mdash;in other words, the assignment <tt>data[k] = data[a[k]]</tt> moves the hole to <tt>a[k]</tt>. Now the hole is at <tt>data[a[k]]</tt>, so we set <tt>k</tt> to <tt>a[k]</tt>. Iterating, we eventually get to a situation where the hole needs to be filled by <tt>data[i]</tt>, which we have saved. When we move an element into position we update the <tt>a</tt> array to so indicate. Any element in position has <tt>a[i]</tt> equal to <tt>i</tt>, and the process just outlined is a no-op in that case. Continuing through the array, starting a new cycle each time that we encounter an element not yet moved, we move every element at most once. <a class="docLink" href="#ch06ex27">Program 6.14</a> is an implementation of this process.</p>
<a name="ch06ex27"></a><h5 id="title-IDAVM0WD" class="docExampleTitle">Program 6.14. In-place sort</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The array <tt>data[0], . . . , data[N-1]</tt> is to be rearranged in place as directed by the index array <tt>a[0], . . ., a[N-1]</tt>. Any element with <tt>a[i] == i</tt> is in place and does not need to be touched again. Otherwise, save <tt>data[i]</tt> as <tt>v</tt> and work through the cycle <tt>a[i]</tt>, <tt>a[a[i]]</tt>, <tt>a[a[a[[[i]]]</tt>, and so on, until reaching the index <tt>i</tt> again. We follow the process again for the next element which is not in place, and continue in this manner, ultimately rearranging the entire file, moving each record only once.</p>
<div class="docText"><pre>template &lt;class Item&gt;
void insitu(Item data[], Index a[], int N)
  { for (int i = 0; i &lt; N; i++)
      { Item v = data[i];
        int j, k;
        for (k = i; a[k] != i; k = a[j], a[j] = j)
          { j = k; data[k] = data[a[k]]; }
        data[k] = v; a[k] = k;
      }
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">This process is called <span class="docEmphasis">in situ permutation</span>, or <span class="docEmphasis">in-place rearrangement</span> of the file. Again, although the algorithm is interesting, it is unnecessary in many applications, because accessing the data indirectly often suffices. Also, if the records are huge relative to their number, the most efficient option may be simply to rearrange them with a conventional selection sort (see <a class="docLink" href="ch06lev1sec5.html#ch06ex11">Property 6.5</a>).</p>
<p class="docText">Indirect sorting requires extra space for the index or pointer array and extra time for the indirect comparisons. In many applications, <a name="iddle1804"></a><a name="iddle2395"></a>these costs are a small price to pay for the flexibility of not having to move the data at all. For files consisting of large records, we will almost always choose to use an indirect sort, and for many applications, we will find that it is not necessary to move the data at all. In this book, we normally will access data directly. In a few applications, however, we do use pointers or index arrays to avoid data movement, for precisely the reasons mentioned here.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa8q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.57</span> Give an implementation of a data type for items where the items are records, rather than pointers to records. This arrangement might be preferable to <a class="docLink" href="#ch06ex25">Programs 6.12</a> and <a class="docLink" href="#ch06ex26">6.13</a> for small records. (Remember that C++ supports structure assignment.)</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa8q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">6.58</span> Show how to use <tt>qsort</tt> to solve the sorting problem that is addressed in <a class="docLink" href="#ch06ex25">Programs 6.12</a> and <a class="docLink" href="#ch06ex26">6.13</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa8q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">6.59</span> Give the index array that results when the keys E A S Y Q U E S T I O N are index sorted.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa8q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">6.60</span> Give the sequence of data moves required to permute the keys E A S Y Q U E S T I O N in place after an index sort (see <a class="docLink" href="#ch06qa8q3">Exercise 6.59</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa8q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.61</span> Describe a permutation of size <span class="docEmphasis">N</span> (a set of values for the array <tt>a</tt>) that maximizes the number of times that <tt>a[i] != i</tt> during <a class="docLink" href="#ch06ex27">Program 6.14</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa8q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.62</span> Prove that we are guaranteed to return to the key with which we started when moving keys and leaving holes in <a class="docLink" href="#ch06ex27">Program 6.14</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa8q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.63</span> Implement a program like <a class="docLink" href="#ch06ex27">Program 6.14</a> corresponding to a pointer sort. Assume that the pointers point into an array of <span class="docEmphasis">N</span> records, of type <tt>Item</tt>.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch06lev1sec7.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch06lev1sec9.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>