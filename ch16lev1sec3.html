<html><head><title>16.3. B Trees</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch16lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch16lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch16lev1sec3"></a>
<h3 id="title-IDAEEH0B" class="docSection1Title">16.3. B Trees</h3>
<p class="docText">To build search structures that can be effective in a dynamic situation, we build multiway trees, but we relax the restriction that every node must have <span class="docEmphasis">exactly</span> <span class="docEmphasis">M</span> entries. Instead, we insist that every node must have <span class="docEmphasis">at most</span> <span class="docEmphasis">M</span> entries, so that they will fit on a page, but we allow nodes to have fewer entries. To be sure that nodes have a sufficient number of entries to provide the branching that we need to keep search paths short, we also insist that all nodes have <span class="docEmphasis">at least</span> (say) <span class="docEmphasis">M/</span>2 entries, except possibly the root, which must have a least one entry (two links). The reason for the exception at the root will become clear when we consider the construction algorithm in detail. Such trees were named <span class="docEmphasis">B trees</span> by <a class="docLink" href="ch16lev2sec1.html#biblio16_003">Bayer</a> and <a class="docLink" href="ch16lev2sec1.html#biblio16_003">McCreight</a>, who, in 1970, were the first researchers to consider the use of multiway balanced trees for external searching. Many people reserve the term <span class="docEmphasis">B tree</span> to describe the exact data structure <a name="iddle1109"></a>built by the algorithm suggested by Bayer and McCreight; we use it as a generic term to refer to a family of related algorithms.</p>
<p class="docText">We have already seen a B-tree implementation: In <a class="docLink" href="ch13lev1sec3.html#ch13ex11">Definitions 13.1</a> and <a class="docLink" href="ch13lev1sec3.html#ch13ex12">13.2</a>, we see that B trees of order 4, where each node has at most four links and at least two links, are none other than the balanced 2-3-4 trees of <a class="docLink" href="ch13.html#ch13">Chapter 13</a>. Indeed, the underlying abstraction generalizes in a straightforward manner, and we can implement B trees by generalizing the top-down 2-3-4 tree implementations in <a class="docLink" href="ch13lev1sec4.html#ch13lev1sec4">Section 13.4</a>. However, the various differences between external and internal searching that we discussed in <a class="docLink" href="ch16lev1sec1.html#ch16lev1sec1">Section 16.1</a> lead us to a number of different implementation decisions. In this section, we consider an implementation that</p>
<ul><li><p class="docList">Generalizes 2-3-4 trees to trees with between <span class="docEmphasis">M/</span>2 and <span class="docEmphasis">M</span> nodes</p></li><li><p class="docList">Represents multiway nodes with an array of items and links</p></li><li><p class="docList">Implements an index instead of a search structure containing the items</p></li><li><p class="docList">Splits from the bottom up</p></li><li><p class="docList">Separates the index from the items</p></li></ul>
<p class="docText">The final two properties in this list are not essential, but are convenient in many situations and are normally found in B tree implementations.</p>
<p class="docText"><a class="docLink" href="#ch16fig04">Figure 16.4</a> illustrates an abstract 4-5-6-7-8 tree, which generalizes the 2-3-4 tree that we considered in <a class="docLink" href="ch13lev1sec3.html#ch13lev1sec3">Section 13.3</a>. The generalization is straightforward: 4-nodes have three keys and four links, 5-nodes have four keys and five links, and so forth, with one link for each possible interval between keys. To search, we start at the root and move from one node to the next by finding the proper interval for the search key in the current node and then exiting through the corresponding link to get to the next node. We terminate the search with a search hit if we find the search key in any node that we touch; we terminate with a search miss if we reach the bottom of the tree without a hit. As we can in top-down 2-3-4 trees, we can insert a new key at the bottom of the tree after a search if, on the way down the tree, we split nodes that are full: If the root is an 8-node, we split it into a 2-node connected to two 4-nodes; then, any time we see a <span class="docEmphasis">k</span>-node attached to an 8-node, we replace it by a (<span class="docEmphasis">k</span> + 1)-node attached to two 4-nodes. This policy guarantees that we have room to insert the new node when we reach the bottom.</p>
<a name="ch16fig04"></a><p><center>
<h5 class="docFigureTitle">Figure 16.4. A 4-5-6-7-8 tree</h5>
<h5></h5><h5></h5></center></p><p class="docText">This figure depicts a generalization of 2-3-4 trees built from nodes with 4 through 8 links (and 3 through 7 keys, respectively). As with 2-3-4 trees, we keep the height constant by splitting 8-nodes when encountering them, with either a top-down or a bottom-up insertion algorithm. For example, to insert another J into this tree, we would first split the 8-node into two 4-nodes, then insert the <tt>M</tt> into the root, converting it into a 6-node. When the root splits, we have no choice but to create a new root that is a 2-node, so the root node is excused from the constraint that nodes must have at least four links.</p>
<p class="docText">
<img border="0" alt="" width="320" height="43" src="16fig04.gif" /></p>
<br />
<p class="docText">Alternatively, as discussed for 2-3-4 trees in <a class="docLink" href="ch13lev1sec3.html#ch13lev1sec3">Section 13.3</a>, we can split from the bottom up: We insert by searching and putting the new key in the bottom node, unless that node is a 8-node, in which case we split it into two 4-nodes and insert the middle key and the links to the two new nodes into its parent, working up the tree until encountering an ancestor that is not a 8-node.</p>
<p class="docText">Replacing 4 by <span class="docEmphasis">M/</span>2 and 8 by <span class="docEmphasis">M</span> in descriptions in the previous two paragraphs converts them into descriptions of search and insert for <span class="docEmphasis">M/2-...-M</span> trees, for any positive even integer <span class="docEmphasis">M</span>, even 2 (see <a class="docLink" href="#ch16qa2q5">Exercise 16.9</a>).</p>
<a name="ch16ex03"></a><h5 id="title-IDASKH0B" class="docExampleTitle">Definition 16.2. A <span class="docEmphasis">B tree</span> of order M is a tree that either is empty or comprises <span class="docEmphasis">k-nodes</span>, with k - <span class="docEmphasis">1</span> keys and k links to trees representing each of the k intervals delimited by the keys, and has the following structural properties: k must be between <span class="docEmphasis">2</span> and M at the root and between M/<span class="docEmphasis">2</span> and M at every other node; and all links to empty trees must be at the same distance from the root.</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">B tree algorithms are built upon this basic set of abstractions. As in <a class="docLink" href="ch13.html#ch13">Chapter 13</a>, we have a great deal of freedom in choosing concrete representations for such trees. For example, we can use an extended red-black representation (see <a class="docLink" href="ch13lev1sec4.html#ch13qa5q22">Exercise 13.69</a>). For external searching, we use the even more straightforward ordered-array representation, taking <span class="docEmphasis">M</span> to be sufficiently large that <span class="docEmphasis">M</span>-nodes fill a page. The branching factor is at least <span class="docEmphasis">M/</span>2, so the number of probes for any search or insert is effectively constant, as discussed following <a class="docLink" href="ch16lev1sec2.html#ch16ex02">Property 16.1</a>.</p>
<p class="docText">Instead of implementing the method just described, we consider a variant that generalizes the standard index that we considered in <a class="docLink" href="ch16lev1sec1.html#ch16lev1sec1">Section 16.1</a>. We keep keys with item references in <span class="docEmphasis">external pages</span>at the bottom of the tree, and copies of keys with page references in <span class="docEmphasis">internal pages</span>. We insert new items at the bottom, and then use the basic <span class="docEmphasis">M/2-. . .-M</span> tree abstraction. When a page has <span class="docEmphasis">M</span> entries, we split it into two pages with <span class="docEmphasis">M/</span>2 pages each, and insert a reference to the new page into its parent. When the root splits, we make a new root with two children, thus increasing the height of the tree by 1.</p>
<p class="docText"><a class="docLink" href="#ch16fig05">Figures 16.5</a> through <a class="docLink" href="#ch16fig07">16.7</a> show the B tree that we build by inserting the keys in <a class="docLink" href="ch16lev1sec2.html#ch16fig01">Figure 16.1</a> (in the order given) into an initially empty tree, with <span class="docEmphasis">M</span> = 5. Doing insertions involves simply adding an item to a page, but we can look at the final tree structure to determine the significant events that occurred during its construction. It has seven external pages, so there must have been six external node splits, and it is of height 3, so the root of the tree must have split twice. These events are described in the commentary that accompanies the figures.</p>
<a name="ch16fig05"></a><p><center>
<h5 class="docFigureTitle">Figure 16.5. B tree construction, part 1</h5>
<h5></h5><h5></h5></center></p><p class="docText">This example shows six insertions into an initially empty B tree built with pages that can hold five keys and links, using keys that are 3-digit octal numbers (9-bit binary numbers). We keep the keys in order in the pages. The sixth insertion causes a split into two external nodes with three keys each and an internal node that serves as an index: Its first pointer points to the page containing all keys greater than or equal to <tt>000</tt> but less than <tt>601</tt>, and its second pointer points to the page containing all keys greater than or equal to <tt>601</tt>.</p><p class="docText"><div class="v1"><a target="_blank" href="16fig05_alt.gif">[View full size image]</a></div><img border="0" alt="" width="500" height="112" src="16fig05.gif" /></p>
</td></tr></table></p><br />
<a name="ch16fig06"></a><p><center>
<h5 class="docFigureTitle">Figure 16.6. B tree construction, part 2</h5>
<h5></h5><h5></h5></center></p><p class="docText">After we insert the four keys <tt>742, 373, 524</tt>, and <tt>766</tt> into the rightmost B tree in <a class="docLink" href="#ch16fig05">Figure 16.5</a>, both of the external pages are full (left). Then, when we insert <tt>275</tt>, the first page splits, sending a link to the new page (along with its smallest key <tt>373</tt>) up to the index (center); when we then insert <tt>737</tt>, the page at the bottom splits, again sending a link to the new page up to the index (right).</p><p class="docText"><div class="v1"><a target="_blank" href="16fig06_alt.gif">[View full size image]</a></div><img border="0" alt="" width="500" height="247" src="16fig06.gif" /></p>
<br />
<a name="ch16fig07"></a><p><center>
<h5 class="docFigureTitle">Figure 16.7. B tree construction, part 3</h5>
<h5></h5><h5></h5></center></p><p class="docText">Continuing our example, we insert the 13 keys <tt>574, 434, 641, 207, 001, 277, 061, 736, 526, 562, 017, 107</tt>, and <tt>147</tt> into the rightmost B tree in <a class="docLink" href="#ch16fig06">Figure 16.6</a>. Node splits occur when we insert <tt>277</tt> (left), <tt>526</tt> (center), and <tt>107</tt> (right). The node split caused by inserting <tt>526</tt> also causes the index page to split, and increases the height of the tree by one.</p><p class="docText"><div class="v1"><a target="_blank" href="16fig07_alt.gif">[View full size image]</a></div><img border="0" alt="" width="500" height="390" src="16fig07.gif" /></p>
<br />
<p class="docText"><a class="docLink" href="#ch16ex04">Program 16.1</a> gives the type definitions for nodes for our B-tree implementation. We do not specify the structure of nodes in the detail that would be required in an actual implementation, because that should involve reference to specific disk pages. For clarity, we use one node type, each node consisting of an array of entries that each contain an item, a key, and a link. Each node also contains a count giving the number of active entries. We do not refer to the items in internal nodes; we do not refer to the links in external nodes; and we do not refer to the keys within the items in the tree. The precise data structure that we would choose in an application might save space by using constructs such as <tt>union</tt> or derived classes. We could also choose to trade space for time by using links to items everywhere in the tree instead of keys. Such design decisions involve straightforward modifications to our code and depend on the precise nature of an application's keys, items, and links.</p>
<a name="ch16ex04"></a><h5 id="title-IDA5RH0B" class="docExampleTitle">Program 16.1. B-tree node-type definitions</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Each node in a B tree contains an array and a count of the number of active entries in the array. Each array entry is a key, an item, and a link to a node. In internal nodes, we use only the keys and links; in external nodes, we use only the keys and items. We initialize new nodes to be empty by setting the count field to 0.</p>
<div class="docText"><pre>    template &lt;class Item, class Key&gt;
      struct entry
        { Key key; Item item; struct node *next; };
    struct node
      { int m; entry&lt;Item, Key&gt; b[M];
        node() { m = 0;}
      };
    typedef node *link;</pre></div><br />
</td></tr></table></p>
<p class="docText">With these definitions and the example trees that we just considered, the code for <span class="docEmphasis">search</span> that is given in <a class="docLink" href="#ch16ex05">Program 16.2</a> is straightforward. For external nodes, we scan through the array of nodes to look for a key matching the search key, returning the associated item if we succeed and a null item if we do not. For internal nodes, we scan through the array of nodes to find the link to the unique subtree that could contain the search key.</p>
<p class="docText"><a class="docLink" href="#ch16ex07">Program 16.3</a> is an implementation of <span class="docEmphasis">insert</span> for B trees; it too uses the recursive approach that we have taken for numerous other search-tree implementations in <a class="docLink" href="ch13.html#ch13">Chapters 13</a> and <a class="docLink" href="ch15.html#ch15">15</a>. It is a bottom-up implementation because we check for node splitting <span class="docEmphasis">after</span> the recursive call, so the first node split is an external node. The split requires that we pass up a new link to the parent of the split node, which in turn might need to split and pass up a link to its parent, and so forth, perhaps all the way up to the root of the tree (when the root splits, we create a new root, with two children). By contrast, the 2-3-4&ndash;tree implementation of <a class="docLink" href="ch13lev1sec4.html#ch13ex15">Program 13.6</a> checks for splits <span class="docEmphasis">before</span> the recursive call, so we do splitting on the way down the tree. We could also use a top-down approach for B trees (see <a class="docLink" href="#ch16qa2q5">Exercise 16.10</a>). This distinction between top-down versus bottom-up approaches is unimportant in many B tree applications, because the trees are so flat.</p>
<p class="docText">&nbsp;<a name="iddle1108"></a><a name="iddle1361"></a><a name="iddle1461"></a><a name="iddle1948"></a><a name="iddle2021"></a><a name="iddle2280"></a><a name="iddle1112"></a></p>
<p class="docText"></p><a name="ch16ex05"></a><h5 id="title-IDALWH0B" class="docExampleTitle">Program 16.2. B-tree search</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This implementation of <span class="docEmphasis">search</span> for B trees is based on a recursive function, as usual. For internal nodes (positive height), we scan to find the first key larger than the search key, and do a recursive call on the subtree referenced by the previous link. For external nodes (height 0), we scan to see whether or not there is an item with key equal to the search key.</p>
<div class="docText"><pre>     private:
       Item searchR(link h, Key v, int ht)
         { int j;
           if (ht == 0)
             for (j = 0; j &lt; h-&gt;m; j++)
               { if (v == h-&gt;b[j].key)
                   return h-&gt;b[j].item; }
           else 
             for (j = 0; j &lt; h-&gt;m; j++)
               if ((j+1 == h-&gt;m) || (v &lt; h-&gt;b[j+1].key))
                 return searchR(h-&gt;b[j].next, v, ht-1);
           return nullItem;
         }
     public:
       Item search(Key v)
         { return searchR(head, v, HT);}</pre></div><br />
</td></tr></table></p>
<p class="docText">The node-splitting code is given in <a class="docLink" href="#ch16ex08">Program 16.4</a>. In the code, we use an even value for the variable <span class="docEmphasis">M</span>, and we allow only <span class="docEmphasis">M</span> - 1 items per node in the tree. This policy allows us to insert the <span class="docEmphasis">M</span>th item into a node <span class="docEmphasis">before</span> splitting that node, and simplifies the code considerably without having much effect on the cost (see <a class="docLink" href="#ch16qa2q16">Exercises 16.20</a> and <a class="docLink" href="#ch16qa2q17">16.21</a>). For simplicity, we use the upper bound of M items per node in the analytic results later in this section; the actual differences are minute. In a top-down implementation, we would not have to resort to this technique, because the convenience of being sure that there is always room to insert a new key in each node comes automatically.</p>
</td></tr></table>
<a name="ch16ex06"></a><h5 id="title-IDAIYH0B" class="docExampleTitle">Property 16.2. <span class="docEmphasis">A search or an insertion in a B tree of order M with N items requires between</span> <span class="docEmphRoman">log</span><span class="docEmphasis"><sub>M</sub> N and</span> <span class="docEmphRoman">log</span><span class="docEmphasis"><sub>M/</sub><sub>2</sub> N probes&mdash;a constant number, for practical purposes</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This property follows from the observation that all the nodes in the interior of the B tree (nodes that are not the root and are not external) have between <span class="docEmphasis">M/</span>2 and <span class="docEmphasis">M</span> links, since they are formed from a split of a full node with <span class="docEmphasis">M</span> keys, and can only grow in size (when a lower node is split). In the best case, these nodes form a complete tree of degree <span class="docEmphasis">M</span>, which leads immediately to the stated bound (see <a class="docLink" href="ch16lev1sec2.html#ch16ex02">Property 16.1</a>). In the worst case, we have a complete tree of degree <span class="docEmphasis">M/</span>2.</p>
</td></tr></table></p>
<p class="docText"></p><a name="ch16ex07"></a><h5 id="title-IDA3ZH0B" class="docExampleTitle">Program 16.3. B-tree insertion</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We insert new items by moving larger items to the right by one position, as in insertion sort. If the insertion overfills the node, we call split to divide the node into two halves, and then insert the link to the new node into the parent internal node, which could also split, possibly propagating the insertion all the way up to the root.</p>
<div class="docText"><pre>private:
  link insertR(link h, Item x, int ht)
    { int i, j; Key v = x.key(); entry&lt;Item, Key&gt; t;
      t.key = v; t.item = x;
      if (ht == 0)
        for (j = 0; j &lt; h-&gt;m; j++)
          { if (v &lt; h-&gt;b[j].key) break; }
      else 
        for (j = 0; j &lt; h-&gt;m; j++)
          if ((j+1 == h-&gt;m) || (v &lt; h-&gt;b[j+1].key))
            { link u;
              u = insertR(h-&gt;b[j++].next, x, ht-1);
              if (u == 0) return 0; t.key = u-&gt;b[0].key; 
              t.next = u;
              break;
            }
     for (i = h-&gt;m; i &gt; j; i--) h-&gt;b[i] = h-&gt;b[i-1];
     h-&gt;b[j] = t;
     if (++h-&gt;m &lt; M) return 0; else return split(h);
    }
public:
  ST(int maxN)
    { N = 0; HT = 0; head = new node; }
  void insert(Item item)
    { link u = insertR(head, item, HT);
      if (u == 0) return;
      link t = new node(); t-&gt;m = 2;
      t-&gt;b[0].key = head-&gt;b[0].key;
      t-&gt;b[1].key = u-&gt;b[0].key;
      t-&gt;b[0].next = head; t-&gt;b[1].next = u;
      head = t; HT++;
    }</pre></div><br />
</td></tr></table></p>
<p class="docText"></p><a name="ch16ex08"></a><h5 id="title-IDAW0H0B" class="docExampleTitle">Program 16.4. B-tree node split</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">To split a node in a B tree, we create a new node, move the larger half of the keys to the new node, and then adjust counts and set sentinel keys in the middle of both nodes. This code assumes that <tt>M</tt> is even, and uses an extra position in each node for the item that causes the split. That is, the maximum number of keys in a node is <tt>M-1</tt>, and when a node gets <tt>M</tt> keys, we split it into two nodes with <tt>M/2</tt> keys each.</p>
<div class="docText"><pre>link split(link h)
  { link t = new node();
    for (int j = 0; j &lt; M/2; j++)
      t-&gt;b[j] = h-&gt;b[M/2+j];
    h-&gt;m = M/2; t-&gt;m = M/2;
    return t;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">When <span class="docEmphasis">M</span> is 1000, the height of the tree is less than three for <span class="docEmphasis">N</span> less than 125 million. In typical situations, we can reduce the cost to two probes by keeping the root node in internal memory. For a disk-searching implementation, we might take this step explicitly before embarking on any application involving a huge number of searches; in a virtual memory with caching, the root node will be the one most likely to be in fast memory, because it is the most frequently accessed node.</p>
<p class="docText">We can hardly expect to have a search implementation that can guarantee a cost of fewer than two probes for <span class="docEmphasis">search</span> and <span class="docEmphasis">insert</span> in huge files, and B trees are widely used because they allow us to achieve this ideal. The price of this speed and flexibility is the empty space within the nodes, which could be a liability for huge files.</p>
<a name="ch16ex09"></a><h5 id="title-IDAH2H0B" class="docExampleTitle">Property 16.3. <span class="docEmphasis">A B tree of order M constructed from N random items is expected to have about</span> <span class="docEmphRoman">1.44</span><span class="docEmphasis">N/M pages</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Yao proved this fact in 1979, using mathematical analysis that is beyond the scope of this book (<span class="docEmphasis">see reference section</span>). It is based on analyzing a simple probabilistic model that describes tree growth. After the first <span class="docEmphasis">M/</span>2 nodes have been inserted, there are, at any given time, <span class="docEmphasis">t<sub>i</sub></span> external pages with <span class="docEmphasis">i</span> items, for <span class="docEmphasis">M/2 <img src="U2264.GIF" border="0" /> i <img src="U2264.GIF" border="0" />  M</span>, with <span class="docEmphasis">t<sub>M/</sub><sub>2</sub> + . . . + t<sub>M</sub> = N</span>. Since each interval between nodes is equally likely to receive a random key, the probability that a node with i items is hit is <span class="docEmphasis">t<sub>i</sub>/N</span>. Specifically, for <span class="docEmphasis">i &lt; M</span>, this quantity is the probability that the number of external pages with <span class="docEmphasis">i</span> items decreases by 1 and the number of external pages with (<span class="docEmphasis">i</span> + 1) items increases by 1; and for <span class="docEmphasis">i</span> = 2<span class="docEmphasis">M</span>, this quantity is the probability that the number of external pages with 2<span class="docEmphasis">M</span> items decreases by 1 and the number of external pages with <span class="docEmphasis">M</span> items increases by 2. Such a probabilistic process is called a <span class="docEmphasis">Markov chain</span>. Yao's result is based on an analysis of the asymptotic properties of this chain.</p>
</td></tr></table></p>
<p class="docText"><a name="iddle1110"></a><a name="iddle1111"></a><a name="iddle1113"></a><a name="iddle1847"></a><a name="iddle2629"></a>We can also validate <a class="docLink" href="#ch16ex09">Property 16.3</a> by writing a program to simulate the probabilistic process (see <a class="docLink" href="#ch16qa2q7">Exercise 16.11</a> and <a class="docLink" href="#ch16fig08">Figures 16.8</a> and <a class="docLink" href="#ch16fig09">16.9</a>). Of course, we also could just build random B trees and measure their structural properties. The probabilistic simulation is simpler to do than either the mathematical analysis or the full implementation, and is an important tool for us to use in studying and comparing variants of the algorithm (see, for example, <a class="docLink" href="#ch16qa2q12">Exercise 16.16</a>).</p>
<a name="ch16fig08"></a><p><center>
<h5 class="docFigureTitle">Figure 16.8. Growth of a large B tree</h5>
<h5></h5><h5></h5></center></p><p class="docText">In this simulation, we insert items with random keys into an initially empty B tree with pages that can hold nine keys and links. Each line displays the external nodes, with each external node depicted as a line segment of length proportional to the number of items in that node. Most insertions land in an external node that is not full, increasing that node's size by 1. When an insertion lands in a full external node, the node splits into two nodes of half the size.</p>
<p class="docText">
<img border="0" alt="" width="275" height="394" src="16fig08.gif" /></p>
<br />
<a name="ch16fig09"></a><p><center>
<h5 class="docFigureTitle">Figure 16.9. Growth of a large B tree, page occupancy exposed</h5>
<h5></h5><h5></h5></center></p><p class="docText">This version of <a class="docLink" href="#ch16fig08">Figure 16.8</a> shows how pages fill during the B tree growth process. Again, most insertions land in a page that is not full and just increase its occupancy by 1. When an insertion does land in a full page, the page splits into two half-empty pages.</p>
<p class="docText">
<img border="0" alt="" width="400" height="417" src="16fig09.gif" /></p>
<br />
<p class="docText">The implementations of other symbol-table operations are similar to those for several other tree-based representations that we have seen before, and are left as exercises (see <a class="docLink" href="#ch16qa2q18">Exercises 16.22</a> through <a class="docLink" href="#ch16qa2q21">16.25</a>). In particular, <span class="docEmphasis">select</span> and <span class="docEmphasis">sort</span> implementations are straightforward, but as usual, implementing a proper <span class="docEmphasis">remove</span> can be a challenging task. Like <span class="docEmphasis">insert</span>, most <span class="docEmphasis">remove</span> operations are a simple matter of removing an item from an external page and decrementing its counter, but what do we do when we have to remove an item from a node that has only <span class="docEmphasis">M/</span>2 items? The natural approach is to find items from sibling nodes to fill the space (perhaps reducing the number of nodes by one), but the implementation becomes complicated because we have to track down the keys associated with any items that we move among nodes. In practical situations, we can typically adopt the much simpler approach of letting external nodes become underfull, without suffering much performance degradation (see <a class="docLink" href="#ch16qa2q21">Exercise 16.25</a>).</p>
<p class="docText">Many variations on the basic B-tree abstraction suggest themselves immediately. One class of variations saves time by packing as many page references as possible in internal nodes, thereby increasing the branching factor and flattening the tree. As we have discussed, the benefits of such changes are marginal in modern systems, since standard values of the parameters allow us to implement <span class="docEmphasis">search</span> and <span class="docEmphasis">insert</span> with two probes&mdash;an efficiency that we could hardly improve. Another class of variations improves storage efficiency by combining nodes with siblings before splitting. <a class="docLink" href="#ch16qa2q9">Exercises 16.13</a> through <a class="docLink" href="#ch16qa2q12">16.16</a> are concerned with such a method, which reduces the excess storage used from 44 to 23 percent, for random keys. As usual, the proper choice among different variations depends on properties of applications. Given the broad variety of different situations where B trees are applicable, we will not consider such issues in detail. We also will not be able to consider details of implementations, because there are so many device- and system-dependent matters to take into account. As usual, delving deeply into such implementations is a risky business, and we shy away from such fragile and nonportable code in modern systems, particularly when the basic algorithm performs so well.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q1"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">16.5</span>Give the contents of the 3-4-5-6 tree that results when you insert the keys E A S Y Q U E S T I O N W I T H P L E N T Y O F K E Y S in that order into an initially empty tree.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q2"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">16.6</span> Draw figures corresponding to <a class="docLink" href="#ch16fig05">Figures 16.5</a> through <a class="docLink" href="#ch16fig07">16.7</a>, to illustrate the process of inserting the keys <tt>516, 177, 143, 632, 572, 161, 774, 470, 411, 706, 461, 612, 761, 474, 774, 635, 343, 461, 351, 430, 664, 127, 345, 171,</tt> and <tt>357</tt> in that order into an initially empty tree, with <span class="docEmphasis"><tt>M = 5</tt></span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q3"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">16.7</span> Give the height of the B trees that result when you insert the keys in <a class="docLink" href="#ch16qa2q2">Exercise 16.6</a> in that order into an initially empty tree, for <span class="docEmphasis">each</span> value of <span class="docEmphasis">M</span> &gt; 2.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">16.8</span> Draw the B tree that results when you insert 16 equal keys into an initially empty tree, with <span class="docEmphasis">M = 4</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q5"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">16.9</span> Draw the 1-2 tree that results when you insert the keys EASYQ UES T I O N into an initially empty tree. Explain why 1-2 trees are not of practical interest as balanced trees.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q6"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">16.10</span> Modify the B-tree&ndash;insertion implementation in <a class="docLink" href="#ch16ex07">Program 16.3</a> to do splitting on the way down the tree, in a manner similar to our implementation of 2-3-4&ndash;tree insertion (<a class="docLink" href="ch13lev1sec4.html#ch13ex15">Program 13.6</a>).</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q7"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">16.11</span> Write a program to compute the average number of external pages for a B tree of order <span class="docEmphasis">M</span> built from <span class="docEmphasis">N</span> random insertions into an initially empty tree, using the probabilistic process described after <a class="docLink" href="ch16lev1sec2.html#ch16ex02">Property 16.1</a>. Run your program for <span class="docEmphasis"><tt>M</tt></span> <tt>= 10, 100</tt>, and <tt>1000</tt> and <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q8"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">16.12</span> Suppose that, in a three-level tree, we can afford to keep <span class="docEmphasis">a</span> links in internal memory, between <span class="docEmphasis">b</span> and 2<span class="docEmphasis">b</span> links in pages representing internal nodes, and between <span class="docEmphasis">c</span> and 2<span class="docEmphasis">c</span> items in pages representing external nodes. What is the maximum number of items that we can hold in such a tree, as a function of <span class="docEmphasis">a</span>, <span class="docEmphasis">b</span>, and <span class="docEmphasis">c</span>?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q9"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">16.13</span> Consider the <span class="docEmphasis">sibling split</span> (or <span class="docEmphasis">B* tree</span>) heuristic for B trees: When it comes time to split a node because it contains M entries, we combine the node with its sibling. If the sibling has <span class="docEmphasis">k</span> entries with <span class="docEmphasis">k &lt; M</span> &ndash; 1, we reallocate the items giving the sibling and the full node each about <span class="docEmphasis">(M + k)/</span>2 entries. Otherwise, we create a new node and give each of the three nodes about 2<span class="docEmphasis">M/</span>3 entries. Also, we allow the root to grow to hold about 4M=3 items, splitting it and creating a new root node with two entries when it reaches that bound. State bounds on the number of probes used for a search or an insertion in a B* tree of order <span class="docEmphasis">M</span> with <span class="docEmphasis">N</span> items. Compare your bounds with the corresponding bounds for B trees (see <a class="docLink" href="#ch16ex06">Property 16.2</a>), for <span class="docEmphasis"><tt>M</tt></span> <tt>= 10, 100</tt>, and <tt>1000</tt> and <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q10"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" />
<span class="docEmphStrong">16.14</span> Develop a B* tree <span class="docEmphasis">insert</span> implementation (based on the sibling-split heuristic).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q11"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">16.15</span> Create a figure like <a class="docLink" href="#ch16fig08">Figure 16.8</a> for the sibling-split heuristic.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q12"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">16.16</span> Run a probabilistic simulation (see <a class="docLink" href="#ch16qa2q7">Exercise 16.11</a>) to determine the average number of pages used when we use the sibling-split heuristic, building a B* tree of order <span class="docEmphasis">M</span> by inserting random nodes into an initially empty tree, for <span class="docEmphasis"><tt>M</tt></span> <tt>= 10, 100</tt>, and <tt>1000</tt> and <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q13"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">16.17</span> Write a program to construct a B tree index from the bottom up, starting with an array of pointers to pages containing between <span class="docEmphasis">M</span> and 2<span class="docEmphasis">M</span> items, in sorted order.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q14"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">16.18</span> Could an index with all pages full, such as <a class="docLink" href="ch16lev1sec2.html#ch16fig02">Figure 16.2</a>, be constructed by the B-tree&ndash;insertion algorithm considered in the text (<a class="docLink" href="#ch16ex07">Program 16.3</a>)? Explain your answer.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q15"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">16.19</span> Suppose that many different computers have access to the same index, so several programs may be trying to insert a new node in the same B tree at about the same time. Explain why you might prefer to use top-down B trees instead of bottom-up B trees in such a situation. Assume that each program can (and does) delay the others from modifying any given node that it has read and might later modify.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q16"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">16.20</span> Modify the B-tree implementation in <a class="docLink" href="#ch16ex04">Programs 16.1</a> through <a class="docLink" href="#ch16ex07">16.3</a> to allow <span class="docEmphasis">M</span> items per node to exist in the tree.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q17"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">16.21</span> Tabulate the difference between <tt>log<sub>999</sub></tt> <span class="docEmphasis"><tt>N</tt></span> and <tt>log<sub>1000</sub></tt> <span class="docEmphasis"><tt>N</tt></span>, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q18"></a><b></b></td><td><p class="docText"><a name="iddle1451"></a><a name="iddle1466"></a><a name="iddle1475"></a><a name="iddle1573"></a><a name="iddle1945"></a><a name="iddle2054"></a><a name="iddle2225"></a><a name="iddle2468"></a>
<img border="0" alt="" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">16.22</span> Implement the <span class="docEmphasis">sort</span> operation for a B-tree&ndash;based symbol table.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q19"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">16.23</span> Implement the <span class="docEmphasis">select</span> operation for a B-tree&ndash;based symbol table.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q20"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" />
<span class="docEmphStrong">16.24</span> Implement the <span class="docEmphasis">remove</span> operation for a B-tree&ndash;based symbol table.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q21"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">16.25</span> Implement the <span class="docEmphasis">remove</span> operation for a B-tree&ndash;based symbol table, using a simple method where you delete the indicated item from its external page (perhaps allowing the number of items in the page to fall below <span class="docEmphasis">M/</span>2), but do not propagate the change up through the tree, except possibly to adjust the key values if the deleted item was the smallest in its page.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa2q22"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">16.26</span> Modify <a class="docLink" href="#ch16ex05">Programs 16.2</a> and <a class="docLink" href="#ch16ex07">16.3</a> to use binary search (see <a class="docLink" href="ch12lev1sec3.html#ch12ex08">Program 12.6</a>) within nodes. Determine the value of <span class="docEmphasis">M</span> that minimizes the time that your program takes to build a symbol table by inserting <span class="docEmphasis">N</span> items with random keys into an initially empty table, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>, and compare the times that you get with the corresponding times for red&ndash;black trees (<a class="docLink" href="ch16lev1sec4.html#ch16ex15">Program 13.6</a>).</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></div></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch16lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch16lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table><!--IP User 2--></td></body></head></html>