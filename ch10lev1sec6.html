<html><head><title>10.6. Performance Characteristics of Radix Sorts</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch10lev1sec5.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch10lev1sec7.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch10lev1sec6"></a>
<h3 id="title-IDAFSN5H" class="docSection1Title">10.6. Performance Characteristics of Radix Sorts</h3>
<p class="docText">The running time of LSD radix sort for sorting <span class="docEmphasis">N</span> records with <span class="docEmphasis">w</span>-byte keys is proportional to <tt>Nw</tt>, because the algorithm makes <span class="docEmphasis">w</span> passes over all <span class="docEmphasis">N</span> keys. This analysis does not depend on the input, as illustrated in <a class="docLink" href="#ch10fig17">Figure 10.17</a>.</p>
<a name="ch10fig17"></a><p><center>
<h5 class="docFigureTitle">Figure 10.17. Dynamic characteristics of LSD radix sort on various types of files</h5>
<h5></h5><h5></h5></center></p><p class="docText">These diagrams illustrate the stages of LSD radix sort for files of size 200 that are random, Gaussian, nearly ordered, nearly reverse ordered, and randomly ordered with 10 distinct key values <span class="docEmphasis">(left to right)</span>. The running time is insensitive to the initial order of the input. The three files that contain the same set of keys (the first, third, and fourth all are a permutation of the integers from 1 to 200) have similar characteristics near the end of the sort.</p>
<p class="docText">
<img border="0" alt="" width="300" height="372" src="10fig17.gif" /></p>
<br />
<p class="docText">For long keys and short bytes, this running time is comparable to <span class="docEmphasis">N</span> lg <span class="docEmphasis">N</span>: For example, if we are using a binary LSD radix sort to sort 1 billion 32-bit keys, then <span class="docEmphasis">w</span> and <tt>lg N</tt> are both about 32. For shorter keys and longer bytes this running time is comparable to <span class="docEmphasis">N</span>: For example, if a 16-bit radix is used on 64-bit keys, then <span class="docEmphasis">w</span> will be 4, a small constant.</p>
<p class="docText">To compare properly the performance of radix sort with the performance of comparison-based algorithms, we need to account carefully for the bytes in the keys, rather than for only the number of keys.</p>
<p class="docText"></p><a name="ch10ex07"></a><h5 id="title-IDAZUN5H" class="docExampleTitle">Property 10.1. The worst case for radix sorting is to examine all the bytes in all the keys</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1741"></a><a name="iddle1745"></a><a name="iddle1924"></a><a name="iddle2198"></a><a name="iddle2200"></a><a name="iddle2207"></a><a name="iddle2211"></a><a name="iddle2471"></a>In other words, the radix sorts are <span class="docEmphasis">linear</span> in the sense that the time taken is at most proportional to the number of digits in the input. This observation follows directly from examination of the programs: No digit is examined more than once. This worst case is achieved, for all the programs we have examined, when all the keys are equal.</p>
</td></tr></table></p>
<p class="docText">As we have seen, for random keys and for many other situations, the running time of MSD radix sorting can be <span class="docEmphasis">sublinear</span> in the total number of data bits, because the whole key does not necessarily have to be examined. The following classical result holds for arbitrarily long keys:</p>
<a name="ch10ex08"></a><h5 id="title-IDAMXN5H" class="docExampleTitle">Property 10.2. Binary quicksort examines about <span class="docEmphasis">N</span> lg<span class="docEmphasis">N</span> bits, on average, when sorting keys composed of random bits</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">If the file size is a power of 2 and the bits are random, then we expect one-half of the leading bits to be 0 and one-half to be 1, so the recurrence <span class="docEmphasis">C<sub>N</sub> = 2C<sub>N/</sub><sub>2</sub> + N</span> should describe the performance, as we argued for quicksort in <a class="docLink" href="ch07.html#ch07">Chapter 7</a>. Again, this description of the situation is not entirely accurate, because the partition falls in the center only on the average (and because the number of bits in the keys is finite). However, the partition is much more likely to be near the center for binary quicksort than for standard quicksort, so the leading term of the running time is the same as it would be were the partitions perfect. The detailed analysis that proves this result is a classical example in the analysis of algorithms, first done by Knuth before 1973 (<span class="docEmphasis">see reference section</span>).</p>
</td></tr></table></p>
<p class="docText">This result generalizes to apply to MSD radix sort. However, since our interest is generally in the total running time, rather than in only the key characters examined, we have to exercise caution, because part of the running time of MSD radix sort is proportional to the size of the radix <span class="docEmphasis">R</span> and has nothing to do with the keys.</p>
<a name="ch10ex09"></a><h5 id="title-IDA2YN5H" class="docExampleTitle">Property 10.3. MSD radix sort with radix <span class="docEmphasis">R</span>on a file of size <span class="docEmphasis">N</span> requires at least <span class="docEmphasis">2N + 2R</span> steps</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">MSD radix sort involves at least one key-indexed counting pass, and key-indexed counting consists of at least two passes through the records (one for counting and one for distributing), accounting for at least <span class="docEmphasis">2N</span> steps, and two passes through the counters (one to initialize them to 0 at the beginning and one to determine where the subfiles are at the end), accounting for at least <span class="docEmphasis">2R</span> steps.</p>
</td></tr></table></p>
<p class="docText">This property almost seems too obvious to state, but it is essential to our understanding of MSD radix sort. In particular, it tells us that we cannot conclude that the running time will be low from the fact that <span class="docEmphasis">N</span> is small, because <span class="docEmphasis">R</span> could be much larger than <span class="docEmphasis">N</span>. In short, <span class="docEmphasis">some other method should be used for small files</span>. This observation is a solution to the empty-bins problem that we discussed at the end of <a class="docLink" href="ch10lev1sec3.html#ch10lev1sec3">Section 10.3</a>. For example, if <span class="docEmphasis">R</span> is 256 and <span class="docEmphasis">N</span> is 2, MSD radix sort will be up to 128 times slower than the simpler method of just comparing elements. The recursive structure of MSD radix sort ensures that the recursive program will call itself for large numbers of small files. Therefore, ignoring the empty-bins problem could make the whole radix sort up to 128 times slower than it could be for this example. For intermediate situations (for example, suppose that <span class="docEmphasis">R</span> is 256 and <span class="docEmphasis">N</span> is 64), the cost is not so catastrophic, but is still significant. Using insertion sort is not wise, because its expected cost of <span class="docEmphasis">N</span><sup>2</sup>/4 comparisons is too high; ignoring the empty bins is not wise, because there are significant numbers of them. The simplest way to cope with this problem is to use a radix that is less than the file size.</p>
<a name="ch10ex10"></a><h5 id="title-IDAV0N5H" class="docExampleTitle">Property 10.4. If the radix is always less than the file size, the number of steps taken by MSD radix sort is within a small constant factor of <span class="docEmphasis">N log<sub>R</sub> N</span> on the average (for keys comprising random bytes), and within a small constant factor of the number of bytes in the keys in the worst case</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The worst-case result follows directly from the preceding discussion, and the analysis cited for <a class="docLink" href="#ch10ex08">Property 10.2</a> generalizes to give the average-case result. For large <span class="docEmphasis">R</span>, the factor <span class="docEmphasis">log<sub>R</sub>N</span> is small, so the total time is proportional to <span class="docEmphasis">N</span> for practical purposes. For example, if <span class="docEmphasis">R</span> = 2<sup>16</sup>, then <span class="docEmphasis">log<sub>R</sub> N</span> is less than 3 for all <span class="docEmphasis">N</span> &lt; 2<sup>48</sup>, which value certainly encompasses all practical file sizes.</p>
</td></tr></table></p>
<p class="docText">As we do from <a class="docLink" href="#ch10ex08">Property 10.2</a> we have from <a class="docLink" href="#ch10ex10">Property 10.4</a> the important practical implication that MSD radix sorting is actually a <span class="docEmphasis">sublinear</span> function of the total number of bits for random keys that are not short. For example, sorting 1 million 64-bit random keys will <a name="iddle1757"></a><a name="iddle2203"></a><a name="iddle2214"></a>require examining only the leading 20 to 30 bits of the keys, or less than one-half of the data.</p>
<a name="ch10ex11"></a><h5 id="title-IDAR3N5H" class="docExampleTitle">Property 10.5. Three-way radix quicksort uses <span class="docEmphasis">2N lnN</span> byte comparisons, on the average, to sort <span class="docEmphasis">N</span> (arbitrarily long) keys</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">There are two instructive ways to understand this result. First, considering the method to be equivalent to quicksort partitioning on the leading byte, then (recursively) using the same method on the subfiles, we should not be surprised that the total number of operations is about the same as for normal quicksort&mdash;but they are single-byte comparisons, not full-key comparisons. Second, considering the method from the point of view depicted in <a class="docLink" href="ch10lev1sec4.html#ch10fig13">Figure 10.13</a>, we expect that the <span class="docEmphasis">N log<sub>R</sub> N</span> running time from <a class="docLink" href="#ch10ex09">Property 10.3</a> should be multiplied by a factor of <span class="docEmphasis">2ln R</span> because it takes quicksort <span class="docEmphasis">2RlnR</span> steps to sort <span class="docEmphasis">R</span> bytes, as opposed to the <span class="docEmphasis">R</span> steps for the same bytes in the trie. We omit the full proof (<span class="docEmphasis">see reference section</span>).</p>
</td></tr></table></p>
<a name="ch10ex12"></a><h5 id="title-IDAB5N5H" class="docExampleTitle">Property 10.6. LSD radix sort can sort <span class="docEmphasis">N</span> records with <span class="docEmphasis">w</span>-bit keys in <span class="docEmphasis">w/lgR</span> passes, using extra space for <span class="docEmphasis">R</span> counters (and a buffer for rearranging the file)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Proof of this fact is straightforward from the implementation. In particular, if we take <span class="docEmphasis">R</span> = 2<sup>w/</sup>4, we get a four-pass linear sort.</p>
</td></tr></table></p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa6q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.39</span> Suppose that an input file consists of 1000 copies of each of the numbers 1 through 1000, each in a 32-bit word. Describe how you would take advantage of this knowledge to get a fast radix sort.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa6q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.40</span> Suppose that an input file consists of 1000 copies of each of a thousand different 32-bit numbers. Describe how you would take advantage of this knowledge to get a fast radix sort.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa6q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.41</span> What is the total number of bytes examined by three-way radix quicksort when sorting fixed-length bytestrings, in the worst case?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa6q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.42</span> Empirically compare the number of bytes examined by three-way radix quicksort for long strings with <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup> with the number of comparisons used by standard quicksort for the same files.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa6q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">10.43</span> Give the number of bytes examined by MSD radix sort and three-way radix quicksort for a file of <span class="docEmphasis">N</span> keys <span class="docEmphStrong">A, AA, AAA, AAAA, AAAAA, AAAAAA,</span>...<span class="docEmphStrong">.</span></p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch10lev1sec5.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch10lev1sec7.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>