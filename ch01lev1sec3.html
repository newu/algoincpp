<html><head><title>1.3. Union&ndash;Find Algorithms</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch01lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch01lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch01lev1sec3"></a>
<h3 id="title-IDA0XWFL" class="docSection1Title">1.3. Union&ndash;Find Algorithms</h3>
<p class="docText">The first step in the process of developing an efficient algorithm to solve a given problem is to <span class="docEmphasis">implement a simple algorithm that solves the problem</span>. If we need to solve a few particular problem instances that turn out to be easy, then the simple implementation may finish the job for us. If a more sophisticated algorithm is called for, then the simple implementation provides us with a correctness check for small cases and a baseline for evaluating performance characteristics. We always care about efficiency, but our primary concern in developing the first program that we write to solve a problem is to make sure that the program is a <span class="docEmphasis">correct</span> solution to the problem.</p>
<p class="docText">The first idea that might come to mind is somehow to save all the input pairs, then to write a function to pass through them to try to discover whether the next pair of objects is connected. We shall use a different approach. First, the number of pairs might be sufficiently large to preclude our saving them all in memory in practical applications. Second, and more to the point, no simple method immediately suggests itself for determining whether two objects are connected from the set of all the connections, even if we could save them all! We consider a basic method that takes this approach in <a class="docLink" href="ch05.html#ch05">Chapter 5</a>, but the methods that we shall consider in this chapter are simpler, because they <a name="iddle1063"></a>solve a less difficult problem, and are more efficient, because they do not require saving all the pairs. They all use an array of integers&mdash;one corresponding to each object&mdash;to hold the requisite information to be able to implement <span class="docEmphasis">union</span> and <span class="docEmphasis">find</span>.</p>
<a name="ch01ex01"></a><h5 id="title-IDAGJXFL" class="docExampleTitle">Program 1.1. Quick-find solution to connectivity problem</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This program reads a sequence of pairs of nonnegative integers less than <span class="docEmphasis">N</span> from standard input (interpreting the pair <tt>p q</tt> to mean &quot;connect object <tt>p</tt> to object <tt>q</tt>&quot;) and prints out pairs representing objects that are not yet connected. It maintains an array <tt>id</tt> that has an entry for each object, with the property that <tt>id[p]</tt> and <tt>id[q]</tt> are equal if and only if <tt>p</tt> and <tt>q</tt> are connected. For simplicity, we define <tt>N</tt> as a compile-time constant. Alternatively, we could take it from the input and allocate the <span class="docEmphasis">id</span> array dynamically (see <a class="docLink" href="ch03lev1sec3.html#ch03lev1sec3">Section 3.3</a>).</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
static const int N = 10000;
int main()
  { int i, p, q, id[N];
    for (i = 0; i &lt; N; i++) id[i] = i;
    while (cin &gt;&gt; p &gt;&gt; q)
      { int t = id[p];
        if (t == id[q]) continue;
        for (i = 0; i &lt; N; i++)
          if (id[i] == t) id[i] = id[q];
        cout &lt;&lt; " " &lt;&lt; p &lt;&lt; " " &lt;&lt; q &lt;&lt; endl;
      }
}</pre></div><br />
</td></tr></table></p>
<p class="docText">Arrays are elementary data structures that we shall discuss in detail in <a class="docLink" href="ch03lev1sec2.html#ch03lev1sec2">Section 3.2</a>. Here, we use them in their simplest form: we declare that we expect to use, say, <tt>1000</tt> integers, by writing <tt>a[1000]</tt>; then we refer to the <span class="docEmphasis"><tt>i</tt></span>th integer in the array by writing <tt>a[i]</tt> for 0 <img src="U2264.GIF" border="0" /> <span class="docEmphasis"><tt>i</tt></span> &lt; 1000.</p>
<p class="docText"><a class="docLink" href="#ch01ex01">Program 1.1</a> is an implementation of a simple algorithm called the <span class="docEmphasis">quick-find algorithm</span> that solves the connectivity problem. The basis of this algorithm is an array of integers with the property that <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span> are connected if and only if the <span class="docEmphasis">p</span>th and <span class="docEmphasis">q</span>th array entries are equal. We initialize the <span class="docEmphasis">i</span>th array entry to <span class="docEmphasis">i</span> for 0 <img src="U2264.GIF" border="0" /> <span class="docEmphasis">i</span> &lt; <span class="docEmphasis">N</span>. To implement the <span class="docEmphasis">union</span> operation for <span class="docEmphasis">p</span> and <span class="docEmphasis">q</span>, we go through the array, <a name="iddle1296"></a><a name="iddle2187"></a><a name="iddle2555"></a><a name="iddle2603"></a>changing all the entries with the same name as <span class="docEmphasis">p</span> to have the same name as <span class="docEmphasis">q</span>. This choice is arbitrary&mdash;we could have decided to change all the entries with the same name as <span class="docEmphasis">q</span> to have the same name as <span class="docEmphasis">p</span>.</p>
<p class="docText"><a class="docLink" href="#ch01fig03">Figure 1.3</a> shows the changes to the array for the <span class="docEmphasis">union</span> operations in the example in <a class="docLink" href="ch01lev1sec2.html#ch01fig01">Figure 1.1</a>. To implement <span class="docEmphasis">find</span>, we just test the indicated array entries for equality&mdash;hence the name <span class="docEmphasis">quick find</span>. The <span class="docEmphasis">union</span> operation, on the other hand, involves scanning through the whole array for each input pair.</p>
<a name="ch01fig03"></a><p><center>
<h5 class="docFigureTitle">Figure 1.3. Example of quick find (slow union)</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts the contents of the <tt>id</tt> array after each of the pairs at left is processed by the quick-find algorithm (<a class="docLink" href="#ch01ex01">Program 1.1</a>). Shaded entries are those that change for the union operation. When we process the pair <tt>p q</tt>, we change all entries with the value <tt>id[p]</tt> to have the value <tt>id[q]</tt>.</p>
<p class="docText">
<img border="0" alt="" width="185" height="219" src="01fig03.gif" /></p>
<br />
<a name="ch01ex02"></a><h5 id="title-IDA4PXFL" class="docExampleTitle">Property 1.1. <span class="docEmphasis">The quick-find algorithm executes at least MN instructions to solve a connectivity problem with N objects that involves M</span> <span class="docEmphRoman">union</span> <span class="docEmphasis">operations</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">For each of the <span class="docEmphasis">M</span> <span class="docEmphasis">union</span> operations, we iterate the <tt>for</tt> loop <span class="docEmphasis">N</span> times. Each iteration requires at least one instruction (if only to check whether the loop is finished).</p>
</td></tr></table></p>
<p class="docText">We can execute tens or hundreds of millions of instructions per second on modern computers, so this cost is not noticeable if <span class="docEmphasis">M</span> and <span class="docEmphasis">N</span> are small, but we also might find ourselves with billions of objects and millions of input pairs to process in a modern application. The inescapable conclusion is that we cannot feasibly solve such a problem using the quick-find algorithm (see <a class="docLink" href="#ch01qa2q7">Exercise 01.2</a>). We consider the process of quantifying such a conclusion precisely in <a class="docLink" href="ch02.html#ch02">Chapter 2</a>.</p>
<p class="docText"><a class="docLink" href="#ch01fig04">Figure 1.4</a> shows a graphical representation of <a class="docLink" href="#ch01fig03">Figure 1.3</a>. We may think of some of the objects as representing the set to which they belong, and all of the other objects as pointing to the representative in their set. The reason for moving to this graphical representation of the array will become clear soon. Observe that the connections between objects in this representation are <span class="docEmphasis">not</span> necessarily the same as the connections in the input pairs&mdash;they are the information that the algorithm chooses to remember to be able to know whether future pairs are connected.</p>
<a name="ch01fig04"></a><p><center>
<h5 class="docFigureTitle">Figure 1.4. Tree representation of quick find</h5>
<h5></h5><h5></h5></center></p><p class="docText">This figure depicts graphical representations for the example in <a class="docLink" href="#ch01fig03">Figure 1.3</a>. The connections in these figures do not necessarily represent the connections in the input. For example, the structure at the bottom has the connection <tt>1-7</tt>, which is not in the input, but which is made because of the string of connections <tt>7-3-4-9-5-6-1</tt>.</p>
<p class="docText">
<img border="0" alt="" width="160" height="442" src="01fig04.gif" /></p>
<br />
<p class="docText">The next algorithm that we consider is a complementary method called the <span class="docEmphasis">quick-union algorithm</span>. It is based on the same data structure&mdash;an array indexed by object names&mdash;but it uses a different interpretation of the values that leads to more complex abstract structures. Each object points to another object in the same set, in a structure with no cycles. To determine whether two objects are in the same set, we follow pointers for each until we reach an object that <a name="iddle2281"></a><a name="iddle2556"></a>points to itself. The objects are in the same set if and only if this process leads them to the same object. If they are not in the same set, we wind up at different objects (which point to themselves). To form the union, then we just link one to the other to perform the <span class="docEmphasis">union</span> operation; hence the name <span class="docEmphasis">quick-union</span>.</p>
<p class="docText"><a class="docLink" href="#ch01fig05">Figure 1.5</a> shows the graphical representation that corresponds to <a class="docLink" href="#ch01fig04">Figure 1.4</a> for the operation of the quick-union algorithm on the example of <a class="docLink" href="ch01lev1sec2.html#ch01fig01">Figure 1.1</a>, and <a class="docLink" href="#ch01fig06">Figure 1.6</a> shows the corresponding changes to the <tt>id</tt> array. The graphical representation of the data structure makes it relatively easy to understand the operation of the algorithm&mdash;input pairs that are known to be connected in the data are also connected to one another in the data structure. As mentioned previously, it is important to note at the outset that the connections in the data structure are not necessarily the same as the connections in the application implied by the input pairs; rather, they are constructed by the algorithm to facilitate efficient implementation of <span class="docEmphasis">union</span> and <span class="docEmphasis">find</span>.</p>
<a name="ch01fig05"></a><p><center>
<h5 class="docFigureTitle">Figure 1.5. Tree representation of quick union</h5>
<h5></h5><h5></h5></center></p><p class="docText">This figure is a graphical representation of the example in <a class="docLink" href="#ch01fig03">Figure 1.3</a>. We draw a line from object <tt>i</tt> to object <tt>id[i]</tt>.</p>
<p class="docText">
<img border="0" alt="" width="175" height="555" src="01fig05.gif" /></p>
<br />
<a name="ch01fig06"></a><p><center>
<h5 class="docFigureTitle">Figure 1.6. Example of quick union (not-too-quick find)</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts the contents of the <tt>id</tt> array after each of the pairs at left are processed by the quick-find algorithm (<a class="docLink" href="#ch01ex01">Program 1.1</a>). Shaded entries are those that change for the union operation (just one per operation). When we process the pair <tt>p q</tt>, we follow pointers from <tt>p</tt> to get an entry <tt>i</tt> with <tt>id[i] == i</tt>; then, we follow pointers from <tt>q</tt> to get an entry <tt>j</tt> with <tt>id[j] == j</tt>; then, if <tt>i</tt> and <tt>j</tt> differ, we set <tt>id[i] = id[j]</tt>. For the find operation for the pair <tt>5-8</tt> (final line), <tt>i</tt> takes on the values <tt>5 6 9 0 1</tt>, and <tt>j</tt> takes on the values <tt>8 0 1</tt>.</p>
<p class="docText">
<img border="0" alt="" width="185" height="297" src="01fig06.gif" /></p>
<br />
<p class="docText">The connected components depicted in <a class="docLink" href="#ch01fig05">Figure 1.5</a> are called <span class="docEmphasis">trees</span>; they are fundamental combinatorial structures that we shall encounter on numerous occasions throughout the book. We shall consider the properties of trees in detail in <a class="docLink" href="ch05.html#ch05">Chapter 5</a>. For the <span class="docEmphasis">union</span> and <span class="docEmphasis">find</span> operations, the trees in <a class="docLink" href="#ch01fig05">Figure 1.5</a> are useful because they are quick to build and have the property that two objects are connected in the tree if and only if the objects are connected in the input. By moving up the tree, we can easily find the root of the tree containing each object, so we have a way to find whether or not they are connected. Each tree has precisely one object that points to itself, which is called the <span class="docEmphasis">root</span> of the tree. The self-pointer is not shown in the diagrams. When we start at any object in the tree, move to the object to which it points, then move to the object to which that object points, and so forth, we eventually end up at the root, always. We can prove this property to be true by induction: It is true after the array is initialized to have every object point to itself, and if it is true before a given <span class="docEmphasis">union</span> operation, it is certainly true afterward.</p>
<p class="docText">The diagrams in <a class="docLink" href="#ch01fig04">Figure 1.4</a> for the quick-find algorithm have the same properties as those described in the previous paragraph. The difference between the two is that we reach the root from all the nodes in the quick-find trees after following just one link, whereas we might need to follow several links to get to the root in a quick-union tree.</p>
<p class="docText"></p><a name="ch01ex03"></a><h5 id="title-IDAC0XFL" class="docExampleTitle">Program 1.2. Quick-union solution to connectivity problem</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1295"></a><a name="iddle2164"></a>If we replace the body of the <tt>while</tt> loop in <a class="docLink" href="#ch01ex01">Program 1.1</a> by this code, we have a program that meets the same specifications as <a class="docLink" href="#ch01ex01">Program 1.1</a>, but does less computation for the <span class="docEmphasis">union</span> operation at the expense of more computation for the <span class="docEmphasis">find</span> operation. The <tt>for</tt> loops and subsequent <tt>if</tt> statement in this code specify the necessary and sufficient conditions on the <span class="docEmphasis">id</span> array for <tt>p</tt> and <tt>q</tt> to be connected. The assignment statement <tt>id[i] = j</tt> implements the <span class="docEmphasis">union</span> operation.</p>
<div class="docText"><pre>for (i = p; i != id[i]; i = id[i]) ;
for (j = q; j != id[j]; j = id[j]) ;
if (i == j) continue;
id[i] = j;
cout &lt;&lt; " " &lt;&lt; p &lt;&lt; " " &lt;&lt; q &lt;&lt; endl;</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch01ex03">Program 1.2</a> is an implementation of the <span class="docEmphasis">union</span> and <span class="docEmphasis">find</span> operations that comprise the quick-union algorithm to solve the connectivity problem. The quick-union algorithm would seem to be faster than the quick-find algorithm, because it does not have to go through the entire array for each input pair; but how much faster is it? This question is more difficult to answer here than it was for quick find, because the running time is much more dependent on the nature of the input. By running empirical studies or doing mathematical analysis (see <a class="docLink" href="ch02.html#ch02">Chapter 2</a>), we can convince ourselves that <a class="docLink" href="#ch01ex03">Program 1.2</a> is far more efficient than <a class="docLink" href="#ch01ex01">Program 1.1</a>, and that it is feasible to consider using <a class="docLink" href="#ch01ex03">Program 1.2</a> for huge practical problems. We shall discuss one such empirical study at the end of this section. For the moment, we can regard quick union as an improvement because it removes quick find's main liability (that the program requires at least <span class="docEmphasis">NM</span> instructions to process <span class="docEmphasis">M</span> <span class="docEmphasis">union</span> operations among <span class="docEmphasis">N</span> objects).</p>
<p class="docText">This difference between quick union and quick find certainly represents an improvement, but quick union still has the liability that we cannot <span class="docEmphasis">guarantee</span> it to be substantially faster than quick find in every case, because the input data could conspire to make the <span class="docEmphasis">find</span> operation slow.</p>
<p class="docText"></p><a name="ch01ex04"></a><h5 id="title-IDA43XFL" class="docExampleTitle">Property 1.2. <span class="docEmphasis">For M &gt; N, the quick-union algorithm could take more than MN/2 instructions to solve a connectivity problem with M pairs of N objects</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle2557"></a><a name="iddle2620"></a>Suppose that the input pairs come in the order <tt>1-2</tt>, then <tt>2-3</tt>, then <tt>3-4</tt>, and so forth. After <span class="docEmphasis">N</span> &ndash; 1 such pairs, we have <span class="docEmphasis">N</span> objects all in the same set, and the tree that is formed by the quick-union algorithm is a straight line, with <span class="docEmphasis">N</span> pointing to <span class="docEmphasis">N &ndash; 1</span>, which points to <span class="docEmphasis">N</span> &ndash; 2, which points to <span class="docEmphasis">N</span> &ndash; 3, and so forth. To execute the <span class="docEmphasis">find</span> operation for object <span class="docEmphasis">N</span>, the program has to follow <span class="docEmphasis">N</span> &ndash; 1 pointers. Thus, the average number of pointers followed for the first <span class="docEmphasis">N</span> pairs is</p>
<div class="docText"><pre>(0 + 1 + ... + (<span class="docEmphasis">N</span> &ndash; 1))/N = (<span class="docEmphasis">N</span> &ndash; 1)/2.</pre></div><br />
<p class="docText">Now suppose that the remainder of the pairs all connect <span class="docEmphasis">N</span> to some other object. The <span class="docEmphasis">find</span> operation for each of these pairs involves at least (<span class="docEmphasis">N</span> &ndash; 1) pointers. The grand total for the <span class="docEmphasis">M</span> <span class="docEmphasis">find</span> operations for this sequence of input pairs is certainly greater than <span class="docEmphasis">MN</span>/2.</p>
</td></tr></table></p>
<p class="docText">Fortunately, there is an easy modification to the algorithm that allows us to guarantee that bad cases such as this one do not occur. Rather than arbitrarily connecting the second tree to the first for <span class="docEmphasis">union</span>, we keep track of the number of nodes in each tree and always connect the smaller tree to the larger. This change requires slightly more code and another array to hold the node counts, as shown in <a class="docLink" href="#ch01ex05">Program 1.3</a>, but it leads to substantial improvements in efficiency. We refer to this algorithm as the <span class="docEmphasis">weighted quick-union algorithm</span>.</p>
<p class="docText"><a class="docLink" href="#ch01fig07">Figure 1.7</a> shows the forest of trees constructed by the weighted union&ndash;find algorithm for the example input in <a class="docLink" href="ch01lev1sec2.html#ch01fig01">Figure 1.1</a>. Even for this small example, the paths in the trees are substantially shorter than for the unweighted version in <a class="docLink" href="#ch01fig05">Figure 1.5</a>. <a class="docLink" href="#ch01fig08">Figure 1.8</a> illustrates what happens in the worst case, when the sizes of the sets to be merged in the <span class="docEmphasis">union</span> operation are always equal (and a power of 2). These tree structures look complex, but they have the simple property that the maximum number of pointers that we need to follow to get to the root in a tree of <span class="docEmphasis">2<sup>n</sup></span> nodes is <span class="docEmphasis">n</span>. Furthermore, when we merge two trees of <span class="docEmphasis">2<sup>n</sup></span> nodes, we get a tree of <span class="docEmphasis">2<sup>n+1</sup></span> nodes, and we increase the maximum distance to the root to <span class="docEmphasis">n+1</span>. This observation generalizes to provide a proof that the weighted algorithm is substantially more efficient than the unweighted algorithm.</p>
<a name="ch01fig07"></a><p><center>
<h5 class="docFigureTitle">Figure 1.7. Tree representation of weighted quick union</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts the result of changing the quick-union algorithm to link the root of the smaller of the two trees to the root of the larger of the two trees. The distance from each node to the root of its tree is small, so the find operation is efficient.</p>
<p class="docText">
<img border="0" alt="" width="150" height="445" src="01fig07.gif" /></p>
<br />
<a name="ch01fig08"></a><p><center>
<h5 class="docFigureTitle">Figure 1.8. Weighted quick union (worst case)</h5>
<h5></h5><h5></h5></center></p><p class="docText">The worst scenario for the weighted quick-union algorithm is that each union operation links trees of equal size. If the number of objects is less than 2<span class="docEmphasis"><sup>n</sup></span>, the distance from any node to the root of its tree is less than <span class="docEmphasis">n</span>.</p>
<p class="docText">
<img border="0" alt="" width="175" height="540" src="01fig08.gif" /></p>
<br />
<p class="docText"></p><a name="ch01ex05"></a><h5 id="title-IDASEYFL" class="docExampleTitle">Program 1.3. Weighted version of quick union</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle2558"></a>This program is a modification to the quick-union algorithm (see <a class="docLink" href="#ch01ex03">Program 1.2</a>) that keeps an additional array <tt>sz</tt> for the purpose of maintaining, for each object with <tt>id[i] == i</tt>, the number of nodes in the associated tree, so that the <span class="docEmphasis">union</span> operation can link the smaller of the two specified trees to the larger, thus preventing the growth of long paths in the trees.</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
static const int N = 10000;
int main()
  { int i, j, p, q, id[N], sz[N];
    for (i = 0; i &lt; N; i++)
      { id[i] = i; sz[i] = 1; }
    while (cin &gt;&gt; p &gt;&gt; q)
      {
        for (i = p; i != id[i]; i = id[i]) ;
        for (j = q; j != id[j]; j = id[j]) ;
        if (i == j) continue;
        if (sz[i] &lt; sz[j])
             { id[i] = j; sz[j] += sz[i]; }
        else { id[j] = i; sz[i] += sz[j]; }
        cout &lt;&lt; " " &lt;&lt; p &lt;&lt; " " &lt;&lt; q &lt;&lt; endl;
      }
  }</pre></div><br />
</td></tr></table></p>
<a name="ch01ex06"></a><h5 id="title-IDA4FYFL" class="docExampleTitle">Property 1.3. <span class="docEmphasis">The weighted quick-union algorithm follows at most</span> <span class="docEmphRoman">lg</span> <span class="docEmphasis">N pointers to determine whether two of N objects are connected</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We can prove that the <span class="docEmphasis">union</span> operation preserves the property that the number of pointers followed from any node to the root in a set of <span class="docEmphasis">k</span> objects is no greater than lg <span class="docEmphasis">k</span>. When we combine a set of <span class="docEmphasis">i</span> nodes with a set of <span class="docEmphasis">j</span> nodes with <span class="docEmphasis">i</span> <img src="U2264.GIF" border="0" /> <span class="docEmphasis">j</span>, we increase the number of pointers that must be followed in the smaller set by 1, but they are now in a set of size <span class="docEmphasis">i</span>+<span class="docEmphasis">j</span>, so the property is preserved because 1+lg <span class="docEmphasis">i</span> = lg(<span class="docEmphasis">i</span>+<span class="docEmphasis">i</span>) <img src="U2264.GIF" border="0" /> lg(<span class="docEmphasis">i</span>+<span class="docEmphasis">j</span>).</p>
</td></tr></table></p>
<p class="docText">The practical implication of <a class="docLink" href="#ch01ex06">Property 1.3</a> is that the weighted quick-union algorithm uses <span class="docEmphasis">at most</span> a constant times <span class="docEmphasis">M</span> lg <span class="docEmphasis">N</span> instructions to process <span class="docEmphasis">M</span> edges on <span class="docEmphasis">N</span> objects (see <a class="docLink" href="#ch01qa2q6">Exercise 1.9</a>). This result is <a name="iddle2044"></a>in stark contrast to our finding that quick find always (and quick union sometimes) uses <span class="docEmphasis">at least</span> <span class="docEmphasis">MN</span>/2 instructions. The conclusion is that, with weighted quick union, we can guarantee that we can solve huge practical problems in a reasonable amount of time (see <a class="docLink" href="#ch01qa2q8">Exercise 1.11</a>). For the price of a few extra lines of code, we get a program that is literally millions of times faster than the simpler algorithms for the huge problems that we might encounter in practical applications.</p>
<p class="docText">It is evident from the diagrams that relatively few nodes are far from the root; indeed, empirical studies on huge problems tell us that the weighted quick-union algorithm of <a class="docLink" href="#ch01ex05">Program 1.3</a> typically can solve practical problems in <span class="docEmphasis">linear</span> time. That is, the cost of running the algorithm is within a constant factor of the cost of reading the input. We could hardly expect to find a more efficient algorithm.</p>
<p class="docText">We immediately come to the question of whether or not we can find an algorithm that has <span class="docEmphasis">guaranteed</span> linear performance. This question is an extremely difficult one that plagued researchers for many years (see <a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7">Section 2.7</a>). There are a number of easy ways to improve the weighted quick-union algorithm further. Ideally, we would like every node to point directly to the root of its tree, but we do not want to pay the price of changing a large number of pointers, as we did in the quick-union algorithm. We can approach the ideal simply by making all the nodes that we do examine point to the root. This step seems drastic at first blush, but it is easy to implement, and there is nothing sacrosanct about the structure of these trees: If we can modify them to make the algorithm more efficient, we should do so. We can implement this method, called <span class="docEmphasis">path compression</span>, easily, by adding another pass through each path during the <span class="docEmphasis">union</span> operation, setting the <tt>id</tt> enTRy corresponding to each vertex encountered along the way to point to the root. The net result is to flatten the trees almost completely, approximating the ideal achieved by the quick-find algorithm, as illustrated in <a class="docLink" href="#ch01fig09">Figure 1.9</a>. The analysis that establishes this fact is extremely complex, but the method is simple and effective. <a class="docLink" href="#ch01fig11">Figure 1.11</a> shows the result of path compression for a large example.</p>
<a name="ch01fig09"></a><p><center>
<h5 class="docFigureTitle">Figure 1.9. Path compression</h5>
<h5></h5><h5></h5></center></p><p class="docText">We can make paths in the trees even shorter by simply making all the objects that we touch point to the root of the new tree for the union operation, as shown in these two examples. The example at the top shows the result corresponding to <a class="docLink" href="#ch01fig07">Figure 1.7</a>. For short paths, path compression has no effect, but when we process the pair 1 6, we make 1, 5, and 6 all point to 3 and get a tree flatter than the one in <a class="docLink" href="#ch01fig07">Figure 1.7</a>. The example at the bottom shows the result corresponding to <a class="docLink" href="#ch01fig08">Figure 1.8</a>. Paths that are longer than one or two links can develop in the trees, but whenever we traverse them, we flatten them. Here, when we process the pair 6 8, we flatten the tree by making 4, 6, and 8 all point to 0.</p>
<p class="docText">
<img border="0" alt="" width="175" height="335" src="01fig09.gif" /></p>
<br />
<a name="ch01fig10"></a><p><center>
<h5 class="docFigureTitle">Figure 1.10. Path compression by halving</h5>
<h5></h5><h5></h5></center></p><p class="docText">We can nearly halve the length of paths on the way up the tree by taking two links at a time, and setting the bottom one to point to the same node as the top one, as shown in this example. The net result of performing this operation on every path that we traverse is asymptotically the same as full path compression.</p>
<p class="docText">
<img border="0" alt="" width="95" height="290" src="01fig10.gif" /></p>
<br />
<a name="ch01fig11"></a><p><center>
<h5 class="docFigureTitle">Figure 1.11. A large example of the effect of path compression</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts the result of processing random pairs from 100 objects with the weighted quick-union algorithm with path compression. All but two of the nodes in the tree are one or two steps from the root.</p>
<p class="docText">
<img border="0" alt="" width="500" height="24" src="01fig11.gif" /></p>
<br />
<p class="docText">There are many other ways to implement path compression. For example, <a class="docLink" href="#ch01ex07">Program 1.4</a> is an implementation that compresses the paths by making each link skip to the next node in the path on the way up the tree, as depicted in <a class="docLink" href="#ch01fig10">Figure 1.10</a>. This method is slightly easier to implement than full path compression (see <a class="docLink" href="#ch01qa2q13">Exercise 1.16</a>), and achieves <a name="iddle1557"></a> the same net result. We refer to this variant as <span class="docEmphasis">weighted quick-union with path compression by halving</span>. Which of these methods is the more effective? Is the savings achieved worth the extra time required to implement path compression? Is there some other technique that we should consider? To answer these questions, we need to look more carefully at the algorithms and implementations. We shall return to this topic in <a class="docLink" href="ch02.html#ch02">Chapter 2</a>, in the context of our discussion of basic approaches to the analysis of algorithms.</p>
<a name="ch01ex07"></a><h5 id="title-IDAVOYFL" class="docExampleTitle">Program 1.4. Path compression by halving</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">If we replace the <tt>for</tt> loops in <a class="docLink" href="#ch01ex05">Program 1.3</a> by this code, we halve the length of any path that we traverse. The net result of this change is that the trees become almost completely flat after a long sequence of operations.</p>
<div class="docText"><pre>for (i = p; i != id[i]; i = id[i])
  id[i] = id[id[i]];
for (j = q; j != id[j]; j = id[j])
  id[j] = id[id[j]];</pre></div><br />
</td></tr></table></p>
<p class="docText">The end result of the succession of algorithms that we have considered to solve the connectivity problem is about the best that we could hope for in any practical sense. We have algorithms that are easy to implement whose running time is guaranteed to be within a constant factor of the cost of gathering the data. Moreover, the algorithms are <span class="docEmphasis">online</span> algorithms that consider each edge once, using space proportional to the number of objects, so there is no limitation on the number of edges that they can handle. The empirical studies in <a class="docLink" href="#ch01table01">Table 1.1</a> validate our conclusion that <a class="docLink" href="#ch01ex05">Program 1.3</a> and its path-compression variations are useful even for huge practical applications. Choosing which is the best among these algorithms requires careful and sophisticated analysis (see <a class="docLink" href="ch02.html#ch02">Chapter 2</a>).</p>
<a name="ch01table01"></a><p><table cellspacing="0" frame="hsides" rules="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 1.1. Empirical study of union-find algorithms</h5></caption><colgroup align="left" span="7"><col width="100"></col><col width="75"></col><col width="75"></col><col width="75"></col><col width="75"></col><col width="75"></col><col width="75"></col></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top" colspan="7"><p class="docText">These relative timings for solving random connectivity problems using various union&ndash;find algorithms demonstrate the effectiveness of the weighted version of the quick union algorithm. The added incremental benefit due to path compression is less important. In these experiments, <span class="docEmphasis">M</span> is the number of random connections generated until all <span class="docEmphasis">N</span> objects were connected. This process involves substantially more <span class="docEmphasis">find</span> operations than <span class="docEmphasis">union</span> operations, so quick union is substantially slower than quick find. Neither quick find nor quick union is feasible for huge <span class="docEmphasis">N</span>. The running time for the weighted methods is evidently proportional to <span class="docEmphasis">N</span>, as it approximately doubles when <span class="docEmphasis">N</span> is doubled.</p></td></tr><tr><td class="bottomBorder" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="bottomBorder" align="center" valign="top"><p class="docText"><span class="docEmphasis">M</span></p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">F</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">U</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">W</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">P</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">H</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">1000</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">6206</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">14</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">25</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">6</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">5</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">3</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">2500</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">20236</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">82</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">210</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">13</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">15</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">12</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">5000</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">41913</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">304</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1172</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">46</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">26</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">25</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">10000</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">83857</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1216</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">4577</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">91</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">73</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">50</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">25000</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">309802</p></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="center" valign="top"><p class="docText">219</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">208</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">216</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">50000</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">708701</p></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="center" valign="top"><p class="docText">469</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">387</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">497</p></td></tr><tr><td class="bottomBorder" align="center" valign="top"><p class="docText">100000</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">1545119</p></td><td class="bottomBorder" align="left" valign="top">&nbsp;</td><td class="bottomBorder" align="left" valign="top">&nbsp;</td><td class="bottomBorder" align="center" valign="top"><p class="docText">1071</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">1106</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">1096</p></td></tr><tr><td class="docTableCell" align="left" valign="top" colspan="7"><p class="docText"><span class="docEmphasis">Key</span>:</p>
<blockquote><p></p><p class="docList">F quick find (<a class="docLink" href="#ch01ex01">Program 1.1</a>)</p></blockquote></td></tr></table></p><p></p><p class="docList">U quick union (<a class="docLink" href="#ch01ex03">Program 1.2</a>)</p><p></p><p class="docList">W weighted quick union (<a class="docLink" href="#ch01ex05">Program 1.3</a>)</p><p></p><p class="docList">P weighted quick union with path compression (<a class="docLink" href="#ch01qa2q13">Exercise 1.16</a>)</p><p></p><p class="docList">H weighted quick union with halving (<a class="docLink" href="#ch01ex07">Program 1.4</a>)</p></td></tr></table><br />
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">1.4</span> Show the contents of the <tt>id</tt> array after each <span class="docEmphasis">union</span> operation when you use the quick-find algorithm (<a class="docLink" href="#ch01ex01">Program 1.1</a>) to solve the connectivity problem for the sequence 0-2, 1-4, 2-5, 3-6, 0-4, 6-0, and 1-3. Also give the number of times the program accesses the <tt>id</tt> array for each input pair.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">1.5</span> Do <a class="docLink" href="#ch01qa2q1">Exercise 1.4</a>, but use the quick-union algorithm (<a class="docLink" href="#ch01ex03">Program 1.2</a>).</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q3"></a><b></b></td><td><p class="docText"><a name="iddle1428"></a><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">1.6</span> Give the contents of the <tt>id</tt> array after each <span class="docEmphasis">union</span> operation for the weighted quick-union algorithm running on the examples corresponding to <a class="docLink" href="#ch01fig07">Figure 1.7</a> and <a class="docLink" href="#ch01fig08">Figure 1.8</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">1.7</span> Do <a class="docLink" href="#ch01qa2q1">Exercise 1.4</a>, but use the weighted quick-union algorithm (<a class="docLink" href="#ch01ex05">Program 1.3</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">1.8</span> Do <a class="docLink" href="#ch01qa2q1">Exercise 1.4</a>, but use the weighted quick-union algorithm with path compression by halving (<a class="docLink" href="#ch01ex07">Program 1.4</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">1.9</span> Prove an upper bound on the number of machine instructions required to process <span class="docEmphasis">M</span> connections on <span class="docEmphasis">N</span> objects using <a class="docLink" href="#ch01ex05">Program 1.3</a>. You may assume, for example, that any C++ assignment statement always requires less than <span class="docEmphasis">c</span> instructions, for some fixed constant <span class="docEmphasis">c</span>.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q7"></a><b></b></td><td><p class="docText"><a name="iddle2045"></a><span class="docEmphStrong">1.10</span> Estimate the minimum amount of time (in days) that would be required for quick find (<a class="docLink" href="#ch01ex01">Program 1.1</a>) to solve a problem with 10<sup>9</sup> objects and 10<sup>6</sup> input pairs, on a computer capable of executing 10<sup>9</sup> instructions per second. Assume that each iteration of the inner <tt>for</tt> loop requires at least 10 instructions.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">1.11</span> Estimate the maximum amount of time (in seconds) that would be required for weighted quick union (<a class="docLink" href="#ch01ex05">Program 1.3</a>) to solve a p10<span class="docEmphasis">10</span><sup>6</sup> input pairs, on a computer capable of executing 10<sup>9</sup> instructions per second. Assume that each iteration of the outer <tt>while</tt> loop requires at most 100 instructions.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">1.12</span> Compute the <span class="docEmphasis">average</span> distance from a node to the root in a worst-case tree of 2<span class="docEmphasis"><sup>n</sup></span> nodes built by the weighted quick-union algorithm.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q10"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">1.13</span> Draw a diagram like <a class="docLink" href="#ch01fig10">Figure 1.10</a>, starting with eight nodes instead of nine.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q11"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">1.14</span> Give a sequence of input pairs that causes the weighted quick-union algorithm (<a class="docLink" href="#ch01ex05">Program 1.3</a>) to produce a path of length 4.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q12"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">1.15</span> Give a sequence of input pairs that causes the weighted quick-union algorithm with path compression by halving (<a class="docLink" href="#ch01ex07">Program 1.4</a>) to produce a path of length 4.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q13"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">1.16</span> Show how to modify <a class="docLink" href="#ch01ex05">Program 1.3</a> to implement <span class="docEmphasis">full</span> path compression, where we complete each <span class="docEmphasis">union</span> operation by making every node that we touch point to the root of the new tree.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q14"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">1.17</span> Answer <a class="docLink" href="#ch01qa2q1">Exercise 1.4</a>, but using the weighted quick-union algorithm with full path compression (<a class="docLink" href="#ch01qa2q13">Exercise 1.16</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q15"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">1.18</span> Give a sequence of input pairs that causes the weighted quick-union algorithm with full path compression (<a class="docLink" href="#ch01qa2q13">Exercise 1.16</a>) to produce a path of length 4.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q16"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">1.19</span> Give an example showing that modifying quick union (<a class="docLink" href="#ch01ex03">Program 1.2</a>) to implement full path compression (see <a class="docLink" href="#ch01qa2q13">Exercise 1.16</a>) is not sufficient to ensure that the trees have no long paths.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q17"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">1.20</span> Modify <a class="docLink" href="#ch01ex05">Program 1.3</a> to use the <span class="docEmphasis">height</span> of the trees (longest path from any node to the root), instead of the weight, to decide whether to set <tt>id[i] = j</tt> or <tt>id[j] = i</tt>. Run empirical studies to compare this variant with <a class="docLink" href="#ch01ex05">Program 1.3</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q18"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">1.21</span> Show that <a class="docLink" href="#ch01ex06">Property 1.3</a> holds for the algorithm described in <a class="docLink" href="#ch01qa2q17">Exercise 1.20</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q19"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">1.22</span> Modify <a class="docLink" href="#ch01ex07">Program 1.4</a> to generate random pairs of integers between 0 and <span class="docEmphasis">N</span> &ndash; 1 instead of reading them from standard input, and to loop until <span class="docEmphasis">N</span> &ndash; 1 <a name="iddle1060"></a><span class="docEmphasis">union</span> operations have been performed. Run your program for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup> and print out the total number of edges generated for each value of <span class="docEmphasis">N</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q20"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">1.23</span> Modify your program from <a class="docLink" href="#ch01qa2q19">Exercise 1.22</a> to plot the number of edges needed to connect <span class="docEmphasis">N</span> items, for 100 <img src="U2264.GIF" border="0" /> <span class="docEmphasis">N</span> <img src="U2264.GIF" border="0" /> 1000.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa2q21"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">1.24</span> Give an approximate formula for the number of random edges that are required to connect <span class="docEmphasis">N</span> objects, as a function of <span class="docEmphasis">N</span>.</p></td></tr></table></p>
<ul></ul></div></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch01lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch01lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table><!--IP User 2--></td></body></head></html>