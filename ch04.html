<html><head><title>Chapter Four. Abstract Data Types</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03lev1sec7.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch04lev1sec1.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch04"></a>
<h2 id="title-IDAN1O1H" class="docChapterTitle">Chapter Four. Abstract Data Types</h2>
<p class="docText"><a name="iddle1001"></a>Developing abstract models for our data and for the ways in which our programs process those data is an essential ingredient in the process of solving problems with a computer. We see examples of this principle at a low level in everyday programming (for example when we use arrays and linked lists, as discussed in <a class="docLink" href="ch03.html#ch03">Chapter 3</a>) and at a high level in problem-solving (as we saw in <a class="docLink" href="ch01.html#ch01">Chapter 1</a>, when we used union&ndash;find forests to solve the connectivity problem). In this chapter, we consider <span class="docEmphasis">abstract data types (ADTs)</span>, which allow us build programs that use high-level abstractions. With abstract data types, we can separate the conceptual transformations that our programs perform on our data from any particular data-structure representation and algorithm implementation.</p>
<p class="docText">All computer systems are based on <span class="docEmphasis">layers of abstraction</span>: We adopt the abstract model of a bit that can take on a binary 0&ndash;1 value from certain physical properties of silicon and other materials; then, we adopt the abstract model of a machine from dynamic properties of the values of a certain set of bits; then, we adopt the abstract model of a programming language that we realize by controlling the machine with a machine-language program; then, we adopt the abstract notion of an algorithm implemented as a C++ language program. Abstract data types allow us to take this process further, to develop abstract mechanisms for certain computational tasks at a higher level than provided by the C++ system, to develop application-specific abstract mechanisms that are suitable for solving problems in numerous applications areas, and to build higher-level abstract mechanisms that use <a name="iddle1002"></a><a name="iddle1005"></a><a name="iddle1261"></a><a name="iddle1274"></a><a name="iddle1627"></a><a name="iddle1686"></a>these basic mechanisms. Abstract data types give us an ever-expanding set of tools that we can use to attack new problems.</p>
<p class="docText">On the one hand, our use of abstract mechanisms frees us from detailed concern about how they are implemented; on the other hand, when performance matters in a program, we need to be cognizant of the costs of basic operations. We use many basic abstractions that are built into the computer hardware and provide the basis for machine instructions; we implement others in software; and we use still others that are provided in previously written systems software. Often, we build higher-level abstract mechanisms in terms of more primitive ones. The same basic principle holds at all levels: We want to identify the critical operations in our programs and the critical characteristics of our data, to define both precisely at an abstract level, and to develop efficient concrete mechanisms to support them. We consider many examples of this principle in this chapter.</p>
<p class="docText">To develop a new layer of abstraction, we need to <span class="docEmphasis">define</span> the abstract objects that we want to manipulate and the operations that we perform on them; we need to <span class="docEmphasis">represent</span> the data in some data structure and to <span class="docEmphasis">implement</span> the operations; and (the point of the exercise) we want to ensure that the objects are convenient to <span class="docEmphasis">use</span> to solve an applications problem. These comments apply to simple data types as well, and, while the basic mechanisms that we discussed in <a class="docLink" href="ch03.html#ch03">Chapter 3</a> to support data types can be adapted to serve our purposes, C++ offers a significant extension to the structure mechaism, called the <span class="docEmphasis">class</span>, which is extremely useful in building layers of abstraction, and therefore will be the primary tool that we use for this purpose throughout the rest of the book.</p>
<a name="ch04ex01"></a><h5 id="title-IDA44O1H" class="docExampleTitle">Definition 4.1. An <span class="docEmphStrong">abstract data type (ADT)</span> is a data type (a set of values and a collection of operations on those values) that is accessed only through an <span class="docEmphStrong">interface</span>. We refer to a program that uses an ADT as a <span class="docEmphStrong">client</span>, and a program that specifies the data type as an <span class="docEmphStrong">implementation</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The key distinction that makes a data type abstract is drawn by the word <span class="docEmphasis">only</span>: with an ADT, client programs do not access any data values except through the operations provided in the interface. The representation of the data and the functions that implement the operations are in the implementation, and are completely separated from the client, by the interface. We say that the interface is <span class="docEmphasis">opaque</span>: the client cannot see the implementation through the interface. In C++ programs, we normally draw a slightly finer distinction, because the simplest way to set up an interface involves including the data representation in the interface, but specifying that client programs are not allowed to access data directly. That is, client programmers may know the data representation, but they have no way to <span class="docEmphasis">use</span> it.</p>
<p class="docText">As an example, consider the interface for the data type for points (<a class="docLink" href="ch03lev1sec1.html#ch03ex04">Program 3.3</a>) in <a class="docLink" href="ch03lev1sec1.html#ch03lev1sec1">Section 3.1</a>, which explicitly declares that points are represented as structures with pairs of floats, with members named x and y. Indeed, this use of data types is common in large software systems: we develop a set of conventions for how data is to be represented (and define a number of associated operations) and make those conventions available in an interface for use by client programs that comprise a large system. The data type ensures that all parts of the system are in agreement on the representation of core system-wide data structures. While valuable, this strategy has a flaw: if we need to <span class="docEmphasis">change</span> the data representation, then we need to change all the client programs. <a class="docLink" href="ch03lev1sec1.html#ch03ex04">Program 3.3</a> again provides a simple example: one reason for developing the data type is to make it convenient for client programs to manipulate points, and we expect that clients will access the individual coordinates when needed. But we cannot change to a different representation (polar coordinates, say, or three dimensions, or even different data types for the individual coordinates) without changing all the client programs.</p>
<p class="docText">By contrast, <a class="docLink" href="#ch04ex02">Program 4.1</a> shows an implementation of an abstract data type corresponding to <a class="docLink" href="ch03lev1sec1.html#ch03ex04">Program 3.3</a>, using a C++ class to define the data and associated operations at once. <a class="docLink" href="#ch04ex03">Program 4.2</a> is a client program that uses this data type. These programs perform the same calculation as <a class="docLink" href="ch03lev1sec1.html#ch03ex04">Programs 3.3</a> and <a class="docLink" href="ch03lev1sec2.html#ch03ex09">3.8</a>. They illustrate a number of basic properties of classes, which we now consider.</p>
<p class="docText">When we write a definition such as <tt>int i</tt> in a program we are directing the system to reserve space for data of (built-in) type <tt>int</tt>, which we refer to with the name <tt>i</tt>. In C++, we use the term <span class="docEmphasis">object</span> to refer to such an entity. When we write a definition such as <tt>POINT p</tt> in a program, we say that we <span class="docEmphasis">create</span> an object of class <tt>POINT</tt>, which we refer to with the name <tt>p</tt>. In this example, each object has two items of data, named <tt>x</tt> and <tt>y</tt>, which, as with structures, are referred to by names such as <tt>p.y</tt>.</p>
<a name="ch04ex02"></a><h5 id="title-IDACDP1H" class="docExampleTitle">Program 4.1. Point class implementation</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This class defines a data type consisting of the set of values &quot;pairs of floating-point numbers&quot; (which are presumably interpreted as points in the Cartesian plane), along with two <span class="docEmphasis">member functions</span> that are defined for all <tt>POINT</tt>s: the function <tt>POINT()</tt> is a <span class="docEmphasis">constructor</span> that initializes the coordinates to random values between 0 and 1, and the function <tt>distance(POINT)</tt> computes the distance to another <tt>POINT</tt>. The data representation is <tt>private</tt> and can be accessed or modified only by the member functions, and the member functions are <tt>public</tt> and can be used by any client. We might keep this code, for example, in a file named <tt>POINT.cxx</tt>.</p>
<div class="docText"><pre>#include &lt;math.h&gt;
class POINT
  {
    private:
      float x, y;
    public:
      POINT()
        { x = 1.0*rand()/RAND_MAX;
          y = 1.0*rand()/RAND_MAX; }
      float distance(POINT a)
        { float dx = x-a.x, dy = y-a.y;
          return sqrt(dx*dx + dy*dy); }
   };</pre></div><br />
</td></tr></table></p>
<p class="docText">We refer to the items <tt>x</tt> and <tt>y</tt> as <span class="docEmphasis">data members</span> of the class. A class may also define <span class="docEmphasis">member functions</span> that implement the operations associated with the data type. For example, the class defined in <a class="docLink" href="#ch04ex02">Program 4.1</a> has two member functions, named <tt>POINT</tt> and <tt>distance</tt>.</p>
<p class="docText">Client programs, such as <a class="docLink" href="#ch04ex03">Program 4.2</a>, can call the member functions associated with an object by referring to them by name, in the same way that they would refer to the data in a <tt>struct</tt>. For example, the expression <tt>p.distance(q)</tt> computes the distance between <tt>p</tt> and <tt>q</tt> (it should compute the same value as <tt>q.distance(p)</tt>). The first function in <a class="docLink" href="#ch04ex02">Program 4.1</a>, <tt>POINT()</tt>, is a special kind of member function called a <span class="docEmphasis">constructor</span>: its name is the same as the name of the class, and it is called when the object is created. The definition <tt>POINT p</tt> in a client causes space to be allocated for a new object, and then (through <tt>POINT()</tt>) causes each of its data items to be set to a random value between 0 and 1.</p>
<a name="ch04ex03"></a><h5 id="title-IDADGP1H" class="docExampleTitle">Program 4.2. Point client (closest-point computation)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This version of <a class="docLink" href="ch03lev1sec2.html#ch03ex09">Program 3.8</a> is a client that uses the <tt>POINT</tt> ADT defined in <a class="docLink" href="#ch04ex04">Program 4.3</a>. The <tt>new[]</tt> operator constructs an array of <tt>POINT</tt> objects (invoking the constructor <tt>POINT()</tt> to initialize each with random coordinates). The call <tt>a[i].distance(a[j])</tt> invokes the <tt>distance</tt> member function for the object <tt>a[i]</tt> with argument <tt>a[j]</tt>.</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
#include "POINT.cxx"
int main(int argc, char *argv[])
 { float d = atof(argv[2]);
   int i, cnt = 0, N = atoi(argv[1]);
   POINT *a = new POINT[N];
   for (i = 0; i &lt; N; i++)
     for (int j = i+1; j &lt; N; j++)
       if (a[i].distance(a[j]) &lt; d) cnt++;
   cout &lt;&lt; cnt &lt;&lt; " pairs within " &lt;&lt; d &lt;&lt; endl;
 }</pre></div><br />
</td></tr></table></p>
<p class="docText">This style of programming, which is sometimes called <span class="docEmphasis">object-oriented programming</span>, is directly supported by the C++ <tt>class</tt> construct. We may think of classes as an extension of structures where we not only aggregate data but also define operations on that data. There may be many different objects that belong to a class, but all of them are similar in that the set of values that their data members can take on is the same, and the collection of operations that can be performed on their data members is the same; in short, they are instances of the same data type. In object-oriented programming, we direct objects to process their member data (as opposed to having free functions processing the data stored in objects).</p>
<p class="docText">We are using this small class as an example to introduce the basic features of classes, so it is far from complete. In real code for points we will have many more operations. For example, <a class="docLink" href="#ch04ex02">Program 4.1</a> does not even provide us with the operations that we need to learn the values of <tt>x</tt> and <tt>y</tt>. Adding such operations, and others, is a straightforward task, as we shall see. In Part 5, we shall consider classes for points and other geometric abstractions, such as lines and polygons, in some detail.</p>
<p class="docText">Stuctures can have associated functions in C++, too (but not in C). The key difference between classes and structures has to do with access to information, as specified by the keywords <tt>private</tt> and <tt>public</tt>. A <span class="docEmphasis">private</span> class member can be referred to only <span class="docEmphasis">within</span> the class; a <span class="docEmphasis">public</span> member can be referred to by any client. Private members can be either data or functions: in <a class="docLink" href="#ch04ex02">Program 4.1</a> only the data is private, but we shall see numerous examples of classes that use private member functions as well. By default, members of classes are private, while members of structures are public.</p>
<p class="docText">For example, in a client program that uses <tt>POINT</tt>, we cannot refer to the data members <tt>p.x</tt>, <tt>q.y</tt>, and so forth, as we could if <tt>POINT</tt> were a <tt>struct</tt>, because <tt>x</tt> and <tt>y</tt> are private. All that we <span class="docEmphasis">can</span> do is use the public member functions to process points. Those functions have direct access to the data members of any object in the class. For example, when we invoke the <tt>distance</tt> function in <a class="docLink" href="#ch04ex02">Program 4.1</a> with the call <tt>p.distance(q)</tt> the name <tt>x</tt> in the statement <tt>dx = x - a.x</tt> refers to the <tt>x</tt> data member in the point <tt>p</tt> (because <tt>distance</tt> was invoked as a member function of the instance <tt>p</tt>), and the name <tt>a.x</tt> refers to the <tt>x</tt> data member in the point <tt>q</tt> (because <tt>q</tt> is the actual parameter corresponding to the formal parameter <tt>a</tt>). We could say <tt>dx = this-&gt;x - a.x</tt> to eliminate possible ambiguity or confusion&mdash;the keyword <tt>this</tt> refers to a pointer to the object for which a member function is invoked.</p>
<p class="docText">When we apply the keyword <tt>static</tt> to a data member, it means that there is only one copy of that variable (which is associated with the class) instead of multiple copies (associated with each object), as in the case of ordinary members. For example, we often use this facility to keep track of statistics associated with the objects: we might include a variable <tt>static int N</tt> in <tt>POINT</tt>,add <tt>N++</tt> to the constructor, and then be able to know the number of points that have been created.</p>
<p class="docText">We certainly might take the point of view that a function computing the distance between two points is <span class="docEmphasis">not</span> something that should be associated with either point, but rather that our previous implementation, taking two points as arguments, is more natural. In C++ we could take this approach by defining a different distance function in our <tt>POINT</tt> class, as follows:</p>
<div class="docText"><pre>static float distance(POINT a, POINT b)
  {
    float dx = a.x - b.y, dy = a.y - b.y;
    return sqrt(dx*dx + dy*dy);
  }</pre></div><br />
<p class="docText">A <span class="docEmphasis">static</span> member function is one that may access members of a class, but does not need to be invoked for a particular object.</p>
<p class="docText">Another alternative would be to define <tt>distance</tt> as a free function outside the declaration of class <tt>POINT</tt> (using the same code as in the previous paragraph, but omitting the keyword <tt>static</tt>). Since this version of <tt>distance</tt> needs access to private data members of <tt>POINT</tt>, we would need to include in the declaration of class <tt>POINT</tt> the line</p>
<div class="docText"><pre>friend float distance(POINT, POINT);</pre></div><br />
<p class="docText">A <span class="docEmphasis">friend</span> is a function that, while not a member of a class, has access to its private members.</p>
<p class="docText">To provide client programs with the capability to read data values, we might provide member functions that return them:</p>
<div class="docText"><pre>float X() const { return x; }
float Y() const { return y; }</pre></div><br />
<p class="docText">These functions are declared to be <tt>const</tt> because they do not modify the data members of the object on which they are called. We often include functions of this kind in C++ classes. Note that they might be more difficult to implement if we use a different data representation, such as polar coordinates, but this difficulty would be transparent to the client. We also can take advantage of this flexibility in member functions&mdash;if we used references like <tt>a.X()</tt> instead of <tt>a.x</tt> in the implementation of <tt>distance</tt> in <a class="docLink" href="#ch04ex02">Program 4.1</a>, then we would not have to change that code if we were to change the data representation. We can give ourselves this flexibility even in classes where we do not want the client to have access to the data, by putting these functions in the private part of the class.</p>
<p class="docText">For many applications, our primary purpose in building a class is to define a new data type, particularly suited to the needs of the application. When we do so, we often find ourselves wanting to use this data type in the same way that we use the C++ built-in types, such as <tt>int</tt> or <tt>float</tt>. We shall consider this topic in detail in <a class="docLink" href="ch04lev1sec8.html#ch04lev1sec8">Section 4.8</a>. One important tool that helps us accomplish this objective is called <span class="docEmphasis">operator overloading</span>, where C++ allows us to specify that we want fundmental operators to apply to objects in our class, and precisely what the operators should do. For example, suppose that we wanted to consider two points as identical if the distance between them is less than <tt>.001</tt>. By adding the code</p>
<div class="docText"><pre>friend int operator==(POINT a, POINT b)
  { return distance(a, b) &lt; .001; }</pre></div><br />
<p class="docText">to our class, we could use the operator <tt>==</tt> to test whether two points are equal (according to this definition).</p>
<p class="docText">Another operator that we typically wish to overload is the operator <tt>&lt;&lt;</tt> from the class <tt>ostream</tt>. In C++ programming, we generally assume that we can use this operator to print out the value of any object; in fact, we can only do so if the class defines the overloaded <tt>operator &lt;&lt;</tt>. For our <tt>POINT</tt> class, we can do so as follows:</p>
<div class="docText"><pre>ostream&amp; operator&lt;&lt;(ostream&amp; t, POINT p)
  {
   cout &lt;&lt; "(" &lt;&lt; p.X() &lt;&lt; "," &lt;&lt; p.Y() &lt;&lt; ")";
   return t;
  }</pre></div><br />
<p class="docText">This operator is not a member function, nor even a <tt>friend</tt>: it uses the public member functions <tt>X()</tt> and <tt>Y()</tt> to access the data.</p>
<p class="docText">How does the C++ class concept relate to the client-interface-implementation paradigm and ADTs? It provides direct language support, but is sufficiently general that there are a number of different approaches that we could take. We shall usually adopt the convention that <span class="docEmphasis">the public function declarations in a class comprise its interface</span>. That is, we keep the data representation in the private part of the class, where it cannot be accessed by programs that use the class (client programs). All the client programs &quot;know&quot; about the class is the public information about its member functions (name, type of return value, and types of arguments). In this book, to emphasize the nature of the interface defined by a class, we shall first consider the interface, as illustrated in <a class="docLink" href="#ch04ex04">Program 4.3</a>. Then, we shall consider an implementation, such as <a class="docLink" href="#ch04ex02">Program 4.1</a>. The essential point is that this arrangement makes it easy for us to consider other implementations, with different data representations and different implementations of the functions, and to test and compare implementations without changing the client programs at all.</p>
<a name="ch04ex04"></a><h5 id="title-IDAGYP1H" class="docExampleTitle">Program 4.3. Point ADT interface</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">By convention, we derive the interface associated with a class ADT implementation by removing the private parts and by replacing function implementations with declarations (signatures). This interface is derived in this way from <a class="docLink" href="#ch04ex02">Program 4.1</a>. We can use different implementations that have the same interface without changing any code in the client programs that use the ADT.</p>
<div class="docText"><pre> class POINT
   {
    private:
      // Implementation-dependent code
    public:
      POINT();
      float distance(POINT) const;
   };</pre></div><br />
</td></tr></table></p>
<p class="docText">For many applications, the ability to change implementations is a requirement. For example, suppose that we are developing software for a company that needs to process mailing lists of potential customers. With a C++ class, we can define functions that allow client programs to manipulate the data without directly accessing it. Instead, we provide member functions that return the data of interest. For example, we might provide client programs with an interface defining operations such as <span class="docEmphasis">extract customer name</span> or <span class="docEmphasis">add customer record</span>. The most important implication of this arrangement is that we can use the same client programs even if we need to change the format used for the mailing lists. That is, we can change the data representation and the implementation of the functions that access the data without having to change the client programs.</p>
<p class="docText">Class data-type implementations of this sort are sometimes called <span class="docEmphasis">concrete data types</span>. However, a data type that adheres to these conventions actually meets our definition of an ADT (<a class="docLink" href="#ch04ex01">Definition 4.1</a>)&mdash;the distinction is a matter of precisely defining words like &quot;access,&quot; &quot;refer,&quot; and &quot;specify,&quot; which is tricky business that we shall leave to programming-language theorists. Indeed, <a class="docLink" href="#ch04ex01">Definition 4.1</a> does not specify what an interface is or how the data type and the operations are to be described. This imprecision is necessary because specifying such information in full generality requires a formal mathematical language and eventually leads to difficult mathematical questions. This question is central in programming language design. We shall discuss the specification issue further after we consider examples of ADTs.</p>
<p class="docText">Our use of C++ classes to implement ADTs with the convention that the public function definitions comprise the interface is not a perfect arrangment because interface and implementation are not completely separate. We do have to recompile clients when we change implementations. We shall consider some alternatives in <a class="docLink" href="ch04lev1sec5.html#ch04lev1sec5">Section 4.5</a>.</p>
<p class="docText">ADTs have emerged as an effective mechanism supporting <span class="docEmphasis">modular programming</span> as an organizing principle for large modern software systems. They provide a way to limit the size and complexity of the interface between (potentially complicated) algorithms and associated data structures and (a potentially large number of) programs that use the algorithms and data structures. This arrangement makes it easier to understand a large applications program as a whole. Moreover, unlike simple data types, ADTs provide the flexibility necessary to make it convenient to change or improve the fundamental data structures and algorithms in the system. Most important, the ADT interface defines a contract between users and implementors that provides a precise means of communicating what each can expect of the other.</p>
<p class="docText">With a carefully designed ADT, we can make use of the separation between client and implementations in many interesting ways. For example, we commonly use driver programs when developing or debugging ADT implementations. Similarly, we often use incomplete implementations of ADTs, called <span class="docEmphasis">stubs</span>, as placeholders while building systems, to learn properties of clients.</p>
<p class="docText">We examine ADTs in detail in this chapter because they also play an important role in the study of data structures and algorithms. Indeed, the essential motivation behind the development of nearly all the algorithms that we consider in this book is to provide efficient implementations of the basic operations for certain fundamental ADTs that play a critical role in many computational tasks. Designing an ADT is only the first step in meeting the needs of applications programs&mdash;we also need to develop viable implementations of the associated operations and underlying data structures that enable them. Those tasks are the topic of this book. Moreover, we use abstract models directly to develop and to compare the performance characteristics of algorithms and data structures, as in the example in <a class="docLink" href="ch01.html#ch01">Chapter 1</a>: Typically, we develop an applications program that uses an ADT to solve a problem, then develop multiple implementations of the ADT and compare their effectiveness. In this chapter, we consider this general process in detail, with numerous examples.</p>
<p class="docText">C++ programmers use data types and ADTs regularly. At a low level, when we process integers using only the operations provided by C++ for integers, we are essentially using a system-defined abstraction for integers. The integers could be represented and the operations implemented some other way on some new machine, but a program that uses only the operations specified for integers will work properly on the new machine. In this case, the various C++ operations for integers constitute the interface, our programs are the clients, and the system hardware and software provide the implementation. Often, the data types are sufficiently abstract that we can move to a new machine with, say, different representations for integers or floating point numbers, without having to change programs. However, this example also illustrates that we cannot achieve this ideal as often as we would like, because client programs can glean information about the data representation by pushing resource bounds. For example, we can learn something about how integers are represented on a machine by, say, going into a loop that doubles an integer until an overflow error is reported.</p>
<p class="docText">A number of the examples in <a class="docLink" href="ch03.html#ch03">Chapter 3</a> are C++ programs written in a &quot;C style.&quot; C programmers often define interfaces in the form of header files that describe a set of operations on some data structure, with implementations in some independent program file. This arrangement provides a contract between user and implementor, and is the basis for the standard libraries that are found in C programming environments. However, many such libraries comprise operations on a particular data structure, and therefore constitute data types, but not <span class="docEmphasis">abstract</span> data types. For example, the C string library is not an ADT because programs that use strings know how strings are represented (arrays of characters) and typically access them directly via array indexing or pointer arithmetic.</p>
<p class="docText">By contrast, C++ classes allow us to not only use different implementations of the operations, but also base them upon different underlying data structures. Again, the key distinction that characterizes ADTs is that we can make such changes without modifying any client programs at all, because of the requirement that the data type be accessed <span class="docEmphasis">only</span> through the interface. The <tt>private</tt> keyword in the class definition prevents client programs from accessing the data directly. For example, we could provide an implementation for the <tt>string</tt> class in the C++ standard library based on, for example, a linked-list representation of strings, and use it without changing our client programs.</p>
<p class="docText">We shall see numerous examples of ADT implementations with C++ classes throughout this chapter. After we have developed a feel for the concept, we shall return to a discussion of philosophical and practical implications, at the end of the chapter.</p>
</td></tr></table></p>
<p class="docText">&nbsp;<a name="iddle1978"></a><a name="iddle1265"></a><a name="iddle1269"></a><a name="iddle1301"></a><a name="iddle1341"></a><a name="iddle1529"></a><a name="iddle1854"></a><a name="iddle2056"></a><a name="iddle1278"></a><a name="iddle1983"></a><a name="iddle1270"></a><a name="iddle1323"></a><a name="iddle1530"></a><a name="iddle1855"></a><a name="iddle2434"></a><a name="iddle2523"></a><a name="iddle1267"></a><a name="iddle1299"></a><a name="iddle1511"></a><a name="iddle1518"></a><a name="iddle1531"></a><a name="iddle1536"></a><a name="iddle1857"></a><a name="iddle1268"></a><a name="iddle1430"></a><a name="iddle1670"></a><a name="iddle1683"></a><a name="iddle1996"></a><a name="iddle2000"></a><a name="iddle2005"></a><a name="iddle2015"></a><a name="iddle1263"></a><a name="iddle1330"></a><a name="iddle1342"></a><a name="iddle2057"></a><a name="iddle1013"></a><a name="iddle1019"></a><a name="iddle1920"></a><a name="iddle2470"></a><a name="iddle1523"></a><a name="iddle1676"></a><a name="iddle1766"></a></p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa1q1"></a><b></b></td><td><p class="docText"><a name="iddle1014"></a><a name="iddle1979"></a><a name="iddle2122"></a><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">4.1</span> Suppose that we wish to count the number of pairs of points that fall within a <span class="docEmphasis">square</span> of size <tt>d</tt>. Give two different versions of client and implementation to solve this problem: first, modify <tt>distance</tt> appropriately; second, replace <tt>distance</tt> with <tt>X</tt> and <tt>Y</tt> member functions.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa1q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.2</span> Add a member function to the point class in <a class="docLink" href="#ch04ex04">Program 4.3</a> that returns the distance to the origin.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa1q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">4.3</span> Modify the point ADT implementation in <a class="docLink" href="#ch04ex04">Program 4.3</a> to represent points with polar coordinates.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa1q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">4.4</span> Write a client program that takes an integer <span class="docEmphasis">N</span> from the command line, and fills an array with <span class="docEmphasis">N</span> points, no two of which are equal. Use the overloaded<tt>==</tt> operator described in the text to test equality.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa1q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">4.5</span> Convert the list-processing interface in <a class="docLink" href="ch03lev1sec4.html#ch03lev1sec4">Section 3.4</a> (<a class="docLink" href="ch03lev1sec4.html#ch03ex15">Program 3.12</a>) into a class-based ADT implementation, using a linked-list representation as in <a class="docLink" href="ch03lev1sec5.html#ch03ex17">Program 3.14</a>. Test your interface by modifying the client program, <a class="docLink" href="ch03lev1sec4.html#ch03ex16">Program 3.13</a>, to use it, then switch to an array-based implementation (see <a class="docLink" href="ch03lev1sec5.html#ch03qa5q7">Exercise 3.52</a>).</p></td></tr></table></p>
<a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03lev1sec7.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch04lev1sec1.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>