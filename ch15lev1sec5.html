<html><head><title>15.5. Text-String&ndash;Index Algorithms</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch15lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch16.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch15lev1sec5"></a>
<h3 id="643999-948" class="docSection1Title">15.5. Text-String&ndash;Index Algorithms</h3>
<p class="docText">In <a class="docLink" href="ch12lev1sec7.html#ch12lev1sec7">Section 12.7</a>, we considered the process of building a <span class="docEmphasis">string index</span>, and we used a binary search tree with string pointers to provide the capability to determine whether or not a given key string appears in a huge text. In this section, we look at more sophisticated algorithms using multiway tries, but starting from the same point of departure. We consider each position in the text to be the beginning of a string key that runs all the way to the end of the text and build a symbol table with these keys, using string pointers. The keys are all different (for example, they are of different lengths), and most of them are extremely long. The purpose of a search is to determine whether or not a given search key is a prefix of one of the keys in the index, which is equivalent to discovering whether the search key appears somewhere in the text string.</p>
<p class="docText">A search tree that is built from keys defined by string pointers into a text string is called a <span class="docEmphasis">suffix tree</span>. We could use any algorithm that can admit variable-length keys. Trie-based methods are particularly suitable, because (except for the trie methods that do one-way branching at the tails of keys) their running time does not depend on the key length, but rather depends on only the number of digits required to distinguish among the keys. This characteristic lies in direct contrast to, for example, hashing algorithms, which do not apply immediately to this problem because their running time is proportional to the key length.</p>
<p class="docText"><a name="iddle1190"></a><a name="iddle2048"></a><a name="iddle2520"></a><a name="iddle2582"></a><a class="docLink" href="#ch15fig20">Figure 15.20</a> gives examples of string indexes built with BSTs, patricia, and TSTs (with leaves). These indexes use just the keys starting at word boundaries; an index starting at character boundaries would provide a more complete index, but would use significantly more space.</p>
<a name="ch15fig20"></a><p><center>
<h5 class="docFigureTitle">Figure 15.20. Text-string index examples</h5>
<h5></h5><h5></h5></center></p><p class="docText">These diagrams show text-string indexes built from the text <tt>call me ishmael some years ago never mind how long precisely...</tt> using a BST (top), a patricia trie (center), and a TST (bottom). Nodes with string pointers are depicted with the first four characters at the point referenced by the pointer.</p><p class="docText"><div class="v1"><a target="_blank" href="15fig20_alt.gif">[View full size image]</a></div><img border="0" alt="" id="118095012104" width="500" height="300" src="15fig20.gif" /></p>
<br />
<p class="docText">Strictly speaking, even a random string text does not give rise to a random set of keys in the corresponding index (because the keys are not independent). However, we rarely work with random texts in practical indexing applications, and this analytic discrepancy will not stop us from taking advantage of the fast indexing implementations that are possible with radix methods. We refrain from discussing the detailed performance characteristics when we use each of the algorithms to build a string index, because many of the same tradeoffs that we have discussed for general symbol tables with string keys also hold for the string-index problem.</p>
<p class="docText"><a name="iddle1433"></a><a name="iddle1999"></a>For a typical text, standard BSTs would be the first implementation that we might choose, because they are simple to implement (see <a class="docLink" href="ch12lev1sec5.html#ch12ex17">Program 12.10</a>). For typical applications, this solution is likely to provide good performance. One byproduct of the interdependence of the keys&mdash;particularly when we are building a string index for each character position&mdash;is that the worst case for BSTs is not a particular concern for huge texts, since unbalanced BSTs occur with only bizarre constructions.</p>
<p class="docText">Patricia was originally designed for the string-index application. To use <a class="docLink" href="ch15lev1sec3.html#ch15ex10">Programs 15.5</a> and <a class="docLink" href="ch15lev1sec3.html#ch15ex09">15.4</a>, we need only to provide an implementation of <tt>bit</tt> that, given a string pointer and an integer <tt>i</tt>, returns the ith bit of the string (see <a class="docLink" href="#ch15qa5q6">Exercise 15.82</a>). In practice, the height of a patricia trie that implements a text string index will be logarithmic. Moreover, a patricia trie will provide fast search implementations for misses because we do not need to examine all the bytes of the key.</p>
<p class="docText">TSTs afford several of the performance advantages of patricia, are simple to implement, and take advantage of built-in byte-access operations that are typically found on modern machines. They also are amenable to simple implementations, such as <a class="docLink" href="ch15lev1sec4.html#ch15ex19">Program 15.9</a>, that can solve search problems more complicated than fully matching a search key. To use TSTs to build a string index, we need to remove the code that handles ends of keys in the data structure, since we are guaranteed that no string is a prefix of another, and thus we never will be comparing strings to their ends. This modification includes changing the definition of <tt>operator==</tt> in the item-type interface to regard two strings as equal if one is a prefix of the other, as we did in <a class="docLink" href="ch12lev1sec7.html#ch12lev1sec7">Section 12.7</a>, since we will be comparing a (short) search key against a (long) text string, starting at some position in the text string. A third change that is convenient is to keep string pointers in each node, rather than characters, so that every node in the tree refers to a position in the text string (the position in the text string following the first occurrence of the character string defined by the characters on equal branches from the root to that node). Implementing these changes is an interesting and informative exercise that leads to a flexible and efficient text-string&ndash;index implementation (see <a class="docLink" href="#ch15qa5q5">Exercise 15.81</a>).</p>
<p class="docText">Despite all the advantages that we have been discussing, there is an important fact that we are overlooking when considering the use of BSTs, patricia tries, or TSTs for typical text indexing applications: <a name="iddle1148"></a><a name="iddle2320"></a>the text itself is usually fixed, so we do not need to support the dynamic <span class="docEmphasis">insert</span> operations that we have become accustomed to supporting. That is, we typically build the index once, then use it for a huge number of searches, without ever changing it. Therefore, we may not need dynamic data structures like BSTs, patricia tries or TSTs at all. The basic algorithm that is appropriate for handling this situation is <span class="docEmphasis">binary search</span>, with string pointers (see <a class="docLink" href="ch12lev1sec4.html#ch12lev1sec4">Section 12.4</a>). The index is a set of string pointers; index construction is a string pointer sort. The primary advantage of using binary search over a dynamic data structure is the space savings. To index a text string at <span class="docEmphasis">N</span> positions using binary search, we need just <span class="docEmphasis">N</span> string pointers; in contrast, to index a string at <span class="docEmphasis">N</span> positions using a tree-based method, we need at least <tt>3</tt><span class="docEmphasis"><tt>N</tt></span> pointers (one string pointer, to the text, and two links). Text indexes are typically huge, so binary search might be preferred because it provides guaranteed logarithmic search time but uses one-third the amount of memory used by tree-based methods. If sufficient memory space is available, however, TSTs will lead to a faster <span class="docEmphasis">search</span> for many applications because it moves through the key without retracing its steps, and binary search does not do so.</p>
<p class="docText">If we have a huge text but plan to perform only a small number of searches, then building a full index is not likely to be justified. In Part 5, we consider the <span class="docEmphasis">string-search</span> problem, where we want to determine quickly whether a given text contains a given search key, without any preprocessing. We shall also consider a number of string-search problems that are between the two extremes of doing no preprocessing and building a full index for a huge text.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa5q1"></a><b></b></td><td><p class="docText">
<img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">15.77</span> Draw the 26-way DST that results when you build a text-string index from the words <tt>now is the time for all good people to come the aid of their party</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa5q2"></a><b></b></td><td><p class="docText">
<img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">15.78</span> Draw the 26-way trie that results when you build a text-string index from the words <tt>now is the time for all good people to come the aid of their party</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa5q3"></a><b></b></td><td><p class="docText">
<img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">15.79</span> Draw the TST that results when you build a text-string index from the words <tt>now is the time for all good people to come the aid of their party</tt>, in the style of <a class="docLink" href="#ch15fig20">Figure 15.20</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa5q4"></a><b></b></td><td><p class="docText">
<img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">15.80</span> Draw the TST that results when you build a text-string index from the words <tt>now is the time for all good people to come the aid of  their party</tt>, using the implementation described in the text, where the TST contains string pointers at every node.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa5q5"></a><b></b></td><td><p class="docText">
<img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">15.81</span> Modify the TST search and insertion implementations in <a class="docLink" href="ch15lev1sec4.html#ch15ex21">Programs 15.11</a> and <a class="docLink" href="ch15lev1sec4.html#ch15ex22">15.12</a> to provide a TST-based string index.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa5q6"></a><b></b></td><td><p class="docText">
<img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">15.82</span> Implement an interface that allows patricia to process C-style string keys (that is, arrays of characters) as though they were bitstrings.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa5q7"></a><b></b></td><td><p class="docText">
<img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">15.83</span> Draw the patricia trie that results when you build a text string index from the words <tt>now is the time for all good people to come the aid of their party</tt>, using a 5-bit binary coding with the <span class="docEmphasis">i</span>th letter in the alphabet represented by the binary representation of <span class="docEmphasis">i</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa5q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.84</span> Explain why the idea of improving binary search using the same basic principle on which TSTs are based (comparing characters rather than strings) is not effective.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa5q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.85</span> Find a large (at least <tt>10<sup>6</sup></tt> bytes) text file on your system, and compare the height and internal path length of a standard BST, patricia trie, and TST, when you use these methods to build an index from that file.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa5q10"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.86</span> Run empirical studies to compare the height and internal path length of a standard BST, patricia trie, and TST, when you use these methods to build an index from a text string consisting of N random characters from a 32-character alphabet, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa5q11"></a><b></b></td><td><p class="docText">
<img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">15.87</span> Write an efficient program to determine the longest repeated sequence in a huge text string.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa5q12"></a><b></b></td><td><p class="docText">
<img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">15.88</span> Write an efficient program to determine the 10-character sequence that occurs most frequently in a huge text string.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa5q13"></a><b></b></td><td><p class="docText">
<img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">15.89</span> Build a string index that supports an operation that returns the number of occurrences of its argument in the indexed text, and supports, in the same manner as <span class="docEmphasis">sort</span>, a <span class="docEmphasis">search</span> operation that visits all the text positions that match the search key.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa5q14"></a><b></b></td><td><p class="docText">
<img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">15.90</span> Describe a text string of <span class="docEmphasis">N</span> characters for which a TST-based string index will perform particularly badly. Estimate the cost of building an index for the same string with a BST.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa5q15"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.91</span> Suppose that we want to build an index for a random N-bit string, for bit positions that are a multiple of 16. Run empirical studies to determine which of the bytesizes 1, 2, 4, 8, or 16 leads to the lowest running times to construct a TST-based index, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch15lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch16.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>