<html><head><title>11.3. External Sorting</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch11lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch11lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch11lev1sec3"></a>
<h3 id="643999-892" class="docSection1Title">11.3. External Sorting</h3>
<p class="docText">We move next to another kind of abstract sorting problem, which applies when the file to be sorted is much too large to fit in the random-access memory of the computer. We use the term <span class="docEmphasis">external sorting</span> to describe this situation. There are many different types of external sorting devices, which can place a variety of different restrictions on the atomic operations used to implement the sort. Still, it is useful to consider sorting methods that use two basic primitive operations: <span class="docEmphasis">read</span> data from external storage into main memory, and <span class="docEmphasis">write</span> data from main memory onto external storage. We assume that the cost of these two operations is so much larger than the cost of primitive computational operations that we ignore the latter entirely. For example, in this abstract model, we ignore the cost of sorting the main memory! For huge memories or poor sorting methods, this assumption may not be justified; but it is generally possible to factor in an estimate of the true cost in practical situations if necessary.</p>
<p class="docText">The wide variety of types and costs of external storage devices makes the development of external sorting methods highly dependent on current technology. These methods can be complicated, and many parameters affect their performance; that a clever method might go unappreciated or unused because of a simple change in the technology is certainly a possibility in the study of external sorting. For this reason, we shall concentrate on reviewing general methods rather than on developing specific implementations in this section.</p>
<p class="docText">Over and above the high read&ndash;write cost for external devices, there are often severe restrictions on access, depending on the device. For example, for most types of devices, read and write operations between main memory and external storage are generally done most <a name="iddle1495"></a><a name="iddle1664"></a><a name="iddle2011"></a><a name="iddle2344"></a>efficiently in large contiguous blocks of data. Also, external devices with huge capacities are often designed such that peak performance is achieved when we access the blocks in a <span class="docEmphasis">sequential</span> manner. For example, we cannot read items at the end of a magnetic tape without first scanning through items at the beginning&mdash;for practical purposes, our access to items on the tape is restricted to those appearing somewhere close to the items most recently accessed. Several modern technologies have this same property. Accordingly, in this section, we concentrate on methods that read and write large blocks of data sequentially, making the implicit assumption that fast implementations of this type of data access can be achieved for the machines and devices that are of interest.</p>
<p class="docText">When we are in the process of reading or writing a number of different files, we assume that they are all on different external storage devices. On ancient machines, where files were stored on externally mounted magnetic tapes, this assumption was an absolute requirement. When working with disks, it is possible to implement the algorithms that we consider using only a single external device, but it generally will be much more efficient to use multiple devices.</p>
<p class="docText">A first step for someone planning to implement an efficient program to sort a huge file might be to implement an efficient program to make a copy of the file. A second step might be to implement a program to reverse the order of the file. Whatever difficulties arise in solving these tasks certainly need to be addressed in implementing an external sort. (The sort might have to do either one of them.) The purpose of using an abstract model is to allow us to separate such implementation issues from algorithm design issues.</p>
<p class="docText">The sorting algorithms that we examine are organized as a number of passes over all the data, and we usually measure the cost of an external sorting method by simply counting the number of such passes. Typically, we need relatively few passes&mdash;perhaps ten or fewer. This fact implies that eliminating even a single pass can significantly improve performance. Our basic assumption is that the running time of an external sorting method is dominated by input and output; thus, we can estimate the running time of an external sort by multiplying the number of passes it uses by the time required to read and write the whole file.</p>
<p class="docText"><a name="iddle1911"></a><a name="iddle2418"></a><a name="iddle2419"></a>In summary, the abstract model that we shall use for external sorting involves a basic assumption that the file to be sorted is far too large to fit in main memory, and accounts for two other resources: running time (number of passes through the data) and the number of external devices available for use. We assume that we have</p>
<ul><li><p class="docList"><span class="docEmphasis">N</span> records to be sorted, on an external device</p></li><li><p class="docList">space in the main memory to hold <span class="docEmphasis">M</span> records and</p></li><li><p class="docList">2<span class="docEmphasis">P</span> external devices for use during the sort.</p></li></ul>
<p class="docText">We assign the the label 0 to the external device containing the input, and the labels 1, 2, <tt>. . .</tt>, 2<span class="docEmphasis">P</span> - 1 to the others. The goal of the sort is to put the records back onto device <span class="docEmphasis">0</span>, in sorted order. As we shall see, there is a tradeoff between <span class="docEmphasis">P</span> and the total running time&mdash;we are interested in quantifying that tradeoff so that we can compare competing strategies.</p>
<p class="docText">There are many reasons why this idealized model may not be realistic. Still, like any good abstract model, it does capture the essential aspects of the situation, and it does provide a precise framework within which we can explore algorithmic ideas, many of which are of direct utility in practical situations.</p>
<p class="docText">Most external sorting methods use the following general strategy. Make a first pass through the file to be sorted, breaking it up into blocks about the size of the internal memory, and <span class="docEmphasis">sort</span> these blocks. Then, <span class="docEmphasis">merge</span> the sorted blocks together, if necessary by making several passes through the file, creating successively larger sorted blocks until the whole file is sorted. This approach is called <span class="docEmphasis">sort&ndash;merge</span>, and it has been used effectively since computers first found widespread use in commercial applications in the 1950s.</p>
<p class="docText">The simplest sort&ndash;merge strategy, which is called <span class="docEmphasis">balanced multiway merging</span>, is illustrated in <a class="docLink" href="#ch11fig12">Figure 11.12</a>. The method consists of an <span class="docEmphasis">initial distribution</span> pass, followed by several <span class="docEmphasis">multiway merging passes</span>.</p>
<a name="ch11fig12"></a><p><center>
<h5 class="docFigureTitle">Figure 11.12. Three-way balanced merge example</h5>
<h5></h5><h5></h5></center></p><p class="docText">In the initial distribution pass, we take the elements <span class="docEmphasis"><tt>A S O</tt></span> from the input, sort them, and put the sorted run <span class="docEmphasis"><tt>A O S</tt></span> on the first output device. Next, we take the elements <span class="docEmphasis"><tt>R T I</tt></span> from the input, sort them, and put the sorted run <span class="docEmphasis"><tt>I R T</tt></span> on the second output device. Continuing in this way, cycling through the output devices, we end with 15 runs: five on each output device. In the first merging phase, we merge <span class="docEmphasis"><tt>A O S</tt></span>, <span class="docEmphasis"><tt>I R T</tt></span>, and <span class="docEmphasis"><tt>A G N</tt></span> to get <span class="docEmphasis"><tt>A A G I O R S T</tt></span>, which we put on the first output device; then, we merge the second runs on the input devices to get <span class="docEmphasis"><tt>D E G G I M N N R</tt></span>, which we put on the second output device; and so forth; again ending up with the data distributed in a balanced manner on three devices. We complete the sort with two additional merging passes.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="500" height="158" src="11fig12.gif" /></p>
<br />
<p class="docText">In the initial distribution pass, we distribute the input among external devices <span class="docEmphasis">P</span>, <span class="docEmphasis">P</span> + 1, <tt>. . .</tt>, 2<span class="docEmphasis">P</span> - 1, in sorted blocks of <span class="docEmphasis">M</span> records each (except possibly the final block, which is smaller, if <span class="docEmphasis">N</span> is not a multiple of <span class="docEmphasis">M</span>). This distribution is easy to do&ndash;we read the first <span class="docEmphasis">M</span> records from the input, sort them, and write the sorted block onto device <span class="docEmphasis">P</span>; then read the next <span class="docEmphasis">M</span> records from the input, sort them, and write the sorted block onto device <span class="docEmphasis">P</span> + 1; and so forth. If, after reaching device 2<span class="docEmphasis">P</span> - 1 we still have more input (that is, if <span class="docEmphasis">N &gt; PM</span>),</p>
<p class="docText">we put a second sorted block on device <span class="docEmphasis">P</span>, then a second sorted block on device <span class="docEmphasis">P</span> + 1, and so forth. We continue in this way until the input is exhausted. After the distribution, the number of sorted blocks on each device is <span class="docEmphasis">N/M</span> rounded up or down to the next integer. If <span class="docEmphasis">N</span> is a multiple of <span class="docEmphasis">M</span>, then all the blocks are of size <span class="docEmphasis">N/M</span> (otherwise, all but the final one are of size <span class="docEmphasis">N/M</span>). For small <span class="docEmphasis">N</span>, there may be fewer than <span class="docEmphasis">P</span> blocks, and one or more of the devices may be empty.</p>
<p class="docText">In the first multiway merging pass, we regard devices <span class="docEmphasis">P</span> through 2<span class="docEmphasis">P</span> - 1 as input devices, and devices 0 through <span class="docEmphasis">P</span> - 1 as output devices. We do <span class="docEmphasis">P</span>-way merging to merge the sorted blocks of size <span class="docEmphasis">M</span> on the input devices into sorted blocks of size <span class="docEmphasis">PM</span>, then distribute them onto the output devices in as balanced a manner as possible. First, we merge together the first block from each of the input devices and put the result onto device 0; then, we put the result of merging the second block on each input device onto device 1; and so forth. After reaching device <span class="docEmphasis">P</span> - 1, we put a second sorted block on device 0, then a second sorted block on device 1, and so forth. We continue in this way until the inputs are exhausted. After the distribution, the number of sorted blocks on each device is <span class="docEmphasis">N</span>/(<span class="docEmphasis">PM</span>) rounded up or down to the next integer. If <span class="docEmphasis">N</span> is a multiple of <span class="docEmphasis">PM</span>, then all the blocks are of size <span class="docEmphasis">PM</span> (otherwise, the final block is smaller). If <span class="docEmphasis">N</span> is not larger than <span class="docEmphasis">PM</span>, there is just one sorted block left (on device 0), and we are finished.</p>
<p class="docText">Otherwise, we iterate the process and do a second multiway merging pass, regarding devices 0, 1, <tt>. . .</tt> , <span class="docEmphasis">P</span> - 1 as the input devices, and devices <span class="docEmphasis">P</span>, <span class="docEmphasis">P</span> + 1, <tt>. . .</tt>, 2<span class="docEmphasis">P</span> - 1 as the output devices. We do <span class="docEmphasis">P</span>-way merging to make the sorted blocks of size <span class="docEmphasis">PM</span> on the input devices <a name="iddle2115"></a>into sorted blocks of size <span class="docEmphasis">P</span><sup>2</sup><span class="docEmphasis">M</span>, then distribute them back onto the output devices. We are finished after the second pass (with the result on device <span class="docEmphasis">P</span>) if <span class="docEmphasis">N</span> is not larger than <span class="docEmphasis">P</span><sup>2</sup><span class="docEmphasis">M</span>.</p>
<p class="docText">Continuing in this way, back and forth between devices 0 through <span class="docEmphasis">P</span> - 1 and devices <span class="docEmphasis">P</span> through 2<span class="docEmphasis">P</span> - 1, we increase the size of the blocks by a factor of <span class="docEmphasis">P</span> through <span class="docEmphasis">P</span>-way merges until we eventually have just one block, on device 0 or on device <span class="docEmphasis">P</span>. The final merge in each pass may not be a full <span class="docEmphasis">P</span>-way merge; otherwise the process is well balanced. <a class="docLink" href="#ch11fig13">Figure 11.13</a> depicts the process using only the numbers and relative sizes of the runs. We measure the cost of the merge by performing the indicated multiplications in this table, summing the results (not including the entry in the bottom row), and dividing by the initial number of runs. This calculation gives cost in terms of the number of <span class="docEmphasis">passes</span> over the data.</p>
<a name="ch11fig13"></a><p><center>
<h5 class="docFigureTitle">Figure 11.13. Run distribution for balanced 3-way merge</h5>
<h5></h5><h5></h5></center></p><p class="docText">In the initial distribution for a balanced three-way sort&ndash;merge of a file 15 times the size of the internal memory, we put five runs of relative size 1 on devices 3, 4, and 5, leaving devices 0, 1, and 2 empty. In the first merging phase, we put two runs of size 3 on devices 0 and 1, and one run of size 3 on device 2, leaving devices 3, 4, and 5 empty. Then, we merge the runs on devices 0, 1, and 2, and distribute them back to devices 3, 4, and 5, and so forth, continuing until only one run remains, on device 0. The total number of records processed is 60: four passes over all 15 records.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="200" height="101" src="11fig13.gif" /></p>
<br />
<p class="docText">To implement <span class="docEmphasis">P</span>-way merging, we can use a priority queue of size <span class="docEmphasis">P</span>. We want to output repeatedly the smallest of the elements not yet output from each of the <span class="docEmphasis">P</span> sorted blocks to be merged, then to replace the element output with the next element from the block from which it came. To accomplish this action, we keep device indices in the priority queue, with an <tt>operator&lt;</tt> function that reads the value of the key of the next record to be read from the indicated device (and provides a sentinel larger than all keys in records when the end of a block is reached). The merge is then a simple loop that reads the next record from the device having the smallest key and writes that record to the output, then replaces that record on the priority queue with the next record from the same device, continuing until a sentinel key is the smallest in the priority queue. We could use a heap implementation to make the time required for the priority queue proportional to log <span class="docEmphasis">P</span>, but <span class="docEmphasis">P</span> is normally so small that this cost is dwarfed by the cost of writing to external storage. In our abstract model, we ignore priority-queue costs and assume that we have efficient sequential access to data on external devices, so that we can measure running time by counting the number of passes through the data. In practice, we might use an elementary priority-queue implementation and focus our programming on making sure that the external devices run at maximum efficiency.</p>
<a name="ch11ex09"></a><h5 id="title-IDAMNZCP" class="docExampleTitle">Property 11.4. With 2<span class="docEmphasis">P</span> external devices and internal memory sufficient to hold <span class="docEmphasis">M</span> records, a sort&ndash;merge that is based on a <span class="docEmphasis">P</span>-way balanced merge takes about 1 + <img src="U2308.GIF" border="0" />log<span class="docEmphasis"><sub>P</sub></span>(<span class="docEmphasis">N</span>/<span class="docEmphasis">M</span>)<img src="U2309.GIF" border="0" /> passes</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">One pass is required for distribution. If <span class="docEmphasis">N</span> = <span class="docEmphasis">MP<sup>k</sup></span>, the blocks are all of size <span class="docEmphasis">MP</span> after the first merge, <span class="docEmphasis">MP</span><sup>2</sup> after the second, <span class="docEmphasis">MP</span><sup>3</sup> after the third; and so forth. The sort is complete after <span class="docEmphasis">k</span> = log<span class="docEmphasis"><sub>P</sub></span>(<span class="docEmphasis">N</span>/<span class="docEmphasis">M</span>) passes. Otherwise, if <span class="docEmphasis">M</span><sup>P</sup><sup>k</sup>-1 &lt; <span class="docEmphasis">N</span> &lt; <span class="docEmphasis">M<sup>P</sup><sup>k</sup></span>, the effect of incomplete and empty blocks makes the blocks vary in size near the end of the process, but we are still finished after <span class="docEmphasis">k</span> = <img src="U2308.GIF" border="0" />log<span class="docEmphasis"><sub>P</sub></span>(<span class="docEmphasis">N/M</span>)<img src="U2309.GIF" border="0" /> passes.</p>
</td></tr></table></p>
<p class="docText">For example, if we want to sort 1 billion records using six devices and enough internal memory to hold 1 million records, we can do so with a three-way sort&ndash;merge with a total of eight passes through the data&ndash;one for distribution and <img src="U2308.GIF" border="0" />log<sub>3</sub> 1000<img src="U2309.GIF" border="0" /> = 7 merging passes. We will have sorted runs of 1 million records after the distribution pass, 3 million records after the first merge, 9 million records after the second merge, 27 million records after the third merge, and so forth. We can estimate that it should take about nine times as long to sort the file as it does to copy the file.</p>
<p class="docText">The most important decision to be made in a practical sort&ndash;merge is the choice of the value of <span class="docEmphasis">P</span>, the order of the merge. In our abstract model, we are restricted to sequential access, which implies that <span class="docEmphasis">P</span> has to be one-half the number of external devices available for use. This model is a realistic one for many external storage devices. For many other devices, however, nonsequential access is possible&ndash;it is just more expensive than sequential access. If only a few devices are available for the sort, nonsequential access might be unavoidable. In such cases, we can still use multiway merging, but we will have to take into account the basic tradeoff that increasing <span class="docEmphasis">P</span> will decrease the number of passes but increase the amount of (slow) nonsequential access.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa3q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">11.35</span> Show how the keys E A S Y Q U E S T I O N W I T H P L E N T Y O F K E Y S are sorted using 3-way balanced merging, in the style of the example diagrammed in <a class="docLink" href="#ch11fig12">Figure 11.12</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa3q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">11.36</span> What would be the effect on the number of passes used in multiway merging if we were to double the number of external devices in use?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa3q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">11.37</span> What would be the effect on the number of passes used in multiway merging if we were to increase by a factor of 10 the amount of internal memory available?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa3q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">11.38</span> Develop an interface for external input and output that involves sequential transfer of blocks of data from external devices that operate asynchronously <a name="iddle2116"></a><a name="iddle2274"></a><a name="iddle2423"></a>(or learn details about an existing one on your system). Use the interface to implement <span class="docEmphasis">P</span>-way merging, with <span class="docEmphasis">P</span> as large as you can make it while still arranging for the <span class="docEmphasis">P</span> input files and the input file to be on different output devices. Compare the running time of your program with the time required to copy the files to the output, one after another.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa3q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">11.39</span> Use the interface from <a class="docLink" href="#ch11qa3q4">Exercise 11.38</a> to write a program to reverse the order of as large a file as is feasible on your system.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa3q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">11.40</span> How would you do a perfect shuffle of all the records on an external device?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa3q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">11.41</span> Develop a cost model for multiway merging that encompasses algorithms that can switch from one file to another on the same device, at a fixed cost that is much higher than the cost of a sequential read.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa3q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">11.42</span> Develop an external sorting approach that is based on partitioning a la quicksort or MSD radix sort, analyze it, and compare it with multiway merge. You may use a high level of abstraction, as we did in the description of sort&ndash;merge in this section, but you should strive to be able to predict the running time for a given number of devices and a given amount of internal memory.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa3q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">11.43</span> How would you sort the contents of an external device if no other devices (except main memory) were available for use?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa3q10"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">11.44</span> How would you sort the contents of an external device if only one extra device (and main memory) was available for use?</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch11lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch11lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>