<html><head><title>13.4. Red&ndash;Black Trees</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch13lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch13lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch13lev1sec4"></a>
<h3 id="643999-803" class="docSection1Title">13.4. Red&ndash;Black Trees</h3>
<p class="docText">The top-down 2-3-4 insertion algorithm described in the previous section is easy to understand, but implementing it directly is cumbersome because of all the different cases that can arise. We need to maintain three different types of nodes, to compare search keys against each of the keys in the nodes, to copy links and other information from one type of node to another, to create and destroy nodes, and so forth. In this section, we examine a simple abstract representation of 2-3-4 trees that leads us to a natural implementation of the symbol-table algorithms with near-optimal worst-case performance guarantees.</p>
<p class="docText">The basic idea is to represent 2-3-4 trees as standard BSTs (2-nodes only), but to add one extra bit of information per node to encode 3-nodes and 4-nodes. We think of the links as being of two different types: <span class="docEmphasis">red</span> links, which bind together small binary trees comprising 3-nodes and 4-nodes, and <span class="docEmphasis">black</span> links, which bind together the 2-3-4 tree. Specifically, as illustrated in <a class="docLink" href="#ch13fig15">Figure 13.15</a>, we represent 4-nodes as three 2-nodes connected by red links, and 3-nodes as two 2-nodes connected by a single red link. The red link in a 3-node may be a left link or a right link, so there are two ways to represent each 3-node.</p>
<a name="ch13fig15"></a><p><center>
<h5 class="docFigureTitle">Figure 13.15. 3-nodes and 4-nodes in red-black trees</h5>
<h5></h5><h5></h5></center></p><p class="docText">The use of two types of links provides us with an efficient way to represent 3-nodes and 4-nodes in 2-3-4 trees. We use red links (thick lines in our diagrams) for internal connections in nodes, and black links (thin lines in our diagrams) for 2-3-4 tree links. A 4-node <tt>(top left)</tt> is represented by a balanced subtree of three 2-nodes connected by red links <tt>(top right)</tt>. Both have three keys and four black links. A 3-node (bottom left) is represented by one 2-node connected to another (either on the right or the left) with a single red link <tt>(bottom right)</tt>. All have two keys and three black links.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="110" height="57" src="13fig15.gif" /></p>
<br />
<p class="docText">In any tree, each node is pointed to by one link, so <span class="docEmphasis">coloring the links is equivalent to coloring the nodes</span>. Accordingly, we use one extra bit per node to store the color of the link pointing <span class="docEmphasis">to</span> that node. We refer to 2-3-4 trees represented in this way as <span class="docEmphasis">red&ndash;black BSTs</span>. The orientation of each 3-node is determined by the dynamics of the algorithm that we shall describe. It would be possible to enforce a rule that 3-nodes all slant the same way, but there is no reason to do so. <a class="docLink" href="#ch13fig16">Figure 13.16</a> shows an example of a red&ndash;black tree. If we eliminate the red links and collapse together the nodes they connect, the result is the 2-3-4 tree in <a class="docLink" href="ch13lev1sec3.html#ch13fig10">Figure 13.10</a>.</p>
<a name="ch13fig16"></a><p><center>
<h5 class="docFigureTitle">Figure 13.16. A red&ndash;black tree</h5>
<h5></h5><h5></h5></center></p><p class="docText">This figure depicts a red&ndash;black tree that contains the keys <tt>A S R C H I N G E X M P L</tt>. We can find a key in such a tree with standard BST search. Any path from the root to an external node in this tree has three black links. If we collapse the nodes connected by red links in this tree, we get the 2-3-4 tree of <a class="docLink" href="ch13lev1sec3.html#ch13fig10">Figure 13.10</a>.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="175" height="80" src="13fig16.gif" /></p>
<br />
<p class="docText">Red&ndash;black trees have two essential properties: (<span class="docEmphasis">i</span>) the standard <span class="docEmphasis">search</span> method for BSTs works without modification; and (<span class="docEmphasis">ii</span>) they correspond directly to 2-3-4 trees, so we can implement the balanced 2-3-4 tree algorithm by maintaining the correspondence. We get the best of both worlds: the simple search method from the standard BST, and the simple insertion&ndash;balancing method from the 2-3-4 search tree.</p>
<p class="docText">The search method never examines the field that represents node color, so the balancing mechanism adds no overhead to the time taken by the fundamental search procedure. Since each key is inserted just once, but may be searched for many times in a typical application, the end result is that we get improved search times (because the trees are balanced) at relatively little cost (because no work for balancing is done during the searches). Moreover, the overhead for insertion is small: we have to take action for balancing only when we see 4-nodes, and there are not many 4-nodes in the tree because we are always breaking them up. The inner loop of the insert procedure is the code that walks down the tree (the same as for the search or search-and-insert operations in standard BSTs), with one extra test added: If a node has two red children, it is a part of a 4-node. This low overhead is a primary reason for the efficiency of red&ndash;black BSTs.</p>
<p class="docText">Now, let us consider the red&ndash;black representation for the two transformations that we might need to perform when we do encounter a 4-node: If we have a 2-node connected to a 4-node, then we should convert the pair into a 3-node connected to two 2-nodes; if we have a 3-node connected to a 4-node, then we should convert the pair into a <a name="iddle2287"></a>4-node connected to two 2-nodes. When a new node is added at the bottom, we imagine it to be a 4-node that has to be split and its middle node passed up to be inserted into the bottom node where the search ends, which is guaranteed by the top-down process to be either a 2-node or a 3-node. The transformation required when we encounter a 2-node connected to a 4-node is easy, and the same transformation works if we have a 3-node connected to a 4-node in the &quot;right&quot; way, as shown in the first two cases in <a class="docLink" href="#ch13fig17">Figure 13.17</a>.</p>
<a name="ch13fig17"></a><p><center>
<h5 class="docFigureTitle">Figure 13.17. Splitting 4-nodes in a red&ndash;black tree</h5>
<h5></h5><h5></h5></center></p><p class="docText">In a red&ndash;black tree, we implement the operation of splitting a 4-node that is not the child of a 4-node by changing the node colors in the three nodes comprising the 4-node, then possibly doing one or two rotations. If the parent is a 2-node <tt>(top)</tt>, or a 3-node that has a convenient orientation <tt>(second from top)</tt>, no rotations are needed. If the 4-node is on the center link of the 3-node <tt>(bottom)</tt>, a double rotation is needed; otherwise, a single rotation suffices <tt>(third from top)</tt>.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="375" height="239" src="13fig17.gif" /></p>
<br />
<p class="docText">We are left with the two other situations that can arise if we encounter a 3-node connected to a 4-node, as shown in the second two cases in <a class="docLink" href="#ch13fig17">Figure 13.17</a>. (There are actually four situations, because the mirror images of these two can also occur for 3-nodes of the other orientation.) In these cases, the naive 4-node split leaves two red links in a row&mdash;the tree that results does not represent a 2-3-4 tree in accordance with our conventions. The situation is not too bad, because we do have three nodes connected by red links: all we need to do is to transform the tree such that the red links point down from the same node.</p>
<p class="docText">Fortunately, the rotation operations that we have been using are precisely what we need to achieve the desired effect. Let us begin with the easier of the two remaining cases: the third case in <a class="docLink" href="#ch13fig17">Figure 13.17</a>, where a 4-node attached to a 3-node has split, leaving two red links in <a name="iddle1185"></a><a name="iddle1122"></a>a row that are oriented the same way. This situation would not have arisen if the 3-node had been oriented the other way: Accordingly, we restructure the tree to switch the orientation of the 3-node, and thus reduce this case to be the same as the second case, where the naive 4-node split was sufficient. Restructuring the tree to reorient a 3-node is a single rotation with the additional requirement that the colors of the two nodes have to be switched.</p>
<a name="ch13ex15"></a><h5 id="title-IDAGJAOE" class="docExampleTitle">Program 13.6. Insertion in red&ndash;black BSTs</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This function implements insertion in 2-3-4 trees using the red&ndash;black representation. We add a color bit <tt>red</tt> to the type <tt>node</tt> (and extend its constructor accordingly), with 1 signifying that the node is red, and 0 signifying that it is black. On the way down the tree (before the recursive call), we check for 4-nodes, and split them by flipping the color bits in all three nodes. When we reach the bottom, we create a new red node for the item to be inserted and return a pointer to it. On the way up the tree (after the recursive call), we check whether a rotation is needed. If the search path has two red links with the same orientation, we do a single rotation from the top node, then flip the color bits to make a proper 4-node. If the search path has two red links with different orientations, we do a single rotation from the bottom node, reducing to the other case for the next step up.</p>
<div class="docText"><pre>  private:
    int red(link x)
      { if (x == 0) return 0; return x-&gt;red; }
    void RBinsert(link&amp; h, Item x, int sw)
      {
       if (h == 0) { h = new node(x); return; }
       if (red(h-&gt;l) &amp;&amp; red(h-&gt;r))
       { h-&gt;red = 1; h-&gt;l-&gt;red = 0; h-&gt;r-&gt;red = 0; }
       if (x.key() &lt; h-&gt;item.key())
         {
           RBinsert(h-&gt;l, x, 0);
           if (red(h) &amp;&amp; red(h-&gt;l) &amp;&amp; sw) rotR(h);
           if (red(h-&gt;l) &amp;&amp; red(h-&gt;l-&gt;l))
             { rotR(h); h-&gt;red = 0; h-&gt;r-&gt;red = 1; }
         }
       else
         {
           RBinsert(h-&gt;r, x, 1);
           if (red(h) &amp;&amp; red(h-&gt;r) &amp;&amp; !sw) rotL(h);
           if (red(h-&gt;r) &amp;&amp; red(h-&gt;r-&gt;r))
             { rotL(h); h-&gt;red = 0; h-&gt;l-&gt;red = 1; }
        }
      }
 public:
   void insert(Item x)
     { RBinsert(head, x, 0); head-&gt;red = 0; }</pre></div><br />
</td></tr></table></p>
<p class="docText">Finally, to handle the case where a 4-node attached to a 3-node has split leaving two red links in a row that are oriented differently, we rotate to reduce immediately to the case where the links are oriented the same way, which we then handle as before. This transformation amounts to the same operations as the left-right and right-left double rotations that we used for splay BSTs in <a class="docLink" href="ch13lev1sec2.html#ch13lev1sec2">Section 13.2</a>, although we have to do slightly more work to maintain the colors properly. <a class="docLink" href="#ch13fig18">Figures 13.18</a> and <a class="docLink" href="#ch13fig19">13.19</a> depict examples of red&ndash;black insertion operations.</p>
<a name="ch13fig18"></a><p><center>
<h5 class="docFigureTitle">Figure 13.18. Insertion into a red&ndash;black tree</h5>
<h5></h5><h5></h5></center></p><p class="docText">This figure depicts the result <tt>(bottom)</tt> of inserting a record with key <tt>I</tt> into the sample red&ndash;black tree at the top. In this case, the insertion process consists of splitting the 4-node at C with a color flip <tt>(center)</tt>, then adding the new node at the bottom, converting the node containing <tt>H</tt> from a 2-node to a 3-node.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="100" height="171" src="13fig18.gif" /></p>
<br />
<a name="ch13fig19"></a><p><center>
<h5 class="docFigureTitle">Figure 13.19. Insertion into a red&ndash;black tree, with rotations</h5>
<h5></h5><h5></h5></center></p><p class="docText">This figure depicts the result (bottom) of inserting a record with key <tt>G</tt> into the red&ndash;black tree at the top. In this case, the insertion process consists of splitting the 4-node at I with a color flip (second from top), then adding the new node at the bottom (third from top), then (returning to each node on the search path in the code after the recursive function calls) doing a left rotation at <tt>C</tt> and a right rotation at <tt>R</tt> to finish the process of splitting the 4-node.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="125" height="339" src="13fig19.gif" /></p>
<br />
<p class="docText"><a class="docLink" href="#ch13ex15">Program 13.6</a> is an implementation of <span class="docEmphasis">insert</span> for red&ndash;black trees that performs the transformations that are summarized in <a class="docLink" href="#ch13fig17">Figure 13.17</a>. The recursive implementation makes it possible to perform the color flips for 4-nodes on the way down the tree (before the recursive calls), then to perform rotations on the way up the tree (after the recursive calls). This program would be difficult to understand without the two layers of abstraction that we have developed to implement it. We can check that the recursive trickery implements the rotations depicted in <a class="docLink" href="#ch13fig17">Figure 13.17</a>; then, we can check that the program implements our high-level algorithm on 2-3-4 trees&mdash;break up 4-nodes on the way down the tree, then insert the new item into the 2- or 3-node where the search path ends at the bottom of the tree.</p>
<p class="docText"><a class="docLink" href="#ch13fig20">Figure 13.20</a> (which we can think of as a more detailed version of <a class="docLink" href="ch13lev1sec3.html#ch13fig13">Figure 13.13</a>) shows how <a class="docLink" href="#ch13ex15">Program 13.6</a> constructs the red&ndash;black trees that represent balanced 2-3-4 trees as a sample set of keys is inserted. <a class="docLink" href="#ch13fig21">Figure 13.21</a> shows a tree built from the larger example that we have been using; the average number of nodes visited during a search for a random key in this tree is just 5.81, as compared to 7.00 for the tree built from the same keys in <a class="docLink" href="ch12.html#ch12">Chapter 12</a>, and to 5.74, the best possible for a perfectly balanced tree. At a cost of only a few rotations, we get a tree that has far better balance than any of the others that we have seen in this chapter for the same keys. <a class="docLink" href="#ch13ex15">Program 13.6</a> is an efficient, relatively compact algorithm for insertion using a binary tree structure that is guaranteed to take a logarithmic number of steps for all searches and insertions. It is one of the few symbol-table implementations with that property, and its use is justified in a library implementation where properties of the key sequence to be processed cannot be characterized accurately.</p>
<a name="ch13fig20"></a><p><center>
<h5 class="docFigureTitle">Figure 13.20. Construction of a red&ndash;black tree</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts the result of inserting records with keys <tt>A S E R C H I N G X</tt> into an initially empty red&ndash;black tree.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="165" height="497" src="13fig20.gif" /></p>
<br />
<a name="ch13fig21"></a><p><center>
<h5 class="docFigureTitle">Figure 13.21. A large red&ndash;black BST</h5>
<h5></h5><h5></h5></center></p><p class="docText">This red&ndash;black BST is the result of inserting 200 randomly ordered keys into an initially empty tree. All search misses in the tree use between six and 12 comparisons.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="450" height="77" src="13fig21.gif" /></p>
<br />
<a name="ch13ex16"></a><h5 id="title-IDAAZAOE" class="docExampleTitle">Property 13.8. A search in a red&ndash;black tree with <span class="docEmphasis">N</span> nodes requires fewer than <span class="docEmphasis">2lg N + 2</span> comparisons</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Only splits that correspond to a 3-node connected to a 4-node in a 2-3-4 tree require a rotation in the red&ndash;black tree, so this property follows from <a class="docLink" href="ch13lev1sec1.html#ch13ex04">Property 13.2</a>. The worst case is when the path to the insertion point consists of alternating 3- and 4-nodes.</p>
</td></tr></table></p>
<p class="docText">Moreover, <a class="docLink" href="#ch13ex15">Program 13.6</a> incurs little overhead for balancing, and the trees that it produces are nearly optimal, so it is also attractive to consider as a fast general-purpose searching method.</p>
<a name="ch13ex17"></a><h5 id="title-IDAE0AOE" class="docExampleTitle">Property 13.9. A searchinared&ndash;blacktree with <span class="docEmphasis">N</span> nodes built from random keys uses about 1.002 lg <span class="docEmphasis">N</span> comparisons, on the average</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The constant 1.002, which has been confirmed through partial analyses and simulations (<span class="docEmphasis">see reference section</span>) is sufficiently low that we can regard red&ndash;black trees as optimal for practical purposes, but the question of whether red&ndash;black trees are truly asymptotically optimal is still open. Is the constant equal to 1?</p>
</td></tr></table></p>
<p class="docText">Because the recursive implementation in <a class="docLink" href="#ch13ex15">Program 13.6</a> does some work before the recursive calls and some work after the recursive calls, it makes some modifications to the tree on the way down the search path and some modifications to the tree on the way back up. Therefore, it does not have the property that the balancing is accomplished in one top-down pass. This fact is of little consequence for most applications because the depth of the recursion is guaranteed to be low. For some applications that involve multiple independent processes with access to the same tree, we might need a nonrecursive implementation that actively operates on only a constant number of nodes at any given time (see <a class="docLink" href="#ch13qa5q19">Exercise 13.66</a>).</p>
<p class="docText">For an application that carries other information in the trees, the rotation operation might be an expensive one, perhaps causing us to update information in all the nodes in the subtrees involved in the rotation. For such an application, we can ensure that each <a name="iddle1105"></a><a name="iddle1119"></a><a name="iddle1399"></a><a name="iddle2535"></a>insertion involves at most one rotation by using red&ndash;black trees to implement the bottom-up 2-3-4 search trees that are described at the end of <a class="docLink" href="ch13lev1sec3.html#ch13lev1sec3">Section 13.3</a>. An insertion in those trees involves splitting 4-nodes along the search path, which involves color changes but no rotations in the red&ndash;black representation, followed by one single or double rotation (one of the cases in <a class="docLink" href="#ch13fig17">Figure 13.17</a>) when the first 2-node or a 3-node is encountered on the way up the search path (see <a class="docLink" href="#ch13qa5q12">Exercise 13.59</a>).</p>
<p class="docText">If duplicate keys are to be maintained in the tree, then, as we did with splay BSTs, we must allow items with keys equal to a given node to fall on both sides of that node. Otherwise, severe imbalance could result from long strings of duplicate keys. Again, this observation tells us that finding all items with a given key requires specialized code.</p>
<p class="docText">As mentioned at the end of <a class="docLink" href="ch13lev1sec3.html#ch13lev1sec3">Section 13.3</a>, red&ndash;black representations of 2-3-4 trees are among several similar strategies that have been proposed for implementing balanced binary trees (<span class="docEmphasis">see reference section</span>). As we saw, it is the rotate operations that balance the trees: We have been looking at a particular view of the trees that makes it easy to decide when to rotate. Other views of the trees lead to other algorithms, a few of which we shall mention briefly here.</p>
<p class="docText">The oldest and most well-known data structure for balanced trees is the <span class="docEmphasis">height-balanced</span>, or <span class="docEmphasis">AVL, tree</span>, discovered in 1962 by Adel'sonVel'skii and Landis. These trees have the property that the heights of the two subtrees of each node differ by at most 1. If an insertion causes one of the subtrees of some node to grow in height by 1, then the balance condition might be violated. However, one single or double rotation will bring the node back into balance in every case. The algorithm that is based on this observation is similar to the method of balancing 2-3-4 trees from the bottom up: Do a recursive search for the node, then, <span class="docEmphasis">after</span> the recursive call, check for imbalance and do a single or double rotation to correct it if necessary (see <a class="docLink" href="#ch13qa5q14">Exercise 13.61</a>). The decision about which rotations (if any) to perform requires that we know whether each node has a height that is 1 less than, the same as, or 1 greater than the height of its sibling. Two bits per node are needed to encode this information in a straightforward way, although it is possible to get by without using any extra storage, using the red&ndash;black abstraction (see <a class="docLink" href="#ch13qa5q15">Exercises 13.62</a> and <a class="docLink" href="#ch13qa5q18">13.65</a>).</p>
<p class="docText"><a name="iddle1106"></a><a name="iddle1116"></a><a name="iddle1118"></a><a name="iddle1128"></a><a name="iddle1130"></a><a name="iddle1192"></a><a name="iddle1194"></a><a name="iddle1621"></a><a name="iddle2536"></a><a name="iddle2569"></a><a name="iddle2571"></a><a name="iddle2594"></a><a name="iddle2596"></a>Because 4-nodes play no special role in the bottom-up 2-3-4 algorithm, it is possible to build balanced trees in essentially the same way, but using only 2-nodes and 3-nodes. Trees built in this way are called<span class="docEmphasis">2-3 trees</span>, and were discovered by Hopcroft in 1970. There is not enough flexibility in 2-3 trees to give a convenient top-down insertion algorithm. Again, the red&ndash;black framework can simplify the implementation, but bottom-up 2-3 trees offer no particular advantage over bottom-up 2-3-4 trees, because single and double rotations are still needed to maintain balance. Bottom-up 2-3-4 trees have slightly better balance and have the advantage of using at most one rotation per insertion.</p>
<p class="docText">In <a class="docLink" href="ch16.html#ch16">Chapter 16</a>, we shall study another important type of balanced tree, an extension of 2-3-4 trees called <span class="docEmphasis">B-trees</span>. B-trees allow up to <span class="docEmphasis">M</span> keys per node for large <span class="docEmphasis">M</span>, and are widely used for search applications that involve huge files.</p>
<p class="docText">We have defined red&ndash;black trees by correspondence to 2-3-4 trees. It is also amusing to formulate direct structural definitions.</p>
<a name="ch13ex18"></a><h5 id="title-IDATKBOE" class="docExampleTitle">Definition 13.3. <span class="docEmphasis">A red&ndash;black BST</span> is a binary search tree in which each node is marked to be either <span class="docEmphasis">red</span>or <span class="docEmphasis">black</span>, with the additional restriction that no two red nodes appear consecutively on any path from an external link to the root</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<pre></pre><br />
</td></tr></table></p>
<a name="ch13ex19"></a><h5 id="title-IDAMLBOE" class="docExampleTitle">Definition 13.4. <span class="docEmphasis">A balanced red&ndash;black BST</span> is a red&ndash;black BST in which all paths from external links to the root have the same number of black nodes</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Now, an alternative approach to developing a balanced tree algorithm is to ignore the 2-3-4 tree abstraction entirely and formulate an insertion algorithm that preserves the defining property of balanced red&ndash;black BSTs through rotations. For example, using the bottom-up algorithm corresponds to attaching the new node at the bottom of the search path with a red link, then proceeding up the search path, doing rotations or color changes, as per the cases in <a class="docLink" href="#ch13fig17">Figure 13.17</a>, to break up any pair of consecutive red links encountered on the path. The fundamental operations that we perform are the same as in <a class="docLink" href="#ch13ex15">Program 13.6</a> and its bottom-up counterpart, but subtle differences arise, because 3-nodes can orient either way, operations can be performed in different orders, and various different rotation decisions can be used successfully.</p>
<p class="docText">Let us summarize: Using red&ndash;black trees to implement balanced 2-3-4 trees, we can develop a symbol table where a <span class="docEmphasis">search</span> operation for a key in a file of, say, 1 million items can be completed by comparing that key with about 20 other keys. In the worst case, no more than 40 comparisons are needed. Furthermore, little overhead is associated with each comparison, so a fast <span class="docEmphasis">search</span> is ensured, even in a huge file.</p>
</td></tr></table></p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">13.48</span> Draw the red&ndash;black BST that results when you insert items with the keys E A S Y Q U T I O N in that order into an initially empty tree, using the top-down insertion method.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">13.49</span> Draw the red&ndash;black BST that results when you insert items with the keys E A S Y Q U T I O N in that order into an initially empty tree, using the bottom-up insertion method.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">13.50</span> Draw the red&ndash;black tree that results when you insert letters A through K in order into an initially empty tree, then describe what happens in general when trees are built by insertion of keys in ascending order.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.51</span> Give a sequence of insertions that will construct the red&ndash;black tree shown in <a class="docLink" href="#ch13fig16">Figure 13.16</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.52</span> Generate two random 32-node red&ndash;black trees. Draw them (either by hand or with a program). Compare them with the (unbalanced) BSTs built with the same keys.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.53</span> How many different red&ndash;black trees correspond to a 2-3-4 tree that has <span class="docEmphasis">t</span> 3-nodes?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">13.54</span> Draw all the structurally different red&ndash;black search trees with <span class="docEmphasis">N</span> keys for <span class="docEmphasis">2 <img src="U2264.GIF" border="0" /> N <img src="U2264.GIF" border="0" /> 12</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">13.55</span> Find the probabilities that each of the trees in <a class="docLink" href="ch13lev1sec3.html#ch13qa4q5">Exercise 13.43</a> is the result of inserting <span class="docEmphasis">N</span> random distinct elements into an initially empty tree.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.56</span> Make a table showing the number of trees for each <span class="docEmphasis">N</span> from <a class="docLink" href="#ch13qa5q7">Exercise 13.54</a> that are isomorphic, in the sense that they can be transformed to one another by exchanges of subtrees in nodes.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q10"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">13.57</span> Show that, in the worst case, almost all the paths from the root to an external node in a red&ndash;black tree of <span class="docEmphasis">N</span> nodes are of length 2 lg <span class="docEmphasis">N</span>.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q11"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.58</span> How many rotations are required for an insertion into a red&ndash;black tree of <span class="docEmphasis">N</span> nodes, in the worst case?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q12"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">13.59</span> Implement <span class="docEmphasis">construct</span>, <span class="docEmphasis">search</span>, and <span class="docEmphasis">insert</span> for symbol tables with bottom-up balanced 2-3-4 trees as the underlying data structure, using the red&ndash;black representation and the same recursive approach as <a class="docLink" href="#ch13ex15">Program 13.6</a>. <span class="docEmphasis">Hint</span>: Your code can be similar to <a class="docLink" href="#ch13ex15">Program 13.6</a>, but should perform the operations in a different order.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q13"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.60</span> Implement <span class="docEmphasis">construct</span>, <span class="docEmphasis">search</span>, and <span class="docEmphasis">insert</span> for symbol tables with bottom-up balanced 2-3 trees as the underlying data structure, using the red&ndash;black representation and the same recursive approach as <a class="docLink" href="#ch13ex15">Program 13.6</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q14"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.61</span> Implement <span class="docEmphasis">construct</span>, <span class="docEmphasis">search</span>, and <span class="docEmphasis">insert</span> for symbol tables with height-balanced (AVL) trees as the underlying data structure, using the same recursive approach as <a class="docLink" href="#ch13ex15">Program 13.6</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q15"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">13.62</span> Modify your implementation from <a class="docLink" href="#ch13qa5q14">Exercise 13.61</a> to use red&ndash;black trees (1 bit per node) to encode the balance information.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q16"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">13.63</span> Implement balanced 2-3-4 trees using a red&ndash;black tree representation in which 3-nodes always lean to the right. <span class="docEmphasis">Note</span>: This change allows you to remove one of the bit tests from the inner loop for <span class="docEmphasis">insert</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q17"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">13.64</span> <a class="docLink" href="#ch13ex15">Program 13.6</a> does rotations to keep 4-nodes balanced. Develop an implementation for balanced 2-3-4 trees using a red&ndash;black tree representation where 4-nodes can be represented as any three nodes connected by two red links (perfectly balanced or not).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q18"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">13.65</span> Implement <span class="docEmphasis">construct</span>, <span class="docEmphasis">search</span>, and <span class="docEmphasis">insert</span> for red&ndash;black trees without using any extra storage for the color bit, based on the following trick. To color a node red, swap its two links. Then, to test whether a node is red, test whether its left child is larger than its right child. You have to modify the comparisons to accommodate the possible pointer swap, and this trick replaces bit comparisons with key comparisons that are presumably more expensive, but it shows that the bit in the nodes can be eliminated, if necessary.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q19"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">13.66</span> Implement a nonrecursive red&ndash;black BST <span class="docEmphasis">insert</span> function (see <a class="docLink" href="#ch13ex15">Program 13.6</a>) that corresponds to balanced 2-3-4 tree insertion with one top-down pass. <span class="docEmphasis">Hint</span>: Maintain links <tt>gg</tt>, <tt>g</tt>, and <tt>p</tt> that point, respectively, to the current node's great-grandparent, grandparent, and parent in the tree. All these links might be needed for double rotation.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q20"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.67</span> Write a program that computes the percentage of black nodes in a given red&ndash;black BST. Test your program by inserting, <span class="docEmphasis">N</span> random keys into an initially empty tree, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup></tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q21"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.68</span> Write a program that computes the percentage of items that are in 3-nodes and 4-nodes in a given 2-3-4 search tree. Test your program by inserting <span class="docEmphasis">N</span> random keys into an initially empty tree, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup></tt>.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q22"></a><b></b></td><td><p class="docText"><a name="iddle1126"></a><a name="iddle1802"></a><a name="iddle1829"></a><a name="iddle2127"></a><a name="iddle2357"></a>
<img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">13.69</span> With 1 bit per node for color, we can represent 2-, 3-, and 4-nodes. How many bits per node would we need to represent 5-, 6-, 7-, and 8-nodes with a binary tree?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q23"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.70</span> Run empirical studies to compute the average and standard deviation of the number of comparisons used for search hits and for search misses in a red&ndash;black tree built by insertion of <span class="docEmphasis"><tt>N</tt></span> random keys into an initially empty tree, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup></tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q24"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.71</span> Instrument your program for <a class="docLink" href="#ch13qa5q23">Exercise 13.70</a> to compute the number of rotations and node splits that are used to build the trees. Discuss the results.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q25"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.72</span> Use your driver program from <a class="docLink" href="ch13lev1sec2.html#ch13qa3q6">Exercise 12.30</a> to compare the self-organizing&ndash;search aspect of splay BSTs with the worst-case guarantees of red&ndash;black BSTs and with standard BSTs for the search query distributions defined in <a class="docLink" href="ch12lev1sec3.html#ch12qa3q16">Exercises 12.31</a> and <a class="docLink" href="ch12lev1sec3.html#ch12qa3q17">12.32</a> (see <a class="docLink" href="ch13lev1sec2.html#ch13qa3q5">Exercise 13.29</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q26"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">13.73</span> Implement a <span class="docEmphasis">search</span> function for red&ndash;black trees that performs rotations and changes node colors on the way down the tree to ensure that the node at the bottom of the search path is not a 2-node.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa5q27"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">13.74</span> Use your solution to <a class="docLink" href="#ch13qa5q26">Exercise 13.73</a> to implement a <span class="docEmphasis">remove</span> function for red&ndash;black trees. Find the node to be deleted, continue the search to a 3-node or 4-node at the bottom of the path, and move the successor from the bottom to replace the deleted node.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch13lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch13lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>