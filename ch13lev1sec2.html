<html><head><title>13.2. Splay BSTs</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch13lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch13lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch13lev1sec2"></a>
<h3 id="title-IDAG3Q5H" class="docSection1Title">13.2. Splay BSTs</h3>
<p class="docText">In the root-insertion method of <a class="docLink" href="ch12lev1sec8.html#ch12lev1sec8">Section 12.8</a>, we accomplished our primary objective of bringing the newly inserted node to the root of the tree by using left and right rotations. In this section, we examine how we can modify root insertion such that the rotations balance the tree in a certain sense, as well.</p>
<p class="docText">Rather than considering (recursively) the single rotation that brings the newly inserted node to the top of the tree, we consider the <span class="docEmphasis">two</span> rotations that bring the node from a position as one of the grandchildren of the root up to the top of the tree. First, we perform one rotation to bring the node to be a child of the root. Then, we perform another rotation to bring it to the root. There are two essentially different cases, depending on whether or not the two links from the root to the node being inserted are oriented in the same way. <a class="docLink" href="#ch13fig05">Figure 13.5</a> shows the case where the orientations are different; the left part of <a class="docLink" href="#ch13fig06">Figure 13.6</a> shows the case where the orientations are the same. Splay BSTs are based on the observation that there is an alternative way to proceed when the links from the root to the node being inserted are oriented in the same way: Simply perform two rotations at the root, as shown at the right in <a class="docLink" href="#ch13fig06">Figure 13.6</a>.</p>
<a name="ch13fig05"></a><p><center>
<h5 class="docFigureTitle">Figure 13.5. Double rotation in a BST (orientations different)</h5>
<h5></h5><h5></h5></center></p><p class="docText">In this sample tree <tt>(top)</tt>, a left rotation at <tt>G</tt> followed by a right rotation at <tt>L</tt> brings <tt>I</tt> to the root (bottom). These rotations might complete a standard or splay BST root-insertion process.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="175" height="380" src="13fig05.gif" /></p>
<br />
<a name="ch13fig06"></a><p><center>
<h5 class="docFigureTitle">Figure 13.6. Double rotation in a BST (orientations alike)</h5>
<h5></h5><h5></h5></center></p><p class="docText">We have two options when both links in a double rotation are oriented in the same direction. With the standard root insertion method, we perform the lower rotation first (left); with splay insertion, we perform the higher rotation first (right).</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="400" height="370" src="13fig06.gif" /></p>
<br />
<p class="docText"><span class="docEmphasis">Splay insertion</span> brings newly inserted nodes to the root using the transformations shown in <a class="docLink" href="#ch13fig05">Figure 13.5</a> (standard root insertion when the links from the root to the grandchild on the search path have different orientation) and on the right in <a class="docLink" href="#ch13fig06">Figure 13.6</a> (two rotations at the root when the links from the root to the grandchild on the search path have the same orientation). The BSTs built in this way are <span class="docEmphasis">splay BSTs</span>. <a class="docLink" href="#ch13ex09">Program 13.5</a> is a recursive implementation of splay insertion; <a class="docLink" href="#ch13fig07">Figure 13.7</a> depicts an example of a single insertion, and <a class="docLink" href="#ch13fig08">Figure 13.8</a> shows the construction process for a sample tree. The difference between splay insertion and standard root insertion may seem inconsequential, but it is quite significant: the splay operation eliminates the quadratic worst case that is the primary liability of standard BSTs.</p>
<a name="ch13fig07"></a><p><center>
<h5 class="docFigureTitle">Figure 13.7. Splay insertion</h5>
<h5></h5><h5></h5></center></p><p class="docText">This figure depicts the result (bottom) of inserting a record with key <tt>D</tt> into the sample tree at top, using splay root insertion. In this case, the insertion process consists of a left-right double rotation followed by a right-right double rotation (from the top).</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="175" height="335" src="13fig07.gif" /></p>
<br />
<a name="ch13fig08"></a><p><center>
<h5 class="docFigureTitle">Figure 13.8. Splay BST construction</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts the insertion of records with keys <tt>A S E R C H I N G</tt> into an initially empty tree using splay insertion.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="110" height="550" src="13fig08.gif" /></p>
<br />
<a name="ch13ex08"></a><h5 id="title-IDA3DR5H" class="docExampleTitle">Property 13.4. The number of comparisons used when a splay BST is built from <span class="docEmphasis">N</span> insertions into an initially empty tree is <span class="docEmphasis">O(N</span> lg <span class="docEmphasis">N)</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This bound is a consequence of <a class="docLink" href="#ch13ex10">Property 13.5</a>, a stronger property that we will consider shortly.</p>
</td></tr></table></p>
<p class="docText">The constant implied in the <span class="docEmphasis">O</span>-notation is 3. For example, it always takes less than 5 million comparisons to build a BST of 100,000 nodes using splay insertion. This result does not guarantee that the resulting search tree will be well-balanced, and does not guarantee that each operation will be efficient, but the implied guarantee on the total running time is significant, and the actual running time that we observe in practice is likely to be lower still.</p>
<p class="docText"></p><a name="ch13ex09"></a><h5 id="title-IDA5ER5H" class="docExampleTitle">Program 13.5. Splay insertion in BSTs</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This function differs from the root insertion algorithm of <a class="docLink" href="ch12lev1sec8.html#ch12ex23">Program 12.13</a> in just one essential detail: If the search path goes left-left or right-right, the node is brought to the root with a double rotation from the top, rather than from the bottom (see <a class="docLink" href="#ch13fig06">Figure 13.6</a>).</p>
<p class="docText">The program checks the four possibilities for two steps of the search path from the root and performs the appropriate rotations:</p>
<p><table cellspacing="0" frame="void" rules="none" cellpadding="5"><colgroup align="left" span="2"><col width="200"></col><col width="350"></col></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis">left-left</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Rotate right at the root twice.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis">left-right</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Rotate left at the left child, then right at the root.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis">right-right</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Rotate left at the root twice.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphasis">right-left</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">Rotate right at the right child, then left at the root.</p></td></tr></table></p><br />
<div class="docText"><pre>  private:
    void splay(link&amp; h, Item x)
      {
       if (h == 0)
         { h = new node(x, 0, 0, 1); return; }
       if (x.key() &lt; h-&gt;item.key())
         { link&amp; hl = h-&gt;l; int N = h-&gt;N;
       if (hl == 0)
         { h = new node(x, 0, h, N+1); return; }
       if (x.key() &lt; hl-&gt;item.key())
            { splay(hl-&gt;l, x); rotR(h); }
       else { splay(hl-&gt;r, x); rotL(hl); }
       rotR(h);
     }
   else
     { link &amp;hr = h-&gt;r; int N = h-&gt;N;
       if (hr == 0)
         { h = new node(x, h, 0, N+1); return; }
       if (hr-&gt;item.key() &lt; x.key())
         { splay(hr-&gt;r, x); rotL(h); }
       else { splay(hr-&gt;l, x); rotR(hr); }
       rotL(h);
     }
    }
public:
  void insert(Item item)
    { splay(head, item); }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a name="iddle2364"></a><a name="iddle2508"></a>When we insert a node into a BST using splay insertion, we not only bring that node to the root, but also bring the other nodes that we encounter (on the search path) closer to the root. Precisely, the rotations that we perform cut in half the distance from the root to any node that we encounter. This property also holds if we implement the <span class="docEmphasis">search</span> operation such that it performs the splay transformations during the search. Some paths in the trees do get longer: If we do not access nodes on those paths, that effect is of no consequence to us. If we do access nodes on a long path, it becomes one-half as long after we do so; thus, no one path can build up high costs.</p>
<a name="ch13ex10"></a><h5 id="title-IDAUJR5H" class="docExampleTitle">Property 13.5. The number of comparisons required for any sequence of <span class="docEmphasis">M</span> insert or search operations in an <span class="docEmphasis">N</span>-node splay BST is <span class="docEmphasis">O((N + M)lg(N + M))</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The proof of this result, by Sleator and Tarjan in 1985, is a classic example of amortized analysis of algorithms (<span class="docEmphasis">see reference section</span>). We will examine it in detail in Part 8.</p>
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch13ex10">Property 13.5</a> is an amortized performance guarantee: We guarantee not that each operation is efficient, but rather that the <span class="docEmphasis">average</span> cost of all the operations performed is efficient. This average is not a probabilistic one; rather, we are stating that the <span class="docEmphasis">total</span> cost is guaranteed to be low. For many applications, this kind of guarantee suffices, but it may not be adequate for some other applications. For example, we cannot provide guaranteed response times for each operation when using splay BSTs, because some operations could take linear time. If an operation does take linear time, then we are guaranteed that other operations will be that much faster, but that may be no consolation to the customer who had to wait.</p>
<p class="docText">The bound given in <a class="docLink" href="#ch13ex10">Property 13.5</a> is a worst-case bound on the total cost of all operations: As is typical with worst-case bounds, it may be much higher than the actual costs. The splaying operation brings recently accessed elements closer to the top of the tree; therefore, this method is attractive for search applications with nonuniform access patterns&mdash;particularly applications with a relatively small, even if slowly changing, working set of accessed items.</p>
<p class="docText"><a class="docLink" href="#ch13fig09">Figure 13.9</a> gives two examples that show the effectiveness of the splay-rotation operations in balancing the trees. In these figures, a degenerate tree (built via insertion of items in order of their keys) <a name="iddle1400"></a>is brought into relatively good balance by a small number of <span class="docEmphasis">search</span> operations.</p>
<a name="ch13fig09"></a><p><center>
<h5 class="docFigureTitle">Figure 13.9. Balancing of a worst-case splay tree with searches</h5>
<h5></h5><h5></h5></center></p><p class="docText">Inserting keys in sorted order into an initially empty tree using splay insertion takes only a constant number of steps per insertion, but leaves an unbalanced tree, shown at the top on the left and on the right. The sequence on the left shows the result of searching (with splaying) for the smallest, second-smallest, third-smallest, and fourth-smallest keys in the tree. Each search halves the length of the path to the search key (and most other keys in the tree). The sequence on the right shows the same worst-case starting tree being balanced by a sequence of random search hits. Each search halves the number of nodes on its path, reducing the length of search paths for many other nodes in the tree. Collectively, a small number of searches improves the tree balance substantially.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="225" height="411" src="13fig09.jpg" /></p>
<br />
<p class="docText">If duplicate keys are maintained in the tree, then the splay operation can cause items with keys equal to the key in a given node to fall on both sides of that node (see <a class="docLink" href="#ch13qa3q14">Exercise 13.38</a>). This observation tells us that we cannot find all items with a given key as easily as we can for standard binary search trees. We must check for duplicates in both subtrees, or use some alternative method to work with duplicate keys, as discussed in <a class="docLink" href="ch12.html#ch12">Chapter 12</a>.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa3q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">13.25</span> Draw the splay BST that results when you insert items with the keys <tt>E A S Y Q U T I O N</tt> in that order into an initially empty tree, using splay insertion.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa3q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">13.26</span> How many tree links must be changed for a double rotation? How many are actually changed for each of the double rotations in <a class="docLink" href="#ch13ex09">Program 13.5</a>?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa3q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.27</span> Add an implementation of <span class="docEmphasis">search</span>, with splaying, to <a class="docLink" href="#ch13ex09">Program 13.5</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa3q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">13.28</span> Implement a nonrecursive version of the splay insertion function in <a class="docLink" href="#ch13ex09">Program 13.5</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa3q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.29</span> Use your driver program from <a class="docLink" href="ch12lev1sec3.html#ch12qa3q15">Exercise 12.30</a> to determine the effectiveness of splay BSTs as self-organizing search structures by comparing them with standard BSTs for the search query distributions defined in <a class="docLink" href="ch12lev1sec3.html#ch12qa3q16">Exercises 12.31</a> and <a class="docLink" href="ch12lev1sec3.html#ch12qa3q17">12.32</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa3q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">13.30</span> Draw all the structurally different BSTs that can result when you insert <span class="docEmphasis">N</span> keys into an initially empty tree using splay insertion, for <span class="docEmphasis">2<img src="U2264.GIF" border="0" /> N <img src="U2264.GIF" border="0" />7</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa3q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">13.31</span> Find the probability that each of the trees in <a class="docLink" href="#ch13qa3q6">Exercise 13.30</a> is the result of inserting <span class="docEmphasis">N</span> random distinct elements into an intially empty tree.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa3q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">13.32</span> Run empirical studies to compute the average and standard deviation of the number of comparisons used for search hits and for search misses in a BST built by insertion of <span class="docEmphasis">N</span> random keys into an initially empty tree with splay insertion, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup></tt>. You do not need to do any searches: Just build the trees and compute their path lengths. Are splay BSTs more nearly balanced than random BSTs, less so, or the same?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa3q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.33</span> Extend your program for <a class="docLink" href="#ch13qa3q8">Exercise 13.32</a> to do <span class="docEmphasis">N</span> random searches (they most likely will be misses) with splaying in each tree constructed. How does splaying affect the average number of comparisons for a search miss?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa3q10"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.34</span> Instrument your programs for <a class="docLink" href="#ch13qa3q8">Exercises 13.32</a> and <a class="docLink" href="#ch13qa3q9">13.33</a> to measure running time, rather than just to count comparisons. Run the same experiments. Explain any changes in the conclusions that you draw from the empirical results.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa3q11"></a><b></b></td><td><p class="docText"><a name="iddle1129"></a><a name="iddle1193"></a><a name="iddle1969"></a><a name="iddle2570"></a><a name="iddle2595"></a><span class="docEmphStrong">13.35</span> Compare splay BSTs with standard BSTs for the task of building an index from a piece of real-world text that has at least 1 million characters. Measure the time taken to build the index and the average path lengths in the BSTs.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa3q12"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.36</span> Empirically determine the average number of comparisons for search hits in a splay BST built by inserting random keys, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup></tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa3q13"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.37</span> Run empirical studies to test the idea of using splay insertion, instead of standard root insertion, for randomized BSTs.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa3q14"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">13.38</span> Draw the splay BST that results when you insert items with the keys <tt>0 0 0 0 0 0 0 0 0 0 0 0 1</tt> in that order into an initially empty tree.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch13lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch13lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>