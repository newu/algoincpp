<html><head><title>3.1. Building Blocks</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch03lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch03lev1sec1"></a>
<h3 id="title-IDA034IE" class="docSection1Title">3.1. Building Blocks</h3>
<p class="docText">In this section, we review the primary low-level constructs that we use to store and process information in C++. All the data that we process on a computer ultimately decompose into individual bits, but writing programs that exclusively process bits would be tiresome indeed. <span class="docEmphasis">Types</span> allow us to specify how we will use particular sets of bits and <span class="docEmphasis">functions</span> allow us to specify the operations that we will perform on the data. We use C++ <span class="docEmphasis">structures</span> to group together heterogeneous pieces of information, and we use <span class="docEmphasis">pointers</span> to refer to information indirectly. In this section, we consider these basic C++ mechanisms, in the context <a name="iddle1229"></a><a name="iddle1254"></a><a name="iddle1329"></a><a name="iddle1333"></a><a name="iddle1334"></a><a name="iddle1498"></a><a name="iddle1681"></a><a name="iddle2230"></a>of presenting a general approach to organizing our programs. Our primary goal is to lay the groundwork for the development, in the rest of the chapter and in <a class="docLink" href="ch04.html#ch04">Chapters 4</a> and <a class="docLink" href="ch05.html#ch05">5</a>, of the higher-level constructs that will serve as the basis for most of the algorithms that we consider in this book.</p>
<p class="docText">We write programs that process information derived from mathematical or natural-language descriptions of the world in which we live; accordingly, computing environments provide built-in support for the basic building blocks of such descriptions&mdash;numbers and characters. In C++, our programs are all built from just a few basic types of data:</p>
<ul><li><p class="docList">Integers (<tt>int</tt>s).</p></li><li><p class="docList">Floating-point numbers (<tt>float</tt>s).</p></li><li><p class="docList">Characters (<tt>char</tt>s).</p></li></ul>
<p class="docText">It is customary to refer to these basic types by their C++ names&mdash;<tt>int</tt>, <tt>float</tt>, and <tt>char</tt>&mdash;although we often use the generic terminology <span class="docEmphasis">integer</span>, <span class="docEmphasis">floating-point number</span>, and <span class="docEmphasis">character</span>, as well. Characters are most often used in higher-level abstractions&mdash;for example to make words and sentences&mdash;so we defer consideration of character data to <a class="docLink" href="ch03lev1sec6.html#ch03lev1sec6">Section 3.6</a> and look at numbers here.</p>
<p class="docText">We use a fixed number of bits to represent numbers, so <tt>int</tt>s are by necessity integers that fall within a specific range that depends on the number of bits that we use to represent them. Floating-point numbers approximate real numbers, and the number of bits that we use to represent them affects the precision with which we can approximate a real number. In C++, we trade space for accuracy by choosing from among the types <tt>int</tt>, <tt>long int</tt>, or <tt>short int</tt> for integers and from among <tt>float</tt> or <tt>double</tt> for floating-point numbers. On most systems, these types correspond to underlying hardware representations. The number of bits used for the representation, and therefore the range of values (in the case of <tt>int</tt>s) or precision (in the case of <tt>float</tt>s), is machine-dependent (see <a class="docLink" href="#ch03qa1q1">Exercise 3.1</a>), although C++ provides certain guarantees. In this book, for clarity, we normally use <tt>int</tt> and <tt>float</tt>, except in cases where we want to emphasize that we are working with problems where big numbers are needed.</p>
<p class="docText">In modern programming, we think of the type of the data more in terms of the needs of the program than the capabilities of the machine, primarily, in order to make programs portable. Thus, for example, we think of a <tt>short int</tt> as an object that can take on values between<a name="iddle1252"></a><a name="iddle1331"></a><a name="iddle2599"></a>&ndash;32,767 and 32,767, instead of as a 16-bit object. Moreover, our concept of an integer includes the operations that we perform on them: addition, multiplication, and so forth.</p>
<a name="ch03ex01"></a><h5 id="title-IDAIM5IE" class="docExampleTitle">Definition 3.1. <span class="docEmphasis">A data type</span> is a set of values and a collection of operations on those values</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Operations are associated with types, not the other way around. When we perform an operation, we need to ensure that its operands and result are of the correct type. Neglecting this responsibility is a common programming error. In some situations, C++ performs implicit type conversions; in other situations, we use <span class="docEmphasis">casts</span>, or explicit type conversions. For example, if <tt>x</tt> and <tt>N</tt> are integers, the expression</p>
<div class="docText"><pre>((float) x) / N</pre></div><br />
<p class="docText">includes both types of conversion: the <tt>(float)</tt> is a cast that converts the value of <tt>x</tt> to floating point; then an implicit conversion is performed for <tt>N</tt> to make both arguments of the divide operator floating point, according to C++'s rules for implicit type conversion.</p>
<p class="docText">Many of the operations associated with standard data types (for example, the arithmetic operations) are built into the C++ language. Other operations are found in the form of functions that are defined in standard function libraries; still others take form in the C++ functions that we define in our programs (see <a class="docLink" href="#ch03ex02">Program 3.1</a>). That is, the concept of a data type is relevant not just to integer, floating point, and character built-in types. We often define our own data types, as an effective way of organizing our software. When we define a simple function in C++, we are effectively creating a new data type, with the operation implemented by that function added to the operations defined for the types of data represented by its arguments. Indeed, in a sense, <span class="docEmphasis">each</span> C++ program is a data type&mdash;a list of sets of values (built-in or other types) and associated operations (functions). This point of view is perhaps too broad to be useful, but we shall see that narrowing our focus to understand our programs in terms of data types is valuable.</p>
<p class="docText">One goal that we have when writing programs is to organize them such that they apply to as broad a variety of situations as possible. The reason for adopting such a goal is that it might put us in the position of being able to reuse an old program to solve a new problem, perhaps completely unrelated to the problem that the program was originally intended to solve. First, by taking care to understand and to specify precisely which operations a program uses, we can easily extend it to any type of data for which we can support those operations. Second, by taking care to understand and to specify precisely what a program does, we can add the abstract operation that it performs to the operations at our disposal in solving new problems.</p>
<a name="ch03ex02"></a><h5 id="title-IDABO5IE" class="docExampleTitle">Program 3.1. Function definition</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The mechanism that we use in C++ to implement new operations on data is the <span class="docEmphasis">function definition</span>, illustrated here.</p>
<p class="docText">All functions have a list of <span class="docEmphasis">arguments</span> and possibly a <span class="docEmphasis">return value</span>. The function <tt>lg</tt> here has one argument and a return value, each of type <tt>int</tt>. The function <tt>main</tt> here takes no arguments and returns an <tt>int</tt> (by default, the value 0 which indicates successful completion).</p>
<p class="docText">We <span class="docEmphasis">declare</span> the function by giving its name and the types of its return values. The first line of the file references a library file that contains declarations of <tt>cout</tt>, <tt>&lt;&lt;</tt> and <tt>endl</tt>. The second line of code is a declaration for <tt>lg</tt>. The declaration is optional if the function is defined (see next paragraph) before it is used. The declaration provides the information necessary for other functions to <span class="docEmphasis">call</span> or <span class="docEmphasis">invoke</span> the function, using arguments of the proper type. The calling function can use the function in an expression, in the same way as it uses variables of the return-value type.</p>
<p class="docText">We <span class="docEmphasis">define</span> functions with C++ code. All C++ programs include a definition of the function <tt>main</tt>, and this code also defines <tt>lg</tt>. In a function definition, we give names to the arguments (which we refer to as <span class="docEmphasis">parameters</span>) and express the computation in terms of those names, as if they were local variables. When the function is invoked, these variables are initialized with the values of the arguments and the function code is executed. The <tt>return</tt> statement is the instruction to end execution of the function and provide the return value to the calling function. In principle, the calling function is not to be otherwise affected, though we shall see many exceptions to this principle.</p>
<p class="docText">The separation of definition and declaration provides flexibility in organizing programs. For example, both could be in separate files (<span class="docEmphasis">see text</span>). Or, in a simple program like this one, we could put the definition of <tt>lg</tt> before the definition of <tt>main</tt> and omit its declaration.</p>
<div class="docText"><pre>
#include &lt;iostream.h&gt;
int lg(int);
int main()
  {
    for (int N = 1000; N &lt;= 1000000000; N *= 10)
      cout &lt;&lt; lg(N) &lt;&lt; " " &lt;&lt; N &lt;&lt; endl;
  }
int lg(int N)
  {
    for (int i = 0; N &gt; 0; i++, N /= 2) ;
    return i;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch03ex03">Program 3.2</a> implements a simple computation on numbers using a simple data type defined with a <tt>typedef</tt> operation and a function (which itself is implemented with a library function). The main function refers to the data type, not the built-in type of the number. By not specifying the type of the numbers that the program processes, we extend its potential utility. For example, this practice is likely to extend the useful lifetime of a program. When some new circumstance (a new application, or perhaps a new compiler or computer), presents us with a new type of number with which we would like to work, we can update our program just by changing the data type.</p>
<p class="docText">This example does not represent a fully general solution to the problem of developing a type-independent program for computing averages and standard deviations&mdash;nor is it intended to do so. For example, the program depends on converting a number of type <tt>Number</tt> to a <tt>float</tt> to be included in the running average and variance. As written, the program depends on the cast to <tt>float</tt> that is part of the <tt>int</tt> built-in type; in general, we could explicitly define such a cast for any type of <tt>Number</tt>.</p>
<p class="docText">If we were to try to do operations other than arithmetic operations, we would soon find the need to add more operations to the data type. For example, we might want to print the numbers. Whenever we strive to develop a data type based on identifying the operations of importance in a program, we need to strike a balance between the level of generality and the ease of implementation and use.</p>
<p class="docText">It is worthwhile to consider in detail how we might change the data type to make <a class="docLink" href="#ch03ex03">Program 3.2</a> work with other types of numbers, say <tt>float</tt>s, rather than with <tt>int</tt>s. There are a number of different mechanisms available in C++ that we could use to take advantage of the fact that we have localized references to the type of the data. For such a small program, the simplest is to make a copy of the file, then to change the <tt>typedef</tt> to <tt>typedef float Number</tt> and the body of the procedure <tt>randNum</tt> to <tt>return 1.0*rand()/RAND_MAX;</tt> (which will return random floating-point numbers between 0 and 1). Even for such a small program, this approach is inconvenient because it leaves us with two copies of the main program, and we will have to make sure that any later changes in that program are reflected in both copies. In C++, an alternative approach is to put the <tt>typedef</tt> and <tt>randNum</tt> into a separate <span class="docEmphasis">header file</span>&mdash;called, say, <tt>Number.h</tt>&mdash;replacing them with the directive</p>
<div class="docText"><pre>#include "Number.h"</pre></div><br />
<p class="docText">in the code in <a class="docLink" href="#ch03ex03">Program 3.2</a>. Then, we can make a second header file with different <tt>typedef</tt> and <tt>randNum</tt>, and, by renaming one of these files or the other <tt>Number.h</tt>, use the main program in <a class="docLink" href="#ch03ex03">Program 3.2</a> with either, without modifying <span class="docEmphasis">it</span> at all.</p>
<a name="ch03ex03"></a><h5 id="title-IDANT5IE" class="docExampleTitle">Program 3.2. Types of numbers</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This program computes the average <span class="docEmphasis">&#956;</span> and standard deviation <span class="docEmphasis">&#963;</span> of a sequence <span class="docEmphasis">x</span><sub>1</sub>, <span class="docEmphasis">x</span><sub>2</sub><span class="docEmphasis">, . . . ,</span><span class="docEmphasis">x<sub>N</sub></span> of integers generated by the library procedure <tt>rand</tt>, following the mathematical definitions</p>
<p class="docText"><img border="0" alt="" width="500" height="46" src="0075equ01.jpg" /></p>
<p class="docText">Note that a direct implementation from the definition of <span class="docEmphasis">&#963;</span><sup>2</sup> requires one pass to compute the average and another to compute the sums of the squares of the differences between the members of the sequence and the average, but rearranging the formula makes it possible for us to compute <span class="docEmphasis">&#963;</span><sup>2</sup> in one pass through the data.</p>
<p class="docText">We use the <tt>typedef</tt> declaration to localize reference to the fact that the type of the data is <tt>int</tt>. For example, we could keep the <tt>typedef</tt> and the function <tt>randNum</tt> in a separate file (referenced by an include directive), and then we could use this program to test random numbers of a different type by changing that file (<span class="docEmphasis">see text</span>).</p>
<p class="docText">Whatever the type of the data, the program uses <tt>ints</tt> for indices and <tt>floats</tt> to compute the average and standard deviation, and will be effective only if conversions from the data type to <tt>float</tt> are defined.</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
typedef int Number;
Number randNum()
  { return rand(); }
int main(int argc, char *argv[])
  { int N = atoi(argv[1]);
    float m1 = 0.0, m2 = 0.0;
    for (int i = 0; i &lt; N; i++)
      {
        Number x = randNum();
        m1 += ((float) x)/N;
        m2 += ((float) x*x)/N;
      }
    cout &lt;&lt; "     Avg.: " &lt;&lt; m1 &lt;&lt; endl;
    cout &lt;&lt; "Std. dev.: " &lt;&lt; sqrt(m2-m1*m1) &lt;&lt; endl;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">A third alternative, which is a recommended software engineering practice that is widely used by programmers in C, C++ and other languages, is to split the program into <span class="docEmphasis">three</span> files:</p>
<ul><li><p class="docList">An <span class="docEmphasis">interface</span>, which defines the data structure and declares the functions to be used to manipulate the data structure</p></li><li><p class="docList">An <span class="docEmphasis">implementation</span> of the functions declared in the interface</p></li><li><p class="docList">A <span class="docEmphasis">client</span> program that uses the functions declared in the interface to work at a higher level of abstraction</p></li></ul>
<p class="docText">With this arrangement, we can use the main program in <a class="docLink" href="#ch03ex03">Program 3.2</a> with integers or floats, or extend it to work with other types, just by compiling it together with the specific code for the type of interest. In the paragraphs that follow, we shall consider the precise changes needed for this example.</p>
<p class="docText">We think of the interface as a definition of the data type. It is a contract between the client program and the implementation program. The client agrees to access the data only through the functions defined in the interface, and the implementation agrees to deliver the promised functions.</p>
<p class="docText">For the example in <a class="docLink" href="#ch03ex03">Program 3.2</a>, the <span class="docEmphasis">interface</span> would consist of the declarations</p>
<div class="docText"><pre>typedef int Number;
Number randNum();</pre></div><br />
<p class="docText">The first line specifies the type of the data to be processed, and the second specifies an operation associated with the type. We might keep this code, for example, in a file named <tt>Number.h</tt>, where it can be independently referenced by both clients and implementations.</p>
<p class="docText">The <span class="docEmphasis">implementation</span> of the interface in <tt>Number.h</tt> is an implementation of the <tt>randNum</tt> function, which might consist of the code</p>
<div class="docText"><pre>#include &lt;stdlib.h&gt;
#include "Number.h"
Number randNum()
  { return rand(); }</pre></div><br />
<p class="docText">The first line refers to the system-supplied interface that describes the <tt>rand()</tt> function; the second line refers to the interface that we are implementing (we include it as a check that the function we are implementing is the same type as the one that we declared), and the final two lines give the code for the function. This code might be kept, for example, in a file named <tt>int.c</tt>. The actual code for the <tt>rand</tt> function is kept in the standard C++ run-time library.</p>
<p class="docText">A <span class="docEmphasis">client</span> program corresponding to <a class="docLink" href="#ch03ex03">Program 3.2</a> would begin with the include directives for interfaces that declare the functions that it uses, as follows:</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
#include &lt;math.h&gt;
#include "Number.h"</pre></div><br />
<p class="docText">The function <tt>main</tt> from <a class="docLink" href="#ch03ex03">Program 3.2</a> then can follow these three lines. This code might be kept, for example, in a file named <tt>avg.c</tt>.</p>
<p class="docText">Compiled together, the programs <tt>avg.c</tt> and <tt>int.c</tt> described in the previous paragraphs have the same functionality as <a class="docLink" href="#ch03ex03">Program 3.2</a>, but they represent a more flexible implementation both because the code associated with the data type is encapsulated and can be used by other client programs and because <tt>avg.c</tt> can be used with other data types without being changed. We are still assuming that whatever type we use for <tt>Number</tt> converts to <tt>float</tt>; C++ allows us to define that conversion, as well as to define what we want built-in operators such as <tt>+=</tt> and <tt>&lt;&lt;</tt> to mean as part of our new data type. Reusing function names or operators in different data types is called <span class="docEmphasis">overloading</span>.</p>
<p class="docText">There are many other ways to support data types besides the client&ndash;interface&ndash;implementation scenario just described. The concept transcends any particular programming language or implementation approach. Indeed, since file names are not part of the language, you might have to modify the simple approach suggested above to get it to work in your C++ environment (rules on inclusion vary, systems have differing conventions or rules on what can be in header files, and some systems require specific filename extensions, such as <tt>.C</tt> or <tt>.cxx</tt>, for program files). One of the most important features in C++ is the concept of a <span class="docEmphasis">class</span>, which provides us with a convenient way to define and implement data types. Although we will stick with the simple approach just described for the remainder of this chapter, we shall be using classes almost exclusively throughout the rest of the book. <a class="docLink" href="ch04.html#ch04">Chapter 4</a> is devoted to the topic of using classes to create the basic data types that are of importance in algorithm design, and covers the relationship between C++ classes and the client&ndash;interface&ndash;implementation design paradigm in detail.</p>
<p class="docText">The primary reason for the existence of these mechanisms is the support that they provide for teams of programmers facing the tasks of creating and maintaining huge applications systems. However, an understanding of this topic is important to us because we exploit the mechanisms throughout the book to create natural ways to substitute improved implementations of algorithms and data structures for old ones, and therefore to compare different algorithms for the same applications problem.</p>
<p class="docText">We often want to build data structures that allow us to handle collections of data. The data structures may be huge, or they may be used extensively, so we are interested in identifying the important operations that we will perform on the data and in knowing how to implement those operations efficiently. Doing these tasks is taking the first steps in the process of incrementally building lower-level abstractions into higher-level ones; that process allows us to conveniently develop ever more powerful programs. The simplest mechanisms for grouping data in an organized way in C++ are <span class="docEmphasis">arrays</span>, which we consider in <a class="docLink" href="ch03lev1sec2.html#ch03lev1sec2">Section 3.2</a>, and <span class="docEmphasis">structures</span>, which we consider next.</p>
<p class="docText">Structures are aggregate types that we use to define collections of data such that we can manipulate an entire collection as a unit, but can still refer to individual components of a given datum by name. In C++, we can use a structure to define a new type of data, and can define operations on that data. That is, we can manipulate the aggregate data in much the same way that we manipulate data defined by built-in types such as <tt>int</tt> or <tt>float</tt>. We can name variables, and can pass those variables as arguments to functions, and can do many other things, as we shall see.</p>
<a name="ch03ex04"></a><h5 id="title-IDAA25IE" class="docExampleTitle">Program 3.3. Point data type interface</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This interface defines a data type consisting of the set of values &quot;pairs of floating-point numbers&quot; and the operation &quot;compute the distance between two points.&quot;</p>
<div class="docText"><pre>struct point { float x; float y; };
float distance(point, point);</pre></div><br />
</td></tr></table></p>
<p class="docText">For example, when processing geometric data we might want to work with the abstract notion of points in the plane. Accordingly, we can write</p>
<div class="docText"><pre>struct point { float x; float y; };</pre></div><br />
<p class="docText">to indicate that we will use the name <tt>point</tt> to refer to pairs of floating-point numbers. For example, the statement</p>
<div class="docText"><pre>struct point a, b;</pre></div><br />
<p class="docText">declares two variables of this type. We can refer to individual members of a structure by name. For example, the statements</p>
<div class="docText"><pre>a.x = 1.0; a.y = 1.0; b.x = 4.0; b.y = 5.0;</pre></div><br />
<p class="docText">set <tt>a</tt> to represent the point (1,1) and <tt>b</tt> to represent the point (4,5).</p>
<p class="docText">We can also pass structures as arguments to functions. For example, the code</p>
<div class="docText"><pre>float distance(point a, point b)
  { float dx = a.x - b.x, dy = a.y - b.y;
    return sqrt(dx*dx + dy*dy);
  }</pre></div><br />
<p class="docText">defines a function that computes the distance between two points in the plane. This example illustrates the natural way in which structures allow us to aggregate our data in typical applications.</p>
<p class="docText"><a class="docLink" href="#ch03ex04">Program 3.3</a> is an interface that embodies our definition of a data type for points in the plane: it uses a structure to represent the points, and includes an operation to compute the distance between two points. <a class="docLink" href="#ch03ex05">Program 3.4</a> is a function that implements the operation. We use interface-implementation arrangements like this to define data types whenever possible, because they encapsulate the definition (in the interface) and the implementation in a clear and direct manner. We make use of the data type in a client program by including the interface and by compiling the implementation with the client program (or by using appropriate separate-compilation facilities). The implementation <a class="docLink" href="#ch03ex05">Program 3.4</a> includes the interface of <a class="docLink" href="#ch03ex04">Program 3.3</a> to ensure that its function definition matches what the client expects. The idea is to make sure that client programs can use points without having to make any assumption about how they are represented. In <a class="docLink" href="ch04.html#ch04">Chapter 4</a>, we shall see how to carry this separation between client and implementation one step further.</p>
<p class="docText">The <tt>point</tt> structure example just given is a simple one that comprises two items of the same type. In general, structures can mix different types of data. We shall be working extensively with such structures throughout the rest of this chapter.</p>
<p class="docText">Structures allow us to aggregate data; in C++, we can, in addition, associate with the data the operations that we want to perform on it in using the <span class="docEmphasis">class</span> mechanism. We shall consider the details of defining classes in <a class="docLink" href="ch04.html#ch04">Chapter 4</a>, along with many examples. With an appropriate class, we could even use a program such as <a class="docLink" href="#ch03ex03">Program 3.2</a> to process items of type <tt>point</tt>, by defining what we want the appropriate arithmetic and type conversion operations to mean for points. This ability to use previously defined high-level abstract operations, even for newly defined types, is one of the essential and distinctive features of C++ programming. It is based on our ability to directly define our own data types within the language, not just by associating data with <tt>struct</tt>, but also by precisely defining the operations on the data (and the data structures and algorithms that support them) with classes. Classes form the basis for our implementations throughout the book, but before considering the definition and use of classes in detail (in <a class="docLink" href="ch04.html#ch04">Chapter 4</a>), we need to consider a number of lower-level mechanisms for manipulating and associating data.</p>
<p class="docText">Beyond giving us the specific basic types <tt>int</tt>, <tt>float</tt>, and <tt>char</tt>, and the ability to build them into compound types with <tt>struct</tt>, C++ provides us with the ability to manipulate our data indirectly. A <span class="docEmphasis">pointer</span> is a reference to an object in memory (usually implemented as a machine address). We declare a variable <tt>a</tt> to be a pointer to (for example) an integer by writing <tt>int *a</tt>, and we can refer to the integer itself as <tt>*a</tt>. We can declare pointers to any type of data. The unary operator <tt>&amp;</tt> gives the machine address of an object, and is useful for initializing pointers. For example, <tt>*&amp;a</tt> is the same as <tt>a</tt>.</p>
<a name="ch03ex05"></a><h5 id="title-IDAOBAJE" class="docExampleTitle">Program 3.4. Point data type implementation</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This implementation provides the definition for the distance function for points that is declared in <a class="docLink" href="#ch03ex04">Program 3.3</a>. It makes use of a library function to compute the square root.</p>
<div class="docText"><pre>#include &lt;math.h&gt;
#include "Point.h"
float distance(point a, point b)
  { float dx = a.x - b.x, dy = a.y - b.y;
    return sqrt(dx*dx + dy*dy);
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">Referring to an object indirectly via a pointer is often more convenient than referring directly to the object, and can also be more efficient, particularly for large objects. We will see many examples of this advantage in <a class="docLink" href="ch03lev1sec3.html#ch03lev1sec3">Sections 3.3</a> through <a class="docLink" href="ch03lev1sec7.html#ch03lev1sec7">3.7</a>. Even more important, as we shall see, we can use pointers to structure our data in ways that support efficient algorithms for processing the data. Pointers are the basis for many data structures and algorithms.</p>
<p class="docText">A simple and important example of the use of pointers arises when we consider the definition of a function that is to return multiple values. For example, the following function (using the functions <tt>sqrt</tt> and <tt>atan2</tt> from the standard library) converts from Cartesian to polar coordinates:</p>
<div class="docText"><pre>polar(float x, float y, float *r, float *theta)
  { *r = sqrt(x*x + y*y); *theta = atan2(y, x); }</pre></div><br />
<p class="docText">The arguments to this function are passed by value&mdash;if the function assigns a new value to an argument variable, that assignment is local to the function and is not seen by the calling function. This function therefore cannot change the <span class="docEmphasis">pointers</span> to the floating-point numbers <tt>r</tt> and <tt>theta</tt>, but it can change the values of the numbers, by indirect reference. For example, if a calling function has a declaration <tt>float a, b</tt>, the function call</p>
<div class="docText"><pre>polar(1.0, 1.0, &amp;a, &amp;b)</pre></div><br />
<p class="docText">will result in <tt>a</tt> being set to <img border="0" alt="" width="85" height="15" src="081inlineequ01.jpg" /> and <tt>b</tt> being set to <tt>0.785398</tt> (<span class="docEmphasis">&#960;/4</span>). The <tt>&amp;</tt> operator allows us to pass the addresses of <tt>a</tt> and <tt>b</tt> to the function, which treats those arguments as pointers.</p>
<p class="docText">In C++, we can achieve the same effect using <span class="docEmphasis">reference</span> parameters, as follows:</p>
<div class="docText"><pre>polar(float x, float y, float&amp; r, float&amp; theta)
  {  r = sqrt(x*x + y*y); theta = atan2(y, x); }</pre></div><br />
<p class="docText">The notation <tt>float&amp;</tt> means &quot;reference to a <tt>float</tt>&quot;. We may think of references as built-in pointers that are automatically followed each time they are used. For example, when we refer to <tt>theta</tt> in this function, we are referring to whatever <tt>float</tt> was used in the second argument in the calling function. If, as in the example in the previous paragraph, a calling function has a declaration <tt>float a, b</tt>, the function call <tt>polar(1.0, 1.0, a, b)</tt> will result in <tt>a</tt> being set to <tt>1.414214</tt> and <tt>b</tt> being set to <tt>0.785398</tt>.</p>
<p class="docText">So far, we have primarily talked about defining individual pieces of information for our programs to process. In many instances, we are interested in working with potentially huge <span class="docEmphasis">collections</span> of data, and we now turn to basic methods for doing so. In general, we use the term <span class="docEmphasis">data structure</span> to refer to a mechanism for organizing our information to provide convenient and efficient mechanisms for accessing and manipulating it. Many important data structures are based on one or both of the two elementary approaches that we shall consider in this chapter. We may use an <span class="docEmphasis">array</span>, where we organize objects in a fixed sequential fashion that is more suitable for access than for manipulation; or a <span class="docEmphasis">list</span>, where we organize objects in a logical sequential fashion that is more suitable for manipulation than for access.</p>
</td></tr></table></p>
<p class="docText">&nbsp;<a name="iddle1346"></a><a name="iddle1538"></a><a name="iddle2024"></a><a name="iddle2275"></a><a name="iddle1517"></a><a name="iddle1677"></a><a name="iddle2215"></a><a name="iddle2433"></a><a name="iddle1273"></a><a name="iddle1335"></a><a name="iddle1491"></a><a name="iddle1604"></a><a name="iddle1626"></a><a name="iddle1682"></a><a name="iddle1494"></a><a name="iddle2004"></a><a name="iddle2014"></a><a name="iddle1064"></a><a name="iddle1260"></a><a name="iddle1321"></a><a name="iddle1340"></a><a name="iddle2055"></a><a name="iddle1026"></a><a name="iddle2006"></a><a name="iddle2059"></a></p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa1q1"></a><b></b></td><td><p class="docText"><a name="iddle1065"></a><a name="iddle1322"></a><a name="iddle1820"></a><a name="iddle2026"></a><a name="iddle2272"></a><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">3.1</span> Find the largest and smallest numbers that you can represent with types <tt>int</tt>, <tt>long int</tt>, <tt>short int</tt>, <tt>float</tt>, and <tt>double</tt> in your programming environment.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa1q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.2</span> Test the random-number generator on your system by generating <span class="docEmphasis">N</span> random integers between <span class="docEmphasis">0</span> and <span class="docEmphasis">r&mdash;1</span> with <tt>rand() % r</tt> and computing the average and standard deviation for <span class="docEmphasis">r</span> = 10, 100, and 1000 and <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa1q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.3</span> Test the random-number generator on your system by generating <span class="docEmphasis">N</span> random numbers of type <tt>double</tt> between 0 and 1, transforming them to integers between 0 and <span class="docEmphasis">r</span>&mdash;1 by multiplying by <span class="docEmphasis">r</span> and truncating the result, and computing the average and standard deviation for <span class="docEmphasis">r</span> = 10, 100, and 1000 and <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa1q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">3.4</span> Do <a class="docLink" href="#ch03qa1q2">Exercises 3.2</a> and <a class="docLink" href="#ch03qa1q3">3.3</a> for <span class="docEmphasis">r</span> = 2, 4, and 16.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa1q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.5</span> Implement the necessary functions to allow <a class="docLink" href="#ch03ex03">Program 3.2</a> to be used for random <span class="docEmphasis">bits</span> (numbers that can take only the values 0 or 1).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa1q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.6</span> Define a <tt>struct</tt> suitable for representing a playing card.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa1q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.7</span> Write a client program that uses the data type in <a class="docLink" href="#ch03ex04">Programs 3.3</a> and <a class="docLink" href="#ch03ex05">3.4</a> for the following task: Read a sequence of points (pairs of floating-point numbers) from standard input, and find the one that is closest to the first.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa1q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">3.8</span> Add a function to the point data type (<a class="docLink" href="#ch03ex04">Programs 3.3</a> and <a class="docLink" href="#ch03ex05">3.4</a>) that determines whether or not three points are collinear, to within a numerical tolerance of 10<sup>&ndash;4</sup>. Assume that the points are all in the unit square.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa1q9"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">3.9</span> Define a data type for <span class="docEmphasis">triangles</span> in the unit square, including a function that computes the area of a triangle. Then write a client program that generates random triples of pairs of <tt>float</tt>s between 0 and 1 and computes the average area of the triangles generated.</p></td></tr></table></p>
<a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch03lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>