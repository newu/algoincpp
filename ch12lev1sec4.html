<html><head><title>12.4. Binary Search</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch12lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch12lev1sec4"></a>
<h3 id="title-IDAZQE5H" class="docSection1Title">12.4. Binary Search</h3>
<p class="docText">In the array implementation of sequential search, we can reduce significantly the total search time for a large set of items by using a search procedure based on applying the standard divide-and-conquer paradigm (see <a class="docLink" href="ch05lev1sec2.html#ch05lev1sec2">Section 5.2</a>): Divide the set of items into two parts, <a name="iddle2314"></a><a name="iddle2492"></a>determine to which of the two parts the search key belongs, then concentrate on that part. A reasonable way to divide the sets of items into parts is to keep the items sorted, then to use indices into the sorted array to delimit the part of the array being worked on. This search technique is called <span class="docEmphasis">binary search</span>. <a class="docLink" href="#ch12ex13">Program 12.7</a> is a recursive implementation of this fundamental strategy. <a class="docLink" href="ch02lev1sec6.html#ch02ex05">Program 2.2</a> is a non-recursive implementation of the method&mdash;no stack is needed because the recursive function in <a class="docLink" href="#ch12ex13">Program 12.7</a> ends in a recursive call.</p>
<p class="docText"><a class="docLink" href="#ch12fig01">Figure 12.1</a> shows the subfiles examined by binary search when a small table is searched; <a class="docLink" href="#ch12fig02">Figure 12.2</a> depicts a larger example. Each iteration eliminates slightly more than one-half of the table, so the number of iterations required is small.</p>
<a name="ch12fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 12.1. Binary search</h5>
<h5></h5><h5></h5></center></p><p class="docText">Binary search uses only three iterations to find a search key <tt>L</tt> in this sample file. On the first call, the algorithm compares <tt>L</tt> to the key in the middle of the file, the <tt>G</tt>. Since <tt>L</tt> is larger, the next iteration involves the right half of the file. Then, since <tt>L</tt> is less than the <tt>M</tt> in the middle of the right half, the third iteration involves the subfile of size 3 containing <tt>H</tt>, <tt>I</tt>, and <tt>L</tt>. After one more iteration, the subfile size is 1, and the algorithm finds the <tt>L</tt>.</p>
<p class="docText">
<img border="0" alt="" width="225" height="60" src="12fig01.gif" /></p>
<br />
<a name="ch12fig02"></a><p><center>
<h5 class="docFigureTitle">Figure 12.2. Binary search</h5>
<h5></h5><h5></h5></center></p><p class="docText">With binary search, we need only seven iterations to find a record in a file of 200 elements. The subfile sizes follow the sequence 200, 99, 49, 24, 11, 5, 2, 1; each is slightly less than one-half of the previous.</p>
<p class="docText">
<img border="0" alt="" width="300" height="160" src="12fig02.gif" /></p>
<br />
<a name="ch12ex12"></a><h5 id="title-IDARVE5H" class="docExampleTitle">Property 12.5. <span class="docEmphasis">Binary search never uses more than</span> <span class="docEmphRoman"><tt><img src="U230A.GIF" border="0" />lg</tt></span> <span class="docEmphasis"><tt>N</tt></span><span class="docEmphRoman"><tt><img src="U230B.GIF" border="0" /> + 1</tt></span> <span class="docEmphasis">comparisons for a search (hit or miss)</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">See <a class="docLink" href="ch02lev1sec6.html#ch02ex06">Property 2.3</a>. It is amusing to note that the maximum number of comparisons used for a binary search in a table of size <span class="docEmphasis">N</span> is precisely the number of bits in the binary representation of <span class="docEmphasis">N</span>, because the operation of shifting 1 bit to the right converts the binary representation of <span class="docEmphasis">N</span> into the binary representation of <img src="U230A.GIF" border="0" /><span class="docEmphasis">N</span>/2<img src="U230B.GIF" border="0" /> (see <a class="docLink" href="ch02lev1sec5.html#ch02fig06">Figure 2.6</a>).</p>
</td></tr></table></p>
<p class="docText">Keeping the table sorted as we do in insertion sort leads to a running time that is a quadratic function of the number of <span class="docEmphasis">insert</span> operations, but this cost might be tolerable or even negligible if the number of <span class="docEmphasis">search</span> operations is huge. In the typical situation where all the items (or even a large number of them) are available before the search begins, we might <span class="docEmphasis">construct</span> the symbol table by having a constructor that takes an array as its argument and uses one of the standard sorting methods from <a class="docLink" href="ch06.html#ch06">Chapters 6</a> through <a class="docLink" href="ch10.html#ch10">10</a> to sort the table during initialization. After doing so, we could handle updates to the table in various ways. For example, we could maintain order during insert, as in <a class="docLink" href="ch12lev1sec3.html#ch12ex07">Program 12.5</a> (see also <a class="docLink" href="ch12lev1sec3.html#ch12qa3q6">Exercise 12.21</a>), or we could batch them, sort, and merge (as discussed in <a class="docLink" href="ch08lev1sec1.html#ch08qa1q1">Exercise 8.1</a>). Any update could involve an item with a smaller key than those of any item in the table, so every item in the table might have to be moved to make room. This potential for a high cost of updating the table is the biggest liability of using binary search. On the other hand, there are a great many applications where a static table can be presorted and the fast access provided by implementations like <a class="docLink" href="#ch12ex13">Program 12.7</a> makes binary search the method of choice.</p>
<a name="ch12ex13"></a><h5 id="title-IDA0YE5H" class="docExampleTitle">Program 12.7. Binary search (for array-based symbol table)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This implementation of <tt>search</tt> uses a recursive binary-search procedure. To find whether a given key <span class="docEmphasis">v</span> is in an ordered array, it first compares <span class="docEmphasis">v</span> with the element at the middle position. If <span class="docEmphasis">v</span> is smaller, then it must be in the first half of the array; if <span class="docEmphasis">v</span> is greater, then it must be in the second half of the array.</p>
<p class="docText">The array must be in sorted order. This function could replace <tt>search</tt> in <a class="docLink" href="ch12lev1sec3.html#ch12ex07">Program 12.5</a>, which maintains the order dynamically during insertion. We could also include a symbol-table constructor that takes an array as an argument, then builds a symbol table from items in the argument array and uses a standard sort routine to prepare it for searching.</p>
<div class="docText"><pre>private:
  Item searchR(int l, int r, Key v)
    { if (l &gt; r) return nullItem;
      int m = (l+r)/2;
      if (v == st[m].key()) return st[m];
      if (l == r) return nullItem;
      if (v &lt; st[m].key())
           return searchR(l, m-1, v);
      else return searchR(m+1, r, v);
  }
public:
  Item search(Key v)
    { return searchR(0, N-1, v); }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a name="iddle1099"></a><a name="iddle1402"></a><a name="iddle1805"></a>If we need to insert new items dynamically, it seems that we need a linked structure, but a singly linked list does not lead to an efficient implementation, because the efficiency of binary search depends on our ability to get to the middle of any subarray quickly via indexing, and the only way to get to the middle of a singly linked list is to follow links. To combine the efficiency of binary search with the flexibility of linked structures, we need more complicated data structures, which we shall begin examining shortly.</p>
<p class="docText">If duplicate keys are present in the table, then we can extend binary search to support symbol-table operations for counting the number of items with a given key or returning them as a group. Multiple items with keys equal to the search key in the table form a contiguous <a name="iddle1201"></a><a name="iddle2228"></a><a name="iddle2490"></a>block in the table (because it is in order), and a successful search in <a class="docLink" href="#ch12ex13">Program 12.7</a> will end somewhere within this block. If an application requires access to all such items, we can add code to scan both directions from the point where the search terminated, and to return two indices delimiting the items with keys equal to the search key. In this case, the running time for the search will be proportional to lg <span class="docEmphasis">N</span> plus the number of items found. A similar approach solves the more general <span class="docEmphasis">range-search</span> problem of finding all items with keys falling within a specified interval. We shall consider such extensions to the basic set of symbol-table operations in Part 6.</p>
<p class="docText">The sequence of comparisons made by the binary search algorithm is predetermined: The specific sequence used depends on the value of the search key and on the value of <span class="docEmphasis">N</span>. The comparison structure can be described by a binary-tree structure such as the one illustrated in <a class="docLink" href="#ch12fig03">Figure 12.3</a>. This tree is similar to the tree that we used in <a class="docLink" href="ch08.html#ch08">Chapter 8</a> to describe the subfile sizes for mergesort (<a class="docLink" href="ch08lev1sec3.html#ch08fig03">Figure 8.3</a>). For binary search, we take one path through the tree; for mergesort, we take all paths through the tree. This tree is static and implicit; in <a class="docLink" href="ch12lev1sec5.html#ch12lev1sec5">Section 12.5</a>, we shall see algorithms that use a dynamic, explicitly constructed binary-tree structure to guide the search.</p>
<a name="ch12fig03"></a><p><center>
<h5 class="docFigureTitle">Figure 12.3. Comparison sequence in binary search</h5>
<h5></h5><h5></h5></center></p><p class="docText">These divide-and-conquer tree diagrams depict the index sequence for the comparisons in binary search. The patterns are dependent on only the initial file size, rather than on the values of the keys in the file. They differ slightly from the trees corresponding to mergesort and similar algorithms (<a class="docLink" href="ch05lev1sec2.html#ch05fig06">Figures 5.6</a> and <a class="docLink" href="ch08lev1sec3.html#ch08fig03">8.3</a>) because the element at the root is not included in the subtrees.</p><h5></h5><p class="docText">The top diagram shows how a file of 15 elements, indexed from 0 to 14, is searched. We look at the middle element (index 7), then (recursively) consider the left subtree if the element sought is less, and the right subtree if the element sought is greater. Each search corresponds to a path from top to bottom in the tree; for example, a search for an element that falls between the elements 10 and 11 would involve the sequence 7, 11, 9, 10. For file sizes that are not 1 less than a power of 2, the pattern is not quite as regular, as indicated by the bottom diagram, for 12 elements</p>
<p class="docText">
<img border="0" alt="" width="200" height="181" src="12fig03.gif" /></p>
<br />
<p class="docText">One improvement that is possible for binary search is to guess where the search key falls within the current interval of interest with more precision (rather than blindly testing it against the middle element at each step). This tactic mimics the way we look up a name in the <a name="iddle1146"></a><a name="iddle1202"></a><a name="iddle1687"></a><a name="iddle2325"></a>telephone directory or a word in a dictionary: If the entry that we are seeking begins with a letter near the beginning of the alphabet, we look near the beginning of the book, but if it begins with a letter near the end of the alphabet, we look near the end of the book. To implement this method, called <span class="docEmphasis">interpolation search</span>, we modify <a class="docLink" href="#ch12ex13">Program 12.7</a> as follows: We replace the statement</p>
<div class="docText"><pre>m = (l+r)/2;</pre></div><br />
<p class="docText">with</p>
<div class="docText"><pre> m = l+(v-a[l].key())*(r-l)/(a[r].key()-a[l].key());</pre></div><br />
<p class="docText">To justify this change, we note that <tt>(</tt><span class="docEmphasis"><tt>l + r</tt></span><tt>)/2</tt> is shorthand for <img border="0" alt="" width="75" height="20" src="514inline01.jpg" />: We compute the middle of the interval by adding one-half of the size of the interval to the left endpoint. Using interpolation search amounts to replacing <img border="0" alt="" width="8" height="23" src="514inline02.jpg" /> in this formula by an estimate of where the key might be&mdash;specifically (<span class="docEmphasis">v - k<sub>l</sub></span>)/(<span class="docEmphasis">k<sub>r</sub> - k<sub>l</sub></span>), where <span class="docEmphasis">k<sub>l</sub></span> and <span class="docEmphasis">k<sub>r</sub></span> denote the values of <tt>a[l].key()</tt> and <tt>a[r].key()</tt>, respectively. This calculation is based on the assumption that the key values are numerical and evenly distributed.</p>
<p class="docText">For files of random keys, it is possible to show that interpolation search uses fewer than <tt>lglg</tt> <span class="docEmphasis"><tt>N</tt></span><tt>+1</tt> comparisons for a search (hit or miss). That proof is quite beyond the scope of this book. This function grows very slowly, and can be thought of as a constant for practical purposes: If <span class="docEmphasis">N</span> is 1 billion, <tt>lglg</tt> <span class="docEmphasis"><tt>N</tt></span> <tt>&lt; 5</tt>. Thus, we can find any item using only a few accesses (on the average)&mdash;a substantial improvement over binary search. For keys that are more regularly distributed than random, the performance of interpolation search is even better. Indeed, the limiting case is the key-indexed search method of <a class="docLink" href="ch12lev1sec2.html#ch12lev1sec2">Section 12.2</a>.</p>
<p class="docText">Interpolation search, however, does depend heavily on the assumption that the keys are well distributed over the interval&mdash;it can be badly fooled by poorly distributed keys, which do commonly arise in practice. Also, it requires extra computation. For small <span class="docEmphasis">N</span>, the lg <span class="docEmphasis">N</span> cost of straight binary search is close enough to lg lg <span class="docEmphasis">N</span> that the cost of interpolating is not likely to be worthwhile. On the other hand, interpolation search certainly should be considered for large files, for applications where comparisons are particularly expensive, and for external methods where high access costs are involved.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa4q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">12.34</span> Implement a nonrecursive binary search function (see <a class="docLink" href="#ch12ex13">Program 12.7</a>).</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa4q2"></a><b></b></td><td><p class="docText"><a name="iddle1150"></a><span class="docEmphStrong">12.35</span> Draw trees that correspond to <a class="docLink" href="#ch12fig03">Figure 12.3</a> for <span class="docEmphasis"><tt>N</tt></span> <tt>= 17</tt> and <span class="docEmphasis"><tt>N</tt></span> <tt>= 24</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa4q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">12.36</span> Find the values of <span class="docEmphasis">N</span> for which binary search in a symbol table of size <span class="docEmphasis">N</span> becomes 10, 100, and 1000 times faster than sequential search. Predict the values with analysis and verify them experimentally.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa4q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.37</span> Suppose that insertions into a dynamic symbol table of size <span class="docEmphasis">N</span> are implemented as in insertion sort, but that we use binary search for <span class="docEmphasis">search</span>. Assume that searches are 1000 times more frequent than insertions. Estimate the percentage of the total time that is devoted to insertions, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa4q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.38</span> Develop a symbol-table implementation using binary search and lazy insertion that supports the <span class="docEmphasis">construct</span>, <span class="docEmphasis">count</span>, <span class="docEmphasis">search</span>, <span class="docEmphasis">insert</span>, and <span class="docEmphasis">sort</span> operations, using the following strategy. Keep a large sorted array for the main symbol table and an unordered array for recently inserted items. When <tt>search</tt> is called, sort the recently inserted items (if there are any), merge them into the main table, then use binary search.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa4q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.39</span> Add lazy removal to your implementation for <a class="docLink" href="#ch12qa4q5">Exercise 12.38</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa4q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.40</span> Answer <a class="docLink" href="#ch12qa4q4">Exercise 12.37</a> for your implementation for <a class="docLink" href="#ch12qa4q5">Exercise 12.38</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa4q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">12.41</span> Implement a function similar to binary search (<a class="docLink" href="#ch12ex13">Program 12.7</a>) that returns the number of items in the symbol table with keys equal to a given key.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa4q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.42</span> Write a program that, given a value of <span class="docEmphasis">N</span>, produces a sequence of <span class="docEmphasis">N</span> macro instructions, indexed from <tt>0</tt> to <tt>N-1</tt>, of the form <tt>compare(l, h)</tt>, where the <span class="docEmphasis">i</span>th instruction on the list means &quot;compare the search key with the value at table index <tt>i</tt>; then report a search hit if equal, do the <span class="docEmphasis">l</span>th instruction next if less, and do the <span class="docEmphasis">h</span>th instruction next if greater&quot; (reserve index 0 to indicate search miss). The sequence should have the property that any search will do the same comparisons as would binary search on the same data.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa4q10"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">12.43</span> Develop an expansion of the macro in <a class="docLink" href="#ch12qa4q9">Exercise 12.42</a> such that your program produces machine code that can do binary search in a table of size <span class="docEmphasis">N</span> with as few machine instructions per comparison as possible.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa4q11"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.44</span> Suppose that <tt>a[i] == 10*i</tt> for <tt>i</tt> between <tt>1</tt> and <span class="docEmphasis"><tt>N</tt></span>. How many table positions are examined by interpolation search during the unsuccessful search for 2<span class="docEmphasis">k</span> - 1?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa4q12"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">12.45</span> Find the values of <span class="docEmphasis">N</span> for which interpolation search in a symbol table of size <span class="docEmphasis">N</span> becomes 1, 2, and 10 times faster than binary search, assuming the keys to be random. Predict the values with analysis, and verify them experimentally.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch12lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>