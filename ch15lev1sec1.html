<html><head><title>15.1. Digital Search Trees</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch15.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch15lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch15lev1sec1"></a>
<h3 id="643999-862" class="docSection1Title">15.1. Digital Search Trees</h3>
<p class="docText">The simplest radix-search method is based on use of <span class="docEmphasis">digital search trees</span> (<span class="docEmphasis">DSTs</span>). The <span class="docEmphasis">search</span> and <span class="docEmphasis">insert</span> algorithms are identical to binary tree search except for one difference: We branch in the tree not according to the result of the comparison between the full keys, but rather according to selected bits of the key. At the first level, the leading bit is used; at the second level, the second leading bit is used; and so on, until an external node is encountered. <a class="docLink" href="#ch15ex01">Program 15.1</a> is an implementation of <span class="docEmphasis">search</span>; the implementation of <span class="docEmphasis">insert</span> is similar. Rather than using &lt; to compare keys, we assume that the <tt>digit</tt> function is available to access individual bits in keys. This code is virtually the same as the code for binary tree search (see <a class="docLink" href="ch12lev1sec5.html#ch12ex15">Program 12.8</a>), but has substantially different performance characteristics, as we shall see.</p>
<p class="docText">We saw in <a class="docLink" href="ch10.html#ch10">Chapter 10</a> that we need to pay particular attention to equal keys in radix sorting; the same is true in radix search. Generally, we assume in this chapter that all the key values to appear in the <a name="iddle2190"></a>symbol table are distinct. We can do so without loss of generality because we can use one of the methods discussed in <a class="docLink" href="ch12lev1sec1.html#ch12lev1sec1">Section 12.1</a> to support applications that have records with duplicate keys. It is important to focus on distinct key values in radix search, because key values are intrinsic components of several of the data structures that we shall consider.</p>
<a name="ch15ex01"></a><h5 id="title-IDAE45RO" class="docExampleTitle">Program 15.1. Binary digital search tree</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">To develop a symbol-table implementation using DSTs, we modify the implementations of <span class="docEmphasis">search</span> and <span class="docEmphasis">insert</span> in the standard BST implementation (see <a class="docLink" href="ch12lev1sec5.html#ch12ex15">Program 12.8</a>) as shown in this implementation of <span class="docEmphasis">search</span>. Rather than doing a full key comparison, we decide whether to move left or right on the basis of testing a single bit (the leading bit) of the key. The recursive function calls have a third argument so that we can move the bit position to be tested to the right as we move down the tree. We use the <tt>digit</tt> operation to test bits, as discussed in <a class="docLink" href="ch10lev1sec1.html#ch10lev1sec1">Section 10.1</a>. These same changes apply to implementation of <span class="docEmphasis">insert</span>; otherwise, we use all the code from <a class="docLink" href="ch12lev1sec5.html#ch12ex15">Program 12.8</a>.</p>
<div class="docText"><pre>  private:
    Item searchR(link h, Key v, int d)
      { if (h == 0) return nullItem;
        if (v == h-&gt;item.key()) return h-&gt;item;
        if (digit(v, d) == 0)
             return searchR(h-&gt;l, v, d+1);
        else return searchR(h-&gt;r, v, d+1);
      }
  public:
    Item search(Key v)
      { return searchR(head, v, 0); }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch15fig01">Figure 15.1</a> gives binary representations for the one-letter keys used in other figures in the chapter. <a class="docLink" href="#ch15fig02">Figure 15.2</a> gives an example of insertion into a DST; <a class="docLink" href="#ch15fig03">Figure 15.3</a> shows the process of inserting keys into an initially empty tree.</p>
<a name="ch15fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 15.1. Binary representation of single-character keys</h5>
<h5></h5><h5></h5></center></p><p class="docText">As we did in <a class="docLink" href="ch10.html#ch10">Chapter 10</a>, we use the 5-bit binary representation of i to represent the ith letter in the alphabet, as shown here for several sample keys, for the small examples in the figures in this chapter. We consider the bits as numbered from 0 to 4, from left to right.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="45" height="194" src="15fig01.gif" /></p>
<br />
<a name="ch15fig02"></a><p><center>
<h5 class="docFigureTitle">Figure 15.2. Digital search tree and insertion</h5>
<h5></h5><h5></h5></center></p><p class="docText">In an unsuccessful search for <tt>M = 01101</tt> in this sample digital search tree <tt>(top)</tt>, we move left at the root (since the first bit in the binary representation of the key is <tt>0</tt>) then right (since the second bit is <tt>1</tt>), then right, then left, to finish at the null left link below <tt>N</tt>. To insert <tt>M (bottom)</tt>, we replace the null link where the search ended with a link to the new node, just as we do with BST insertion.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="300" height="234" src="15fig02.gif" /></p>
<br />
<a name="ch15fig03"></a><p><center>
<h5 class="docFigureTitle">Figure 15.3. Digital search tree construction</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts the result of inserting the keys <tt>A S E R C H I N G</tt> into an initially empty digital search tree.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="250" height="874" src="15fig03.gif" /></p>
<br />
<p class="docText">The bits of the keys control search and insertion, but note that DSTs do not have the ordering property that characterizes BSTs. That is, it is<span class="docEmphasis">not</span> necessarily the case that nodes to the left of a given node have smaller keys or that nodes to the right have larger keys, as would be the case in a BST with distinct keys. It is true that keys on the left of a given node are smaller than keys on the right&mdash;if the node is at level <span class="docEmphasis">k</span>, they all agree in the first <span class="docEmphasis">k</span> bits, but the next bit is 0 for the keys on the left and is 1 for the keys on the right&mdash;but the node's key could itself could be the smallest, largest, or any value in between of all the keys in that node's subtree.</p>
<p class="docText">DSTs are characterized by the property that each key is <span class="docEmphasis">somewhere</span> along the path specified by the bits of the key (in order from left to right). This property is sufficient for the <span class="docEmphasis">search</span> and <span class="docEmphasis">insert</span> implementations in <a class="docLink" href="#ch15ex01">Program 15.1</a> to operate properly.</p>
<p class="docText">Suppose that the keys are words of a fixed length, all consisting of <span class="docEmphasis">w</span> bits. Our requirement that keys are distinct implies that <span class="docEmphasis">N</span> <img src="U2264.GIF" border="0" /> <span class="docEmphRoman">2<sup>w</sup></span>, and we normally assume that <span class="docEmphasis">N</span> is significantly smaller than <span class="docEmphRoman">2<sup>w</sup></span>, since otherwise key-indexed search (see <a class="docLink" href="ch12lev1sec2.html#ch12lev1sec2">Section 12.2</a>) would be the appropriate algorithm to use. Many practical problems fall within this range. For example, DSTs are appropriate for a symbol table containing up to <span class="docEmphRoman">10<sup>5</sup></span> records with 32-bit keys (but perhaps not as many as <span class="docEmphRoman">10<sup>6</sup></span> records), or for any number of 64-bit keys. Digital tree search also works for variable-length keys; we defer considering that case in detail to <a class="docLink" href="ch15lev1sec2.html#ch15lev1sec2">Section 15.2</a>, where we consider a number of other alternatives as well.</p>
<p class="docText">The worst case for trees built with digital search is much better than that for binary search trees, if the number of keys is large and the key lengths are small relative to the number of keys. The length of the longest path in a digital search tree is likely to be relatively small for many applications (for example, if the keys comprise random bits). In particular, the longest path is certainly limited by the length of the longest key; moreover, if the keys are of a fixed length, then the search time is limited by the length. <a class="docLink" href="#ch15fig04">Figure 15.4</a> illustrates this fact.</p>
<a name="ch15fig04"></a><p><center>
<h5 class="docFigureTitle">Figure 15.4. Digital search tree, worst case</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts the result of inserting the keys <tt>P = 10000, H = 01000, D = 00100, B = 00010,</tt> and <tt>A = 00001</tt> into an initially empty digital search tree. The sequence of trees appears degenerate, but the path length is limited by the length of the binary representation of the keys. Except for <tt>00000</tt>, no other 5-bit key will increase the height of the tree any further.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="130" height="466" src="15fig04.gif" /></p>
<br />
<a name="ch15ex02"></a><h5 id="title-IDAUHYRO" class="docExampleTitle">Property 15.1. <span class="docEmphasis">A search or insertion in a digital search tree requires about</span> <span class="docEmphRoman">lg</span> <span class="docEmphasis">N comparisons on the average, and about</span> <span class="docEmphRoman">2 lg</span> <span class="docEmphasis">N comparisons in the worst case, in a tree built from N random keys. The number of comparisons is never more than the number of bits in the search key</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We can establish the stated average-case and worst-case results for random keys with an argument similar to one given for a more natural problem in the next section, so we leave this proof for an exercise there (see <a class="docLink" href="ch15lev1sec2.html#ch15qa2q20">Exercise 15.30</a>). It is based on the simple intuitive notion that the unseen portion of a random key should be equally likely to begin with a 0 bit as a 1 bit, so half should fall on either side of any node. Each time that we move down the tree, we use up a key bit, so no search in a digital search tree can require more comparisons than there are bits in the search key. For the typical condition where we have <span class="docEmphasis">w</span>-bit words and the number of keys <span class="docEmphasis">N</span> is far smaller than the total possible number of keys <span class="docEmphRoman">2<sup>w</sup></span>, the path lengths are close to <span class="docEmphRoman">lg</span> <span class="docEmphasis">N</span>, so the number of comparisons is far smaller than the number of bits in the keys for random keys.</p>
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch15fig05">Figure 15.5</a> shows a large digital search tree made from random 7-bit keys. This tree is nearly perfectly balanced. DSTs are attractive in many practical applications because they provide near-optimal performance even for huge problems, with little implementation effort. For example, a digital search tree built from 32-bit keys (or four 8-bit characters) is guaranteed to require fewer than <span class="docEmphRoman">32</span> comparisons, and a digital search tree built from 64-bit keys (or eight 8-bit characters) is guaranteed to require fewer than 64 comparisons, even if there are billions of keys. For large <span class="docEmphasis">N</span>, these guarantees are comparable to the guarantee provided by red&ndash;black trees, but are achieved with about the same implementation effort as is required for standard BSTs (which can promise only guaranteed performance proportional to <span class="docEmphasis">N<sup>2</sup></span>). This feature makes the use of digital search trees an attractive alternative to use of balanced trees in practice for implementing the <span class="docEmphasis">search</span> and <span class="docEmphasis">insert</span> symbol-table functions, <span class="docEmphasis">provided</span> that efficient access to key bits is available.</p>
<a name="ch15fig05"></a><p><center>
<h5 class="docFigureTitle">Figure 15.5. Digital search tree example</h5>
<h5></h5><h5></h5></center></p><p class="docText">This digital search tree, built by insertion of about 200 random keys, is as well-balanced as its counterparts in <a class="docLink" href="ch15.html#ch15">Chapter 15</a>.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="500" height="85" src="15fig05.gif" /></p>
<br />
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa1q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">15.1</span> Draw the DST that results when you insert items with the keys E A S Y Q U T I O N in that order into an initially empty tree, using the binary encoding given in <a class="docLink" href="#ch15fig01">Figure 15.1</a>.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa1q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.2</span> Give an insertion sequence for the keys A B C D E F G that results in a perfectly balanced DST that is also a valid BST.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa1q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.3</span> Give an insertion sequence for the keys A B C D E F G that results in a perfectly balanced DST with the property that every node has a key smaller than those of all the nodes in its subtree.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa1q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">15.4</span> Draw the DST that results when you insert items with the keys <tt>01010011 00000111 00100001 01010001 11101100 00100001 10010101 01001010</tt> in that order into an initially empty tree.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa1q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.5</span> Can we keep records with duplicate keys in DSTs, in the same way that we can in BSTs? Explain your answer.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa1q6"></a><b></b></td><td><p class="docText"><a name="iddle1345"></a><a name="iddle1507"></a><a name="iddle2574"></a><span class="docEmphStrong">15.6</span> Run empirical studies to compare the height and internal path length of a DST built by insertion of <span class="docEmphasis">N</span> random 32-bit keys into an initially empty tree with the same measures of a standard binary search tree and a red&ndash;black tree (<a class="docLink" href="ch13.html#ch13">Chapter 13</a>) built from the same keys, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa1q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">15.7</span> Give a full characterization of the worst-case internal path length of a DST with <span class="docEmphasis">N</span> distinct <span class="docEmphasis">w</span>-bit keys.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa1q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">15.8</span> Implement the <span class="docEmphasis">remove</span> operation for a DST-based symbol table.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa1q9"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">15.9</span> Implement the <span class="docEmphasis">select</span> operation for a DST-based symbol table.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa1q10"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">15.10</span> Describe how you could compute the height of a DST made from a given set of keys, in linear time, without building the DST.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch15.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch15lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>