<html><head><title>5.2. Divide and Conquer</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch05lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch05lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch05lev1sec2"></a>
<h3 id="title-IDAEMXRE" class="docSection1Title">5.2. Divide and Conquer</h3>
<p class="docText">Many of the recursive programs that we consider in this book use two recursive calls, each operating on about one-half of the input. This recursive scheme is perhaps the most important instance of the well-known <span class="docEmphasis">divide-and-conquer</span> paradigm for algorithm design, which serves as the basis for many of our most important algorithms.</p>
<p class="docText">As an example, let us consider the task of finding the maximum among <span class="docEmphasis">N</span> items stored in an array <tt>a[0]</tt>,<tt>. . .</tt> , <tt>a[N-1]</tt>. We can easily accomplish this task with a single pass through the array, as follows:</p>
<div class="docText"><pre>for (t = a[0], i = 1; i &lt; N; i++)
  if (a[i] &gt; t) t = a[i];</pre></div><br />
<p class="docText">The recursive divide-and-conquer solution given in <a class="docLink" href="#ch05ex06">Program 5.6</a> is also a simple (entirely different) algorithm for the same problem; we use it to illustrate the divide-and-conquer concept.</p>
<a name="ch05ex06"></a><h5 id="title-IDARNXRE" class="docExampleTitle">Program 5.6. Divide-and-conquer to find the maximum</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This function divides an array <tt>a[l]</tt>, <tt>. . .</tt> , <tt>a[r]</tt> into <tt>a[l]</tt>, <tt>. . .</tt> , <tt>a[m]</tt> and <tt>a[m+1]</tt>, <tt>. . .</tt> , <tt>a[r]</tt>, finds the maximum elements in the two parts (recursively), and returns the larger of the two as the maximum element in the whole array. It assumes that <tt>Item</tt> is a first-class type for which <tt>&gt;</tt> is defined. If the array size is even, the two parts are equal in size; if the array size is odd, the sizes of the two parts differ by 1.</p>
<div class="docText"><pre>Item max(Item a[], int l, int r)
  {
    if (l == r) return a[l];
    int m = (l+r)/2;
    Item u = max(a, l, m);
    Item v = max(a, m+1, r);
    if (u &gt; v) return u; else return v;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a name="iddle1534"></a><a name="iddle2260"></a>Most often, we use the divide-and-conquer approach because it provides solutions faster than those available with simple iterative algorithms (we shall discuss several examples at the end of this section), but it also is worthy of close examination as a way of understanding the nature of certain fundamental computations.</p>
<p class="docText"><a class="docLink" href="#ch05fig04">Figure 5.4</a> shows the recursive calls that are made when <a class="docLink" href="#ch05ex06">Program 5.6</a> is invoked for a sample array. The underlying structure seems complicated, but we normally do not need to worry about it&mdash;we depend on a proof by induction that the program works, and we use a recurrence relation to analyze the program's performance.</p>
<a name="ch05fig04"></a><p><center>
<h5 class="docFigureTitle">Figure 5.4. A recursive approach to finding the maximum</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence of function calls illustrates the dynamics of finding the maximum with a recursive algorithm.</p>
<p class="docText">
<img border="0" alt="" width="175" height="391" src="05fig04.gif" /></p>
<br />
<p class="docText">As usual, the code itself suggests the proof by induction that it performs the desired computation:</p>
<ul><li><p class="docList">It finds the maximum for arrays of size 1 explicitly and immediately.</p></li><li><p class="docList">For <span class="docEmphasis">N</span> &gt; 1, it partitions the array into two arrays of size less than <span class="docEmphasis">N</span>, finds the maximum of the two parts by the inductive hypothesis, and returns the larger of these two values, which must be the maximum value in the whole array.</p></li></ul>
<p class="docText">Moreover, we can use the recursive structure of the program to understand its performance characteristics.</p>
<a name="ch05ex07"></a><h5 id="title-IDARRXRE" class="docExampleTitle">Property 5.1. <span class="docEmphasis">A recursive function that divides a problem of size N into two independent (nonempty) parts that it solves recursively calls itself less than N times</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">If the parts are one of size <span class="docEmphasis">k</span> and one of size <span class="docEmphasis">N &ndash; k</span>, then the total number of recursive function calls that we use is</p>
<div class="docText"><pre><span class="docEmphasis">T<sub>N</sub> = T<sub>k</sub> + T<sub>N&ndash;k</sub></span> + 1,    for <span class="docEmphasis">N</span> <img src="U2265.GIF" border="0" /> 1 with <span class="docEmphasis">T</span><sub>1</sub> = 0.</pre></div><br />
<p class="docText">The solution <span class="docEmphasis">T<sub>N</sub></span> = <span class="docEmphasis">N</span> &ndash; 1 is immediate by induction. If the sizes sum to a value less than <span class="docEmphasis">N</span>, the proof that the number of calls is less than <span class="docEmphasis">N &ndash;</span> 1 follows the same inductive argument. We can prove analogous results under general conditions (see <a class="docLink" href="#ch05qa2q5">Exercise 5.20</a>).</p>
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch05ex06">Program 5.6</a> is representative of many divide-and-conquer algorithms with precisely the same recursive structure, but other examples may differ in two primary respects. First, <a class="docLink" href="#ch05ex06">Program 5.6</a> does a constant amount of work on each function call, so its total running time is linear. Other divide-and-conquer algorithms may perform more work <a name="iddle1375"></a><a name="iddle1380"></a><a name="iddle1382"></a><a name="iddle1558"></a><a name="iddle2294"></a><a name="iddle2540"></a>on each function call, as we shall see, so determining the total running time requires more intricate analysis. The running time of such algorithms depends on the precise manner of division into parts. Second, <a class="docLink" href="#ch05ex06">Program 5.6</a> is representative of divide-and-conquer algorithms for which the parts sum to make the whole. Other divide-and-conquer algorithms may divide into smaller parts that constitute less than the whole problem, or overlapping parts that total up to more than the whole problem. These algorithms are still proper recursive algorithms because <span class="docEmphasis">each</span> part is smaller than the whole, but analyzing them is more difficult than analyzing <a class="docLink" href="#ch05ex06">Program 5.6</a>. We shall consider the analysis of these different types of algorithms in detail as we encounter them.</p>
<p class="docText">For example, the binary-search algorithm that we studied in <a class="docLink" href="ch02lev1sec6.html#ch02lev1sec6">Section 2.6</a> is a divide-and-conquer algorithm that divides a problem in half, then works on just one of the halves. We examine a recursive implementation of binary search in <a class="docLink" href="ch12.html#ch12">Chapter 12</a>.</p>
<p class="docText"><a class="docLink" href="#ch05fig05">Figure 5.5</a> indicates the contents of the internal stack maintained by the programming environment to support the computation in <a class="docLink" href="#ch05fig04">Figure 5.4</a>. The model depicted in the figure is idealistic, but it gives useful insights into the structure of the divide-and-conquer computation. If a program has two recursive calls, the actual internal stack contains one entry corresponding to the first function call while that function is being executed (which contains values of arguments, local variables, and a return address), then a similar entry corresponding to the second function call while that function is being executed. The alternative that is depicted in <a class="docLink" href="#ch05fig05">Figure 5.5</a> is to put the two entries on the stack at once, keeping all the subtasks remaining to be done explicitly on the stack. This arrangement plainly delineates the computation, and sets the stage for more general computational schemes, such as those that we examine in <a class="docLink" href="ch05lev1sec6.html#ch05lev1sec6">Sections 5.6</a> and <a class="docLink" href="ch05lev1sec8.html#ch05lev1sec8">5.8</a>.</p>
<a name="ch05fig05"></a><p><center>
<h5 class="docFigureTitle">Figure 5.5. Example of internal stack dynamics</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence is an idealistic representation of the contents of the internal stack during the sample computation of <a class="docLink" href="#ch05fig04">Figure 5.4</a>. We start with the left and right indices of the whole subarray on the stack. Each line depicts the result of popping two indices and, if they are not equal, pushing four indices, which delimit the left subarray and the right subarray after the popped subarray is divided into two parts. In practice, the system keeps return addresses and local variables on the stack, instead of this specific representation of the work to be done, but this model suffices to describe the computation.</p>
<p class="docText">
<img border="0" alt="" width="175" height="254" src="05fig05.gif" /></p>
<br />
<p class="docText"><a class="docLink" href="#ch05fig06">Figure 5.6</a> depicts the structure of the divide-and-conquer find-the-maximum computation. It is a recursive structure: the node at the top contains the size of the input array, the structure for the left subarray is drawn at the left and the structure for the right subarray is drawn at the right. We will formally define and discuss tree structures of this type in <a class="docLink" href="ch05lev1sec4.html#ch05lev1sec4">Sections 5.4</a> and <a class="docLink" href="ch05lev1sec5.html#ch05lev1sec5">5.5</a>. They are useful for understanding the structure of any program involving nested function calls&mdash;recursive programs in particular. Also shown in <a class="docLink" href="#ch05fig06">Figure 5.6</a> is the same tree, but with each node labeled with the return value for the corresponding <a name="iddle1381"></a><a name="iddle2266"></a><a name="iddle2526"></a>function call. In <a class="docLink" href="ch05lev1sec7.html#ch05lev1sec7">Section 5.7</a>, we shall consider the process of building explicit linked structures that represent trees like this one.</p>
<a name="ch05fig06"></a><p><center>
<h5 class="docFigureTitle">Figure 5.6. Recursive structure of find-the-maximum algorithm</h5>
<h5></h5><h5></h5></center></p><p class="docText">The divide-and-conquer algorithm splits a problem of size 11 into one of size 6 and one of size 5, a problem of size 6 into two problems of size 3, and so forth, until reaching problems of size 1 (<span class="docEmphasis">top</span>). Each circle in these diagrams represents a call on the recursive function, to the nodes just below connected to it by lines (squares are those calls for which the recursion terminates). The diagram in the middle shows the value of the index into the middle of the file that we use to effect the split; the diagram at the bottom shows the return value.</p>
<p class="docText">
<img border="0" alt="" width="200" height="357" src="05fig06.gif" /></p>
<br />
<p class="docText">No discussion of recursion would be complete without the ancient <span class="docEmphasis">towers of Hanoi</span> problem. We have three pegs and <span class="docEmphasis">N</span> disks that fit onto the pegs. The disks differ in size, and are initially arranged on one of the pegs, in order from largest (disk <span class="docEmphasis">N</span>) at the bottom to smallest (disk <span class="docEmphasis">1</span>) at the top. The task is to move the stack of disks to the right one position (peg), while obeying the following rules: (<span class="docEmphasis">i</span>) only one disk may be shifted at a time; and (<span class="docEmphasis">ii</span>) no disk may be placed on top of a smaller one. One legend says that the world will end when a certain group of monks accomplishes this task in a temple with 40 golden disks on three diamond pegs.</p>
<p class="docText"><a class="docLink" href="#ch05ex09">Program 5.7</a> gives a recursive solution to the problem. It specifies which disk should be shifted at each step, and in which direction (+ means move one peg to the right, cycling to the leftmost peg when on the rightmost peg; and - means move one peg to the left, cycling to the rightmost peg when on the leftmost peg). The recursion is based on the following idea: To move <span class="docEmphasis">N</span> disks one peg to the right, we first move the top <span class="docEmphasis">N</span> &ndash; 1 disks one peg to the left, then shift disk <span class="docEmphasis">N</span> one peg to the right, then move the <span class="docEmphasis">N</span> &ndash; 1 disks one more peg to the left (onto disk <span class="docEmphasis">N</span>). We can verify that this solution works by induction. <a class="docLink" href="#ch05fig07">Figure 5.7</a> shows the moves for <span class="docEmphasis">N</span> = 5 and the recursive calls for <span class="docEmphasis">N</span> = 3. An underlying pattern is evident, which we now consider in detail.</p>
<a name="ch05fig07"></a><p><center>
<h5 class="docFigureTitle">Figure 5.7. Towers of Hanoi</h5>
<h5></h5><h5></h5></center></p><p class="docText">This diagram depicts the solution to the towers of Hanoi problem for five disks. We shift the top four disks left one position (<span class="docEmphasis">left column</span>), then move disk 5 to the right, then shift the top four disks left one position <span class="docEmphasis">(right column)</span>. The sequence of function calls that follows constitutes the computation for three disks. The computed sequence of moves is <span class="docEmphasis"><tt>+1 -2 +1 +3 +1 -2 +1</tt></span>, which appears four times in the solution (for example, the first seven moves).</p><p class="docText"><div class="v1"><a target="_blank" href="05fig07_alt.gif">[View full size image]</a></div><img border="0" alt="" width="500" height="592" src="05fig07.gif" /></p><br />
<p class="docText">First, the recursive structure of this solution immediately tells us the number of moves that the solution requires.</p>
<a name="ch05ex08"></a><h5 id="title-IDAV3XRE" class="docExampleTitle">Property 5.2. <span class="docEmphasis">The recursive divide-and-conquer algorithm for the towers of Hanoi problem produces a solution that has</span> <span class="docEmphRoman">2<sup><span class="docEmphasis">N</span></sup> &ndash; 1</span> <span class="docEmphasis">moves</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">As usual, it is immediate from the code that the number of moves satisfies a recurrence. In this case, the recurrence satisfied by the number of disk moves is similar to Formula 2.5:</p>
<div class="docText"><pre><span class="docEmphasis">T<sub>N</sub></span> = 2<span class="docEmphasis">T</span><span class="docEmphasis"><sub>N &ndash; 1</sub></span> + 1, for <span class="docEmphasis">N</span> <img src="U2265.GIF" border="0" /> 2 with <span class="docEmphasis">T</span><sub>1</sub> = 1.</pre></div><br />
<p class="docText">We can verify the stated result directly by induction: we have <span class="docEmphasis"><tt>T</tt></span><tt>(1) = 2<sup>1</sup></tt> &ndash; <tt>1 = 1;</tt> and, if <span class="docEmphasis"><tt>T(k)</tt></span> <tt>= 2</tt><span class="docEmphasis"><tt><sup>k</sup></tt></span> &ndash; <tt>1</tt> for <span class="docEmphasis"><tt>k</tt></span> &lt; <span class="docEmphasis"><tt>N</tt></span>, then <span class="docEmphasis"><tt>T(N)</tt></span> <tt>= 2(2</tt><sup><span class="docEmphasis"><tt>N</tt></span></sup> <tt><sup>&ndash; 1</sup> &ndash; 1) + 1 = 2</tt><sup><span class="docEmphasis"><tt>N</tt></span></sup> &ndash; <tt>1</tt>.</p>
</td></tr></table></p>
<p class="docText">If the monks are moving disks at the rate of one per second, it will take at least 348 centuries for them to finish (see <a class="docLink" href="ch02lev1sec3.html#ch02fig01">Figure 2.1</a>), <a name="iddle1372"></a><a name="iddle2240"></a>assuming that they do not make a mistake. The end of the world is likely be even further off than that because those monks presumably never have had the benefit of being able to use <a class="docLink" href="#ch05ex09">Program 5.7</a>, and might not be able to figure out so quickly which disk to move next. We now consider an analysis of the method that leads to a simple (nonrecursive) method that makes the decision easy. While we may not wish to let the monks in on the secret, it is relevant to numerous important practical algorithms.</p>
<a name="ch05ex09"></a><h5 id="title-IDASBYRE" class="docExampleTitle">Program 5.7. Solution to the towers of Hanoi</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We shift the tower of disks to the right by (recursively) shifting all but the bottom disk to the left, then shifting the bottom disk to the right, then (recursively) shifting the tower back onto the bottom disk.</p>
<div class="docText"><pre>void hanoi(int N, int d)
  {
    if (N == 0) return;
    hanoi(N-1, -d);
    shift(N, d);
    hanoi(N-1, -d);
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">To understand the towers of Hanoi solution, let us consider the simple task of drawing the markings on a ruler. Each inch on the ruler has a mark at the <tt>1/2</tt> inch point, slightly shorter marks at <tt>1/4</tt> inch intervals, still shorter marks at <tt>1/8</tt> inch intervals, and so forth. Our task is to write a program to draw these marks at any given resolution, assuming that we have at our disposal a procedure <tt>mark(x, h)</tt> to make a mark <tt>h</tt> units high at position <tt>x</tt>.</p>
<p class="docText">If the desired resolution is <tt>1/2<sup><span class="docEmphasis">n</span></sup></tt> inches, we rescale so that our task is to put a mark at every point between 0 and 2<sup><span class="docEmphasis">n</span></sup>, endpoints not included. Thus, the middle mark should be <span class="docEmphasis">n</span> units high, the marks in the middle of the left and right halves should be <span class="docEmphasis">n</span> &ndash; 1 units high, and so forth. <a class="docLink" href="#ch05ex10">Program 5.8</a> is a straightforward divide-and-conquer algorithm to accomplish this objective; <a class="docLink" href="#ch05fig08">Figure 5.8</a> illustrates it in operation on a small example. Recursively speaking, the idea behind the method is the following. To make the marks in an interval, we first divide the interval into two equal halves. Then, we make the (shorter) marks in the left half (recursively), the long mark in the middle, and the (shorter) <a name="iddle2542"></a>marks in the right half (recursively). Iteratively speaking, <a class="docLink" href="#ch05fig08">Figure 5.8</a> illustrates that the method makes the marks in order, from left to right&mdash;the trick lies in computing the lengths. The recursion tree in the figure helps us to understand the computation: Reading down, we see that the length of the mark decreases by 1 for each recursive function call. Reading across, we get the marks in the order that they are drawn, because, for any given node, we first draw the marks associated with the function call on the left, then the mark associated with the node, then the marks associated with the function call on the right.</p>
<a name="ch05fig08"></a><p><center>
<h5 class="docFigureTitle">Figure 5.8. Ruler-drawing function calls</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence of function calls constitutes the computation for drawing a ruler of length 8, resulting in marks of lengths 1, 2, 1, 3, 1, 2, and 1.</p>
<p class="docText">
<img border="0" alt="" width="150" height="567" src="05fig08.gif" /></p>
<br />
<a name="ch05ex10"></a><h5 id="title-IDA3EYRE" class="docExampleTitle">Program 5.8. Divide and conquer to draw a ruler</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">To draw the marks on a ruler, we draw the marks on the left half, then draw the longest mark in the middle, then draw the marks on the right half. This program is intended to be used with <span class="docEmphasis">r &ndash; l</span> equal to a power of 2&mdash;a property that it preserves in its recursive calls (see <a class="docLink" href="#ch05qa2q12">Exercise 5.27</a>).</p>
<div class="docText"><pre>void rule(int l, int r, int h)
  { int m = (l+r)/2;
    if (h &gt; 0)
      {
        rule(l, m, h-1);
        mark(m, h);
        rule(m, r, h-1);
      }
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">We see immediately that the sequence of lengths is precisely the same as the sequence of disks moved for the towers of Hanoi problem. Indeed, a simple proof that they are identical is that the recursive programs are the same. Put another way, our monks could use the marks on a ruler to decide which disk to move.</p>
<p class="docText">Moreover, both the towers of Hanoi solution in <a class="docLink" href="#ch05ex09">Program 5.7</a> and the ruler-drawing program in <a class="docLink" href="#ch05ex10">Program 5.8</a> are variants of the basic divide-and-conquer scheme exemplified by <a class="docLink" href="#ch05ex06">Program 5.6</a>. All three solve a problem of size 2<span class="docEmphasis"><sup>n</sup></span> by dividing it into two problems of size 2<span class="docEmphasis"><sup>n &ndash; 1</sup></span>. For finding the maximum, we have a linear-time solution in the size of the input; for drawing a ruler and for solving the towers of Hanoi, we have a linear-time solution in the size of the output. For the towers of Hanoi, we normally think of the solution as being <span class="docEmphasis">exponential</span> time, because we measure the size of the problem in terms of the number of disks, <span class="docEmphasis">n</span>.</p>
<p class="docText">It is easy to draw the marks on a ruler with a recursive program, but is there some simpler way to compute the length of the <span class="docEmphasis">i</span>th mark, for any given <span class="docEmphasis">i</span>? <a class="docLink" href="#ch05fig09">Figure 5.9</a> shows yet another simple computational process that provides the answer to this question. The <span class="docEmphasis">i</span>th number printed out by both the towers of Hanoi program and the ruler program is nothing other than the number of trailing 0 bits in the binary representation of <span class="docEmphasis">i</span>. We can prove this property by induction by correspondence with a divide-and-conquer formulation for the process of printing the table of <span class="docEmphasis">n</span>-bit numbers: Print the table of (<span class="docEmphasis">n</span> &ndash; 1)-bit numbers, each preceded by a 0 bit, then print the table of (<span class="docEmphasis">n</span> &ndash; 1)-bit numbers each preceded by a 1-bit (see <a class="docLink" href="#ch05qa2q10">Exercise 5.25</a>).</p>
<a name="ch05fig09"></a><p><center>
<h5 class="docFigureTitle">Figure 5.9. Binary counting and the ruler function</h5>
<h5></h5><h5></h5></center></p><p class="docText">Computing the ruler function is equivalent to counting the number of trailing zeros in the even N-bit numbers.</p>
<p class="docText">
<img border="0" alt="" width="100" height="483" src="05fig09.gif" /></p>
<br />
<p class="docText">For the towers of Hanoi problem, the implication of the correspondence with <span class="docEmphasis">n</span>-bit numbers is a simple algorithm for the task. We can move the pile one peg to the right by iterating the following two steps until done:</p>
<a name="ch05pro01"></a>
<table border="0" class="docText"><tr><td width="25" valign="top"><div class="docText"><b>1. </b></div></td><td><div class="docText">Move the small disk to the right if <span class="docEmphasis">n</span> is odd (left if <span class="docEmphasis">n</span> is even).<br /><br /></div></td></tr><tr><td width="25" valign="top"><div class="docText"><b>1. </b></div></td><td><div class="docText">Make the only legal move not involving the small disk.<br /><br /></div></td></tr></table>
<p class="docText">That is, after we move the small disk, the other two pegs contain two disks, one smaller than the other. The only legal move not involving the small disk is to move the smaller one onto the larger one. Every other move involves the small disk for the same reason that every other number is odd and that every other mark on the rule is the shortest. Perhaps our monks <span class="docEmphasis">do</span> know this secret, because it is hard to imagine how they might be deciding which moves to make otherwise.</p>
<p class="docText">A formal proof by induction that every other move in the towers of Hanoi solution involves the small disk (beginning and ending with such moves) is instructive: For <span class="docEmphasis">n</span> = 1, there is just one move, involving the small disk, so the property holds. For <span class="docEmphasis">n</span> &gt; 1, the assumption that the property holds for <span class="docEmphasis">n</span> &ndash; 1 implies that it holds for n by the recursive construction: The first solution for <span class="docEmphasis">n</span> &ndash; 1 begins with a small-disk move, and the second solution for <span class="docEmphasis">n</span> &ndash; 1 ends with a small-disk move, so the solution for <span class="docEmphasis">n</span> begins and ends with a small-disk move. We put a move not involving the small disk in between two moves that do involve the small disk (the move ending the first solution for <span class="docEmphasis">n</span> &ndash; 1 and the move beginning the second solution for <span class="docEmphasis">n</span> &ndash; 1), so the property that every other move involves the small disk is preserved.</p>
<p class="docText"></p><a name="ch05ex11"></a><h5 id="title-IDAMKYRE" class="docExampleTitle">Program 5.9. Nonrecursive program to draw a ruler</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1371"></a><a name="iddle2237"></a>In contrast to <a class="docLink" href="#ch05ex10">Program 5.8</a>, we can also draw a ruler by first drawing all the marks of length 1, then drawing all the marks of length 2, and so forth. The variable <span class="docEmphasis">t</span> carries the length of the marks and the variable <span class="docEmphasis">j</span> carries the number of marks in between two successive marks of length <span class="docEmphasis">t</span>. The outer <tt>for</tt> loop increments <span class="docEmphasis">t</span> and preserves the property <span class="docEmphasis">j</span> = 2<span class="docEmphasis"><sup>t&ndash;1</sup></span>. The inner <tt>for</tt> loop draws all the marks of length <span class="docEmphasis">t</span>.</p>
<div class="docText"><pre>void rule(int l, int r, int h)
  {
    for (int t = 1, j = 1; t &lt;= h; j += j, t++)
      for (int i = 0; l+j+i &lt;= r; i += j+j)
        mark(l+j+i, t);
  }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch05ex11">Program 5.9</a> is an alternate way to draw a ruler that is inspired by the correspondence to binary numbers (see <a class="docLink" href="#ch05fig10">Figure 5.10</a>). We refer to this version of the algorithm as a <span class="docEmphasis">bottom-up</span> implementation. It is not recursive, but it is certainly suggested by the recursive algorithm. This correspondence between divide-and-conquer algorithms and the binary representations of numbers often provides insights for analysis and development of improved versions, such as bottom-up approaches. We consider this perspective to understand, and possibly to improve, each of the divide-and-conquer algorithms that we examine.</p>
<a name="ch05fig10"></a><p><center>
<h5 class="docFigureTitle">Figure 5.10. Drawing a ruler in bottom-up order</h5>
<h5></h5><h5></h5></center></p><p class="docText">To draw a ruler nonrecursively, we alternate drawing marks of length 1 and skipping positions, then alternate drawing marks of length 2 and skipping remaining positions, then alternate drawing marks of length 3 and skipping remaining positions, and so forth.</p>
<p class="docText">
<img border="0" alt="" width="150" height="112" src="05fig10.gif" /></p>
<br />
<p class="docText">The bottom-up approach involves rearranging the <span class="docEmphasis">order</span> of the computation when we are drawing a ruler. <a class="docLink" href="#ch05fig11">Figure 5.11</a> shows another example, where we rearrange the order of the three function calls in the recursive implementation. It reflects the recursive computation in the way that we first described it: Draw the middle mark, then draw the left half, then draw the right half. The pattern of drawing the marks is complex, but is the result of simply exchanging two statements in <a class="docLink" href="#ch05ex10">Program 5.8</a>. As we shall see in <a class="docLink" href="ch05lev1sec6.html#ch05lev1sec6">Section 5.6</a>, the relationship between <a class="docLink" href="#ch05fig08">Figures 5.8</a> and <a class="docLink" href="#ch05fig11">5.11</a> is akin to the distinction between postfix and prefix in arithmetic expressions.</p>
<a name="ch05fig11"></a><p><center>
<h5 class="docFigureTitle">Figure 5.11. Ruler-drawing function calls (preorder version)</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence indicates the result of drawing marks before the recursive calls, instead of in between them.</p>
<p class="docText">
<img border="0" alt="" width="165" height="621" src="05fig11.gif" /></p>
<br />
<p class="docText">Drawing the marks in order as in <a class="docLink" href="#ch05fig08">Figure 5.8</a> might be preferable to doing the rearranged computations contained in <a class="docLink" href="#ch05ex11">Program 5.9</a> and indicated in <a class="docLink" href="#ch05fig11">Figure 5.11</a>, because we can draw an arbitrarily long ruler, if we imagine a drawing device that simply moves on to the <a name="iddle1284"></a><a name="iddle1374"></a><a name="iddle1506"></a><a name="iddle1748"></a><a name="iddle2246"></a>next mark in a continuous scroll. Similarly, to solve the towers of Hanoi problem, we are constrained to produce the sequence of disk moves in the order that they are to be performed. In general, many recursive programs depend on the subproblems being solved in a particular order. For other computations (see, for example, <a class="docLink" href="#ch05ex06">Program 5.6</a>), the order in which we solve the subproblems is irrelevant. For such computations, the only constraint is that we must solve the subproblems before we can solve the main problem. Understanding when we have the flexibility to reorder the computation not only is a secret to success in algorithm design, but also has direct practical effects in many contexts. For example, this matter is critical when we consider implementing algorithms on parallel processors.</p>
<p class="docText">The bottom-up approach corresponds to the general method of algorithm design where we solve a problem by first solving trivial subproblems, then combining those solutions to solve slightly bigger subproblems, and so forth, until the whole problem is solved. This approach might be called <span class="docEmphasis">combine and conquer</span>.</p>
<p class="docText">It is a small step from drawing rulers to drawing two-dimensional patterns such as <a class="docLink" href="#ch05fig12">Figure 5.12</a>. This figure illustrates how a simple recursive description can lead to a computation that appears to be complex (see <a class="docLink" href="#ch05qa2q15">Exercise 5.30</a>).</p>
<a name="ch05fig12"></a><p><center>
<h5 class="docFigureTitle">Figure 5.12. Two-dimensional fractal star</h5>
<h5></h5><h5></h5></center></p><p class="docText">This fractal is a two-dimensional version of <a class="docLink" href="#ch05fig10">Figure 5.10</a>. The outlined boxes in the bottom diagram highlight the recursive structure of the computation.</p>
<p class="docText">
<img border="0" alt="" width="65" height="344" src="05fig12.gif" /></p>
<br />
<p class="docText">Recursively defined geometric patterns such as <a class="docLink" href="#ch05fig12">Figure 5.12</a> are sometimes called <span class="docEmphasis">fractals</span>. If more complicated drawing primitives are used, and more complicated recursive invocations are involved (especially including recursively-defined functions on reals and in the complex plane), patterns of remarkable diversity and complexity can be developed. Another example, demonstrated in <a class="docLink" href="#ch05fig13">Figure 5.13</a>, is the <span class="docEmphasis">Koch star</span>, which is defined recursively as follows: A Koch star of order 0 is the simple <tt>hill</tt> example of <a class="docLink" href="ch04lev1sec3.html#ch04fig03">Figure 4.3</a>, and a Koch star of order <span class="docEmphasis">n</span> is a Koch star of order <span class="docEmphasis">n</span> &ndash; 1 with each line segment replaced by the star of order 0, scaled appropriately.</p>
<a name="ch05fig13"></a><p><center>
<h5 class="docFigureTitle">Figure 5.13. Recursive PostScript for Koch fractal</h5>
<h5></h5><h5></h5></center></p><p class="docText">This modification to the PostScript program of <a class="docLink" href="ch04lev1sec3.html#ch04fig03">Figure 4.3</a> transforms the output into a fractal (<span class="docEmphasis">see text</span>).</p>
<p class="docText">
<img border="0" alt="" width="185" height="626" src="05fig13.gif" /></p>
<br />
<p class="docText">Like the ruler-drawing and the towers of Hanoi solutions, these algorithms are linear in the number of steps, but that number is exponential in the maximum depth of the recursion (see <a class="docLink" href="#ch05qa2q14">Exercises 5.29</a> and <a class="docLink" href="#ch05qa2q18">5.33</a>). They also can be directly related to counting in an appropriate number system (see <a class="docLink" href="#ch05qa2q19">Exercise 5.34</a>).</p>
<p class="docText">The towers of Hanoi problem, ruler-drawing problem, and fractals are amusing; and the connection to binary numbers is surprising, <a name="iddle1144"></a><a name="iddle1369"></a><a name="iddle1379"></a><a name="iddle2317"></a>but our primary interest in all of these topics is that they provide us with insights in understanding the basic algorithm design paradigm of divide in half and solve one or both halves independently, which is perhaps the most important such technique that we consider in this book. <a class="docLink" href="#ch05table01">Table 5.1</a> includes details about binary search and mergesort, which not only are important and widely used practical algorithms, but also exemplify the divide-and-conquer algorithm design paradigm.</p>
<a name="ch05table01"></a><p><table cellspacing="0" frame="hsides" rules="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 5.1. Basic divide-and-conquer algorithms</h5></caption><colgroup align="left" span="3"><col width="200"></col><col width="150"></col><col width="150"></col></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top" colspan="3"><p class="docText">Binary search (see <a class="docLink" href="ch02.html#ch02">Chapters 2</a> and <a class="docLink" href="ch12.html#ch12">12</a>) and mergesort (see <a class="docLink" href="ch08.html#ch08">Chapter 8</a>) are prototypical divide-and-conquer algorithms that provide guaranteed optimal performance for searching and sorting, respectively. The recurrences indicate the nature of the divide-and-conquer computation for each algorithm. (See <a class="docLink" href="ch02lev1sec5.html#ch02lev1sec5">Sections 2.5</a> and <a class="docLink" href="ch02lev1sec6.html#ch02lev1sec6">2.6</a> for derivations of the solutions in the rightmost column.) Binary search splits a problem in half, does 1 comparison, then makes a recursive call for one of the halves. Merge-sort splits a problem in half, then works on both halves recursively, then does <span class="docEmphasis">N</span> comparisons. Throughout the book, we shall consider numerous other algorithms developed with these recursive schemes.</p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="center" valign="bottom"><p class="docText">recurrence</p></td><td class="docTableCell" align="center" valign="bottom"><p class="docText">approximate solution</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">binary search</p></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">comparisons</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">C<sub>N</sub> = C<sub>N/2</sub></span> + 1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">mergesort</p></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">recursive calls</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">A<sub>N</sub> = 2A<sub>N/2</sub></span> + 1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">comparisons</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">C<sub>N</sub> = 2C<sub>N/2</sub></span> + N</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span> lg <span class="docEmphasis">N</span></p></td></tr></table></p><br />
<p class="docText">Quicksort (see <a class="docLink" href="ch07.html#ch07">Chapter 7</a>) and binary-tree search (see <a class="docLink" href="ch12.html#ch12">Chapter 12</a>) represent a significant variation on the basic divide-and-conquer theme where the problem is split into subproblems of size <span class="docEmphasis">k</span> &ndash; <span class="docEmphasis">1</span> and <span class="docEmphasis">N</span> &ndash; <span class="docEmphasis">k</span>, for some value <span class="docEmphasis">k</span>, which is determined by the input. For random input, these algorithms divide a problem into subproblems that are half the size (as in mergesort or in binary search) <span class="docEmphasis">on the average</span>. We study the analysis of the effects of this difference when we discuss these algorithms.</p>
<p class="docText">Other variations on the basic theme that are worthy of consideration include these: divide into parts of varying size, divide into more than two parts, divide into overlapping parts, and do various amounts of work in the nonrecursive part of the algorithm. In general, divide-and-conquer algorithms involve doing work to split the input into pieces, or to merge the results of processing two independent solved portions of the input, or to help things along after half of the input has been processed. That is, there may be code before, after, or in between the two recursive calls. Naturally, such variations lead to algorithms more complicated than are binary search and mergesort, and are more difficult to analyze. We consider numerous examples in this book; we return to advanced applications and analysis in Part 8.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.16</span> Write a recursive program that finds the maximum element in an array, based on comparing the first element in the array against the maximum element in the rest of the array (computed recursively).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.17</span> Write a recursive program that finds the maximum element in a linked list.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.18</span> Modify the divide-and-conquer program for finding the maximum element in an array (<a class="docLink" href="#ch05ex06">Program 5.6</a>) to divide an array of size <span class="docEmphasis">N</span> into one part of size <span class="docEmphasis">k</span> = 2<sup><img src="U2308.GIF" border="0" />lg <span class="docEmphasis">N</span><img src="U2309.GIF" border="0" /> &ndash; 1</sup> and another of size <span class="docEmphasis">N</span> &ndash; <span class="docEmphasis">k</span> (so that the size of at least one of the parts is a power of 2).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.19</span> Draw the tree corresponding to the recursive calls that your program from <a class="docLink" href="#ch05qa2q3">Exercise 5.18</a> makes when the array size is 11.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q5"></a><b></b></td><td><p class="docText"><a name="iddle1145"></a><a name="iddle1370"></a><a name="iddle1376"></a><a name="iddle1749"></a><a name="iddle2318"></a><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">5.20</span> Prove by induction that the number of function calls made by any divide-and-conquer algorithm that divides a problem into parts that constitute the whole, then solves the parts recursively, is linear.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">5.21</span> Prove that the recursive solution to the towers of Hanoi problem (<a class="docLink" href="#ch05ex09">Program 5.7</a>) is optimal. That is, show that any solution <span class="docEmphasis">requires</span> at least 2<span class="docEmphasis"><sup>N</sup></span>&ndash;1 moves.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">5.22</span> Write a recursive program that computes the length of the <span class="docEmphasis">i</span>th mark in a ruler with 2<span class="docEmphasis"><sup>n</sup></span>&ndash;1 marks.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">5.23</span> Examine tables of <span class="docEmphasis">n</span>-bit numbers, such as <a class="docLink" href="#ch05fig09">Figure 5.9</a>, to discover a property of the <span class="docEmphasis">i</span>th number that determines the direction of the <span class="docEmphasis">i</span>th move (indicated by the sign bit in <a class="docLink" href="#ch05fig07">Figure 5.7</a>) for solving the towers of Hanoi problem.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.24</span> Write a program that produces a solution to the towers of Hanoi problem by filling in an array that holds all the moves, as in <a class="docLink" href="#ch05ex11">Program 5.9</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q10"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.25</span> Write a recursive program that fills in an <span class="docEmphasis">n</span>-by-<span class="docEmphasis">2<sup>n</sup></span> array with 0s and 1s such that the array represents all the <span class="docEmphasis">n</span>-bit binary numbers, as depicted in <a class="docLink" href="#ch05fig09">Figure 5.9</a>.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q11"></a><b></b></td><td><p class="docText"><a name="iddle1407"></a><a name="iddle2241"></a><span class="docEmphStrong">5.26</span> Draw the results of using the recursive ruler-drawing program (<a class="docLink" href="#ch05ex10">Program 5.8</a>) for these unintended values of the arguments: <tt>rule(0, 11, 4)</tt>, <tt>rule(4, 20, 4)</tt>, and <tt>rule(7, 30, 5)</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q12"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.27</span> Prove the following fact about the ruler-drawing program (<a class="docLink" href="#ch05ex10">Program 5.8</a>): If the difference between its first two arguments is a power of 2, then both of its recursive calls have this property also.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q13"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.28</span> Write a function that computes efficiently the number of trailing 0s in the binary representation of an integer.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q14"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.29</span> How many squares are there in <a class="docLink" href="#ch05fig12">Figure 5.12</a> (counting the ones that are covered up by bigger squares)?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q15"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.30</span> Write a recursive C++ program that outputs a PostScript program that draws the bottom diagram in <a class="docLink" href="#ch05fig12">Figure 5.12</a>, in the form of a list of function calls <tt>x y r box</tt>, which draws an <span class="docEmphasis">r</span>-by-<span class="docEmphasis">r</span> square at <span class="docEmphasis">(x,y)</span>. Implement <tt>box</tt> in PostScript (see <a class="docLink" href="ch04lev1sec3.html#ch04lev1sec3">Section 4.3</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q16"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.31</span> Write a bottom-up nonrecursive program (similar to <a class="docLink" href="#ch05ex11">Program 5.9</a>) that draws the bottom diagram in <a class="docLink" href="#ch05fig12">Figure 5.12</a>, in the manner described in <a class="docLink" href="#ch05qa2q15">Exercise 5.30</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q17"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">5.32</span> Write a PostScript program that draws the bottom diagram in <a class="docLink" href="#ch05fig12">Figure 5.12</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q18"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">5.33</span> How many line segments are there in a Koch star of order <span class="docEmphasis">n</span>?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q19"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">5.34</span> Drawing a Koch star of order <span class="docEmphasis">n</span> amounts to executing a sequence of commands of the form &quot;rotate <span class="docEmphasis">a</span> degrees, then draw a line segment of length 1/3<span class="docEmphasis"><sup>n</sup></span>.&quot; Find a correspondence with number systems that gives you a way to draw the star by incrementing a counter, then computing the angle <span class="docEmphasis">a</span> from the counter value.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q20"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">5.35</span> Modify the Koch star program in <a class="docLink" href="#ch05fig13">Figure 5.13</a> to produce a different fractal based on a five-line figure for order 0, defined by 1-unit moves east, north, east, south, and east, in that order (see <a class="docLink" href="ch04lev1sec3.html#ch04fig03">Figure 4.3</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa2q21"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.36</span> Write a recursive divide-and-conquer function to draw an approximation to a line segment in an integer coordinate space, given the endpoints. Assume that all coordinates are between 0 and <span class="docEmphasis">M</span>. <span class="docEmphasis">Hint</span>: First plot a point close to the middle.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch05lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch05lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>