<html><head><title>5.3. Dynamic Programming</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch05lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch05lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch05lev1sec3"></a>
<h3 id="title-IDALOP0D" class="docSection1Title">5.3. Dynamic Programming</h3>
<p class="docText">An essential characteristic of the divide-and-conquer algorithms that we considered in <a class="docLink" href="ch05lev1sec2.html#ch05lev1sec2">Section 5.2</a> is that they partition the problem into independent subproblems. When the subproblems are not independent, the situation is more complicated, primarily because direct recursive <a name="iddle1046"></a><a name="iddle1408"></a><a name="iddle1410"></a><a name="iddle1413"></a><a name="iddle1450"></a><a name="iddle1477"></a><a name="iddle1544"></a><a name="iddle2244"></a><a name="iddle2257"></a><a name="iddle2301"></a>implementations of even the simplest algorithms of this type can require unthinkable amounts of time. In this section, we consider a systematic technique for avoiding this pitfall in some cases.</p>
<p class="docText">For example, <a class="docLink" href="#ch05ex12">Program 5.10</a> is a direct recursive implementation of the recurrence that defines the Fibonacci numbers (see <a class="docLink" href="ch02lev1sec3.html#ch02lev1sec3">Section 2.3</a>). <span class="docEmphasis">Do not use this program</span>: It is spectacularly inefficient. Indeed, the number of recursive calls to compute <span class="docEmphasis">F<sub>N</sub></span> is exactly <span class="docEmphasis">F<sub>N+1</sub></span>. But <span class="docEmphasis">F<sub>N</sub></span> is about &#248;<span class="docEmphasis"><sup>N</sup></span>, where &#248; <img src="U2248.GIF" border="0" /> 1:618 is the golden ratio. The awful truth is that <a class="docLink" href="#ch05ex12">Program 5.10</a> is an <span class="docEmphasis">exponential-time</span> algorithm for this trivial computation. <a class="docLink" href="#ch05fig14">Figure 5.14</a>, which depicts the recursive calls for a small example, makes plain the amount of recomputation that is involved.</p>
<a name="ch05fig14"></a><p><center>
<h5 class="docFigureTitle">Figure 5.14. Structure of recursive algorithm for Fibonacci numbers</h5>
<h5></h5><h5></h5></center></p><p class="docText">The picture of the recursive calls needed to used to compute <span class="docEmphasis"><tt>F</tt></span><tt><sub>8</sub></tt> by the standard recursive algorithm illustrates how recursion with overlapping subproblems can lead to exponential costs. In this case, the second recursive call ignores the computations done during the first, which results in massive recomputation because the effect multiplies recursively. The recursive calls to compute <span class="docEmphasis"><tt>F</tt></span><tt><sub>6</sub> = 8</tt> (which are reflected in the right subtree of the root and the left subtree of the left subtree of the root) are listed below.</p>
<p class="docText">
<img border="0" alt="" width="125" height="435" src="05fig14a.jpg" /></p>
<br />
<p class="docText">By contrast, it is easy to compute the first <span class="docEmphasis">N</span> Fibonacci numbers in time proportional to <span class="docEmphasis">N</span>, using an array:</p>
<div class="docText"><pre>F[0] = 0; F[1] = 1;
for (i = 2; i &lt;= N; i++)
  F[i] = F[i-1] + F[i-2];</pre></div><br />
<p class="docText">The numbers grow exponentially, so the array is small&mdash;for example, <span class="docEmphasis"><tt>F</tt></span><tt><sub>45</sub> = 1836311903</tt> is the largest Fibonacci number that can be represented as a 32-bit integer, so an array of size 46 will do.</p>
<p class="docText">This technique gives us an immediate way to get numerical solutions for any recurrence relation. In the case of Fibonacci numbers, we can even dispense with the array, and keep track of just the previous two values (see <a class="docLink" href="#ch05qa3q1">Exercise 5.37</a>); for many other commonly encountered recurrences (see, for example, <a class="docLink" href="#ch05qa3q4">Exercise 5.40</a>), we need to maintain the array with all the known values.</p>
<p class="docText">A recurrence is a recursive function with integer values. Our discussion in the previous paragraph leads to the conclusion that we can evaluate any such function by computing all the function values in order starting at the smallest, using previously computed values at each step to compute the current value. We refer to this technique as <span class="docEmphasis">bottom-up dynamic programming</span>. It applies to any recursive computation, <span class="docEmphasis">provided</span> that we can afford to save all the previously computed values. It is an algorithm-design technique that has been used successfully for a wide range of problems. We have to pay attention to a simple technique that can improve the running time of an algorithm from exponential to linear!</p>
<p class="docText"><span class="docEmphasis">Top-down dynamic programming</span> is an even simpler view of the technique that allows us to execute recursive functions at the same cost <a name="iddle1411"></a><a name="iddle1743"></a><a name="iddle1858"></a><a name="iddle2249"></a>as (or less cost than) bottom-up dynamic programming, in an automatic way. We instrument the recursive program to save each value that it computes (as its final action), and to check the saved values to avoid recomputing any of them (as its first action). <a class="docLink" href="#ch05ex13">Program 5.11</a> is the mechanical transformation of <a class="docLink" href="#ch05ex12">Program 5.10</a> that reduces its running time to be linear via top-down dynamic programming. <a class="docLink" href="#ch05fig15">Figure 5.15</a> shows the drastic reduction in the number of recursive calls achieved by this simple automatic change. Top-down dynamic programming is also sometimes called <span class="docEmphasis">memoization</span>.</p>
<a name="ch05fig15"></a><p><center>
<h5 class="docFigureTitle">Figure 5.15. Top-down dynamic programming for computing Fibonacci numbers</h5>
<h5></h5><h5></h5></center></p><p class="docText">This picture of the recursive calls used to compute F<sub>8</sub> by the top-down dynamic programming implementation of the recursive algorithm illustrates how saving computed values cuts the cost from exponential (see <a class="docLink" href="#ch05fig14">Figure 5.14</a>) to linear.</p>
<p class="docText">
<img border="0" alt="" width="185" height="170" src="05fig15.gif" /></p>
<br />
<a name="ch05ex12"></a><h5 id="title-IDAUYP0D" class="docExampleTitle">Program 5.10. Fibonacci numbers (recursive implementation)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This program, although compact and elegant, is not usable because it takes exponential time to compute <span class="docEmphasis">F<sub>N</sub></span>. The running time to compute <span class="docEmphasis">F</span><sub><span class="docEmphasis">N</span>+1</sub> is &#248; <img src="U2248.GIF" border="0" /> 1.6 times as long as the running time to compute <span class="docEmphasis">F</span><span class="docEmphasis"><sub>N</sub></span>. For example, since &#248;<sup>9</sup> &gt; 60, if we notice that our computer takes about a second to compute <span class="docEmphasis">F<sub>N</sub></span>, we know that it will take more than a minute to compute <span class="docEmphasis">F</span><sub><span class="docEmphasis">N</span>+9</sub> and more than an hour to compute <span class="docEmphasis">F</span><sub><span class="docEmphasis">N</span>+18</sub>.</p>
<div class="docText"><pre>int F(int i)
  {
    if (i &lt; 1) return 0;
    if (i == 1) return 1;
    return F(i-1) + F(i-2);
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">For a more complicated example, consider the <span class="docEmphasis">knapsack problem</span>: A thief robbing a safe finds it filled with <span class="docEmphasis">N</span> types of items of varying size and value, but has only a small knapsack of capacity <span class="docEmphasis">M</span> to use to carry the goods. The knapsack problem is to find the combination of items which the thief should choose for the knapsack in order to maximize the total value of all the stolen items. For example, with the item types depicted in <a class="docLink" href="#ch05fig16">Figure 5.16</a>, a thief with a knapsack of size 17 can take five A's (but not six) for a total take of 20, or a D and an E for a total take of 24, or one of many other combinations. Our goal is to find an efficient algorithm that somehow finds the maximum among all the possibilities, given any set of items and knapsack capacity.</p>
<a name="ch05fig16"></a><p><center>
<h5 class="docFigureTitle">Figure 5.16. Knapsack example</h5>
<h5></h5><h5></h5></center></p><p class="docText">An instance of the knapsack problem <span class="docEmphasis">(top)</span> consists of a knapsack capacity and a set of items of varying size (horizontal dimension) and value (vertical dimension). This figure shows four different ways to fill a knapsack of size 17, two of which lead to the highest possible total value of 24.</p>
<p class="docText">
<img border="0" alt="" width="185" height="501" src="05fig16.gif" /></p>
<br />
<p class="docText">There are many applications in which solutions to the knapsack problem are important. For example, a shipping company might wish to know the best way to load a truck or cargo plane with items for shipment. In such applications, other variants to the problem might arise as well: for example, there might be a limited number of each kind of item available, or there might be two trucks. Many such variants can be handled with the same approach that we are about to examine for solving the basic problem just stated; others turn out to be much more difficult. There is a fine line between feasible and infeasible problems of this type, which we shall examine in Part 8.</p>
<p class="docText">
<img border="0" alt="" width="500" height="142" src="05fig14.gif" /></p>
<p class="docText">In a recursive solution to the knapsack problem, each time that we choose an item, we assume that we can (recursively) find an optimal way to pack the rest of the knapsack. For a knapsack of size <tt>cap</tt>, we determine, for each item <tt>i</tt> among the available item types, what total value we could carry by placing <tt>i</tt> in the knapsack with an optimal packing of other items around it. That optimal packing is simply the one we have discovered (or will discover) for the smaller knapsack of size <tt>cap-items[i].size</tt>. This solution exploits the principle that optimal decisions, once made, do not need to be changed. Once we know how to pack knapsacks of smaller capacities with optimal sets of items, we do not need to reexamine those problems, regardless of what the next items are.</p>
<p class="docText"><a class="docLink" href="#ch05ex15">Program 5.12</a> is a direct recursive solution based on this discussion. Again, this program is not feasible for use in solving actual problems, because it takes exponential time due to massive recomputation (see <a class="docLink" href="#ch05fig17">Figure 5.17</a>), but we can automatically apply top-down dynamic programming to eliminate this problem, as shown in <a class="docLink" href="#ch05ex16">Program 5.13</a>. As before, this technique eliminates all recomputation, as shown in <a class="docLink" href="#ch05fig18">Figure 5.18</a>.</p>
<a name="ch05fig17"></a><p><center>
<h5 class="docFigureTitle">Figure 5.17. Recursive structure of knapsack algorithm</h5>
<h5></h5><h5></h5></center></p><p class="docText">This tree represents the recursive call structure of the simple recursive knapsack algorithm in <a class="docLink" href="#ch05ex15">Program 5.12</a>. The number in each node represents the remaining capacity in the knapsack. The algorithm suffers the same basic problem of exponential performance due to massive recomputation for overlapping subproblems that we considered in computing Fibonacci numbers (see <a class="docLink" href="#ch05fig14">Figure 5.14</a>).</p><p class="docText"><div class="v1"><a target="_blank" href="05fig17_alt.gif">[View full size image]</a></div><img border="0" alt="" width="500" height="68" src="05fig17.gif" /></p><br />
<a name="ch05fig18"></a><p><center>
<h5 class="docFigureTitle">Figure 5.18. Top-down dynamic programming for knapsack algorithm</h5>
<h5></h5><h5></h5></center></p><p class="docText">As it did for the Fibonacci numbers computation, the technique of saving known values reduces the cost of the knapsack algorithm from exponential (see <a class="docLink" href="#ch05fig17">Figure 5.17</a>) to linear.</p>
<p class="docText">
<img border="0" alt="" width="500" height="102" src="05fig18.gif" /></p>
<br />
<p class="docText">By design, dynamic programming eliminates all recomputation in <span class="docEmphasis">any</span> recursive program, subject only to the condition that we can <a name="iddle1409"></a><a name="iddle1412"></a><a name="iddle1535"></a><a name="iddle2261"></a><a name="iddle2296"></a>afford to save the values of the function for arguments smaller than the call in question.</p>
<a name="ch05ex13"></a><h5 id="title-IDAHBQ0D" class="docExampleTitle">Program 5.11. Fibonacci numbers (dynamic programming)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">By saving the values that we compute in a static array (whose entries are initialized to 0 in C++), we explicitly avoid any recomputation. This program computes <span class="docEmphasis">F<sub>N</sub></span> in time proportional to <span class="docEmphasis">N</span>, in stark contrast to the <span class="docEmphasis">O(&#248;<sup>N</sup>)</span> time used by <a class="docLink" href="#ch05ex12">Program 5.10</a>.</p>
<div class="docText"><pre>int F(int i)
{ static int knownF[maxN];
  if (knownF[i] != 0) return knownF[i];
  int t = i;
  if (i &lt; 0) return 0;
  if (i &gt; 1) t = F(i-1) + F(i-2);
  return knownF[i] = t;
}</pre></div><br />
</td></tr></table></p>
<a name="ch05ex14"></a><h5 id="title-IDAQCQ0D" class="docExampleTitle">Property 5.3. <span class="docEmphasis">Dynamic programming reduces the running time of a recursive function to be at most the time required to evaluate the function for all arguments less than or equal to the given argument, treating the cost of a recursive call as constant</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">See <a class="docLink" href="#ch05qa3q14">Exercise 5.50</a>.</p>
</td></tr></table></p>
<p class="docText">For the knapsack problem, this property implies that the running time is proportional to <span class="docEmphasis">NM</span>. Thus, we can solve the knapsack problem easily when the capacity is not huge; for huge capacities, the time and space requirements may be prohibitively large.</p>
<p class="docText">Bottom-up dynamic programming applies to the knapsack problem, as well. Indeed, we can use the bottom-up approach any time that we use the top-down approach, although we need to take care to ensure that we compute the function values in an appropriate order, so that each value that we need has been computed when we need it. For functions with single integer arguments such as the two that we have considered, we simply proceed in increasing order of the argument (see <a class="docLink" href="#ch05qa3q17">Exercise 5.53</a>); for more complicated recursive functions, determining a proper order can be a challenge.</p>
<p class="docText">For example, we do not need to restrict ourselves to recursive functions with single integer arguments. When we have a function <a name="iddle1414"></a>with multiple integer arguments, we can save solutions to smaller subproblems in multidimensional arrays, one for each argument. Other situations involve no integer arguments at all, but rather use an abstract discrete problem formulation that allows us to decompose problems into smaller ones. We shall consider examples of such problems in Parts 5 through 8.</p>
<a name="ch05ex15"></a><h5 id="title-IDAEEQ0D" class="docExampleTitle">Program 5.12. Knapsack problem (recursive implementation)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">As we warned about the recursive solution to the problem of computing the Fibonacci numbers, <span class="docEmphasis">do not use this program</span>, because it will take exponential time and therefore may not ever run to completion even for small problems. It does, however, represent a compact solution that we can improve easily (see <a class="docLink" href="#ch05ex16">Program 5.13</a>). This code assumes that items are structures with a size and a value, defined with</p>
<div class="docText"><pre>typedef struct { int size; int val; } Item;</pre></div><br />
<p class="docText">and that we have an array of <tt>N items</tt> of type <tt>Item</tt>. For each possible item, we calculate (recursively) the maximum value that we could achieve by including that item, then take the maximum of all those values.</p>
<div class="docText"><pre>int knap(int cap)
  { int i, space, max, t;
    for (i = 0, max = 0; i &lt; N; i++)
      if ((space = cap-items[i].size) &gt;= 0)
        if ((t = knap(space) + items[i].val) &gt; max)
          max = t;
    return max;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">In top-down dynamic programming, we save known values; in bottom-up dynamic programming, we precompute them. We generally prefer top-down to bottom-up dynamic programming, because</p>
<ul><li><p class="docList">It is a mechanical transformation of a natural problem solution.</p></li><li><p class="docList">The order of computing the subproblems takes care of itself.</p></li><li><p class="docList">We may not need to compute answers to all the subproblems.</p></li></ul>
<p class="docText">Dynamic-programming applications differ in the nature of the subproblems and in the amount of information that we need to save regarding the subproblems.</p>
<p class="docText">A crucial point that we cannot overlook is that dynamic programming becomes ineffective when the number of possible function <a name="iddle2547"></a>values that we might need is so high that we cannot afford to save (top-down) or precompute (bottom-up) all of them. For example, if <span class="docEmphasis">M</span> and the item sizes are 64-bit quantities or floating-point numbers in the knapsack problem, we will not be able to save values by indexing into an array. This distinction causes more than a minor annoyance&mdash;it poses a fundamental difficulty. No good solution is known for such problems; we will see in Part 8 that there is good reason to believe that no good solution exists.</p>
<p class="docText">Dynamic programming is an algorithm-design technique that is primarily suited for the advanced problems of the type that we shall consider in Parts 5 through 8. Most of the algorithms that we discuss in <a class="docLink" href="part02.html#part02">Parts 2</a> through <a class="docLink" href="part04.html#part04">4</a> are divide-and-conquer methods with nonover-lapping subproblems, and we are focusing on subquadratic or sub-linear, rather than subexponential, performance. However, top-down dynamic programming is a basic technique for developing efficient implementations of recursive algorithms that belongs in the toolbox of anyone engaged in algorithm design and implementation.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">5.37</span> Write a function that computes <span class="docEmphasis">F</span><sub><span class="docEmphasis">N</span></sub> mod <span class="docEmphasis">M</span>, using only a constant amount of space for intermediate calculations.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.38</span> What is the largest <span class="docEmphasis">N</span> for which <span class="docEmphasis">F</span><sub>N</sub> can be represented as a 64-bit integer?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.39</span> Draw the tree corresponding to <a class="docLink" href="#ch05fig15">Figure 5.15</a> for the case where we exchange the recursive calls in <a class="docLink" href="#ch05ex13">Program 5.11</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.40</span> Write a function that uses bottom-up dynamic programming to compute the value of <span class="docEmphasis">P</span><sub><span class="docEmphasis">N</span></sub> defined by the recurrence</p>
<p class="docText"><img border="0" alt="" width="495" height="21" src="228equ01.jpg" /></p>
<p class="docText">Draw a plot of <span class="docEmphasis">N</span> versus <span class="docEmphasis">P</span><sub><span class="docEmphasis">N</span></sub> &ndash; <span class="docEmphasis">N</span> lg <span class="docEmphasis">N</span>/2 for 0 <img src="U2264.GIF" border="0" /> <span class="docEmphasis">N</span> <img src="U2264.GIF" border="0" /> 1024.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.41</span> Write a function that uses top-down dynamic programming to solve <a class="docLink" href="#ch05qa3q4">Exercise 5.40</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.42</span> Draw the tree corresponding to <a class="docLink" href="#ch05fig15">Figure 5.15</a> for your function from <a class="docLink" href="#ch05qa3q5">Exercise 5.41</a>, when invoked for <span class="docEmphasis">N</span> = 23.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.43</span> Draw a plot of <span class="docEmphasis">N</span> versus the number of recursive calls that your function from <a class="docLink" href="#ch05qa3q5">Exercise 5.41</a> makes to compute <span class="docEmphasis">P</span><sub><span class="docEmphasis">N</span></sub>, for 0 <img src="U2264.GIF" border="0" /> <span class="docEmphasis">N</span> <img src="U2264.GIF" border="0" /> 1024. (For the purposes of this calculation, start your program from scratch for each <span class="docEmphasis">N</span>.)</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.44</span> Write a function that uses bottom-up dynamic programming to compute the value of <span class="docEmphasis">C</span><sub><span class="docEmphasis">N</span></sub> defined by the recurrence</p>
<p class="docText"><img border="0" alt="" width="400" height="39" src="229equ01.jpg" /></p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.45</span> Write a function that uses top-down dynamic programming to solve <a class="docLink" href="#ch05qa3q8">Exercise 5.44</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q10"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.46</span> Draw the tree corresponding to <a class="docLink" href="#ch05fig15">Figure 5.15</a> for your function from <a class="docLink" href="#ch05qa3q9">Exercise 5.45</a>, when invoked for <span class="docEmphasis">N</span> = 23.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q11"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.47</span> Draw a plot of <span class="docEmphasis">N</span> versus the number of recursive calls that your function from <a class="docLink" href="#ch05qa3q9">Exercise 5.45</a> makes to compute <span class="docEmphasis">C</span><sub><span class="docEmphasis">N</span></sub>, for 0 <img src="U2264.GIF" border="0" /> <span class="docEmphasis">N</span> <img src="U2264.GIF" border="0" /> 1024. (For the purposes of this calculation, start your program from scratch for each <span class="docEmphasis">N</span>.)</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q12"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">5.48</span> Give the contents of the arrays <tt>maxKnown</tt> and <tt>itemKnown</tt> that are computed by <a class="docLink" href="#ch05ex16">Program 5.13</a> for the call <tt>knap(17)</tt> with the items in <a class="docLink" href="#ch05fig16">Figure 5.16</a>.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q13"></a><b></b></td><td><p class="docText"><a name="iddle2534"></a><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">5.49</span> Give the tree corresponding to <a class="docLink" href="#ch05fig18">Figure 5.18</a> under the assumption that the items are considered in decreasing order of their size.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q14"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">5.50</span> Prove <a class="docLink" href="#ch05ex14">Property 5.3</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q15"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.51</span> Write a function that solves the knapsack problem using a bottom-up dynamic programming version of <a class="docLink" href="#ch05ex15">Program 5.12</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q16"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">5.52</span> Write a function that solves the knapsack problem using top-down dynamic programming, but using a recursive solution based on computing the optimal number of a particular item to include in the knapsack, based on (recursively) knowing the optimal way to pack the knapsack without that item.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q17"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.53</span> Write a function that solves the knapsack problem using a bottom-up dynamic programming version of the recursive solution described in <a class="docLink" href="#ch05qa3q16">Exercise 5.52</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q18"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">5.54</span> Use dynamic programming to solve <a class="docLink" href="ch05lev1sec1.html#ch05qa1q4">Exercise 5.4</a>. Keep track of the total number of function calls that you save.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa3q19"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.55</span> Write a program that uses top-down dynamic programming to compute the binomial coefficient <img border="0" alt="" width="24" height="23" src="230equ01.jpg" />, based on the recursive rule</p>
<p class="docText"><img border="0" alt="" width="175" height="35" src="230equ02.jpg" /></p>
<p class="docText">with <img border="0" alt="" width="127" height="26" src="230equ03.jpg" /></p></td></tr></table></p>
<a name="ch05ex16"></a><h5 id="title-IDA1XQ0D" class="docExampleTitle">Program 5.13. Knapsack problem (dynamic programming)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This mechanical modification to the code of <a class="docLink" href="#ch05ex15">Program 5.12</a> reduces the running time from exponential to linear. We simply save any function values that we compute, then retrieve any saved values whenever we need them (using a sentinel value to represent unknown values), rather than making recursive calls. We save the index of the item, so that we can reconstruct the contents of the knapsack after the computation, if we wish: <tt>itemKnown[M]</tt> is in the knapsack, the remaining contents are the same as for the optimal knapsack of size <tt>M-itemKnown[M].size</tt> so <tt>itemKnown[M-items[M].size]</tt> is in the knapsack, and so forth.</p>
<div class="docText"><pre>int knap(int M)
  { int i, space, max, maxi = 0, t;
    if (maxKnown[M] != unknown) return maxKnown[M];
    for (i = 0, max = 0; i &lt; N; i++)
      if ((space = M-items[i].size) &gt;= 0)
        if ((t = knap(space) + items[i].val) &gt; max)
          { max = t; maxi = i; }
    maxKnown[M] = max; itemKnown[M] = items[maxi];
    return max;
  }</pre></div><br />
</td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch05lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch05lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>