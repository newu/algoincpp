<html><head><title>10.1. Bits, Bytes, and Words</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch10.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch10lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch10lev1sec1"></a>
<h3 id="title-IDAXS42N" class="docSection1Title">10.1. Bits, Bytes, and Words</h3>
<p class="docText">The key to understanding radix sort is to recognize that (<span class="docEmphasis">i</span>) computers generally are built to process bits in groups called <span class="docEmphasis">machine words</span>, which are often grouped into smaller pieces call <span class="docEmphasis">bytes</span>; (<span class="docEmphasis">ii</span>) sort keys <span class="docEmphasis">also</span> are commonly organized as byte sequences; and (<span class="docEmphasis">iii</span>) small byte sequences can also serve as array indices or machine addresses. Therefore, it will be convenient for us to work with the following abstractions.</p>
<p class="docText"></p><a name="ch10ex01"></a><h5 id="title-IDAXT42N" class="docExampleTitle">Definition 10.1. A <span class="docEmphasis">byte</span> is a fixed-length sequence of bits; a <span class="docEmphasis">string</span> is a variable-length sequence of bytes; a <span class="docEmphasis">word</span> is a fixed-length sequence of bytes</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1230"></a><a name="iddle2460"></a>In radix sorting, depending on the context, a <span class="docEmphasis">key</span> may be a word or a string. Some of the radix-sorting algorithms that we consider in this chapter depend on the keys being fixed length (words); others are designed to adapt to the situation when the keys are variable length (strings).</p>
<p class="docText">A typical machine might have 8-bit bytes and 32- or 64-bit words (the actual values may be found in the header file <tt>&lt;limits.h&gt;</tt>), but it will be convenient for us to consider various other byte and word sizes as well (generally small integer multiples or fractions of built-in machine sizes). We use machine- and application-dependent defined constants for the number of bits per word and the number of bits per byte, for example:</p>
<div class="docText"><pre>const int bitsword = 32;
const int bitsbyte = 8;
const int bytesword = bitsword/bitsbyte;
const int R = 1 &lt;&lt; bitsbyte;</pre></div><br />
<p class="docText">Also included in these definitions for use when we begin looking at radix sorts is the constant <span class="docEmphasis">R</span>, the number of different byte values. When using these definitions, we generally assume that <tt>bitsword</tt> is a multiple of <tt>bitsbyte</tt>; that the number of bits per machine word is not less than (typically, is equal to) <tt>bitsword</tt>; and that bytes are individually addressable. Different computers have different conventions for referring to their bits and bytes; for the purposes of our discussion, we will consider the bits in a word to be numbered, left to right, from 0 to <tt>bitsword-1</tt>, and the bytes in a word to be numbered, left to right, from 0 to <tt>bytesword-1</tt>. In both cases, we assume the numbering to also be from most significant to least significant.</p>
<p class="docText">Most computers have bitwise <span class="docEmphasis">and</span> and <span class="docEmphasis">shift</span> operations, which we can use to extract bytes from words. In C++, we can directly express the operation of extracting the <span class="docEmphasis">B</span>th byte of a binary word <span class="docEmphasis">A</span> as follows:</p>
<div class="docText"><pre>inline int digit(long A, int B)
  { return (A &gt;&gt; bitsbyte*(bytesword-B-1)) &amp; (R-1); }</pre></div><br />
<p class="docText">For example, this macro would extract byte 2 (the third byte) of a 32-bit number by shifting right 32-3*8 = 8 bit positions, then using the mask <tt>00000000000000000000000011111111</tt> to zero out all the bits except those of the desired byte, in the 8 bits at the right.</p>
<p class="docText">Another option on many machines is to arrange things such that the radix is aligned with the byte size, and therefore a single access will get the right bits quickly. This operation is supported directly for C-style strings in C++:</p>
<div class="docText"><pre>inline int digit(char* A, int B)
  { return A[B]; }</pre></div><br />
<p class="docText">If we are using a <tt>struct</tt> wrapper as in <a class="docLink" href="ch06lev1sec8.html#ch06lev1sec8">Section 6.8</a>, we would write:</p>
<div class="docText"><pre>inline int digit(Item&amp; A, int B)
  { return A.str[B]; }</pre></div><br />
<p class="docText">This approach could be used for numbers as well, though differing number-representation schemes may make such code nonportable. In any case, we need to be aware that byte-access operations of this type might be implemented with underlying shift-and-mask operations similar to the ones in the previous paragraph in some computing environments.</p>
<p class="docText">At a slightly different level of abstraction, we can think of keys as numbers and bytes as digits. Given a (key represented as a) number, the fundamental operation needed for radix sorts is to extract a digit from the number. When we choose a radix that is a power of 2, the digits are groups of bits, which we can easily access directly using one of the macros just discussed. Indeed, the primary reason that we use radices that are powers of 2 is that the operation of accessing groups of bits is inexpensive. In some computing environments, we can use other radices, as well. For example, if <span class="docEmphasis">a</span> is a positive integer, the <span class="docEmphasis">b</span>th digit of the radix-<span class="docEmphasis">R</span> representation of <span class="docEmphasis">a</span> is</p>
<div class="docText"><pre><img src="U230A.GIF" border="0" /><span class="docEmphasis">a/R<sup>b</sup></span><img src="U230B.GIF" border="0" />mod <span class="docEmphasis">R</span>.</pre></div><br />
<p class="docText">On a machine built for high-performance numerical calculations, this computation might be as fast for general <span class="docEmphasis">R</span> as for <span class="docEmphasis">R</span> = 2.</p>
<p class="docText">Yet another viewpoint is to think of keys as numbers between 0 and 1 with an implicit decimal point at the left, as shown in <a class="docLink" href="ch10.html#ch10fig01">Figure 10.1</a>. In this case, the <span class="docEmphasis">b</span>th digit of <span class="docEmphasis">a</span> is</p>
<div class="docText"><pre><img src="U230A.GIF" border="0" /><span class="docEmphasis">aR<sup>b</sup></span><img src="U230B.GIF" border="0" />mod <span class="docEmphasis">R</span>.</pre></div><br />
<p class="docText">If we are using a machine where we can do such operations efficiently, then we can use them as the basis for our radix sort. This model applies when keys are variable length, such as character strings.</p>
<p class="docText">Thus, for the remainder of this chapter, we view keys as radix-<span class="docEmphasis">R</span> numbers (with <span class="docEmphasis">R</span> not specified), and use the abstract <tt>digit</tt> operation to access digits of keys, with confidence that we will be able to develop fast implementations of <tt>digit</tt> for particular computers.</p>
</td></tr></table></p>
<p class="docText">&nbsp;<a name="iddle1738"></a><a name="iddle2195"></a></p>
<a name="ch10ex02"></a><h5 id="title-IDAWKB3N" class="docExampleTitle">Definition 10.2. A <span class="docEmphStrong">key</span> is a radix- R number, with digits numbered from the left (starting at 0)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">In light of the examples that we just considered, it is safe for us to assume that this abstraction will admit efficient implementations for many applications on most computers, although we must be careful that a particular implementation is efficient within a given hardware and software environment.</p>
<p class="docText">We assume that the keys are not short, so it is worthwhile to extract their bits. If the keys are short, then we can use the key-indexed counting method of <a class="docLink" href="ch06.html#ch06">Chapter 6</a>. Recall that this method can sort <span class="docEmphasis">N</span> keys known to be integers between 0 and <span class="docEmphasis">R</span> - 1 in linear time, using one auxiliary table of size <span class="docEmphasis">R</span> for counts and another of size <span class="docEmphasis">N</span> for rearranging records. Thus, if we can afford a table of size 2 <span class="docEmphasis"><sup>w</sup></span>, then <span class="docEmphasis">w</span>-bit keys can easily be sorted in linear time. Indeed, key-indexed counting lies at the heart of the basic MSD and LSD radix-sorting methods. Radix sorting comes into play when the keys are sufficiently long (say <span class="docEmphasis">w</span> = 64) that using a table of size 2<span class="docEmphasis"><sup>w</sup></span> is not feasible.</p>
</td></tr></table></p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa1q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">10.1</span> How many digits are there when a 32-bit quantity is viewed as a radix-256 number? Describe how to extract each of the digits. Answer the same question for radix 2<sup>16</sup>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa1q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">10.2</span> For <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>6</sup>, and 10<sup>9</sup>, give the smallest byte size that allows any number between 0 and <span class="docEmphasis">N</span> to be represented in a 4-byte word.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa1q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">10.3</span> Overload <tt>operator&lt;</tt> using the <tt>digit</tt> abstraction (so that, for example, we could run empirical studies comparing the algorithms in <a class="docLink" href="ch06.html#ch06">Chapters 6</a> and <a class="docLink" href="ch09.html#ch09">9</a> with the methods in this chapter, using the same data).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa1q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">10.4</span> Design and carry out an experiment to compare the cost of extracting digits using bit-shifting and arithmetic operations on your machine. How many digits can you extract per second, using each of the two methods? <span class="docEmphasis">Note</span>: Be wary; your compiler might convert arithmetic operations to bit-shifting ones, or vice versa!</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa1q5"></a><b></b></td><td><p class="docText"><a name="iddle2192"></a><a name="iddle2210"></a><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">10.5</span> Write a program that, given a set of <span class="docEmphasis">N</span> random decimal numbers (<span class="docEmphasis">R</span> = 10) uniformly distributed between 0 and 1, will compute the number of digit comparisons necessary to sort them, in the sense illustrated in <a class="docLink" href="ch10.html#ch10fig01">Figure 10.1</a>. Run your program for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa1q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">10.6</span> Answer <a class="docLink" href="#ch10qa1q5">Exercise 10.5</a> for <span class="docEmphasis">R</span> = 2, using random 32-bit quantities.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa1q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">10.7</span> Answer <a class="docLink" href="#ch10qa1q5">Exercise 10.5</a> for the case where the numbers are distributed according to a Gaussian distribution.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch10.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch10lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>