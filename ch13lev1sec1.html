<html><head><title>13.1. Randomized BSTs</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch13.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch13lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch13lev1sec1"></a>
<h3 id="title-IDAUKW0D" class="docSection1Title">13.1. Randomized BSTs</h3>
<p class="docText"><a name="iddle1124"></a><a name="iddle1172"></a><a name="iddle1715"></a><a name="iddle2223"></a>To analyze the average-case performance costs for binary search trees, we made the assumption that the items are inserted in random order (see <a class="docLink" href="ch12lev1sec6.html#ch12lev1sec6">Section 12.6</a>). The primary consequence of this assumption in the context of the BST algorithm is that each node in the tree is equally likely to be the one at the root, and this property also holds for the subtrees. Remarkably, it is possible to introduce randomness into the algorithm so that this property holds without <span class="docEmphasis">any</span> assumptions about the order in which the items are inserted. The idea is simple: When we insert a new node into a tree of <span class="docEmphasis">N</span> nodes, the new node should appear at the root with probability <span class="docEmphasis">1/(N + 1)</span>, so we simply make a randomized decision to use root insertion with that probability. Otherwise, we recursively use the method to insert the new record into the left subtree if the record's key is less than the key at the root, and into the right subtree if the record's key is greater. <a class="docLink" href="#ch13ex03">Program 13.2</a> is an implementation of this method.</p>
<p class="docText">Viewed nonrecursively, doing randomized insertion is equivalent to performing a standard search for the key, making a randomized decision at every step whether to continue the search or to terminate it and do root insertion. Thus, the new node could be inserted anywhere on its search path, as illustrated in <a class="docLink" href="#ch13fig02">Figure 13.2</a>. This simple probabilistic combination of the standard BST algorithm with the root insertion method gives guaranteed performance in a probabilistic sense.</p>
<a name="ch13fig02"></a><p><center>
<h5 class="docFigureTitle">Figure 13.2. Insertion into a randomized BST</h5>
<h5></h5><h5></h5></center></p><p class="docText">The final position of a new record in a randomized BST may be anywhere on the record's search path, depending on the outcome of randomized decisions made during the search. This figure shows each of the possible final positions for a record with key <tt>F</tt> when the record is inserted into a sample tree <tt>(top)</tt>.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="185" height="440" src="13fig02.gif" /></p>
<br />
<a name="ch13ex02"></a><h5 id="title-IDABOW0D" class="docExampleTitle">Property 13.1. <span class="docEmphasis">Building a randomized BST is equivalent to building a standard BST from a random initial permutation of the keys. We use about 2N</span> <span class="docEmphRoman">ln</span> <span class="docEmphasis">N comparisons to construct a randomized BST with N items (no matter in what order the items are presented for insertion), and about 2</span> <span class="docEmphRoman">ln</span> <span class="docEmphasis">N comparisons for searches in such a tree</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Each element is equally likely to be the root of the tree, and this property holds for both subtrees, as well. The first part of this statement is true by construction, but a careful probabilistic argument is needed to show that the root insertion method preserves randomness in the subtrees (<span class="docEmphasis">see reference section</span>).</p>
</td></tr></table></p>
<p class="docText">The distinction between average-case performance for randomized BSTs and for standard BSTs is subtle, but essential. The average costs are the same (though the constant of proportionality is slightly <a name="iddle1179"></a><a name="iddle2278"></a>higher for randomized trees), but for standard trees the result depends on the <span class="docEmphasis">assumption</span> that the items are presented for insertion in a random ordering of their keys (all orderings equally likely). This assumption is not valid in many practical applications, and therefore the significance of the randomized algorithm is that it allows us to remove the assumption, and to depend instead on the laws of probability and randomness in the random-number generator. If the items are inserted with their keys in order, or in reverse order, or <span class="docEmphasis">any order whatever</span>, the BST will still be random.</p>
<a name="ch13ex03"></a><h5 id="title-IDAYPW0D" class="docExampleTitle">Program 13.2. Randomized BST insertion</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This function makes a randomized decision whether to use the root insertion method of <a class="docLink" href="ch12lev1sec8.html#ch12ex23">Program 12.13</a> or the standard insertion method of <a class="docLink" href="ch12lev1sec5.html#ch12ex15">Program 12.8</a>. In a random BST, each of the nodes is at the root with equal probability; so we get random trees by putting a new node at the root of a tree of size <span class="docEmphasis">N</span> with probability 1/(<span class="docEmphasis">N</span> + 1).</p>
<div class="docText"><pre>  private:
    void insertR(link&amp; h, Item x)
      { if (h == 0) { h = new node(x); return; }
        if (rand() &lt; RAND_MAX/(h-&gt;N+1))
          { insertT(h, x); return; }
        if (x.key() &lt; h-&gt;item.key())
             insertR(h-&gt;l, x);
        else insertR(h-&gt;r, x);
        h-&gt;N++;
     }
 public:
   void insert(Item x)
     { insertR(head, x); }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch13fig03">Figure 13.3</a> depicts the construction of a randomized tree for an example set of keys. Since the decisions made by the algorithm are randomized, the sequence of trees is likely to be different each time that we run the algorithm. <a class="docLink" href="#ch13fig04">Figure 13.4</a> shows that a randomized tree constructed from a set of items with keys in increasing order looks to have the same properties as a standard BST constructed from randomly ordered items (cf. <a class="docLink" href="ch12lev1sec6.html#ch12fig08">Figure 12.8</a>).</p>
<a name="ch13fig03"></a><p><center>
<h5 class="docFigureTitle">Figure 13.3. Construction of a randomized BST</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts the insertion of the keys <tt>A B C D E F G H I</tt> into an initially empty BST, with randomized insertion. The tree at the bottom appears to have been built with the standard BST algorithm, with the same keys inserted in random order.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="135" height="525" src="13fig03.gif" /></p>
<br />
<a name="ch13fig04"></a><p><center>
<h5 class="docFigureTitle">Figure 13.4. A large randomized BST</h5>
<h5></h5><h5></h5></center></p><p class="docText">This BST is the result of inserting 200 keys in increasing order into an initially empty tree, using randomized insertion. The tree appears to have been built from randomly ordered keys (see <a class="docLink" href="ch12lev1sec6.html#ch12fig08">Figure 12.8</a>).</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="500" height="114" src="13fig04.gif" /></p>
<br />
<p class="docText"><a name="iddle1183"></a><a name="iddle1699"></a>There is still a chance that the random number generator could lead to the wrong decision at every opportunity, and thus leave us with poorly balanced trees, but we can analyze this chance mathematically and prove it to be vanishingly small.</p>
<a name="ch13ex04"></a><h5 id="title-IDASUW0D" class="docExampleTitle">Property 13.2. <span class="docEmphasis">The probability that the construction cost of a randomized BST is more than a factor of &#945; times the average is less than e<sup>&ndash;&#945;</sup></span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This result and similar ones with the same character are implied by a general solution to probabilistic recurrence relations that was developed by Karp in 1995 (<span class="docEmphasis">see reference section</span>).</p>
</td></tr></table></p>
<p class="docText">For example, it takes about 2.3 million comparisons to build a randomized BST of 100,000 nodes, but the probability that the number of comparisons will be more than 23 million is much less than 0.01 percent. Such a performance guarantee is more than adequate for meeting the practical requirements of processing real data sets of this size. When using a standard BST for such a task, we cannot provide such a guarantee: for example, we are subject to performance problems if there is significant order in the data, which is unlikely in random data, but certainly would not be unusual in real data, for a host of reasons.</p>
<p class="docText">A result analogous to <a class="docLink" href="#ch13ex04">Property 13.2</a> also holds for the running time of quicksort, by the same argument. But the result is more important here, because it also implies that the cost of <span class="docEmphasis">searching</span> in the tree is close to the average. Regardless of any extra costs in constructing the trees, we can use the standard BST implementation to perform <span class="docEmphasis">search</span> operations, with costs that depend only on the shape of the trees, and no extra costs at all for balancing. This property is important in typical applications, where <span class="docEmphasis">search</span> operations are far more numerous than are any others. For example, the 100,000-node BST described in the previous paragraph might hold a telephone directory, and might be used for millions of searches. We can be nearly certain that each search will be within a small constant factor of the average cost of about 23 comparisons, and, for practical purposes, we do not have to worry about the possibility that a large number of searches would cost close to 100,000 comparisons, whereas with standard BSTs, we would need to be concerned.</p>
<p class="docText"></p><a name="ch13ex05"></a><h5 id="title-IDAZVW0D" class="docExampleTitle">Program 13.3. Randomized BST combination</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle2218"></a>This function uses the same method as <a class="docLink" href="ch12lev1sec9.html#ch12ex27">Program 12.17</a>, except that it makes a randomized, rather than an arbitrary, decision about which node to use for the root in a combined tree, using probabilities that ensure that each node is equally likely to be the root. The private member function <tt>fixN</tt> updates <tt>b-&gt;N</tt> to be 1 plus the sum of the corresponding fields in the subtrees (0 for null trees).</p>
<div class="docText"><pre>   private:
     link joinR(link a, link b)
       {
         if (a == 0) return b;
         if (b == 0) return a;
         insertR(b, a-&gt;item);
         b-&gt;l = joinR(a-&gt;l, b-&gt;l);
         b-&gt;r = joinR(a-&gt;r, b-&gt;r);
         delete a[;;] fixN(b); return b;
      }
  public:
    void join(ST&lt;Item, Key&gt;&amp; b)

      { int N = head-&gt;N;
        if (rand()/(RAND_MAX/(N+b.head-&gt;N)+1) &lt; N)
             head = joinR(head, b.head);
        else head = joinR(b.head, head); }</pre></div><br />
</td></tr></table></p>
<p class="docText">One of the main drawbacks to randomized insertion is the cost of generating random numbers at every node during every insertion. A high-quality system-supported random number generator might work hard to produce pseudo-random numbers with more randomness than randomized BSTs require, so constructing a randomized BST might be slower than constructing a standard BST in certain practical situations (for example, if the assumption that the items are in random order <span class="docEmphasis">is</span> valid). As we did with quicksort, we can reduce this cost by using numbers that are less than perfectly random, but that are cheap to generate and are sufficiently similar to random numbers that they achieve the goal of avoiding the bad worst case for BSTs for key insertion sequences that are likely to arise in practice (see <a class="docLink" href="#ch13qa2q7">Exercise 13.14</a>).</p>
<p class="docText"></p><a name="ch13ex06"></a><h5 id="title-IDAPXW0D" class="docExampleTitle">Program 13.4. Deletion in a randomized BST</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1162"></a><a name="iddle1177"></a>We use the same <tt>remove</tt> function as we did for standard BSTs (see <a class="docLink" href="ch12lev1sec9.html#ch12ex26">Program 12.16</a>), but replace the <tt>joinLR</tt> function with the one shown here, which makes a randomized, rather than an arbitrary, decision about whether to replace the deleted node with the predecessor or the successor, using probabilities that ensure that each node in the resulting tree is equally likely to be the root. To properly maintain the node counts, we also need to include a call to <tt>fixN</tt> (see <a class="docLink" href="#ch13ex05">Program 13.3</a>) for <tt>h</tt> as the last statement in <tt>removeR</tt>.</p>
<div class="docText"><pre>   link joinLR(link a, link b)
     {
       if (a == 0) return b;
       if (b == 0) return a;
       if (rand()/(RAND_MAX/(a-&gt;N+b-&gt;N)+1) &lt; a-&gt;N)
            { a-&gt;r = joinLR(a-&gt;r, b); return a; }
       else { b-&gt;l = joinLR(a, b-&gt;l); return b; }
    }</pre></div><br />
</td></tr></table></p>
<p class="docText">Another potential drawback of randomized BSTs is that they need to have a field in each node for the number of nodes in that node's subtree. The extra space required for this field may be a liability for large trees. On the other hand, as we discussed in <a class="docLink" href="ch12lev1sec9.html#ch12lev1sec9">Section 12.9</a>, this field may be needed for other reasons&mdash;for example, to support the <span class="docEmphasis">select</span> operation, or to provide a check on the integrity of the data structure. In such cases, randomized BSTs incur no extra space cost, and are an attractive choice.</p>
<p class="docText">The basic guiding principle of preserving randomness in the trees also leads to efficient implementations of the <span class="docEmphasis">remove</span>, <span class="docEmphasis">join</span>, and other symbol-table ADT operations, still producing random trees.</p>
<p class="docText">To <span class="docEmphasis">join</span> an <span class="docEmphasis">N</span>-node tree with an <span class="docEmphasis">M</span>-node tree, we use the basic method from <a class="docLink" href="ch12.html#ch12">Chapter 12</a>, except that we make a randomized decision to choose the root based on reasoning that the root of the combined tree must come from the <span class="docEmphasis">N</span>-node tree with probability <span class="docEmphasis">N</span>/(<span class="docEmphasis">M</span>+<span class="docEmphasis">N</span>) and from the <span class="docEmphasis">M</span>-node tree with probability <span class="docEmphasis">M</span>/(<span class="docEmphasis">M</span>+<span class="docEmphasis">N</span>). <a class="docLink" href="#ch13ex05">Program 13.3</a> is an implementation of this operation.</p>
<p class="docText">In the same way, we replace the arbitrary decision in the <span class="docEmphasis">remove</span> algorithm by a randomized one, as shown in <a class="docLink" href="#ch13ex06">Program 13.4</a>. This method corresponds to an option that we did not consider for deleting nodes in standard BSTs because it would seem&mdash;in the absence of randomization&mdash;to lead to unbalanced trees (see <a class="docLink" href="#ch13qa2q14">Exercise 13.21</a>).</p>
<a name="ch13ex07"></a><h5 id="title-IDA51W0D" class="docExampleTitle">Property 13.3. <span class="docEmphasis">Making a tree with an arbitrary sequence of randomized insert, remove, and join operations is equivalent to building a standard BST from a random permutation of the keys in the tree</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">As it is for <a class="docLink" href="#ch13ex02">Property 13.1</a>, a careful probabilistic argument is needed to establish this fact (<span class="docEmphasis">see reference section</span>).</p>
</td></tr></table></p>
<p class="docText">Proving facts about probabilistic algorithms requires having a good understanding of probability theory, but understanding these proofs is not necessarily a requirement for programmers using the algorithms. A careful programmer will check claims such as <a class="docLink" href="#ch13ex07">Property 13.3</a> no matter how they are proved (to check, for example, the quality of the random-number generator or other properties of the implementation), and therefore can use these methods with confidence. Randomized BSTs are perhaps the easiest way to support a full symbol-table ADT with near-optimal performance guarantees; they are therefore useful for many practical applications.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa2q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">13.8</span> Draw the randomized BST that results when you insert items with the keys <tt>E A S Y Q U T I O N</tt> in that order into an initially empty tree, assuming a bad randomization function that results in the root insertion option being taken whenever the tree size is odd.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa2q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.9</span> Write a driver program that performs the following experiment 1000 times, for <span class="docEmphasis">N</span> = <span class="docEmphRoman">10</span> and <span class="docEmphRoman">100</span>: Insert items with keys <span class="docEmphRoman">0</span> through <span class="docEmphasis">N</span> - 1 (in that order) into an initially empty randomized BST using <a class="docLink" href="#ch13ex03">Program 13.2</a>. Then print, for each <span class="docEmphasis">N</span>, the <span class="docEmphasis">x</span><sup>2</sup> statistic for the hypothesis that each key falls at the root with probability <span class="docEmphasis">1/N</span> (see <a class="docLink" href="ch14lev1sec1.html#ch14qa1q5">Exercise 14.5</a>).</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa2q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">13.10</span> Give the probability that <tt>F</tt> lands in each of the positions depicted in <a class="docLink" href="#ch13fig02">Figure 13.2</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa2q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.11</span> Write a program to compute the probability that a randomized insertion ends at one of the internal nodes in a given tree, for each of the nodes on the search path.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa2q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.12</span> Write a program to compute the probability that a randomized insertion ends at one of the external nodes of a given tree.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa2q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">13.13</span> Implement a nonrecursive version of the randomized insertion function in <a class="docLink" href="#ch13ex03">Program 13.2</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa2q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.14</span> Draw the randomized BST that results when you insert items with the keys E A S Y Q U T I O N in that order into an initially empty tree, using a version of <a class="docLink" href="#ch13ex03">Program 13.2</a> where you replace the expression involving <tt>rand()</tt> with the test <tt>(111 % h-&gt;N) == 3</tt> to decide to switch to root insertion.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa2q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.15</span> Do <a class="docLink" href="#ch13qa2q2">Exercise 13.9</a> for a version of <a class="docLink" href="#ch13ex03">Program 13.2</a> where you replace the expression involving <tt>rand()</tt> with the test <tt>(111 % h-&gt;N) == 3</tt> to decide to switch to root insertion.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa2q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.16</span> Show the sequence of randomized decisions that would result in the keys E A S Y Q U T I O N being built into a degenerate tree (keys in order, left links null). What is the probability that this event will happen?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa2q10"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.17</span> Could <span class="docEmphasis">every</span> BST containing the keys E A S Y Q U T I O N be constructed by <span class="docEmphasis">some</span> sequence of randomized decisions when those keys are inserted in that order into an initially empty tree? Explain your answer.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa2q11"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.18</span> Run empirical studies to compute the average and standard deviation of the number of comparisons used for search hits and for search misses in a randomized BST built by inserting <span class="docEmphasis">N</span> random keys into an initially empty tree, for <span class="docEmphasis">N</span> = <span class="docEmphRoman">10</span><sup>3</sup>, <span class="docEmphRoman">10</span><sup>4</sup>, <span class="docEmphRoman">10</span><sup>5</sup>, and <span class="docEmphRoman">10</span><sup>6</sup>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa2q12"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">13.19</span> Draw the BST that results from using <a class="docLink" href="#ch13ex06">Program 13.4</a> to delete the <tt>Q</tt> from your tree in <a class="docLink" href="#ch13qa2q7">Exercise 13.14</a>, using the test <tt>(111 % (a-&gt;N + b-&gt;N)) &lt; a-&gt;N</tt> to decide to join with a at the root.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa2q13"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.20</span> Draw the BST that results when you insert items with the key<tt>s E A S Y</tt> into one initially empty tree, and items with the keys <tt>Q U E S T I O N</tt> into another initially empty tree, then combine the result, using <a class="docLink" href="#ch13ex05">Program 13.3</a> with the test described in <a class="docLink" href="#ch13qa2q12">Exercise 13.19</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa2q14"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.21</span> Draw the BST that results when you insert items with the keys E A S Y Q U T I O N in that order into an initially empty tree, then use <a class="docLink" href="#ch13ex06">Program 13.4</a> to delete the <tt>Q</tt>, assuming a bad randomization function that always returns 0.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa2q15"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.22</span> Run experiments to determine how the height of a BST grows as a long sequence of alternating random insertions and deletions using <a class="docLink" href="#ch13ex03">Programs 13.2</a> and <a class="docLink" href="#ch13ex05">13.3</a> is made in a tree of <span class="docEmphasis">N</span> nodes, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10, 100,</tt> and <tt>1000</tt>, and for <span class="docEmphasis">N</span><sup>2</sup> insertion&ndash;deletion pairs for each <span class="docEmphasis">N</span>.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa2q16"></a><b></b></td><td><p class="docText"><a name="iddle1127"></a><a name="iddle1181"></a><a name="iddle1188"></a><a name="iddle2286"></a><a name="iddle2429"></a><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">13.23</span> Compare your results from <a class="docLink" href="#ch13qa2q15">Exercise 13.22</a> with the result of deleting and reinserting the largest key in a random tree of <span class="docEmphasis">N</span> nodes using <a class="docLink" href="#ch13ex03">Programs 13.2</a> and <a class="docLink" href="#ch13ex05">13.3</a>, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10, 100</tt>, and <tt>1000</tt>, and for <span class="docEmphasis">N</span><sup>2</sup> insertion&ndash;deletion pairs for each <span class="docEmphasis">N</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa2q17"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.24</span> Instrument your program from <a class="docLink" href="#ch13qa2q15">Exercise 13.22</a> to determine the average number of calls to <tt>rand()</tt> that it makes per item deleted.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch13.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch13lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>