<html><head><title>6.10. Key-Indexed Counting</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch06lev1sec9.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch07.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch06lev1sec10"></a>
<h3 id="643999-876" class="docSection1Title">6.10. Key-Indexed Counting</h3>
<p class="docText"><a name="iddle1639"></a><a name="iddle1705"></a><a name="iddle1737"></a><a name="iddle2393"></a>A number of sorting algorithms gain efficiency by taking advantage of special properties of keys. For example, consider the following problem: Sort a file of <span class="docEmphasis">N</span> items whose keys are distinct integers between <tt>0</tt> and <span class="docEmphasis">N</span> &ndash; 1. We can solve this problem immediately, using a temporary array <tt>b</tt>, with the statement</p>
<div class="docText"><pre>for (i = 0; i &lt; N; i++) b[key(a[i])] = a[i]</pre></div><br />
<p class="docText">That is, we sort by using the keys as <span class="docEmphasis">indices</span>, rather than as abstract items that are compared. In this section, we consider an elementary method that uses key indexing in this way to sort efficiently when the keys are integers in a small range.</p>
<p class="docText">If all the keys are 0, sorting is trivial, but now suppose that there are two distinct key values 0 and 1. Such a sorting problem might arise when we want to separate out the items in a file that satisfy some (perhaps complicated) acceptance test: we take the key 0 to mean &quot;accept&quot; and the key 1 to mean &quot;reject.&quot; One way to proceed is to count the number of 0s, then to make a second pass through the input <tt>a</tt> to distribute its items to the temporary array <tt>b</tt>, using an array of two counters, as follows. We start with 0 in <tt>cnt[0]</tt> and the number of 0 keys in the file <tt>cnt[1]</tt>, to indicate that there are no keys that are less than 0 and <tt>cnt[1]</tt> keys that are less than 1 in the file. Clearly, we can fill in the <tt>b</tt> array by putting 0s at the beginning (starting at <tt>b[[cnt[0]]</tt>, or <tt>b[0]</tt>) and 1s starting at <tt>b[cnt[1]</tt>. That is, the code</p>
<div class="docText"><pre>for (i = 0; i &lt; N; i++) b[cnt[a[i]]++] = a[i];</pre></div><br />
<p class="docText">serves to distribute the items from <tt>a</tt> to <tt>b</tt>. Again, we get a fast sort by using the keys as indices (to pick between <tt>cnt[0]</tt> and <tt>cnt[1]</tt>).</p>
<p class="docText">This approach generalizes immediately. A more realistic problem in the same spirit is this: Sort a file of <span class="docEmphasis">N</span> items whose keys are integers between <tt>0</tt> and <tt>M &ndash;1</tt>. We can extend the basic method in the previous paragraph to an algorithm called <span class="docEmphasis">key-indexed counting</span>, which solves this problem effectively if <span class="docEmphasis">M</span> is not too large. Just as with two key values, the idea is to count the number of keys with each value, and then to use the counts to move the items into position on a second pass through the file. First, we count the number of keys of each value: then, we compute partial sums to get counts of the number of keys less than or equal to each value. Then, again just as we did when we had two key values, we use these counts as indices for the purpose of distributing the keys. For each key, we view its associated count as an index pointing to the end of the block of keys with the same value, use the index to distribute the key into <tt>b</tt>, and decrement. This process is illustrated in <a class="docLink" href="#ch06fig17">Figure 6.17</a>. An implementation is given in <a class="docLink" href="#ch06ex30">Program 6.17</a>.</p>
<a name="ch06fig17"></a><p><center>
<h5 class="docFigureTitle">Figure 6.17. Sorting by key-indexed counting</h5>
<h5></h5><h5></h5></center></p><p class="docText">First, we determine how many keys of each value there are in the file: In this example there are six 0s, four 1s, two 2s, and three 3s. Then, we take partial sums to find the number of keys less than each key: 0 keys are less than 0, 6 keys are less than 1, 10 keys are less than 2, and 12 keys are less than 3 (table in middle). Then, we use the partial sums as indices in placing the keys into position: The 0 at the beginning of the file is put into location 0; we then increment the pointer corresponding to 0, to point to where the next 0 should go. Then, the 3 from the next position on the left in the file is put into location 12 (since there are 12 keys less than 3); its corresponding count is incremented; and so forth.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="250" height="357" src="06fig17.gif" /></p>
<br />
<a name="ch06ex30"></a><h5 id="title-IDAATZ0D" class="docExampleTitle">Program 6.17. Key-indexed counting</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The first <tt>for</tt> loop initializes the counts to 0; the second <tt>for</tt> loop sets the second counter to the number of 0s, the third counter to the number of 1s, and so forth. Then, the third <tt>for</tt> loop simply adds these numbers to produce counts of the number of keys less than or equal to the one corresponding to the count. These numbers now give the indices of the end of the part of the file where keys belong. The fourth <tt>for</tt> loop moves the keys into an auxiliary array <tt>b</tt> according to these indices, and the final loop moves the sorted file back into <tt>a</tt>. The keys must be integers less than <span class="docEmphasis">M</span> for this code to work, although we can easily modify it to extract such keys from more complex items (see <a class="docLink" href="#ch06qa10q4">Exercise 6.77</a>).</p>
<div class="docText"><pre>void distcount(int a[], int l, int r)
  { int i, j, cnt[M];
    static int b[maxN];
    for (j = 0; j &lt;  M; j++) cnt[j] = 0;
    for (i = l; i &lt;= r; i++) cnt[a[i]+1]++;
    for (j = 1; j &lt;  M; j++) cnt[j] += cnt[j-1];
    for (i = l; i &lt;= r; i++) b[cnt[a[i]]++] = a[i];
    for (i = l; i &lt;= r; i++) a[i] = b[i];
  }</pre></div><br />
</td></tr></table></p>
<a name="ch06ex31"></a><h5 id="title-IDAMUZ0D" class="docExampleTitle">Property 6.12. Key-indexed counting is a linear-time sort, provided that the range of distinct key values is within a constant factor of the file size</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Each item is moved twice, once for the distribution and once to be moved back to the original array; and each key is referenced twice, once to do the counts and once to do the distribution. The two other <tt>for</tt> loops in the algorithm involve building the counts, and will contribute insignificantly to the running time unless the number of counts becomes significantly larger than the file size.</p>
</td></tr></table></p>
<p class="docText">If huge files are to be sorted, the auxiliary array <tt>b</tt> can present memory-allocation problems. We can modify <a class="docLink" href="#ch06ex30">Program 6.17</a> to complete the sort in place (avoiding the need for an auxiliary array), using a method similar to that used in <a class="docLink" href="ch06lev1sec8.html#ch06ex27">Program 6.14</a>. This operation is closely related to the basic methods that we shall be discussing in <a class="docLink" href="ch07.html#ch07">Chapters 7</a> and <a class="docLink" href="ch10.html#ch10">10</a>, so we defer it to <a class="docLink" href="ch12lev1sec3.html#ch12qa3q1">Exercises 12.16</a> and <a class="docLink" href="ch12lev1sec3.html#ch12qa3q2">12.17</a> in <a class="docLink" href="ch12lev1sec3.html#ch12lev1sec3">Section 12.3</a>. As we shall see in <a class="docLink" href="ch12.html#ch12">Chapter 12</a>, this space savings comes at the cost of the stability property of the algorithm, and thus limits the algorithm's utility because applications involving large numbers of duplicate keys often have other associated keys, whose relative order should be preserved. We shall see a particularly important example of such an application in <a class="docLink" href="ch10.html#ch10">Chapter 10</a>.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa10q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">6.74</span> Give a specialized version of key-indexed counting for sorting files where elements can take on only one of three values (<tt>a</tt>, <tt>b</tt>, or <tt>c</tt>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa10q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.75</span> Suppose that we use insertion sort on a randomly ordered file where elements have only one of three values. Is the running time linear, quadratic, or something in between?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa10q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">6.76</span> Show how key-indexed counting sorts the file <tt>A B R A C A D A B R A</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa10q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.77</span> Implement key-indexed counting for items that are potentially large records with integer keys from a small range.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa10q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.78</span> Implement key-indexed counting as a pointer sort.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch06lev1sec9.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch07.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>