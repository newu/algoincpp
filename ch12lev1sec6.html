<html><head><title>12.6. Performance Characteristics of BSTs</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12lev1sec5.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch12lev1sec7.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch12lev1sec6"></a>
<h3 id="title-IDANZ3XE" class="docSection1Title">12.6. Performance Characteristics of BSTs</h3>
<p class="docText">The running times of algorithms on binary search trees are dependent on the shapes of the trees. In the best case, the tree could be perfectly <a name="iddle1158"></a><a name="iddle1167"></a><a name="iddle1714"></a><a name="iddle2041"></a>balanced, with about <tt>lg</tt> <span class="docEmphasis"><tt>N</tt></span> nodes between the root and each external node, but in the worst case there could be <span class="docEmphasis">N</span> nodes on the search path.</p>
<p class="docText">We might expect the search times also to be logarithmic in the average case, because the first element inserted becomes the root of the tree: If <span class="docEmphasis">N</span> keys are to be inserted at random, then this element would divide the keys in half (on the average), which would yield logarithmic search times (using the same argument on the subtrees). Indeed, it could happen that a BST would lead to precisely the same comparisons as binary search (see <a class="docLink" href="#ch12qa6q3">Exercise 12.58</a>). This case would be the best for this algorithm, with guaranteed logarithmic running time for all searches. In a truly random situation, the root is equally likely to be any key, so such a perfectly balanced tree is extremely rare, and we cannot easily keep the tree perfectly balanced after every insertion. However, highly unbalanced trees are also extremely rare for random keys, so the trees are rather well-balanced on the average. In this section, we shall quantify this observation.</p>
<p class="docText">Specifically, the path-length and height measures of binary trees that we considered in <a class="docLink" href="ch05lev1sec5.html#ch05lev1sec5">Section 5.5</a> relate directly to the costs of searching in BSTs. The height is the worst-case cost of a search, the internal path length is directly related to the cost of search hits, and external path length is directly related to the cost of search misses.</p>
<a name="ch12ex18"></a><h5 id="title-IDA313XE" class="docExampleTitle">Property 12.6. <span class="docEmphasis">Search hits require about</span> <span class="docEmphRoman">2ln</span> <span class="docEmphasis">N</span> <span class="docEmphRoman"><img src="U2248.GIF" border="0" /> 1:39 lg</span> <span class="docEmphasis">N</span> <span class="docEmphasis">comparisons, on the average, in a BST built from N random keys</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We regard successive <tt>==</tt> and <tt>&lt;</tt> operations as a single comparison, as discussed in <a class="docLink" href="ch12lev1sec3.html#ch12lev1sec3">Section 12.3</a>. The number of comparisons used for a search hit ending at a given node is 1 plus the distance from that node to the root. Adding these distances for all nodes, we get the internal path length of the tree. Thus, the desired quantity is 1 plus the average internal path length of the BST, which we can analyze with a familiar argument: If <span class="docEmphasis">C<sub>N</sub></span> denotes the average internal path length of a binary search tree of <span class="docEmphasis">N</span> nodes, we have the recurrence</p>
<p class="docText">
<img border="0" alt="" width="300" height="46" src="522equ01.jpg" /></p>
<p class="docText">with <span class="docEmphasis">C</span><sub>1</sub> = 1. The <span class="docEmphasis">N</span> - 1 term takes into account that the root contributes 1 to the path length of each of the other <span class="docEmphasis">N</span> - 1 nodes in the tree; the rest of the expression comes from observing that the key at the root (the first inserted) is equally likely to be the <tt>k</tt>th largest, leaving random subtrees of size <span class="docEmphasis">k</span> - 1 and <span class="docEmphasis">N - k</span>. This recurrence is nearly identical to the one that we solved in <a class="docLink" href="ch07.html#ch07">Chapter 7</a> for quicksort, and we can solve it in the same way to derive the stated result.</p>
</td></tr></table></p>
<a name="ch12ex19"></a><h5 id="title-IDAT43XE" class="docExampleTitle">Property 12.7. <span class="docEmphasis">Insertions and search misses require about</span> <span class="docEmphRoman">2ln</span> <span class="docEmphasis">N</span> <span class="docEmphRoman"><img src="U2248.GIF" border="0" /> 1:39 lg</span><span class="docEmphasis">N comparisons, on the average, in a BST built from N random keys</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">A search for a random key in a tree of <span class="docEmphasis">N</span> nodes is equally likely to end at any of the <span class="docEmphasis">N</span> + 1 external nodes on a search miss. This property, coupled with the fact that the difference between the external path length and the internal path length in any tree is merely 2<span class="docEmphasis">N</span> (see <a class="docLink" href="ch05lev1sec5.html#ch05ex26">Property 5.7</a>), establishes the stated result. In any BST, the average number of comparisons for an insertion or a search miss is about 1 greater than the average number of comparisons for a search hit.</p>
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch12ex18">Property 12.6</a> says that we should expect the search cost for BSTs to be about 39% higher than that for binary search for random keys, but <a class="docLink" href="#ch12ex19">Property 12.7</a> says that the extra cost is well worthwhile, because a new key can be inserted at about the same cost&mdash;flexibility not available with binary search. <a class="docLink" href="#ch12fig08">Figure 12.8</a> shows a BST built from a long random permutation. Although it has some short paths and some long paths, we can characterize it as well balanced: Any search requires less than 12 comparisons, and the average number of comparisons for a random search hit is 7.00, as compared to 5.74 for binary search.</p>
<a name="ch12fig08"></a><p><center>
<h5 class="docFigureTitle">Figure 12.8. Example of a binary search tree</h5>
<h5></h5><h5></h5></center></p><p class="docText">In this BST, which was built by inserting about 200 random keys into an initially empty tree, no search uses more than 12 comparisons. The average cost for a search hit is about 10.</p>
<p class="docText">
<img border="0" alt="" width="450" height="100" src="12fig08.gif" /></p>
<br />
<p class="docText"><a class="docLink" href="#ch12ex18">Properties 12.6</a> and <a class="docLink" href="#ch12ex19">12.7</a> are results on average-case performance that depend on the keys being randomly ordered. If the keys are not randomly ordered, the algorithm can perform badly.</p>
<a name="ch12ex20"></a><h5 id="title-IDAAC4XE" class="docExampleTitle">Property 12.8. <span class="docEmphasis">In the worst case, a search in a binary search tree with N keys can require N comparisons</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a class="docLink" href="#ch12fig09">Figures 12.9</a> and <a class="docLink" href="#ch12fig10">12.10</a> depict two examples of worst-case BSTs. For these trees, binary-tree search is no better than sequential search using singly linked lists.</p>
</td></tr></table></p>
<a name="ch12fig09"></a><p><center>
<h5 class="docFigureTitle">Figure 12.9. A worst-case BST</h5>
<h5></h5><h5></h5></center></p><p class="docText">If the keys arrive in increasing order at a BST, it degenerates to a form equivalent to a singly linked list, leading to quadratic tree-construction time and linear search time.</p>
<p class="docText">
<img border="0" alt="" width="125" height="532" src="12fig09.gif" /></p>
<br />
<a name="ch12fig10"></a><p><center>
<h5 class="docFigureTitle">Figure 12.10. Another worst-case BST</h5>
<h5></h5><h5></h5></center></p><p class="docText">Many other key insertion orders, such as this one, lead to degenerate BSTs. Still, a BST built from randomly ordered keys is likely to be well balanced.</p>
<p class="docText">
<img border="0" alt="" width="125" height="530" src="12fig10.gif" /></p>
<br />
<p class="docText"><a name="iddle1197"></a>Thus, good performance of the basic BST implementation of symbol tables is dependent on the keys being sufficiently similar to random keys that the tree is not likely to contain many long paths. Furthermore, this worst-case behavior is not unlikely in practice&mdash;it arises when we insert keys in order or in reverse order into an initially empty tree using the standard algorithm, a sequence of operations that we certainly might attempt without any explicit warnings to avoid doing so. In <a class="docLink" href="ch13.html#ch13">Chapter 13</a>, we shall examine techniques for making this worst case extremely unlikely and for eliminating it entirely, making all trees look more like best-case trees, with all path lengths guaranteed to be logarithmic.</p>
<p class="docText">None of the other symbol-table implementations that we have discussed can be used for the task of inserting a huge number of random keys into a table, then searching for each of them&mdash;the running time of each of the methods that we discussed in <a class="docLink" href="ch12lev1sec2.html#ch12lev1sec2">Sections 12.2</a> through <a class="docLink" href="ch12lev1sec4.html#ch12lev1sec4">12.4</a> goes quadratic for this task. Furthermore, the analysis tells us that the average distance to a node in a binary tree is proportional to the logarithm of the number of nodes in the tree, which gives us the flexibility to efficiently handle intermixed searches, insertions, and other symbol-table ADT operations, as we shall soon see.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa6q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">12.56</span> Write a recursive program that computes the maximum number of comparisons required by any search in a given BST (the height of the tree).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa6q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">12.57</span> Write a recursive program that computes the average number of comparisons required by a search hit in a given BST (the internal path length of the tree divided by <span class="docEmphasis">N</span>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa6q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.58</span> Give an insertion sequence for the keys EASY <tt>Q U E S T I O N</tt> into an initially empty BST such that the tree produced is equivalent to binary search, in the sense that the sequence of comparisons done in the search for any key in the BST is the same as the sequence of comparisons used by binary search for the same set of keys.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa6q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">12.59</span> Write a program that inserts a set of keys into an initially empty BST such that the tree produced is equivalent to binary search, in the sense described in <a class="docLink" href="#ch12qa6q3">Exercise 12.58</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa6q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.60</span> Draw all the structurally different BSTs that can result when <span class="docEmphasis">N</span> keys are inserted into an initially empty tree, for 2 <img src="U2264.GIF" border="0" /> <span class="docEmphasis">N</span> <img src="U2264.GIF" border="0" /> 5.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa6q6"></a><b></b></td><td><p class="docText"><a name="iddle1160"></a><a name="iddle1198"></a><a name="iddle1645"></a><a name="iddle2484"></a><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">12.61</span> Find the probability that each of the trees in <a class="docLink" href="#ch12qa6q5">Exercise 12.60</a> is the result of inserting <span class="docEmphasis">N</span> random distinct elements into an initially empty tree.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa6q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">12.62</span> How many binary trees of <span class="docEmphasis">N</span> nodes are there with height <span class="docEmphasis">N</span>? How many different ways are there to insert <span class="docEmphasis">N</span> distinct keys into an initially empty tree that result in a BST of height <span class="docEmphasis">N</span>?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa6q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">12.63</span> Prove by induction that the difference between the external path length and the internal path length in any binary tree is 2<span class="docEmphasis">N</span> (see <a class="docLink" href="ch05lev1sec5.html#ch05ex26">Property 5.7</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa6q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.64</span> Run empirical studies to compute the average and standard deviation of the number of comparisons used for search hits and for search misses in a binary search tree built by inserting <span class="docEmphasis">N</span> random keys into an initially empty tree, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa6q10"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.65</span> Write a program that builds <span class="docEmphasis">t</span> BSTs by inserting <span class="docEmphasis">N</span> random keys into an initially empty tree, and that computes the maximum tree height (the maximum number of comparisons involved in any search miss in any of the <span class="docEmphasis">t</span> trees), for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt> with <span class="docEmphasis"><tt>t</tt></span> <tt>= 10, 100</tt>, and <tt>1000</tt>.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12lev1sec5.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch12lev1sec7.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>