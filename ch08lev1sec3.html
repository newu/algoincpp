<html><head><title>8.3. Top-Down Mergesort</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch08lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch08lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch08lev1sec3"></a>
<h3 id="title-IDANBFMK" class="docSection1Title">8.3. Top-Down Mergesort</h3>
<p class="docText">Once we have a merging procedure, it is not difficult to use that procedure as the basis for a recursive sorting procedure. To sort a given file, we divide it in half, recursively sort the two halves, and then merge them. An implementation is given in <a class="docLink" href="#ch08ex03">Program 8.3</a>; an example is depicted in <a class="docLink" href="#ch08fig02">Figure 8.2</a>. As mentioned in <a class="docLink" href="ch05.html#ch05">Chapter 5</a>, this algorithm is one of the best-known examples of the utility of the <span class="docEmphasis">divide-and-conquer</span> paradigm for efficient algorithm design.</p>
<a name="ch08fig02"></a><p><center>
<h5 class="docFigureTitle">Figure 8.2. Top-down mergesort example</h5>
<h5></h5><h5></h5></center></p><p class="docText">Each line shows the result of a call on <span class="docEmphasis"><tt>merge</tt></span> during top-down mergesort. First, we merge A and S to get A S; then, we merge O and R to get O R; then, we merge O R with A S to get A O R S. Later, we merge I T with G N to get G I N T, then merge this result with A O R S to get A G I N O R S T, and so on. The method recursively builds up small sorted files into larger ones.</p>
<p class="docText">
<img border="0" alt="" width="200" height="193" src="08fig02.gif" /></p>
<br />
<p class="docText">Top-down mergesort is analogous to a top-down management style, where a manager gets an organization to take on a big task by dividing it into pieces to be solved independently by underlings. If each manager operates by simply dividing the given task in half, then putting together the solutions that the subordinates develop and passing the result up to a superior, the result is a process like mergesort. Not much real work gets done until someone with no subordinates gets a task (in this case, merging two files of size 1); but management does much of the work, putting together solutions.</p>
<p class="docText">Mergesort is important because it is a straightforward optimal sorting method (it runs in time proportional to <span class="docEmphasis">N</span> <span class="docEmphRoman">log</span> <span class="docEmphasis">N</span>) that can be implemented in a stable manner. These facts are relatively easy to prove.</p>
<p class="docText">As we have seen in <a class="docLink" href="ch05.html#ch05">Chapter 5</a> (and, for quicksort, in <a class="docLink" href="ch07.html#ch07">Chapter 7</a>), we can use tree structures to help us to visualize the recursive call <a name="iddle1383"></a><a name="iddle1889"></a><a name="iddle2541"></a>structure of a recursive algorithm, to help us to understand variants of the algorithm, and to expedite the analysis of the algorithm. For mergesort, the recursive call structure depends only upon the size of the input. For any given <span class="docEmphasis">N</span>, we define a tree, called a <span class="docEmphasis">divide-and-conquer tree</span>, that describes the sizes of the subfiles that are processed during the operation of <a class="docLink" href="#ch08ex03">Program 8.3</a> (see <a class="docLink" href="ch05lev1sec5.html#ch05qa5q6">Exercise 5.73</a>): If <span class="docEmphasis">N</span> is 1, the tree is a single node with label 1; otherwise, the tree is a node containing the file size <span class="docEmphasis">N</span> as the root, the tree for <span class="docEmphasis"><img src="U230A.GIF" border="0" />N/2<img src="U230B.GIF" border="0" /></span> as the left subtree, and the tree for <span class="docEmphasis"><img src="U2308.GIF" border="0" />N/2<img src="U2309.GIF" border="0" /></span> as the right subtree. Each node in the tree thus corresponds to a call on <tt>mergesort</tt>, with the label giving the problem size corresponding to the recursive call. When <span class="docEmphasis">N</span> is a power of 2, this construction leads to a complete balanced tree with powers of 2 in all the nodes and 1s in all the external nodes. When <span class="docEmphasis">N</span> is not a power of 2, the tree is more complicated. Examples of both cases are illustrated in <a class="docLink" href="#ch08fig03">Figure 8.3</a>. We have enountered such trees before, when considering an algorithm with the same recursive call structure as mergesort, in <a class="docLink" href="ch05lev1sec2.html#ch05lev1sec2">Section 5.2</a>.</p>
<a name="ch08fig03"></a><p><center>
<h5 class="docFigureTitle">Figure 8.3. Divide-and-conquer trees</h5>
<h5></h5><h5></h5></center></p><p class="docText">These tree diagrams depict the sizes of the subproblems created by top-down mergesort. Unlike the trees corresponding to quicksort, for example, these patterns are dependent on only the initial file size, rather than on the values of the keys in the file. The top diagram shows how a file of 32 elements is sorted. We (recursively) sort two files of 16 elements, then merge them. We sort the files of 16 elements by (recursively) sorting files of 8 elements, and so forth. For file sizes that are not a power of 2, the pattern is more intricate, as indicated by the bottom diagram.</p>
<p class="docText">
<img border="0" alt="" width="400" height="200" src="08fig03.gif" /></p>
<br />
<a name="ch08ex03"></a><h5 id="title-IDARHFMK" class="docExampleTitle">Program 8.3. Top-down mergesort</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This basic mergesort implementation is a prototypical divide-and-conquer recursive program. It sorts the array <tt>a[l], ..., a[r]</tt> by dividing it into two parts <tt>a[l], ..., a[m]</tt> and <tt>a[m+1], ..., a[r]</tt>, sorting them independently (via recursive calls), and merging the resulting ordered subfiles to produce the final ordered result. The <tt>merge</tt> function may need to use an auxiliary array big enough to hold a copy of the input, but it is convenient to consider the abstract operation as an inplace merge (see text).</p>
<div class="docText"><pre>    template &lt;class Item&gt;
    void mergesort(Item a[], int l, int r)
      { if (r &lt;= l) return;
        int m = (r+l)/2;
        mergesort(a, l, m);
        mergesort(a, m+1, r);
        merge(a, l, m, r);
      }</pre></div><br />
</td></tr></table></p>
<p class="docText">Structural properties of divide-and-conquer trees are directly relevant to the analysis of mergesort. For example, the total number of <a name="iddle1871"></a><a name="iddle1893"></a>comparisons used by the algorithm is precisely the sum of all the node labels.</p>
<a name="ch08ex04"></a><h5 id="title-IDAJJFMK" class="docExampleTitle">Property 8.1. Mergesort requires about <span class="docEmphasis">N</span> lg <span class="docEmphasis">N</span> comparisons to sort any file of <span class="docEmphasis">N</span> elements</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">In the implementations in <a class="docLink" href="ch08lev1sec1.html#ch08lev1sec1">Sections 8.1</a> and <a class="docLink" href="ch08lev1sec2.html#ch08lev1sec2">8.2</a>, each (<span class="docEmphasis">N</span>/2)-by-(<span class="docEmphasis">N</span>/2) merge will require <span class="docEmphasis">N</span> comparisons (this amount could vary by 1 or 2, depending on how sentinels are used). The total number of comparisons for the full sort is therefore described by the standard divide-and-conquer recurrence: <span class="docEmphasis">M<sub>N</sub></span> = <span class="docEmphasis">M<sub><img src="U230A.GIF" border="0" /></sub><sub>N/</sub><sub>2</sub><sub><img src="U230A.GIF" border="0" /></sub></span> + <span class="docEmphasis">M<sub><img src="U2308.GIF" border="0" /></sub><sub>N/</sub><sub>2</sub><sub><img src="U2309.GIF" border="0" /></sub></span> + <span class="docEmphasis">N</span>; with <span class="docEmphasis">M<sub>1</sub></span> = 0. The recurrence also describes the sum of the node labels and the external path length of a divide-and-conquer tree with <span class="docEmphasis">N</span> nodes (see <a class="docLink" href="ch05lev1sec5.html#ch05qa5q6">Exercise 5.73</a>). The stated result is easy to verify when <span class="docEmphasis">N</span> is a power of 2 (see <a class="docLink" href="ch02lev1sec5.html#ch02ex02d">Formula 2.4</a>) and to prove by induction for general <span class="docEmphasis">N</span>. <a class="docLink" href="#ch08qa3q4">Exercises 8.12</a> through <a class="docLink" href="#ch08qa3q6">8.14</a> describe a direct proof.</p>
</td></tr></table></p>
<a name="ch08ex05"></a><h5 id="title-IDAOMFMK" class="docExampleTitle">Property 8.2. Mergesort uses extra space proportional to <span class="docEmphasis">N</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This fact is clear from the discussion in <a class="docLink" href="ch08lev1sec2.html#ch08lev1sec2">Section 8.2</a>. We can take some steps to reduce the extra space used at the expense of making the algorithm considerably more complicated (for example, see <a class="docLink" href="ch08lev1sec4.html#ch08qa4q6">Exercise 8.21</a>). As we shall see in <a class="docLink" href="ch08lev1sec7.html#ch08lev1sec7">Section 8.7</a>, mergesort is also effective when the file to be sorted is organized as a linked list. In this case, the property still holds, but the extra space is used for the links. For arrays, as we noted in <a class="docLink" href="ch08lev1sec2.html#ch08lev1sec2">Section 8.2</a> and shall discuss in <a class="docLink" href="ch08lev1sec4.html#ch08lev1sec4">Section 8.4</a>, it is possible to do merges in place, although this strategy is unlikely to be worthwhile in practice.</p>
</td></tr></table></p>
<p class="docText"></p><a name="ch08ex06"></a><h5 id="title-IDAFOFMK" class="docExampleTitle">Property 8.3. Mergesort is stable, if the underlying merge is stable</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1667"></a><a name="iddle1901"></a>This fact is easy to verify by induction. For merge implementations such as <a class="docLink" href="ch08lev1sec1.html#ch08ex01">Program 8.1</a>, it is easy to show that the relative position of duplicate keys is undisturbed by merging. However, the more intricate the algorithm, the higher the chance that stability is disturbed (see <a class="docLink" href="ch08lev1sec2.html#ch08qa2q2">Exercise 8.6</a>).</p>
</td></tr></table></p>
<a name="ch08ex07"></a><h5 id="title-IDATPFMK" class="docExampleTitle">Property 8.4. The resource requirements of mergesort are insensitive to the initial order of its input</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">In our implementations, the input determines only the order in which elements are processed in the merges. Each pass requires space and a number of steps proportional to the subfile size, because of the costs of moving to the auxiliary array. The two branches of <tt>if</tt> statements may take slightly different amounts of time in the compiled code, which could lead to a slight input-dependent variation in running time, but the number of comparisons and other operations on the input is not dependent on how it is ordered. Note that this is <span class="docEmphasis">not</span> the same as saying that the algorithm is nonadaptive (see <a class="docLink" href="ch06lev1sec1.html#ch06lev1sec1">Section 6.1</a>)&mdash;the sequence of comparisons does depend on the input order.</p>
</td></tr></table></p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa3q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">8.9</span> Show the merges that <a class="docLink" href="#ch08ex03">Program 8.3</a> does to sort the keys E A S Y Q U E S T I O N.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa3q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">8.10</span> Draw divide-and-conquer trees for <span class="docEmphasis">N</span> = 16, 24, 31, 32, 33, and 39.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa3q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />8.11</span> Implement a recursive mergesort on arrays, using the idea of doing <span class="docEmphasis">three-way</span>, rather than two-way, merges.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa3q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">8.12</span> Prove that all the nodes labeled 1 in a divide-and-conquer tree are on the bottom two levels.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa3q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">8.13</span> Prove that the labels on the nodes on each level in the divide-and-conquer tree of size <span class="docEmphasis">N</span> sum to <span class="docEmphasis">N</span>, except possibly for the bottom level.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa3q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">8.14</span> Using <a class="docLink" href="#ch08qa3q4">Exercises 8.12</a> and <a class="docLink" href="#ch08qa3q5">8.13</a>, prove that the number of comparisons required by mergesort is between <span class="docEmphasis">N</span> lg <span class="docEmphasis">N</span> and <span class="docEmphasis">N lg N + N</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa3q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">8.15</span> Find and prove a relationship between the number of comparisons used by mergesort and the number of bits in the <span class="docEmphasis"><img src="U2308.GIF" border="0" />lg N<img src="U2309.GIF" border="0" /></span>-bit positive numbers less than <span class="docEmphasis">N</span>.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch08lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch08lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>