<html><head><title>7.5. Median-of-Three Partitioning</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch07lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch07lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch07lev1sec5"></a>
<h3 id="title-IDASTSIF" class="docSection1Title">7.5. Median-of-Three Partitioning</h3>
<p class="docText">Another improvement to quicksort is to use a partitioning element that is more likely to divide the file near the middle. There are several possibilities here. A safe choice to avoid the worst case is to use a random element from the array for a partitioning element. Then, the worst case will happen with negligibly small probability. This method is a simple example of a <span class="docEmphasis">probabilistic algorithm</span>&mdash;one that uses randomness to achieve good performance with high probability, regardless of the arrangement of the input. We will see numerous examples later in the book of the utility of randomness in algorithm design, particularly when bias in the input is suspected. For quicksort, it may be overkill in practice to put in a full random-number generator just for this purpose: simple arbitrary choices can also be effective.</p>
<p class="docText">Another well-known way to find a better partitioning element is to take a sample of three elements from the file, then to use the median of the three for the partitioning element. By choosing the three elements from the left, middle, and right of the array, we can incorporate sentinels into this scheme as well: sort the three elements (using the three-exchange method in <a class="docLink" href="ch06.html#ch06">Chapter 6</a>), then exchange the one in the middle with <tt>a[r-1]</tt>, and then run the partitioning algorithm on <tt>a[l+1]</tt>, <tt>. ..</tt>, <tt>a[r-2]</tt>. This improvement is called the <span class="docEmphasis">median-of-three</span> method.</p>
<p class="docText"><a name="iddle2176"></a><a name="iddle2185"></a>The median-of-three method helps quicksort in three ways. First, it makes the worst case much more unlikely to occur in any actual sort. For the sort to take <span class="docEmphasis">N</span><tt><sup>2</sup></tt> time, two out of the three elements examined must be among the largest or among the smallest elements in the file, and this event must happen consistently through most of the partitions. Second, it eliminates the need for a sentinel key for partitioning, because this function is served by one of the three elements that are examined before partitioning. Third, it reduces the total average running time of the algorithm by about 5 percent.</p>
<p class="docText">The combination of using the median-of-three method with a cutoff for small subfiles can improve the running time of quicksort over the naive recursive implementation by 20 to 25 percent. <a class="docLink" href="#ch07ex07">Program 7.4</a> is an implementation that incorporates all these improvements.</p>
<p class="docText">We might consider continuing to improve the program by removing recursion, replacing the subroutine calls by inline code, using sentinels, and so forth. However, on modern machines, such procedure calls are normally efficient, and they are not in the inner loop. More important, the use of the cutoff for small subfiles tends to compensate for any extra overhead that may be involved (outside the inner loop). The primary reason to use a nonrecursive implementation with an explicit stack is to be able to provide guarantees on limiting the stack size (see <a class="docLink" href="#ch07fig10">Figure 7.10</a>).</p>
<a name="ch07fig10"></a><p><center>
<h5 class="docFigureTitle">Figure 7.10. Stack size for improved versions of quicksort</h5>
<h5></h5><h5></h5></center></p><p class="docText">Sorting the smaller subfile first guarantees that the stack size will be logarithmic at worst. Plotted here are the stack sizes for the same files as in <a class="docLink" href="ch07lev1sec3.html#ch07fig05">Figure 7.5</a>, with the smaller of the subfiles sorted first during the sort <span class="docEmphasis">(left)</span> and with the median-of-three modification added <span class="docEmphasis">(right)</span>. These diagrams are not indicative of running time; that variable depends on the size of the files on the stack, rather than only their number. For example, the third file (partially sorted) does not require much stack space, but leads to a slow sort because the subfiles being processed are usually large.</p>
<p class="docText">
<img border="0" alt="" width="150" height="315" src="07fig10.gif" /></p>
<br />
<p class="docText">Further algorithmic improvements are possible (for example, we could use the median of five or more elements), but the amount of time gained will be marginal for random files. We <span class="docEmphasis">can</span> realize significant time savings by coding the inner loops (or the whole program) in assembly or machine language. These observations have been validated on numerous occasions by experts with serious sorting applications (<span class="docEmphasis">see reference section</span>).</p>
<p class="docText">For randomly ordered files, the first exchange in <a class="docLink" href="#ch07ex07">Program 7.4</a> is superfluous. We include it not just because it leads to optimal partitioning for files already in order, but also because it protects against anomalous situations that might occur in practice (see, for example, <a class="docLink" href="#ch07qa7q2">Exercise 7.33</a>). <a class="docLink" href="#ch07fig11">Figure 7.11</a> illustrates the effectiveness of involving the middle element in the partitioning decision, for various types of files.</p>
<a name="ch07fig11"></a><p><center>
<h5 class="docFigureTitle">Figure 7.11. Dynamic characteristics of median-of-three quicksort on various types of files</h5>
<h5></h5><h5></h5></center></p><p class="docText">The median-of three modification (particularly, using the middle element of the file) does a good job of making the partitioning process more robust. The degenerate types of files shown in <a class="docLink" href="ch07lev1sec2.html#ch07fig04">Figure 7.4</a> are handled particularly well. Another option that achieves this same goal is to use a random partitioning element.</p>
<p class="docText">
<img border="0" alt="" width="300" height="372" src="07fig11.gif" /></p>
<br />
<p class="docText">The median-of-three method is a special case of the general idea that we can sample an unknown file and use properties of the sample to estimate properties of the whole file. For quicksort, we want to estimate the median to balance the partitioning. It is the nature of the algorithm that we do not need a particularly good estimate (and may not want one if such an estimate is expensive to compute); we just want to avoid a particularly bad estimate. If we use a random sample of just one element, we get a randomized algorithm that is virtually certain to run quickly, no matter what the input. If we randomly choose three or five elements from the file, then use the median of that sample for partitioning, we get a better partition, but the improvement is offset by the cost of taking the sample.</p>
<a name="ch07ex07"></a><h5 id="title-IDARZSIF" class="docExampleTitle">Program 7.4. Improved quicksort</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Choosing the median of the first, middle, and final elements as the partitioning element and cutting off the recursion for small subfiles can significantly improve the performance of quicksort. This implementation partitions on the median of the first, middle, and final elements in the array (otherwise leaving these elements out of the partitioning process). Files of size 11 or smaller are ignored during partitioning; then, <tt>insertion</tt> from <a class="docLink" href="ch06.html#ch06">Chapter 6</a> is used to finish the sort.</p>
<div class="docText"><pre>    static const int M = 10;
    template &lt;class Item&gt;
    void quicksort(Item a[], int l, int r)
      {
       if (r-l &lt;= M) return;
       exch(a[(l+r)/2], a[r-1]);
       compexch(a[l], a[r-1]);
         compexch(a[l], a[r]);
           compexch(a[r-1], a[r]);
       int i = partition(a, l+1, r-1);
       quicksort(a, l, i-1);
       quicksort(a, i+1, r);
      }
    template &lt;class Item&gt;
    void hybridsort(Item a[], int l, int r)
      { quicksort(a, l, r); insertion(a, l, r); }</pre></div><br />
</td></tr></table></p>
<p class="docText">Quicksort is widely used because it runs well in a variety of situations. Other methods might be more appropriate for particular cases that might arise, but quicksort handles more types of sorting problems <a name="iddle1422"></a>than are handled by many other methods, and it is often significantly faster than alternative approaches. <a class="docLink" href="#ch07table01">Table 7.1</a> gives empirical results in support of some of these comments.</p>
<a name="ch07table01"></a><p><table cellspacing="0" frame="hsides" rules="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 7.1. Empirical study of basic quicksort algorithms</h5></caption><colgroup align="left" span="8"><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top" colspan="8"><p class="docText">Quicksort (<a class="docLink" href="ch07lev1sec1.html#ch07ex01">Program 7.1</a>) is more than twice as fast as shellsort (<a class="docLink" href="ch06lev1sec7.html#ch06ex19">Program 6.6</a>) for large randomly ordered files. A cutoff for small subfiles and the median-of-three improvement (<a class="docLink" href="#ch07ex07">Program 7.4</a>) lower the running time by about 10 percent each.</p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="bottomBorder" align="center" valign="top" colspan="3"><p class="docText">Basic quicksort</p></td><td class="bottomBorder" align="center" valign="top" colspan="3"><p class="docText">Median-of-three quicksort</p></td></tr><tr><td class="bottomBorder" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">shellsort</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText"><span class="docEmphasis">M</span> = 0</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText"><span class="docEmphasis">M</span> = 10</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText"><span class="docEmphasis">M</span> = 20</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText"><span class="docEmphasis">M</span> = 0</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText"><span class="docEmphasis">M</span> = 10</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText"><span class="docEmphasis">M</span> = 20</p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">12500</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">6</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">2</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">2</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">2</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">3</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">2</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">3</p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">25000</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">10</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">5</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">5</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">5</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">5</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">4</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">6</p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">50000</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">26</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">11</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">10</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">10</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">12</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">9</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">14</p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">100000</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">58</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">24</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">22</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">22</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">25</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">20</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">28</p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">200000</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">126</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">53</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">48</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">50</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">52</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">44</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">54</p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">400000</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">278</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">116</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">105</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">110</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">114</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">97</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">118</p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">800000</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">616</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">255</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">231</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">241</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">252</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">213</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">258</p></td></tr></table></p><br />
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa6q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">7.28</span> Our implementation of the median-of-three method is careful to ensure that the sampled elements do not participate in the partitioning process. One reason is that they can serve as sentinels. Give another reason.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa6q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">7.29</span> Implement a quicksort based on partitioning on the median of a random sample of five elements from the file. Make sure that the elements of the sample do not participate in partitioning (see <a class="docLink" href="#ch07qa6q1">Exercise 7.28</a>). Compare the performance of your algorithm with the median-of-three method for large random files.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa6q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">7.30</span> Run your program from <a class="docLink" href="#ch07qa6q2">Exercise 7.29</a> on large nonrandom files&mdash;for example, sorted files, files in reverse order, or files with all keys equal. How does its performance for these files differ from its performance for random files?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa6q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">7.31</span> Implement a quicksort based on using a sample of size <tt>2</tt><span class="docEmphasis"><sup>k</sup></span> - 1. First, sort the sample, then, arrange to have the recursive routine partition on the median of the sample and to move the two halves of the rest of the sample to each subfile, such that they can be used in the subfiles, without having to be sorted again. This algorithm is called <span class="docEmphasis">samplesort</span>.</p></td></tr></table></p>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa7q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">7.32</span> Run empirical studies to determine the best value of the sample size in samplesort (see <a class="docLink" href="#ch07qa6q4">Exercise 7.31</a>), for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>. Does it matter whether quicksort or samplesort is used to sort the sample?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa7q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">7.33</span> Show that <a class="docLink" href="#ch07ex07">Program 7.4</a>, if changed to omit the first exchange and to scan over keys equal to the partitioning element, runs in quadratic time on a file that is in reverse order.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch07lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch07lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>