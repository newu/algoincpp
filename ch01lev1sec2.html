<html><head><title>1.2. A Sample Problem: Connectivity</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch01lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch01lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch01lev1sec2"></a>
<h3 id="title-IDAKML3N" class="docSection1Title">1.2. A Sample Problem: Connectivity</h3>
<p class="docText"><a name="iddle1291"></a>Suppose that we are given a sequence of pairs of integers, where each integer represents an object of some type and we are to interpret the pair <tt>p-q</tt> as meaning &quot;<tt>p</tt> is connected to <tt>q</tt>.&quot; We assume the relation &quot;is connected to&quot; to be transitive: If <tt>p</tt> is connected to <tt>q</tt>, and <tt>q</tt> is connected to <tt>r</tt>, then <tt>p</tt> is connected to <tt>r</tt>. Our goal is to write a program to filter out extraneous pairs from the set: When the program inputs a pair <tt>p-q</tt>, it should output the pair only if the pairs it has seen to that point <span class="docEmphasis">do not</span> imply that <tt>p</tt> is connected to <tt>q</tt>. If the previous pairs do imply that <tt>p</tt> is connected to <tt>q</tt>, then the program should ignore <tt>p-q</tt> and should proceed to input the next pair. <a class="docLink" href="#ch01fig01">Figure 1.1</a> gives an example of this process.</p>
<a name="ch01fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 1.1. Connectivity example</h5>
<h5></h5><h5></h5></center></p><p class="docText">Given a sequence of pairs of integers representing connections between objects (left), the task of a connectivity algorithm is to output those pairs that provide new connections (center). For example, the pair <tt>2-9</tt> is not part of the output because the connection <tt>2-3-4-9</tt> is implied by previous connections (this evidence is shown at right).</p>
<p class="docText">
<img border="0" alt="" width="145" height="163" src="01fig01.gif" /></p>
<br />
<p class="docText">Our problem is to devise a program that can remember sufficient information about the pairs it has seen to be able to decide whether or not a new pair of objects is connected. Informally, we refer to the task of designing such a method as the <span class="docEmphasis">connectivity problem</span>. This problem arises in a number of important applications. We briefly consider three examples here to indicate the fundamental nature of the problem.</p>
<p class="docText">For example, the integers might represent computers in a large network, and the pairs might represent connections in the network. Then, our program might be used to determine whether we need to establish a new direct connection for <tt>p</tt> and <tt>q</tt> to be able to communicate, or whether we could use existing connections to set up a communications path. In this kind of application, we might need to process millions of points and billions of connections, or more. As we shall see, it would be impossible to solve the problem for such an application without an efficient algorithm.</p>
<p class="docText">Similarly, the integers might represent contact points in an electrical network, and the pairs might represent wires connecting the points. In this case, we could use our program to find a way to connect all the points without any extraneous connections, if that is possible. There is no guarantee that the edges in the list will suffice to connect all the points&mdash;indeed, we shall soon see that determining whether or not they will could be a prime application of our program.</p>
<p class="docText"><a class="docLink" href="#ch01fig02">Figure 1.2</a> illustrates these two types of applications in a larger example. Examination of this figure gives us an appreciation for the <a name="iddle2608"></a>difficulty of the connectivity problem: How can we arrange to tell quickly whether <span class="docEmphasis">any</span> given two points in such a network are connected?</p>
<a name="ch01fig02"></a><p><center>
<h5 class="docFigureTitle">Figure 1.2. A large connectivity example</h5>
<h5></h5><h5></h5></center></p><p class="docText">The objects in a connectivity problem might represent connection points, and the pairs might be connections between them, as indicated in this idealized example that might represent wires connecting buildings in a city or components on a computer chip. This graphical representation makes it possible for a human to spot nodes that are not connected, but the algorithm has to work with only the pairs of integers that it is given. Are the two nodes marked with the large black dots connected?</p>
<p class="docText">
<img border="0" alt="" width="300" height="294" src="01fig02.gif" /></p>
<br />
<p class="docText">Still another example arises in certain programming environments where it is possible to declare two variable names as equivalent. The problem is to be able to determine whether two given names are equivalent, after a sequence of such declarations. This application is an early one that motivated the development of several of the algorithms that we are about to consider. It directly relates our problem to a simple abstraction that provides us with a way to make our algorithms useful for a wide variety of applications, as we shall see.</p>
<p class="docText">Applications such as the variable-name&ndash;equivalence problem described in the previous paragraph require that we associate an integer with each distinct variable name. This association is also implicit in the <a name="iddle2126"></a><a name="iddle2427"></a>network-connection and circuit-connection applications that we have described. We shall be considering a host of algorithms in <a class="docLink" href="ch10.html#ch10">Chapters 10</a> through <a class="docLink" href="ch16.html#ch16">16</a> that can provide this association in an efficient manner. Thus, we can assume in this chapter, without loss of generality, that we have <span class="docEmphasis">N</span> objects with integer names, from <span class="docEmphasis"><tt>0</tt></span> to <span class="docEmphasis"><tt>N</tt></span> &ndash; <tt>1</tt>.</p>
<p class="docText">We are asking for a program that does a specific and well-defined task. There are many other related problems that we might want to have solved, as well. One of the first tasks that we face in developing an algorithm is to be sure that we have specified the <span class="docEmphasis">problem</span> in a reasonable manner. The more we require of an algorithm, the more time and space we may expect it to need to finish the task. It is impossible to quantify this relationship a priori, and we often modify a problem specification on finding that it is difficult or expensive to solve, or, in happy circumstances, on finding that an algorithm can provide information more useful than was called for in the original specification.</p>
<p class="docText">For example, our connectivity-problem specification requires only that our program somehow know whether or not any given pair <tt>p-q</tt> is connected, and not that it be able to demonstrate any or all ways to connect that pair. Adding a requirement for such a specification makes the problem more difficult, and would lead us to a different family of algorithms, which we consider briefly in <a class="docLink" href="ch05.html#ch05">Chapter 5</a> and in detail in Part 7.</p>
<p class="docText">The specifications mentioned in the previous paragraph ask us for <span class="docEmphasis">more</span> information than our original one did; we could also ask for <span class="docEmphasis">less</span> information. For example, we might simply want to be able to answer the question: &quot;Are the <span class="docEmphasis">M</span> connections sufficient to connect together all <span class="docEmphasis">N</span> objects?&quot; This problem illustrates that, to develop efficient algorithms, we often need to do high-level reasoning about the abstract objects that we are processing. In this case, a fundamental result from graph theory implies that all <span class="docEmphasis">N</span> objects are connected if and only if the number of pairs output by the connectivity algorithm is precisely <span class="docEmphasis"><tt>N</tt></span> &ndash; <tt>1</tt> (see <a class="docLink" href="ch05lev1sec4.html#ch05lev1sec4">Section 5.4</a>). In other words, a connectivity algorithm will never output more than <span class="docEmphasis"><tt>N</tt></span> &ndash; <tt>1</tt> pairs, because, once it has output <span class="docEmphasis">N &ndash; 1</span> pairs, any pair that it encounters from that point on will be connected. Accordingly, we can get a program that answers the yes&ndash;no question just posed by changing a program that solves the connectivity problem to one that increments a counter, rather than <a name="iddle1022"></a><a name="iddle1034"></a><a name="iddle1293"></a><a name="iddle1297"></a><a name="iddle1548"></a><a name="iddle2425"></a><a name="iddle2564"></a><a name="iddle2601"></a>writing out each pair that was not previously connected, answering &quot;yes&quot; when the counter reaches <span class="docEmphasis">N &ndash; 1</span> and &quot;no&quot; if it never does. This question is but one example of a host of questions that we might wish to answer regarding connectivity. The set of pairs in the input is called a <span class="docEmphasis">graph</span>, and the set of pairs output is called a <span class="docEmphasis">spanning tree</span> for that graph, which connects all the objects. We consider properties of graphs, spanning trees, and all manner of related algorithms in Part 7.</p>
<p class="docText">It is worthwhile to try to identify the fundamental operations that we will be performing, and so to make any algorithm that we develop for the connectivity task useful for a variety of similar tasks. Specifically, each time that we get a new pair, we have first to determine whether it represents a new connection, then to incorporate the information that the connection has been seen into its understanding about the connectivity of the objects such that it can check connections to be seen in the future. We encapsulate these two tasks as <span class="docEmphasis">abstract operations</span> by considering the integer input values to represent elements in abstract sets, and then design algorithms and data structures that can</p>
<ul><li><p class="docList"><span class="docEmphasis">Find</span> the set containing a given item.</p></li><li><p class="docList">Replace the sets containing two given items by their <span class="docEmphasis">union</span>.</p></li></ul>
<p class="docText">Organizing our algorithms in terms of these abstract operations does not seem to foreclose any options in solving the connectivity problem, and the operations may be useful for solving other problems. Developing ever more powerful layers of abstraction is an essential process in computer science in general and in algorithm design in particular, and we shall turn to it on numerous occasions throughout this book. In this chapter, we use abstract thinking in an informal way to guide us in designing programs to solve the connectivity problem; in <a class="docLink" href="ch04.html#ch04">Chapter 4</a>, we shall see how to encapsulate abstractions in C++ code.</p>
<p class="docText">The connectivity problem is easily solved in terms of the <span class="docEmphasis">find</span> and <span class="docEmphasis">union</span> abstract operations. After reading a new pair <tt>p-q</tt> from the input, we perform a <span class="docEmphasis">find</span> operation for each member of the pair. If the members of the pair are in the same set, we move on to the next pair; if they are not, we do a <span class="docEmphasis">union</span> operation and write out the pair. The sets represent <span class="docEmphasis">connected components</span>: subsets of the objects with the property that any two objects in a given component are connected. This approach reduces the development of an algorithmic solution for connectivity to the tasks of defining a data structure representing the <a name="iddle1294"></a><a name="iddle2163"></a><a name="iddle2604"></a>sets and developing <span class="docEmphasis">union</span> and <span class="docEmphasis">find</span> algorithms that efficiently use that data structure.</p>
<p class="docText">There are many possible ways to represent and process abstract sets, which we consider in more detail in <a class="docLink" href="ch04.html#ch04">Chapter 4</a>. In this chapter, our focus is on finding a representation that can support efficiently the <span class="docEmphasis">union</span> and <span class="docEmphasis">find</span> operations that we see in solving the connectivity problem.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa1q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">1.1</span> Give the output that a connectivity algorithm should produce when given the input <tt>0-2, 1-4, 2-5, 3-6, 0-4, 6-0,</tt> and <tt>1-3</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa1q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">1.2</span> List all the different ways to connect two different objects for the example in <a class="docLink" href="#ch01fig01">Figure 1.1</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch01qa1q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">1.3</span> Describe a simple method for counting the number of sets remaining after using the <span class="docEmphasis">union</span> and <span class="docEmphasis">find</span> operations to solve the connectivity problem as described in the text.</p></td></tr></table></p>
<a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch01lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch01lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>