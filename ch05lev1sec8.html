<html><head><title>5.8. Graph Traversal</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch05lev1sec7.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch05lev1sec9.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch05lev1sec8"></a>
<h3 id="title-IDAVXO3H" class="docSection1Title">5.8. Graph Traversal</h3>
<p class="docText">For our final example of a recursive program in this chapter, we consider one of the most important of all recursive programs: recursive graph traversal, or <span class="docEmphasis">depth-first search</span>. This method for systematically visiting all the nodes in a graph is a direct generalization of the tree-traversal methods that we considered in <a class="docLink" href="ch05lev1sec6.html#ch05lev1sec6">Section 5.6</a>, and it serves as the basis for many basic algorithms for processing graphs (see Part 7). It is a simple recursive algorithm. Starting at any node <span class="docEmphasis">v</span>, we</p>
<ul><li><p class="docList">Visit <span class="docEmphasis">v</span>.</p></li><li><p class="docList">(Recursively) visit each (<span class="docEmphasis">unvisited</span>) node attached to <span class="docEmphasis">v</span>.</p></li></ul>
<p class="docText">If the graph is connected, we eventually reach all of the nodes. <a class="docLink" href="#ch05ex37">Program 5.21</a> is an implementation of this recursive procedure.</p>
<p class="docText">For example, suppose that we use the adjacency-list representation depicted in the sample graph in <a class="docLink" href="ch03lev1sec7.html#ch03fig15">Figure 3.15</a>. <a class="docLink" href="#ch05fig32">Figure 5.32</a> shows the recursive calls made during the depth-first search of this graph, and the sequence on the left in <a class="docLink" href="#ch05fig33">Figure 5.33</a> depicts the way in which we follow the edges in the graph. We follow each edge in the graph, with one of two possible outcomes: if the edge takes us to a node that we have already visited, we ignore it; if it takes us to a node that we have not yet visited, we follow it there via a recursive call. The set of all edges that we follow in this way forms a spanning tree for the graph.</p>
<a name="ch05fig32"></a><p><center>
<h5 class="docFigureTitle">Figure 5.32. Depth-first&ndash;search function calls</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence of function calls constitutes depth-first search for the example graph in <a class="docLink" href="ch03lev1sec7.html#ch03fig15">Figure 3.15</a>. The tree that depicts the recursive-call structure <span class="docEmphasis">(top)</span> is called the depth-first&ndash;search tree.</p>
<p class="docText">
<img border="0" alt="" width="175" height="489" src="05fig32.gif" /></p>
<br />
<a name="ch05fig33"></a><p><center>
<h5 class="docFigureTitle">Figure 5.33. Depth-first search and breadth-first search</h5>
<h5></h5><h5></h5></center></p><p class="docText">Depth-first search <span class="docEmphasis">(left)</span> moves from node to node, backing up to the previous node to try the next possibility whenever it has tried every possibility at a given node. Breadth-first search <span class="docEmphasis">(right)</span> exhausts all the possibilities at one node before moving to the next.</p>
<p class="docText">
<img border="0" alt="" width="275" height="709" src="05fig33.gif" /></p>
<br />
<p class="docText">The difference between depth-first search and general tree traversal (see <a class="docLink" href="ch05lev1sec6.html#ch05ex29">Program 5.14</a>) is that we need to guard explicitly against visiting nodes that we have already visited. In a tree, we never encounter any such nodes. Indeed, if the graph is a tree, recursive depth-first search starting at the root is equivalent to preorder traversal.</p>
<a name="ch05ex36"></a><h5 id="title-IDAW2O3H" class="docExampleTitle">Property 5.10. Depth-first search requires time proportional to <span class="docEmphasis">V</span> + <span class="docEmphasis">E</span> in a graph with <span class="docEmphasis">V</span> vertices and <span class="docEmphasis">E</span> edges, using the adjacency lists representation.</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">In the adjacency lists representation, there is one list node corresponding to each edge in the graph, and one list head pointer corresponding to each vertex in the graph. Depth-first search touches all of them, at most once.</p>
</td></tr></table></p>
<p class="docText"></p><a name="ch05ex37"></a><h5 id="title-IDAR3O3H" class="docExampleTitle">Program 5.21. Depth-first search</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1554"></a><a name="iddle2132"></a>To visit all the nodes connected to node <span class="docEmphasis">k</span> in a graph, we mark it as <span class="docEmphasis">visited</span>, then (recursively) visit the all unvisited nodes on <span class="docEmphasis">k</span>'s adjacency list.</p>
<div class="docText"><pre>void traverse(int k, void visit(int))
  { visit(k); visited[k] = 1;
    for (link t = adj[k]; t != 0; t = t-&gt;next)
      if (!visited[t-&gt;v]) traverse(t-&gt;v, visit);
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">Because it also takes time proportional to <span class="docEmphasis">V</span> + <span class="docEmphasis">E</span> to build the adjacency lists representation from an input sequence of edges (see <a class="docLink" href="ch03lev1sec7.html#ch03ex22">Program 3.19</a>), depth-first search gives us a linear-time solution to the connectivity problem of <a class="docLink" href="ch01.html#ch01">Chapter 1</a>. For huge graphs, however, the union&ndash;find solutions might still be preferable, because representing the whole graph takes space proportional to <span class="docEmphasis">E</span>, while the union&ndash;find solutions take space only proportional to <span class="docEmphasis">V</span>.</p>
<p class="docText">As we did with tree traversal, we can define a graph-traversal method that uses an explicit stack, as depicted in <a class="docLink" href="#ch05fig34">Figure 5.34</a>. We can think of an abstract stack that holds dual entries: a node and a pointer into that node's adjacency list. With the stack initialized to the start node and a pointer initialized to the first node on that node's adjacency list, the depth-first search algorithm is equivalent to entering into a loop, where we visit the node at the top of the stack (if it has not already been visited); save the node referenced by the current adjacency-list pointer; update the adjacency list reference to the next node (popping the entry if at the end of the adjacency list); and push a stack entry for the saved node, referencing the first node on its adjacency list.</p>
<a name="ch05fig34"></a><p><center>
<h5 class="docFigureTitle">Figure 5.34. Depth-first&ndash;search stack dynamics</h5>
<h5></h5><h5></h5></center></p><p class="docText">We can think of the pushdown stack supporting depth-first search as containing a node and a reference to that node's adjacency list (indicated by a circled node) <span class="docEmphasis">(left)</span>. Thus, we begin with node 0 on the stack, with reference to the first node on its list, node 7. Each line indicates the result of popping the stack, pushing a reference to the next node on the list for nodes that have been visited, and pushing an entry on the stack for nodes that have not been visited. Alternatively, we can think of the process as simply pushing all nodes adjacent to any unvisited node onto the stack <span class="docEmphasis">(right)</span>.</p>
<p class="docText">
<img border="0" alt="" width="350" height="400" src="05fig34.gif" /></p>
<br />
<p class="docText">Alternatively, as we did for tree traversal, we can consider the stack to contain links to nodes only. With the stack initialized to the start node, we enter into a loop where we visit the node at the top of the stack (if it has not already been visited), then push all the nodes adjacent to it onto the stack. <a class="docLink" href="#ch05fig34">Figure 5.34</a> illustrates that both of these <a name="iddle1238"></a><a name="iddle2321"></a><a name="iddle1029"></a><a name="iddle2133"></a>methods are equivalent to depth-first search for our example graph, and the equivalence indeed holds in general.</p>
<p class="docText">The visit-the-top-node-and-push-all-its-neighbors algorithm is a simple formulation of depth-first search, but it is clear from <a class="docLink" href="#ch05fig34">Figure 5.34</a> that it suffers the disadvantage of possibly leaving multiple copies of each node on the stack. It does so even if we test whether each node that is about to go on the stack has been visited and refrain from putting the node in the stack if it has been. To avoid this problem, we can use a stack implementation that disallows duplicates by using a forget-the-old-item policy, because the copy nearest the top of the stack is always the first one visited, so the others are simply popped.</p>
<p class="docText">The stack dynamics for depth-first search that are illustrated in <a class="docLink" href="#ch05fig34">Figure 5.34</a> depend on the nodes on each each adjacency list ending up on the stack in the same order that they appear in the list. To get this ordering for a given adjacency list when pushing one node at a time, we would have to push the last node first, then the next-to-last node, <a name="iddle1239"></a><a name="iddle2322"></a>and so forth. Moreover, to limit the stack size to the number of vertices while at the same time visiting the nodes in the same order as in depth-first search, we need to use a stack discipline with a forget-the-old-item policy. If visiting the nodes in the same order as depth-first search is not important to us, we can avoid both of these complications and directly formulate a nonrecursive stack-based graph-traversal method: With the stack initialized to the start node, we enter into a loop where we visit the node at the top of the stack, then proceed through its adjacency list, pushing each node onto the stack (if the node has not been visited already), using a stack implementation that disallows duplicates with an ignore-the-new-item policy. This algorithm visits all the nodes in the graph in a manner similar to depth-first-search, but it is not recursive.</p>
<a name="ch05ex38"></a><h5 id="title-IDAQ1OJF" class="docExampleTitle">Program 5.22. Breadth-first search</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">To visit all the nodes connected to node <span class="docEmphasis">k</span> in a graph, we put <span class="docEmphasis">k</span> onto a FIFO queue, then enter into a loop where we get the next node from the queue, and, if it has not been visited, visit it and push all the unvisited nodes on its adjacency list, continuing until the queue is empty.</p>
<div class="docText"><pre>void traverse(int k, void visit(int))
  {
    QUEUE&lt;int&gt; q(V*V);
    q.put(k);
    while (!q.empty())
      if (visited[k = q.get()] == 0)
        {
          visit(k); visited[k] = 1;
          for (link t = adj[k]; t != 0; t = t-&gt;next)
            if (visited[t-&gt;v] == 0) q.put(t-&gt;v);
        }
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">The algorithm in the previous paragraph is noteworthy because we could use any generalized queue ADT, and still visit each of the nodes in the graph (and generate a spanning tree). For example, if we use a queue instead of a stack, then we have <span class="docEmphasis">breadth-first search</span>, which is analogous to level-order traversal in a tree. <a class="docLink" href="#ch05ex38">Program 5.22</a> is an implementation of this method (assuming that we use a queue implementation like <a class="docLink" href="ch04lev1sec5.html#ch04ex15">Program 4.12</a>); an example of the algorithm in operation is depicted in <a class="docLink" href="#ch05fig35">Figure 5.35</a>. In Part 6, we shall examine numerous graph algorithms based on more sophisticated generalized queue ADTs.</p>
<a name="ch05fig35"></a><p><center>
<h5 class="docFigureTitle">Figure 5.35. Breadth-first&ndash;search queue dynamics</h5>
<h5></h5><h5></h5></center></p><p class="docText">We start with <span class="docEmphasis">0</span> on the queue, then get <span class="docEmphasis">0</span>, visit it, and put the nodes on its adjacency list <span class="docEmphasis">7 5 2 1 6</span>, in that order onto the queue. Then we get <span class="docEmphasis">7</span>, visit it, and put the nodes on its adjacency list, and so forth. With duplicates disallowed with an ignore-the-new-item policy <span class="docEmphasis">(right)</span>, we get the same result without any extraneous queue entries.</p>
<p class="docText">
<img border="0" alt="" width="400" height="224" src="05fig35.gif" /></p>
<br />
<p class="docText">Breadth-first search and depth-first search both visit all the nodes in a graph, but their manner of doing so is dramatically different, as illustrated in <a class="docLink" href="#ch05fig36">Figure 5.36</a>. Breadth-first search amounts to an army of searchers fanning out to cover the territory; depth-first search corresponds to a single searcher probing unknown territory as deeply as possible, retreating only when hitting dead ends. These are basic problem-solving paradigms of significance in many areas of computer science beyond graph searching.</p>
<a name="ch05fig36"></a><p><center>
<h5 class="docFigureTitle">Figure 5.36. Graph-traversal trees</h5>
<h5></h5><h5></h5></center></p><p class="docText">This diagram shows depth-first search <span class="docEmphasis">(center)</span> and breadth-first search <span class="docEmphasis">(bottom)</span>, halfway through searching in a large graph <span class="docEmphasis">(top)</span>. Depth-first search meanders from one node to the next, so most nodes are connected to just two others. By contrast, breadth-first search sweeps through the graph, visiting all the nodes connected to a given node before moving on, so several nodes are connected to many others.</p>
<p class="docText">
<img border="0" alt="" width="120" height="382" src="05fig36.gif" /></p>
<br />
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa8q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.92</span> Show how recursive depth-first search visits the nodes in the graph built for the edge sequence 0-2, 1-4, 2-5, 3-6, 0-4, 6-0,and 1-3 (see <a class="docLink" href="ch03lev1sec7.html#ch03qa7q9">Exercise 3.70</a>), by giving diagrams corresponding to <a class="docLink" href="#ch05fig33">Figures 5.33</a> (left) and <a class="docLink" href="#ch05fig34">5.34</a> (right).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa8q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.93</span> Show how stack-based depth-first search visits the nodes in the graph built for the edge sequence 0-2, 1-4, 2-5, 3-6, 0-4, 6-0, and 1-3, by giving diagrams corresponding to <a class="docLink" href="#ch05fig33">Figures 5.33</a> (left) and <a class="docLink" href="#ch05fig34">5.34</a> (right).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa8q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.94</span> Show how (queue-based) breadth-first search visits the nodes in the graph built for the edge sequence 0-2, 1-4, 2-5, 3-6, 0-4, 6-0, and 1-3, by giving diagrams corresponding to <a class="docLink" href="#ch05fig33">Figures 5.33</a> (right) and <a class="docLink" href="#ch05fig35">5.35</a> (left).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa8q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.95</span> Why is the running time in <a class="docLink" href="#ch05ex36">Property 5.10</a> quoted as <span class="docEmphasis">V</span> + <span class="docEmphasis">E</span> and not simply <span class="docEmphasis">E</span>?</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa8q5"></a><b></b></td><td><p class="docText"><a name="iddle2545"></a><span class="docEmphStrong">5.96</span> Show how stack-based depth-first search visits the nodes in the example graph in the text (<a class="docLink" href="ch03lev1sec7.html#ch03fig15">Figure 3.15</a>) when using a forget-the-old-item policy, by giving diagrams corresponding to <a class="docLink" href="#ch05fig33">Figures 5.33</a> (left) and <a class="docLink" href="#ch05fig35">5.35</a> (right).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa8q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.97</span> Show how stack-based depth-first search visits the nodes in the example graph in the text (<a class="docLink" href="ch03lev1sec7.html#ch03fig15">Figure 3.15</a>) when using an ignore-the-new-item policy, by giving diagrams corresponding to <a class="docLink" href="#ch05fig33">Figures 5.33</a> (left) and <a class="docLink" href="#ch05fig35">5.35</a> (right).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa8q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">5.98</span> Implement a stack-based depth-first search for graphs that are represented with adjacency lists.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa8q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.99</span> Implement a recursive depth-first search for graphs that are represented with adjacency lists.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch05lev1sec7.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch05lev1sec9.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>