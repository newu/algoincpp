<html><head><title>10.5. LSD Radix Sort</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch10lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch10lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch10lev1sec5"></a>
<h3 id="title-IDAQQR5H" class="docSection1Title">10.5. LSD Radix Sort</h3>
<p class="docText">An alternative radix-sorting method is to examine the bytes from right to left. <a class="docLink" href="#ch10fig14">Figure 10.14</a> shows how our three-letter word sorting task is accomplished in just three passes through the file. We sort the file according to the final letter (using key-indexed counting), then according to the middle letter, then according to the first letter.</p>
<a name="ch10fig14"></a><p><center>
<h5 class="docFigureTitle">Figure 10.14. LSD radix sort example</h5>
<h5></h5><h5></h5></center></p><p class="docText">Three-letter words are sorted in three passes <span class="docEmphasis">(left to right)</span> with LSD radix sorting.</p>
<p class="docText">
<img border="0" alt="" width="150" height="640" src="10fig14.gif" /></p>
<br />
<p class="docText">It is not easy, at first, to be convinced that the method works; in fact, it does not work at all unless the sort method used is <span class="docEmphasis">stable</span> (see <a class="docLink" href="ch06lev1sec1.html#ch06ex02">Definition 6.1</a>). Once stability has been identified as being significant, a simple proof that LSD radix sorting works is easy to articulate: After putting keys into order on their <span class="docEmphasis">i</span> trailing bytes (in a stable manner), we know that any two keys appear in proper order (on the basis of the bits so far examined) in the file either because the first of their <span class="docEmphasis">i</span> trailing bytes are different, in which case the sort on that byte put them in the proper order, or because the first of their <span class="docEmphasis">i</span>th trailing bytes are the same, in which case they are in proper order because of stability. Stated another way, if the <span class="docEmphasis">w - i</span> bytes that have not been examined for a pair of keys are identical, any difference between the keys is restricted to the <span class="docEmphasis">i</span> bytes already examined, and the keys have been properly ordered, and will remain so because of stability. If, on the other hand, the <span class="docEmphasis">w - i</span> bytes that have not been examined are different, the <span class="docEmphasis">i</span> bytes already <a name="iddle1740"></a><a name="iddle2197"></a>examined do not matter, and a later pass will correctly order the pair based on the more-significant differences.</p>
<a name="ch10ex06"></a><h5 id="title-IDARTR5H" class="docExampleTitle">Program 10.4. LSD radix sort</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This Program implements key-indexed counting on the bytes in the words, moving right to left. The key-indexed counting implementation must be stable. If <span class="docEmphasis">R</span> is 2 (and therefore <tt>bytesword</tt> and <tt>bitsword</tt> are the same), this program is <span class="docEmphasis">straight radix sort</span>&mdash;a right-to-left bit-by-bit radix sort (see <a class="docLink" href="#ch10fig15">Figure 10.15</a>).</p>
<div class="docText"><pre>template &lt;class Item&gt;
void radixLSD(Item a[], int l, int r)
  { static Item aux[maxN];
    for (int d = bytesword-1; d &gt;= 0; d--)
      {
        int i, j, count[R+1];
        for (j = 0; j &lt; R; j++) count[j] = 0;
        for (i = l; i &lt;= r; i++)
          count[digit(a[i], d) + 1]++;
        for (j = 1; j &lt; R; j++)
          count[j] += count[j-1];
        for (i = l; i &lt;= r; i++)
          aux[count[digit(a[i], d)]++] = a[i];
        for (i = l; i &lt;= r; i++) a[i] = aux[i];
      }
  }</pre></div><br />
</td></tr></table></p>
<a name="ch10fig15"></a><p><center>
<h5 class="docFigureTitle">Figure 10.15. LSD (binary) radix sort example (key bits exposed)</h5>
<h5></h5><h5></h5></center></p><p class="docText">This diagram depicts a right-to-left bit-by-bit radix sort working on our file of sample keys. We compute the ith column from the (i - <span class="docEmphasis">1</span>)st column by extracting (in a stable manner) all the keys with a 0 in the ith bit, then all the keys with a 1 in the ith bit. If the (i - <span class="docEmphasis">1</span>)st column is in order on the trailing (i - <span class="docEmphasis">1</span>) bits of the keys before the operation, then the ith column is in order on the trailing i bits of the keys after the operation. The movement of the keys in the third stage is indicated explicitly.</p>
<p class="docText">
<img border="0" alt="" width="500" height="240" src="10fig15.gif" /></p>
<br />
<p class="docText">The stability requirement means, for example, that the partitioning method used for binary quicksort could not be used for a binary version of this right-to-left sort. On the other hand, key-indexed counting <span class="docEmphasis">is</span> stable, and immediately leads to a classic and efficient algorithm. <a class="docLink" href="#ch10ex06">Program 10.4</a> is an implementation of this method. An auxiliary array for the distribution seems to be required&mdash;the technique of <a class="docLink" href="ch10lev1sec3.html#ch10qa3q4">Exercises 10.17</a> and <a class="docLink" href="ch10lev1sec3.html#ch10qa3q5">10.18</a> for doing the distribution in place sacrifices stability to avoid using the auxiliary array.</p>
<p class="docText">LSD radix sorting is the method used by old computer-card&ndash;sorting machines. Such machines had the capability of distributing a deck of cards among 10 bins, according to the pattern of holes punched in the selected columns. If a deck of cards had numbers <a name="iddle2034"></a><a name="iddle2462"></a>punched in a particular set of columns, an operator could sort the cards by running them through the machine on the rightmost digit, then picking up and stacking the output decks in order, then running them through the machine on the next-to-rightmost digit, and so forth, until getting to the first digit. The physical stacking of the cards is a stable process, which is mimicked by key-indexed counting sort. Not only was this version of LSD radix sorting important in commercial applications in the 1950s and 1960s, but it was also used by many cautious programmers, who would punch sequence numbers in the final few columns of a program deck so as to be able to put the deck back in order mechanically if it were accidentally dropped.</p>
<p class="docText"><a class="docLink" href="#ch10fig15">Figure 10.15</a> depicts the operation of binary LSD radix sort on our sample keys, for comparison with <a class="docLink" href="ch10lev1sec2.html#ch10fig03">Figure 10.3</a>. For these 5-bit keys, the sort is completed in five passes, moving right to left through the keys. Sorting records with single-bit keys amounts to partitioning the file such that all the records with 0 keys appear before all the records with 1 keys. As just mentioned, we cannot use the partitioning strategy that we discussed at the beginning of this chapter in <a class="docLink" href="ch10lev1sec2.html#ch10ex03">Program 10.1</a>, even though it seems to solve this same problem, because it is not stable. It is worthwhile to look at radix-2 sorting, because it is often appropriate for high-performance machines and special-purpose hardware (see <a class="docLink" href="#ch10qa5q7">Exercise 10.38</a>). In software, we use as many bits as we can to reduce the number of passes, limited only by the size of the array for the counts (see <a class="docLink" href="#ch10fig16">Figure 10.16</a>).</p>
<a name="ch10fig16"></a><p><center>
<h5 class="docFigureTitle">Figure 10.16. Dynamic characteristics of LSD radix sort</h5>
<h5></h5><h5></h5></center></p><p class="docText">This diagram shows the stages of LSD radix sort on random 8-bit keys, for both radix 2 <span class="docEmphasis">(left)</span> and radix 4, which comprises every other stage from the radix-2 diagram <span class="docEmphasis">(right)</span>. For example, when two bits remain (second-to-last stage on the left, next-to-last stage on the right), the file consists of four intermixed sorted subfiles consisting of the keys beginning with 00, 01, 10, and 11.</p>
<p class="docText">
<img border="0" alt="" width="165" height="476" src="10fig16.gif" /></p>
<br />
<p class="docText">It is typically difficult to apply the LSD approach to a string-sorting application because of variable-length keys. For MSD sorting, <a name="iddle2209"></a><a name="iddle2310"></a>it is simple enough to distinguish keys according to their leading bytes, but LSD sorting is based on a fixed-length key, with the leading keys getting involved for only the final pass. Even for (long) fixed-length keys, LSD radix sorting would seem to be doing unnecessary work on the right parts of the keys, since, as we have seen, only the left parts of the keys are typically used in the sort. We shall see a way to address this problem in <a class="docLink" href="ch10lev1sec7.html#ch10lev1sec7">Section 10.7</a>, after we have examined the properties of radix sorts in detail.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa5q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.32</span> Using the key generator of <a class="docLink" href="ch10lev1sec3.html#ch10qa3q6">Exercise 10.19</a>, run LSD radix sort for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>,and 10<sup>6</sup>. Compare its performance with that of MSD radix sort.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa5q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.33</span> Using the key generators of <a class="docLink" href="ch10lev1sec3.html#ch10qa3q8">Exercises 10.21</a> and <a class="docLink" href="ch10lev1sec3.html#ch10qa3">10.23</a>, run LSD radix sort for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>. Compare its performance with that of MSD radix sort.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa5q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.34</span> Show the (unsorted) result of trying to use an LSD radix sort based on the binary quicksort partitioning method for the example of <a class="docLink" href="#ch10fig15">Figure 10.15</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa5q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">10.35</span> Show the result of using LSD radix sort on the leading two characters for the set of keys <tt>now is the time for all good people to come the aid of their party</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa5q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">10.36</span> Develop an implementation of LSD radix sort using linked lists.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa5q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">10.37</span> Find an efficient method that (<span class="docEmphasis">i</span>) rearranges the records of a file such that all those whose keys begin with a 0 bit come before all those whose keys begin with a 1 bit, (<span class="docEmphasis">ii</span>) uses extra space proportional to the square root of the number of records (or less), and (<span class="docEmphasis">iii</span>) is stable.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa5q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">10.38</span> Implement a routine that sorts an array of 32-bit words using only the following abstract operation: Given a bit position <span class="docEmphasis">i</span> and a pointer into the array <tt>a[k]</tt>, rearrange <tt>a[k], a[k+1], ..., a[k+63]</tt> in a stable manner such that those words with a 0 bit in position <span class="docEmphasis">i</span> appear before those words with a 1 bit in position <span class="docEmphasis">i</span>.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch10lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch10lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>