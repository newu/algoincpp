<html><head><title>8.4. Improvements to the Basic Algorithm</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch08lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch08lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch08lev1sec4"></a>
<h3 id="643999-993" class="docSection1Title">8.4. Improvements to the Basic Algorithm</h3>
<p class="docText"><a name="iddle1655"></a><a name="iddle1840"></a><a name="iddle1891"></a><a name="iddle1896"></a><a name="iddle2171"></a>As we saw with quicksort, we can improve most recursive algorithms by handling small cases differently. The recursion guarantees that the method will be used often for small cases, so improvements in handling them lead to improvements in the whole algorithm. Thus, just as it did with quicksort, switching to insertion sort for small subfiles will improve the running time of a typical mergesort implementation by 10 to 15 percent.</p>
<p class="docText">A second improvement that is reasonable to consider for mergesort is to eliminate the time taken to copy to the auxiliary array used for merging. To do so, we arrange the recursive calls such that the computation switches the roles of the input array and the auxiliary array at each level. One way to proceed is to implement two versions of the routines&mdash;one taking its input in <tt>aux</tt> and its output in <tt>a</tt>, and the other taking its input in <tt>a</tt> and its output in <tt>aux</tt>&mdash;then having the two versions call each other. A different approach is shown in <a class="docLink" href="#ch08ex08">Program 8.4</a>, which makes one copy of the array at the beginning, then uses <a class="docLink" href="ch08lev1sec1.html#ch08ex01">Program 8.1</a> and switches arguments in the recursive calls to eliminate the explicit array copy operation. Instead, we switch back and forth between putting the merged output in the auxiliary array and putting it in the input array. (This program is a tricky one.)</p>
<p class="docText">This technique eliminates the array copy at the expense of putting back into the inner loop the tests for whether the input arrays are exhausted. (Recall that our technique for eliminating those tests in <a class="docLink" href="ch08lev1sec2.html#ch08ex02">Program 8.2</a> involved making the array bitonic during the copy.) That loss can be regained via a recursive implementation of the same idea: We implement routines for both merge and mergesort, one each for putting arrays in increasing order and in decreasing order. With this strategy, it is possible to bring back the bitonic strategy, and thus to arrange that the inner loop for the merge never needs sentinels.</p>
<p class="docText">Given that it uses up to four copies of the basic routines and some mindbending recursive argument switchery, this superoptimization is only recommended for experts (or students!), but it does speed up mergesort considerably. The experimental results that we discuss in <a class="docLink" href="ch08lev1sec6.html#ch08lev1sec6">Section 8.6</a> indicate that the combination of all these improvements speeds up mergesort by a factor of about 40 percent, but still leaves mergesort about 25 percent slower than quicksort. These numbers are dependent on the implementation and on the machine, but similar results are likely in a variety of situations.</p>
<a name="ch08ex08"></a><h5 id="title-IDAIVYXE" class="docExampleTitle">Program 8.4. Mergesort with no copying</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This recursive program is set up to sort <tt>b</tt>, leaving the result in <tt>a</tt>. Thus, the recursive calls are written to leave their result in <tt>b</tt>, and we use <a class="docLink" href="ch08lev1sec1.html#ch08ex01">Program 8.1</a> to merge those files from <tt>b</tt> into <tt>a</tt>. In this way, all the data movement is done during the course of the merges.</p>
<div class="docText"><pre>    template &lt;class Item&gt;
    void mergesortABr(Item a[], Item b[], int l, int r)
      { if (r-l &lt;= 10) { insertion(a, l, r); return; }
        int m = (l+r)/2;
        mergesortABr(b, a, l, m);
        mergesortABr(b, a, m+1, r);
        mergeAB(a+l, b+l, m-l+1, b+m+1, r-m);
      }
    template &lt;class Item&gt;
    void mergesortAB(Item a[], int l, int r)
      { static Item aux[maxN];
        for (int i = l; i &lt;= r; i++) aux[i] = a[i];
        mergesortABr(a, aux, l, r);
      }</pre></div><br />
</td></tr></table></p>
<p class="docText">Other implementations of merging that involve an explicit test for the first file being exhausted may lead to a greater variation of running time depending on the input, but not to much of one. In random files, the size of the other subfile when the first subfile exhausts will be small, and the cost of moving to the auxiliary array still will be proportional to the subfile size. We might consider improving the performance of mergesort when a great deal of order is present in the file by skipping the call on <tt>merge</tt> when the file is already in sorted order, but this strategy is not effective for many types of files.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa4q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">8.16</span> Implement an abstract in-place merge that uses extra space proportional to the size of the smaller of the two arrays to be merged. (Your method should cut in half the space requirement for mergesort.)</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa4q2"></a><b></b></td><td><p class="docText"><a name="iddle1886"></a><span class="docEmphStrong">8.17</span> Run mergesort for large random files, and make an empirical determination of the average length of the other subfile when the first subfile exhausts, as a function of <span class="docEmphasis">N</span> (the sum of the two subfile sizes for a given merge).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa4q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">8.18</span> Suppose that <a class="docLink" href="ch08lev1sec3.html#ch08ex03">Program 8.3</a> is modified to skip the call on <tt>merge</tt> when <tt>a[m]&lt;a[m+1]</tt>. How many comparisons does this alternative save when the file to be sorted is already in sorted order?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa4q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">8.19</span> Run the modified algorithm suggested in <a class="docLink" href="#ch08qa4q3">Exercise 8.18</a> for large random files. Determine empirically the average number of times the merge is skipped, as a function of <span class="docEmphasis">N</span> (the original file size for the sort).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa4q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">8.20</span> Suppose that mergesort is to be run on <span class="docEmphasis">h</span> -sorted files for small <span class="docEmphasis">h</span>. How would you change the <tt>merge</tt> routine to take advantage of this property of the input? Experiment with shellsort&ndash;mergesort hybrids based on this routine.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa4q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">8.21</span> Develop a merge implementation that reduces the extra space requirement to <tt>max</tt> (<span class="docEmphasis">M</span>, <span class="docEmphasis">N</span> /<span class="docEmphasis">M</span> ), based on the following idea. Divide the array into <span class="docEmphasis">N/M</span> blocks of size <span class="docEmphasis">M</span> (for simplicity in this description, assume that <span class="docEmphasis">N</span> is a multiple of <span class="docEmphasis">M</span>). Then, (<span class="docEmphasis">i</span>) considering the blocks as records with their first key as the sort key, sort them using selection sort; and (<span class="docEmphasis">ii</span>) run through the array merging the first block with the second, then the second block with the third, and so forth.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa4q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">8.22</span> Prove that the method of <a class="docLink" href="#ch08qa4q6">Exercise 8.21</a> runs in linear time.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa4q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">8.23</span> Implement bitonic mergesort with no copying.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch08lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch08lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>