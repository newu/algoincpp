<html><head><title>8.1. Two-Way Merging</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch08.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch08lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch08lev1sec1"></a>
<h3 id="title-IDAC3YWD" class="docSection1Title">8.1. Two-Way Merging</h3>
<p class="docText">Given two ordered input files, we can combine them into one ordered output file simply by keeping track of the smallest element in each file and entering a loop where the smaller of the two elements that are <a name="iddle1075"></a><a name="iddle1908"></a>smallest in their files is moved to the output, continuing until both input files are exhausted. We shall look at several implementations of this basic abstract operation in this and the next section. The running time is linear in the number of elements in the output, as long as we can perform the operation of finding the next smallest element in a file in constant time, which is certainly the case for files that are in sorted order and represented with a data structure that supports constant-time sequential access, such as an array or a linked list. This procedure is <span class="docEmphasis">two-way merging</span>; in <a class="docLink" href="ch11.html#ch11">Chapter 11</a>, we shall look in detail at <span class="docEmphasis">multiway merging</span>, when more than two files are involved. The most important application of multiway merging is external sorting, which is discussed in detail in that chapter.</p>
<a name="ch08ex01"></a><h5 id="title-IDAO4YWD" class="docExampleTitle">Program 8.1. Merging</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">To combine two ordered arrays <tt>a</tt> and <tt>b</tt> into an ordered array <tt>c</tt>, we use a <tt>for</tt> loop that puts an element into <tt>c</tt> at each iteration. If <tt>a</tt> is exhausted, the element comes from <tt>b</tt>; if <tt>b</tt> is exhausted, the element comes from <tt>a</tt>; and if items remain in both, the smallest of the remaining elements in <tt>a</tt> and <tt>b</tt> goes to <tt>c</tt>. Beyond the implicit assumption that the arrays are ordered, this implementation assumes that the array <tt>c</tt> is disjoint from (that is, does not overlap or share storage with) <tt>a</tt> and <tt>b</tt>.</p>
<div class="docText"><pre>    template &lt;class Item&gt;
    void mergeAB(Item c[], Item a[], int N,
                           Item b[], int M )
      {
        for (int i = 0, j = 0, k = 0; k &lt; N+M; k++)
          {
            if (i == N) { c[k] = b[j++]; continue; }
            if (j == M) { c[k] = a[i++]; continue; }
            c[k] = (a[i] &lt; b[j]) ? a[i++] : b[j++];
          }
       }</pre></div><br />
</td></tr></table></p>
<p class="docText">To begin, let us suppose that we have two disjoint ordered arrays <tt>a[0], ..., a[N-1]</tt> and <tt>b[0]</tt>, <tt>...</tt>,<tt>b[M-1]</tt> of integers that we wish to merge into a third array<tt>c[0]</tt>, <tt>...</tt>,<tt>c[N+M-1]</tt>. The obvious strategy, which is easily implemented, is to choose successively for<tt>c</tt> the smallest remaining element from <tt>a</tt> and <tt>b</tt>, as shown in <a class="docLink" href="#ch08ex01">Program 8.1</a>. This <a name="iddle1660"></a><a name="iddle1910"></a>implementation is simple, but it has two important characteristics that we shall now examine.</p>
<p class="docText">First, the implementation assumes that the arrays are disjoint. In particular, if <tt>a</tt> and <tt>b</tt> are huge arrays, then a third (also huge) array <tt>c</tt> is needed to hold the output. Instead of using extra space proportional to the size of the merged file, it would be desirable to have an in-place method, so that, for example, we could combine the ordered files <tt>a[l]</tt>, <tt>...</tt>, <tt>a[m]</tt> and <tt>a[m+1]</tt>, <tt>...</tt>, <tt>a[r]</tt> into a single ordered file by moving the elements around within <tt>a[l]</tt>, <tt>...</tt>, <tt>a[r]</tt>, without using a significant amount of other extra space. It is a worthwhile exercise to pause momentarily to consider how we might do that. This problem seems to be one that must be simple to solve; actually, however, the solutions that are known are complicated, especially by comparison to <a class="docLink" href="#ch08ex01">Program 8.1</a>. Indeed, it is not easy to develop an algorithm for in-place merging that can outperform the alternative of using an in-place <span class="docEmphasis">sort</span>. We shall return to this issue in <a class="docLink" href="ch08lev1sec2.html#ch08lev1sec2">Section 8.2</a>.</p>
<p class="docText">Merging has specific applications in its own right. For example, in a typical data-processing environment, we might need to maintain a large (ordered) data file, to which we will need to regularly add new entries. One approach is to <span class="docEmphasis">batch</span> each group of new entries&mdash;append them to the (much larger) main file, then resort the whole file. This situation is tailor-made for merging: A much more efficient strategy is to sort the (small) batch of new entries, then to merge the resulting small file with the large main file. Merging has many other similar applications that make its study worthwhile. Our prime interest in this chapter will be the sorting methods that are based on merging.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa1q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">8.1</span> Suppose that an ordered file of size <span class="docEmphasis">N</span> is to be combined with an unordered file of size <span class="docEmphasis">M</span>, with <span class="docEmphasis">M</span> much smaller than <span class="docEmphasis">N</span>. How many times faster than resorting is the suggested merge-based method, as a function of <span class="docEmphasis">M</span>, for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>6</sup>, and 10<sup>9</sup>? Assume that you have a sorting program that takes about <span class="docEmphasis">c</span><sub>1</sub> <span class="docEmphasis">N</span> lg <span class="docEmphasis">N</span> seconds to sort a file of size <span class="docEmphasis">N</span> and a merging program that takes about <span class="docEmphasis">c</span><sub>2</sub> (<span class="docEmphasis">N + M</span>) seconds to merge a file of size <span class="docEmphasis">N</span> with one of size <span class="docEmphasis">M</span>, with <span class="docEmphasis">c</span><sub>1</sub> <img src="U2248.GIF" border="0" /> <span class="docEmphasis">c</span><sub>2</sub>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa1q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">8.2</span> How does the strategy of using insertion sort for the whole file compare with the two methods postulated in <a class="docLink" href="#ch08qa1q1">Exercise 8.1</a>? (Assume that the small file is random, so each insertion goes about halfway into the large file, and the running time is about <span class="docEmphasis">c</span><sub>3</sub> <span class="docEmphasis">MN</span>/2, with <span class="docEmphasis">c</span><sub>3</sub> approximately the same as the other constants.)</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa1q3"></a><b></b></td><td><p class="docText"><a name="iddle1021"></a><a name="iddle1720"></a><a name="iddle1915"></a><a name="iddle2338"></a><span class="docEmphStrong">8.3</span> Describe what happens if you try to use <a class="docLink" href="#ch08ex01">Program 8.1</a> for an in-place merge, by using the call <tt>merge(a, a, N/2, a+N/2, N-N/2)</tt> for the keys <tt>A E QS U Y E I NO S T</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa1q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">8.4</span> Does <a class="docLink" href="#ch08ex01">Program 8.1</a>, called as described in <a class="docLink" href="#ch08qa1q3">Exercise 8.3</a>, produce proper output if and only if the two input subarrays are in sorted order? Prove your answer, or provide a counterexample.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch08.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch08lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>