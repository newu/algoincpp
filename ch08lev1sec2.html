<html><head><title>8.2. Abstract In-Place Merge</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch08lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch08lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch08lev1sec2"></a>
<h3 id="643999-907" class="docSection1Title">8.2. Abstract In-Place Merge</h3>
<p class="docText">Although implementing a merge seems to require extra space, we still find the <span class="docEmphasis">abstraction</span> of an in-place merge useful in the implementations of sorting methods that we examine here. In our next implementation of merging, we shall emphasize this point by using the interface <tt>merge(a, l, m, r)</tt> to indicate that the <tt>merge</tt> subroutine will put the result of merging <tt>a[l]</tt>, <tt>...</tt>, <tt>a[m]</tt> and <tt>a[m+1], ..., a[r]</tt> into a single ordered file, leaving the result in <tt>a[l]</tt>, <tt>...</tt>, <tt>a[r]</tt>. We could implement this merge routine by first copying everything to an auxiliary array and then using the basic method of <a class="docLink" href="ch08lev1sec1.html#ch08ex01">Program 8.1</a>; instead we shall consider an improvement to that approach. Although the extra <span class="docEmphasis">space</span> for the auxiliary array seems to be a fixed practical cost, we shall consider in <a class="docLink" href="ch08lev1sec4.html#ch08lev1sec4">Section 8.4</a> further improvements that allow us to avoid the the extra <span class="docEmphasis">time</span> required to copy the array.</p>
<p class="docText">The second characteristic of the basic merge that is worthy of note is that the inner loop includes two tests to determine whether the ends of the two input arrays have been reached. Of course, these two tests usually fail, and the situation thus cries out for the use of sentinel keys to allow the tests to be removed. That is, if elements with a key value larger than those of all the other keys are added to the ends of the <tt>a</tt> and <tt>aux</tt> arrays, the tests can be removed, because, when the <tt>a</tt> (<tt>b</tt>) array is exhausted, the sentinel causes the next elements for the <tt>c</tt> array to be taken from the <tt>b</tt> (<tt>a</tt>) array until the merge is complete.</p>
<p class="docText">As we saw in <a class="docLink" href="ch06.html#ch06">Chapters 6</a> and <a class="docLink" href="ch07.html#ch07">7</a>, however, it is not always easy to use sentinels, either because it might not be easy to know the largest key value or because space might not be available conveniently. For merging, there is a simple remedy, which is illustrated in <a class="docLink" href="#ch08fig01">Figure 8.1</a>. The method is based on the following idea: Given that we are resigned to copying the arrays to implement the in-place abstraction, we simply put the second array in reverse order when it is copied (at no extra <a name="iddle1233"></a><a name="iddle1701"></a><a name="iddle1917"></a>cost), so that its associated pointer moves from right to left. This arrangement leads to the largest element&mdash;in whichever array it is&mdash;serving as sentinel for the other array. <a class="docLink" href="#ch08ex02">Program 8.2</a> is an efficient implementation of the abstract in-place merge based on this idea; it serves as the basis for the sorting algorithms that we discuss later in this chapter. It still uses an auxiliary array of size proportional to the merge output, but it is more efficient than the straightforward implementation because it avoids the tests for the ends of the arrays.</p>
<a name="ch08fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 8.1. Merging without sentinels</h5>
<h5></h5><h5></h5></center></p><p class="docText">To merge two ascending files, we copy into an auxiliary array, with the second file in reverse order immediately following the first. Then, we follow thIs simple rule: Move the left or right item, whichever has the smaller key, to the output. The largest key serves as a sentinel for the other file, no matter in which file the key is. This figure illustrates how the files <tt>A R S T</tt> and <tt>G I N</tt> are merged.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="175" height="113" src="08fig01.gif" /></p>
<br />
<a name="ch08ex02"></a><h5 id="title-IDA5RRRE" class="docExampleTitle">Program 8.2. Abstract in-place merge</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This program merges without using sentinels by copying the second array into <tt>aux</tt> in reverse order back to back with the first (putting <tt>aux</tt> in <span class="docEmphasis">bitonic</span> order). The first <tt>for</tt> loop moves the first array and leaves <tt>i</tt> pointing to <tt>l</tt>, ready to begin the merge. The second <tt>for</tt> loop moves the second array, and leaves <tt>j</tt> pointing to <tt>r</tt>. Then, in the merge (the third <tt>for</tt> loop), the largest element serves as the sentinel in whichever array it is. The inner loop of this program is short (move to <tt>aux</tt>, compare, move back to <tt>a</tt>, increment <tt>i</tt> or <tt>j</tt>, increment and test <span class="docEmphasis">k</span>).</p>
<div class="docText"><pre>    template &lt;class Item&gt;
    void merge(Item a[], int l, int m, int r)
      { int i, j;
        static Item aux[maxN];
        for (i = m+1; i &gt; l; i--) aux[i-1] = a[i-1];
        for (j = m; j &lt; r; j++) aux[r+m-j] = a[j+1];
        for (int k = l; k &lt;= r; k++)
           if (aux[j] &lt; aux[i])
              a[k] = aux[j--]; else a[k] = aux[i++];
      }</pre></div><br />
</td></tr></table></p>
<p class="docText">A sequence of keys that increases, then decreases (or decreases, then increases) is referred to as a <span class="docEmphasis">bitonic</span> sequence. Sorting bitonic sequences is equivalent to merging, but it is sometimes convenient to cast a merging problem as a bitonic sorting problem; this method of avoiding sentinel tests is a simple example.</p>
<p class="docText">An important property of <a class="docLink" href="ch08lev1sec1.html#ch08ex01">Program 8.1</a> is that the merge is stable: It preserves the relative order of duplicate keys. This characteristic is easy to verify, and it is often worth making sure that stability is maintained when we implement an abstract in-place merge, because a stable merge leads immediately to stable <span class="docEmphasis">sorting</span> methods, as we shall see in <a name="iddle1378"></a><a name="iddle1884"></a><a name="iddle1902"></a><a class="docLink" href="ch08lev1sec3.html#ch08lev1sec3">Section 8.3</a>. It is not always easy to maintain stability: for example, <a class="docLink" href="ch08lev1sec1.html#ch08ex01">Program 8.1</a> is not stable (see <a class="docLink" href="#ch08qa2q2">Exercise 8.6</a>). This consideration further complicates the problem of developing a true in-place merge.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa2q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">8.5</span> Show how the keys AEQSUYEINOST are merged using <a class="docLink" href="#ch08ex02">Program 8.2</a>, in the style of the example diagrammed in <a class="docLink" href="#ch08fig01">Figure 8.1</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa2q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">8.6</span> Explain why <a class="docLink" href="#ch08ex02">Program 8.2</a> is not stable, and develop a version that is stable.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa2q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">8.7</span> What is the result when <a class="docLink" href="#ch08ex02">Program 8.2</a> is used for the keys E A S Y Q U E S T I O N?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa2q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">8.8</span> Does <a class="docLink" href="#ch08ex02">Program 8.2</a> produce proper output if and only if the two input subarrays are in sorted order? Prove your answer, or provide a counterexample.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch08lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch08lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>