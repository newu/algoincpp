<html><head><title>14.3. Linear Probing</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch14lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch14lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch14lev1sec3"></a>
<h3 id="title-IDAVRDMN" class="docSection1Title">14.3. Linear Probing</h3>
<p class="docText">If we can estimate in advance the number of elements to be put into the hash table and have enough contiguous memory available to hold all the keys with some room to spare, then it is probably not worthwhile to use any links at all in the hash table. Several methods have been devised that store <span class="docEmphasis">N</span> items in a table of size <span class="docEmphasis">M &gt; N</span>, relying on empty places in the table to help with collision resolution. Such methods are called <span class="docEmphasis">open-addressing</span> hashing methods.</p>
<p class="docText">The simplest open-addressing method is called <span class="docEmphasis">linear probing</span>: when there is a collision (when we hash to a place in the table that is already occupied with an item whose key is not the same as the search key), then we just check the next position in the table. It is customary to refer to such a check (determining whether or not a given table position holds an item with key equal to the search key) as a <span class="docEmphasis">probe</span>.</p>
<p class="docText"><a name="iddle1279"></a><a name="iddle1566"></a><a name="iddle1578"></a>Linear probing is characterized by identifying three possible outcomes of a probe: if the table position contains an item whose key matches the search key, then we have a search hit; if the table position is empty, then we have a search miss; otherwise (if the table position contains an item whose key does not match the search key) we just probe the table position with the next higher index, continuing (wrapping back to the beginning of the table if we reach the end) until either the search key or an empty table position is found. If an item containing the search key is to be inserted following an unsuccessful search, then we put it into the empty table space that terminated the search. <a class="docLink" href="#ch14ex06">Program 14.4</a> is an implementation of the symbol-table ADT using this method. The process of constructing a hash table for a sample set of keys using linear probing is shown in <a class="docLink" href="#ch14fig07">Figure 14.7</a>.</p>
<a name="ch14fig07"></a><p><center>
<h5 class="docFigureTitle">Figure 14.7. Hashing with linear probing</h5>
<h5></h5><h5></h5></center></p><p class="docText">This diagram shows the process of inserting the keys A S E R C H I N G X M P into an initially empty hash table of size 13 with open addressing, using the hash values given at the top and resolving collisions with linear probing. First, the A goes into position 7, then the S goes into position 3, then the E goes into position 9, then the R goes into position 10 after a collision at position 9, and so forth. Probe sequences that run off the right end of the table continue on the left end: for example, the final key inserted, the P, hashes to position 8, then ends up in position 5 after collisions at positions 8 through 12, then 0 throuh 5. All table positions not probed are shaded.</p>
<p class="docText">
<img border="0" alt="" width="185" height="227" src="14fig07.gif" /></p>
<br />
<p class="docText">As with separate chaining, the performance of open-addressing methods is dependent on the ratio <span class="docEmphasis">&#945; = N/M</span>, but we interpret it differently. For separate chaining, <span class="docEmphasis">&#945;</span> is the average number of items per list and is generally larger than 1. For open addressing, <span class="docEmphasis">&#945;</span> is the percentage of those table positions that are occupied; it must be less than 1. We sometimes refer to <span class="docEmphasis">&#945;</span> as the <span class="docEmphasis">load factor</span> of the hash table.</p>
<p class="docText">For a sparse table (small <span class="docEmphasis">&#945;</span>), we expect most searches to find an empty position with just a few probes. For a nearly full table (<span class="docEmphasis">&#945;</span> close to 1), a search could require a huge number of probes, and could even fall into an infinite loop when the table is completely full. Typically, we insist that the table <span class="docEmphasis">not</span> be allowed to become nearly full when using linear probing, to avoid long search times. That is, rather than using extra memory for links, we use it for extra space in the hash table that shortens probe sequences. The table size for linear probing is greater than for separate chaining, since we must have <span class="docEmphasis">M &gt; N</span>, but the total amount of memory space used may be less, since no links are used. We will discuss space-usage comparisons in detail in <a class="docLink" href="ch14lev1sec5.html#ch14lev1sec5">Section 14.5</a>; for the moment, we consider the analysis of the running time of linear probing as a function of <span class="docEmphasis">&#945;</span>.</p>
<p class="docText">The average cost of linear probing depends on the way in which the items cluster together into contiguous groups of occupied table cells, called <span class="docEmphasis">clusters</span>, when they are inserted. Consider the following two extremes in a linear probing table that is half full (<span class="docEmphasis">M</span> = 2<span class="docEmphasis">N</span>): In the best case, table positions with even indices could be empty, and table positions with odd indices could be occupied. In the worst case, <a name="iddle1747"></a>the first half of the table positions could be empty, and the second half occupied. The average length of the clusters in both cases is <span class="docEmphasis">N</span>/(2<span class="docEmphasis">N</span>) = 1/2, but the average number of probes for an unsuccessful search is 1 (all searches take at least 1 probe) plus</p>
<a name="ch14ex06"></a><h5 id="title-IDANWDMN" class="docExampleTitle">Program 14.4. Linear probing</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This symbol-table implementation keeps items in a table twice the size of the maximum number of items expected, initialized to <tt>nullItem</tt>. The table holds the items themselves; if the items are large, we can modify the item type to hold links to the items.</p>
<p class="docText">To insert a new item, we hash to a table position and scan to the right to find an unoccupied position, using null items as sentinels in unoccupied positions in precisely the same manner as in we did in key-indexed search (<a class="docLink" href="ch12lev1sec2.html#ch12ex06">Program 12.4</a>). To search for an item with a given key, we go to the key hash position and scan to look for a match, stopping when we hit an unoccupied position.</p>
<p class="docText">The constructor sets <span class="docEmphasis">M</span> such that we may expect the table to be less than half full, so the other operations will require just a few probes, if the hash function produces values that are sufficiently close to random ones.</p>
<div class="docText"><pre> private:
   Item *st;
   int N, M;
   Item nullItem;
 public:
   ST(int maxN)
     {
       N = 0; M = 2*maxN;
       st = new Item[M];
       for (int i = 0; i &lt; M; i++) st[i] = nullItem;
     }
   int count() const { return N; }
   void insert(Item item)
     { int i = hash(item.key(), M);
       while (!st[i].null()) i = (i+1) % M;
       st[i] = item; N++;
     }
   Item search(Key v)
     { int i = hash(v, M);
       while (!st[i].null())
       if (v == st[i].key()) return st[i];
         else i = (i+1) % M;
       return nullItem;
     }</pre></div><br />
</td></tr></table></p>
<div class="docText"><pre>(0+ 1 + 0 + 1 + . . .)/(2<span class="docEmphasis">N</span>) = 1/2</pre></div><br />
<p class="docText">in the best case, and is 1 plus</p>
<div class="docText"><pre>(<span class="docEmphasis">N</span> + (<span class="docEmphasis">N</span> &ndash; 1) + (<span class="docEmphasis">N</span> &ndash; 2) + . . .)/(2<span class="docEmphasis">N</span>)<img src="U2248.GIF" border="0" /><span class="docEmphasis">N</span>/4</pre></div><br />
<p class="docText">in the worst case.</p>
<p class="docText">Generalizing this argument, we find that the average number of probes for an unsuccessful search is proportional to the <span class="docEmphasis">squares</span> of the lengths of the clusters. We compute the average by computing the cost of a search miss starting at each position in the table, then dividing the total by <span class="docEmphasis">M</span>. All search misses take at least 1 probe, so we count the number of probes after the first. If a cluster is of length <span class="docEmphasis">t</span>, then the expression</p>
<div class="docText"><pre>(<span class="docEmphasis">t</span>+(<span class="docEmphasis">t</span> &ndash; 1) + . . .+ 2 + 1)/<span class="docEmphasis">M</span> =<span class="docEmphasis">t</span>(<span class="docEmphasis">t</span>+1)=(2<span class="docEmphasis">M</span>)</pre></div><br />
<p class="docText">counts the contribution of that cluster to the grand total. The sum of the cluster lengths is <span class="docEmphasis">N</span>, so, adding this cost for all cells in the table, we find that the total average cost for a search miss is 1 + <span class="docEmphasis">N</span>/(2<span class="docEmphasis">M</span>) plus the sum of the squares of the lengths of the clusters, divided by 2<span class="docEmphasis">M</span>. Given a table, we can quickly compute the average cost of unsuccessful search in that table (see <a class="docLink" href="#ch14qa3q5">Exercise 14.28</a>), but the clusters are formed by a complicated dynamic process (the linear-probing algorithm) that is difficult to characterize analytically.</p>
<a name="ch14ex07"></a><h5 id="title-IDAHC2LN" class="docExampleTitle">Property 14.3. When collisions are resolved with linear probing, the average number of probes required to search in a hash table of size <span class="docEmphasis">M</span> that contains <span class="docEmphasis">N = &#945;M</span> keys is about</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"></p><p class="docText"><img border="0" alt="" width="75" height="26" src="605equ01.jpg" /></p> and <p class="docText"><img border="0" alt="" width="110" height="35" src="605equ02.jpg" /></p></td></tr></table></p>
<p class="docText">for hits and misses, respectively.</p>
<p class="docText">Despite the relatively simple form of the results, precise analysis of linear probing is a challenging task. Knuth's completion of it in 1962 was a landmark in the analysis of algorithms (<span class="docEmphasis">see reference section</span>).</p>
</td></tr></table>
<p class="docText"><a name="iddle1591"></a><a name="iddle1599"></a><a name="iddle2273"></a>These estimates lose accuracy as <span class="docEmphasis">&#945;</span> approaches 1, but we do not need them for that case, because we should not be using linear probing in a nearly full table in any event. For smaller <span class="docEmphasis">&#945;</span>, the equations are sufficiently accurate. The following table summarizes the expected number of probes for search hits and misses with linear probing:</p>
<p><table cellspacing="0" frame="void" rules="groups" cellpadding="5"><colgroup align="left" span="5"><col width="110"></col><col width="110"></col><col width="110"></col><col width="110"></col><col width="110"></col></colgroup><thead><tr><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">load factor(<span class="docEmphasis">&#945;</span>)</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">1/2</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">2/3</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">3/4</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">9/10</p></th></tr></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText">search hit</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">1.5</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">2.0</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">3.0</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">5.5</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">search miss</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">2.5</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">5.0</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">8.5</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">55.5</p></td></tr></table></p><br />
<p class="docText">Search misses are always more expensive than hits, and both require only a few probes, on the average, in a table that is less than half full.</p>
<p class="docText">As we did with separate chaining, we leave to the client the choice of whether or not to keep items with duplicate keys in the table. Such items do not necessarily appear in contiguous positions in a linear probing table&mdash;other items with the same hash value can appear among items with duplicate keys.</p>
<p class="docText">By the very nature of the way the table is constructed, the keys in a table built with linear probing are in random order. The <span class="docEmphasis">sort</span> and <span class="docEmphasis">select</span> ADT operations require starting from scratch with one of the methods described in <a class="docLink" href="ch06.html#ch06">Chapters 6</a> through <a class="docLink" href="ch10.html#ch10">10</a>, so linear probing is not appropriate for applications where these operations are performed frequently.</p>
<p class="docText">How do we delete a key from a table built with linear probing? We cannot just remove it, because items that were inserted later might have skipped over that item, so searches for those items would terminate prematurely at the hole left by the deleted item. One solution to this problem is to rehash all the items for which this problem could arise&mdash;those between the deleted one and the next unoccupied position to the right. <a class="docLink" href="#ch14fig08">Figure 14.8</a> shows an example illustrating this process; <a class="docLink" href="#ch14ex08">Program 14.5</a> is an implementation. In a sparse table, this repair process will require only a few rehash operations, at most. Another way to implement deletion is to replace the deleted key with a sentinel key that can serve as a placeholder for searches but can be identified and reused for insertions (see <a class="docLink" href="ch14lev1sec4.html#ch14qa4q3">Exercise 14.33</a>).</p>
<a name="ch14fig08"></a><p><center>
<h5 class="docFigureTitle">Figure 14.8. Removal in a linear-probing hash table</h5>
<h5></h5><h5></h5></center></p><p class="docText">This diagram shows the process of removing the <span class="docEmphasis">X</span> from the table in <a class="docLink" href="#ch14fig07">Figure 14.7</a>. The second line shows the result of just taking the <span class="docEmphasis">X</span> out of the table, and is an unacceptable final result because the <span class="docEmphasis">M</span> and the <span class="docEmphasis">P</span> are cut off from their hash positions by the empty table position left by the <span class="docEmphasis">X</span>. Thus, we reinsert the <span class="docEmphasis">M, S, H</span>, and <span class="docEmphasis">P</span> (the keys to the right of the <span class="docEmphasis">X</span> in the same cluster), in that order, using the hash values given at the top and resolving collisions with linear probing. The <span class="docEmphasis">M</span> fills the hole left by the <span class="docEmphasis">X</span>, then the <span class="docEmphasis">S</span> and the <span class="docEmphasis">H</span> hash into the table without collisions, then the <span class="docEmphasis">P</span> winds up in position 2.</p><p class="docText">
<img border="0" alt="" width="175" height="242" src="14fig08.gif" /></p>
<br />
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa3q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">14.24</span> How long could it take, in the worst case, to insert <span class="docEmphasis">N</span> keys into an initially empty table, using linear probing?</p>
<p class="docText"></p><a name="ch14ex08"></a><h5 id="title-IDAQUYLN" class="docExampleTitle">Program 14.5. Removal from a linear-probing hash table</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">To remove an item with a given key, we search for such an item and replace it with <tt>nullItem</tt>. Then, we need to correct for the possibility that some item that lies to the right of the now-unoccupied position originally hashed to that position or to its left, because the vacancy would terminate a search for such an item. Therefore, we reinsert all the items in the same cluster as the removed item and to that item's right. Since the table is less than half full, the number of items that are reinserted will be small, on the average.</p>
<div class="docText"><pre>  void remove(Item x)
    { int i = hash(x.key(), M), j;
      while (!st[i].null())
        if (x.key() == st[i].key()) break;
          else i = (i+1) % M;
      if (st[i].null()) return;
      st[i] = nullItem; N--;
      for (j = i+1; !st[j].null(); j = (j+1) % M, N--)
      { Item v = st[j]; st[j] = nullItem; insert(v); }
    }</pre></div><br />
</td></tr></table></p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa3q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">14.25</span> Give the contents of the hash table that results when you insert items with the keys E A S Y Q U T I O N in that order into an initially empty table of size <span class="docEmphasis">M</span> = 16 using linear probing. Use the hash function 11<span class="docEmphasis">k</span> mod <span class="docEmphasis">M</span> to transform the <span class="docEmphasis">k</span>th letter of the alphabet into a table index.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa3q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.26</span> Do <a class="docLink" href="#ch14qa3q2">Exercise 14.25</a> for <span class="docEmphasis">M</span> = 10.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa3q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">14.27</span> Write a program that inserts 10<sup>5</sup> random nonnegative integers less than 10<sup>6</sup> into a table of size 10<sup>5</sup> using linear probing, and that plots the total number of probes used for each 10<sup>3</sup> consecutive insertions.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa3q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.28</span> Write a program that inserts <span class="docEmphasis">N</span>/2 random integers into a table of size <span class="docEmphasis">N</span> using linear probing, then computes the average cost of a search miss in the resulting table from the cluster lengths, for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa3q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.29</span> Write a program that inserts <span class="docEmphasis">N</span>/2 random integers into a table of size <span class="docEmphasis">N</span> using linear probing, then computes the average cost of a search hit in the resulting table, for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>. Do <span class="docEmphasis">not</span> search for all the keys at the end (keep track of the cost of constructing the table).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa3q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">14.30</span> Run experiments to determine whether the average cost of search hits or search misses changes as a long sequence of alternating random insertions and deletions using <a class="docLink" href="#ch14ex06">Programs 14.4</a> and <a class="docLink" href="#ch14ex08">14.5</a> is made in a hash table of size 2<span class="docEmphasis">N</span> with <span class="docEmphasis">N</span> keys, for <span class="docEmphasis">N</span> = 10, 100, and 1000, and for up to <span class="docEmphasis">N</span><sup>2</sup> insertion&ndash;deletion pairs for each <span class="docEmphasis">N</span>.</p></td></tr></table></p>
<ul></ul></div></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch14lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch14lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table><!--IP User 2--></td></body></head></html>