<html><head><title>13.3. Top-Down 2-3-4 Trees</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch13lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch13lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch13lev1sec3"></a>
<h3 id="643999-929" class="docSection1Title">13.3. Top-Down 2-3-4 Trees</h3>
<p class="docText">Despite the performance guarantees that we can provide with randomized BSTs and with splay BSTs, both still admit the possibility that a particular search operation could take linear time. They therefore do not help us answer the fundamental question for balanced trees: Is there a type of BST for which we can guarantee that each and every <span class="docEmphasis">insert</span> and <span class="docEmphasis">search</span> operation will be logarithmic in the size of the tree? In this section and <a class="docLink" href="ch13lev1sec4.html#ch13lev1sec4">Section 13.4</a>, we consider an abstract generalization of BSTs and an abstract representation of these trees as a type of BST that allows us to answer this question in the affirmative.</p>
<p class="docText">To guarantee that our BSTs will be balanced, we need flexibility in the tree structures that we use. To get this flexibility, let us assume that the nodes in our trees can hold more than one key. Specifically, we will allow <span class="docEmphasis">3-nodes</span> and <span class="docEmphasis">4-nodes</span>, which can hold two and three keys, respectively. A 3-node has three links coming out of it: one for all items with keys smaller than both its keys, one for all items with keys in between its two keys, and one for all items with keys larger than both its keys. Similarly, a 4-node has four links coming out of it: one for each of the intervals defined by its three keys. The nodes in a standard BST could thus be called <span class="docEmphasis">2-nodes</span>: one key, two links. Later, we shall see efficient ways to define and implement the basic operations on these extended nodes; for now, let us assume that we can manipulate them conveniently, and see how they can be put together to form trees.</p>
<a name="ch13ex11"></a><h5 id="title-IDANAORE" class="docExampleTitle">Definition 13.1. </h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><span class="docEmphBoldItalic">A 2-3-4 search tree</span> <span class="docEmphStrong">is a tree that either is empty or comprises three types of nodes:</span> <span class="docEmphBoldItalic">2-nodes</span>, <span class="docEmphStrong">with one key, a left link to a tree with smaller keys, and a right link to a tree with larger keys;</span> <span class="docEmphBoldItalic">3-nodes</span><span class="docEmphStrong">, with two keys, a left link to a tree with smaller keys, a middle link to a tree with key values between the node's keys and a right link to a tree with larger keys; and</span> <span class="docEmphBoldItalic">4-nodes</span><span class="docEmphStrong">, with three keys and four links to trees with key values defined by the ranges subtended by the node's keys</span></p>
</td></tr></table></p>
<p class="docText"></p><a name="ch13ex12"></a><h5 id="title-IDA3BORE" class="docExampleTitle">Definition 13.2. <span class="docEmphasis">A balanced 2-3-4 search tree</span> is a 2-3-4 search tree with all links to empty trees at the same distance from the root</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1184"></a>In this chapter, we shall use the term <span class="docEmphasis">2-3-4 tree</span> to refer to balanced 2-3-4 search trees (it denotes a more general structure in other contexts). <a class="docLink" href="#ch13fig10">Figure 13.10</a> depicts an example of a 2-3-4 tree. The search algorithm for keys in such a tree is a generalization of the search algorithm for BSTs. To determine whether a key is in the tree, we compare it against the keys at the root: If it is equal to any of them, we have a search hit, otherwise, we follow the link from the root to the subtree corresponding to the set of key values containing the search key, and recursively search in that tree. There are a number of ways to represent 2-, 3-, and 4-nodes and to organize the mechanics of finding the proper link; we defer discussing these solutions until <a class="docLink" href="ch13lev1sec4.html#ch13lev1sec4">Section 13.4</a>, where we shall discuss a particularly convenient arrangement.</p>
<a name="ch13fig10"></a><p><center>
<h5 class="docFigureTitle">Figure 13.10. A 2-3-4 tree</h5>
<h5></h5><h5></h5></center></p><p class="docText">This figure depicts a 2-3-4 tree that contains the keys <tt>A S R C H I N G E X M P L</tt>. We can find a key in such a tree by using the keys in the node at the root to find a link to a subtree, then continuing recursively. For example, to search for <tt>P</tt> in this tree, we would follow the right link from the root, since <tt>P</tt> is larger than I, follow the middle link from the right child of the root, since <tt>P</tt> is between <span class="docEmphasis">N</span> and <tt>R</tt>, then terminate the successful search at the 2-node containing the <tt>P</tt>.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="135" height="53" src="13fig10.gif" /></p>
</td></tr></table></p><br />
<p class="docText">To insert a new node in a 2-3-4 tree, we could do an unsuccessful search and then hook on the node, as we did with BSTs, but the new tree would not be balanced. The primary reason that 2-3-4 trees are important is that we can do insertions and still maintain perfect balance in the tree, in every case. For example, it is easy to see what to do if the node at which the search terminates is a 2-node: We just turn the node into a 3-node. Similarly, if the search terminates at a 3-node, we just turn the node into a 4-node. But what should we do if the search terminates at a 4-node? The answer is that we can make room for the new key while maintaining the balance in the tree, by first splitting the 4-node into two 2-nodes, passing the middle key up to the node's parent. These three cases are illustrated in <a class="docLink" href="#ch13fig11">Figure 13.11</a>.</p>
<a name="ch13fig11"></a><p><center>
<h5 class="docFigureTitle">Figure 13.11. Insertion into a 2-3-4 tree</h5>
<h5></h5><h5></h5></center></p><p class="docText">A 2-3-4 tree consisting only of 2-nodes is the same as a BST <tt>(top)</tt>. We can insert <tt>C</tt> by converting the 2-node where the search for <tt>C</tt> terminates into a 3-node (second from top). Similarly, we can insert <tt>H</tt> by converting the 3-node where the search for it terminates into a 4-node (third from top). We need to do more work to insert <tt>I</tt>, because the search for it terminates at a 4-node. First, we split up the 4-node, pass its middle key up to its parent, and convert that node into a 3-node (fourth from top, highlighted). This transformation gives a valid 2-3-4 tree containing the keys, one that has room for I at the bottom. Finally, we insert <tt>I</tt> into the 2-node that now terminates the search, and convert that node into a 3-node (bottom).</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="75" height="274" src="13fig11.gif" /></p>
<br />
<p class="docText">Now, what do we do if we need to split a 4-node whose parent is also a 4-node? One method would be to split the parent also, but the grandparent could also be a 4-node, and so could its parent, and so forth&mdash;we could wind up splitting nodes all the way back up the tree. An easier approach is to make sure that the search path will not end at a 4-node, by splitting any 4-node we see on the way <span class="docEmphasis">down</span> the tree.</p>
<p class="docText">Specifically, as shown in <a class="docLink" href="#ch13fig12">Figure 13.12</a>, every time we encounter a 2-node connected to a 4-node, we transform the pair into a 3-node connected to two 2-nodes, and every time we encounter a 3-node connected to a 4-node, we transform the pair into a 4-node connected to two 2-nodes. Splitting 4-nodes is possible because of the way not only the keys but also the <span class="docEmphasis">links</span> can be moved around. Two 2-nodes have the same number (four) of links as a 4-node, so we can execute the split without having to propagate any changes below (or above) the split node. A 3-node is not changed to a 4-node just by the addition of another key; another pointer is needed also (in this case, the extra link provided by the split). The crucial point is that these transformations are purely local: No part of the tree needs to be examined or modified other than the part shown in <a class="docLink" href="#ch13fig12">Figure 13.12</a>. Each of the transformations passes up one of the keys from a 4-node to that node's parent in the tree, and restructures links accordingly.</p>
<a name="ch13fig12"></a><p><center>
<h5 class="docFigureTitle">Figure 13.12. Splitting 4-nodes in a 2-3-4 tree</h5>
<h5></h5><h5></h5></center></p><p class="docText">In a 2-3-4 tree, we can split any 4-node that is not the child of a 4-node into two 2-nodes, passing its middle record up to its parent. A 2-node attached to a 4-node <tt>(top left)</tt> becomes a 3-node attached to two 2-nodes (top right), and a 3-node attached to a 4-node <tt>(bottom left)</tt> becomes a 4-node attached to two 2-nodes <tt>(bottom right)</tt>.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="125" height="81" src="13fig12.gif" /></p>
<br />
<p class="docText">On our way down the tree, we do not need to worry explicitly about the parent of the current node being a 4-node, because our transformations ensure that, as we pass through each node in the tree, we come out on a node that is not a 4-node. In particular, when we reach the bottom of the tree, we are not on a 4-node, and we can insert the new node directly by transforming either a 2-node to a 3-node or a 3-node to a 4-node. We can think of the insertion as a split of an imaginary 4-node at the bottom that passes up the new key.</p>
<p class="docText">One final detail: Whenever the root of the tree becomes a 4-node, we just split it into a triangle of three 2-nodes, as we did for our first node split in the preceding example. Splitting the root after an insertion is slightly more convenient than is the alternative of waiting until the next insertion to do the split because we never need to worry about the parent of the root. Splitting the root (and only this operation) makes the tree grow one level higher.</p>
<p class="docText"><a class="docLink" href="#ch13fig13">Figure 13.13</a> depicts the construction of a 2-3-4 tree for a sample set of keys. Unlike standard BSTs, which grow down from the top, these trees grow up from the bottom. Because the 4-nodes are split on the way from the top down, the trees are called top-down 2-3-4 trees. The algorithm is significant because it produces search trees that are nearly perfectly balanced, yet it makes only a few local transformations as it walks through the tree.</p>
<a name="ch13fig13"></a><p><center>
<h5 class="docFigureTitle">Figure 13.13. 2-3-4 search tree construction</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts the result of inserting items with keys <tt>A S E R C H I N G X</tt> into an initially empty 2-3-4 tree. We split each 4-node that we encounter on the search path, thus ensuring that there is room for the new item at the bottom.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="125" height="512" src="13fig13.gif" /></p>
<br />
<a name="ch13ex13"></a><h5 id="title-IDAMZIN" class="docExampleTitle">Property 13.6. Searches in <span class="docEmphasis">N</span>-node 2-3-4 trees visit at most <span class="docEmphasis">lg N+ 1</span>nodes</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Every external node is the same distance from the root: The transformations that we perform have no effect on the distance from any node to the root, except when we split the root (in this case the distance from all nodes to the root is increased by 1). If all the nodes are 2-nodes, the stated result holds, since the tree is like a full binary tree; if there are 3-nodes and 4-nodes, the height can only be lower.</p>
</td></tr></table></p>
<a name="ch13ex14"></a><h5 id="title-IDA5ZIN" class="docExampleTitle">Property 13.7. Insertions into <span class="docEmphasis">N</span>-node 2-3-4 trees require fewer than <span class="docEmphasis">lg N + 1</span> node splits in the worst case, and seem to require less than one node split on the average</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The worst that can happen is that all the nodes on the path to the insertion point are 4-nodes, all of which will be split. But in a tree built from a random permutation of <span class="docEmphasis">N</span> elements, not only is this worst case unlikely to occur, but also few splits seem to be required on the average, because there are not many 4-nodes in the trees. For example, in the large tree depicted in <a class="docLink" href="#ch13fig14">Figure 13.14</a>, all but two of the 4-nodes are on the bottom level. Precise analytic results on the average-case performance of 2-3-4 trees have so far eluded the experts, but it is clear from empirical studies that very few splits are used to balance the trees. The worst case is only lg <span class="docEmphasis">N</span>, and that is not approached in practical situations.</p>
</td></tr></table></p>
<a name="ch13fig14"></a><p><center>
<h5 class="docFigureTitle">Figure 13.14. A large 2-3-4 tree</h5>
<h5></h5><h5></h5></center></p><p class="docText">This 2-3-4 tree is the result of 200 random insertions into an initially empty tree. All search paths in the trees have six or fewer nodes.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="450" height="38" src="13fig14.gif" /></p>
<br />
<p class="docText">The preceding description is sufficient to define an algorithm for searching using 2-3-4 trees that has guaranteed good worst-case performance. However, we are only half of the way to an implementation. Although it would be possible to write algorithms which actually perform transformations on distinct data types representing 2-, 3-, and 4-nodes, most of the tasks that are involved are inconvenient to implement in this direct representation. As in splay BSTs, the overhead incurred in manipulating the more complex node structures could make the algorithms slower than standard BST search. The primary purpose of balancing is to provide insurance against a bad worst case, but we would prefer the overhead cost for that insurance to be low and we also would prefer to avoid paying the cost on every run of the algorithm. Fortunately, as we will see in <a class="docLink" href="ch13lev1sec4.html#ch13lev1sec4">Section 13.4</a>, there is a relatively simple representation of 2-, 3-, and 4-nodes that allows the transformations to be done in a uniform way with little overhead beyond the costs incurred by standard binary-tree search.</p>
<p class="docText">The algorithm that we have described is just one possible way to maintain balance in 2-3-4 search trees. Several other methods that achieve the same goals have been developed.</p>
<p class="docText">For example, we can balance from the bottom up. First, we do a search in the tree to find the bottom node where the item to be inserted belongs. If that node is a 2-node or a 3-node, we grow it to a 3-node or a 4-node, just as before. If it is a 4-node, we split it as before (inserting the new item into one of the resulting 2-nodes at the bottom), and insert the middle item into the parent, if the parent is a 2-node or a 3-node. If the parent is a 4-node, we split that node (inserting the middle node from the bottom into the appropriate 2-node), and insert the middle item into its parent, if the parent is a 2-node or a 3-node. If the grandparent is also a 4-node, we continue up the tree in the same way, splitting 4-nodes until we encounter a 2-node or a 3-node on the search path.</p>
<p class="docText">We can do this kind of bottom-up balancing in trees that have only 2- or 3-nodes (no 4-nodes). This approach leads to more node splitting during the execution of the algorithm, but is easier to code because there are fewer cases to consider. In another approach, we seek to reduce the amount of node splitting by looking for siblings that are not 4-nodes when we are ready to split a 4-node.</p>
<p class="docText">Implementations of all these methods involve the same basic recursive scheme, as we shall see in <a class="docLink" href="ch13lev1sec4.html#ch13lev1sec4">Section 13.4</a>. We shall also discuss generalizations, in <a class="docLink" href="ch16.html#ch16">Chapter 16</a>. The primary advantage of the top-down insertion approach that we are considering over other methods is that it can achieve the necessary balancing in one top-down pass through the tree.</p>
</td></tr></table>
<p class="docText">&nbsp;<a name="iddle2279"></a><a name="iddle1121"></a></p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa4q1"></a><b></b></td><td><p class="docText"><a name="iddle1117"></a><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">13.39</span> Draw the balanced 2-3-4 search tree that results when you insert items with the keys E A S Y Q U T I O N in that order into an initially empty tree, using the top-down insertion method.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa4q2"></a><b></b></td><td><p class="docText"><a name="iddle1125"></a><a name="iddle1174"></a><a name="iddle1962"></a><a name="iddle2268"></a><a name="iddle2560"></a><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">13.40</span> Draw the balanced 2-3-4 search tree that results when you insert items with the keys E A S Y Q U T I O N in that order into an initially empty tree, using the bottom-up insertion method.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa4q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">13.41</span> What are the minimum and maximum heights possible for balanced 2-3-4 trees with <span class="docEmphasis">N</span> nodes?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa4q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">13.42</span> What are the minimum and maximum heights possible for balanced 2-3-4 BSTs with <span class="docEmphasis">N</span> keys?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa4q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">13.43</span> Draw all the structurally different balanced 2-3-4 BSTs with <span class="docEmphasis">N</span> keys for <span class="docEmphasis">2 <img src="U2264.GIF" border="0" /> N <img src="U2264.GIF" border="0" /> 12</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa4q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">13.44</span> Find the probability that each of the trees in <a class="docLink" href="#ch13qa4q5">Exercise 13.43</a> is the result of the insertion of <span class="docEmphasis">N</span> random distinct elements into an initially empty tree.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa4q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.45</span> Make a table showing the number of trees for each <span class="docEmphasis">N</span> from <a class="docLink" href="#ch13qa4q5">Exercise 13.43</a> that are isomorphic, in the sense that they can be transformed to one another by exchanges of subtrees in nodes.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa4q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">13.46</span> Describe algorithms for search and insertion in balanced 2-3-4-5-6 search trees.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa4q9"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">13.47</span> Draw the unbalanced 2-3-4 search tree that results when you insert items with the keys E A S Y Q U T I O N in that order into an initially empty tree, using the following method. If the search ends in a 2-node or a 3-node, change it to a 3-node or a 4-node, as in the balanced algorithm; if the search ends in a 4-node, replace the appropriate link in that 4-node with a new 2-node.</p></td></tr></table></p>
<ul></ul></div></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch13lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch13lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table><!--IP User 2--></td></body></head></html>