<html><head><title>14.2. Separate Chaining</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch14lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch14lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch14lev1sec2"></a>
<h3 id="643999-817" class="docSection1Title">14.2. Separate Chaining</h3>
<p class="docText">The hash functions discussed in <a class="docLink" href="ch14lev1sec1.html#ch14lev1sec1">Section 14.1</a> convert keys into table addresses; the second component of a hashing algorithm is to decide how to handle the case when two keys hash to the same address. The most straightforward method is to build, for each table address, a linked list of the items whose keys hash to that address. This approach leads directly to the generalization of elementary list search (see <a class="docLink" href="ch12.html#ch12">Chapter 12</a>) that is given in <a class="docLink" href="#ch14ex03">Program 14.3</a>. Rather than maintaining a single list, we maintain <span class="docEmphasis">M</span> lists.</p>
<p class="docText">This method is traditionally called <span class="docEmphasis">separate chaining</span>, because items that collide are chained together in separate linked lists. An example is depicted in <a class="docLink" href="#ch14fig06">Figure 14.6</a>. As with elementary sequential search, we can choose to keep the lists in sorted order, or we can leave them unordered. The same basic tradeoffs as those discussed in <a class="docLink" href="ch12lev1sec3.html#ch12lev1sec3">Section 12.3</a> apply, but, for separate chaining, the time savings are less significant (because the lists are short) and the space usage is more significant (because there are so many lists).</p>
<a name="ch14fig06"></a><p><center>
<h5 class="docFigureTitle">Figure 14.6. Hashing with separate chaining</h5>
<h5></h5><h5></h5></center></p><p class="docText">This diagram shows the result of inserting the keys A S E R C H I N G X M P L into an initially empty hash table with separate chaining (unordered lists), using the hash values given at the top. The A goes into list 0, then the S goes into list 2, then the E goes into list 0 (at the front, to keep the insertion time constant), then the R goes into list 4, and so forth.</p><p class="docText">
<img border="0" alt="" id="118095012104" width="175" height="135" src="14fig06.gif" /></p>
<br />
<p class="docText">We might be using a header node to streamline the code for insertion into an ordered list, but we might not want to use <span class="docEmphasis">M</span> header nodes for individual lists in separate chaining. Indeed, we could even eliminate the M links to the lists by having the first nodes in the lists comprise the table (see <a class="docLink" href="#ch14qa2q5">Exercise 14.20</a>).</p>
<a name="ch14ex03"></a><h5 id="title-IDAMLPLM" class="docExampleTitle">Program 14.3. Hashing with separate chaining</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This symbol-table implementation is based on replacing the <tt>ST</tt> constructor, <tt>search</tt>, and <tt>insert</tt> functions in the linked-list&ndash;based symbol table of <a class="docLink" href="ch12lev1sec3.html#ch12ex08">Program 12.6</a> with the functions given here, and replacing the link <tt>head</tt> with an array of links <tt>heads</tt>. We use the same recursive list search and deletion procedures as in <a class="docLink" href="ch12lev1sec3.html#ch12ex08">Program 12.6</a>, but we maintain <span class="docEmphasis">M</span> lists, with head links in <tt>heads</tt>, using a hash function to choose among the lists. The constructor sets <span class="docEmphasis">M</span> such that we expect the lists to have about five items each; therefore the other operations require just a few probes.</p>
<div class="docText"><pre> private:
   link* heads;
   int N, M;
 public:
   ST(int maxN)
     {
       N = 0; M = maxN/5;
       heads = new link[M];
       for (int i = 0; i &lt; M; i++) heads[i] = 0;
     }
   Item search(Key v)
     { return searchR(heads[hash(v, M)], v); }
   void insert(Item item)
     { int i = hash(item.key(), M);
       heads[i] = new node(item, heads[i]); N++; }</pre></div><br />
</td></tr></table></p>
<p class="docText">For a search miss, we can assume that the hash function scrambles the key values sufficiently well that each of the <span class="docEmphasis">M</span> lists is equally likely to be searched. Then the performance characteristics that we studied in <a class="docLink" href="ch12lev1sec3.html#ch12lev1sec3">Section 12.3</a> apply, for each list.</p>
<a name="ch14ex04"></a><h5 id="title-IDARNPLM" class="docExampleTitle">Property 14.1. Separate chaining reduces the number of comparisons for sequential search by a factor of <span class="docEmphasis">M</span> (on the average), using extra space for <span class="docEmphasis">M</span> links</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The average length of the lists is <span class="docEmphasis">N/M</span>. As described in <a class="docLink" href="ch12.html#ch12">Chapter 12</a>, successful searches are expected to go about halfway down some list. Unsuccessful searches go to the end of a list if the lists are unordered, halfway down a list if the lists are kept in order.</p>
</td></tr></table></p>
<p class="docText"><a name="iddle1594"></a>Most often, we use unordered lists for separate chaining, because that approach is both easy to implement and efficient: <span class="docEmphasis">insert</span> takes constant time and <span class="docEmphasis">search</span> takes time proportional to <span class="docEmphasis">N/M</span>. If huge numbers of search misses are expected, we can speed up the misses by a factor of 2 by keeping the lists ordered, at the cost of a slower <span class="docEmphasis">insert</span>.</p>
<p class="docText">As stated, <a class="docLink" href="#ch14ex04">Property 14.1</a> is a trivial result, because the average length of the lists is <span class="docEmphasis">N/M</span>, no matter how the items are distributed among the lists. For example, suppose that all the items fall onto the first list. Then, the average length of the lists is (<span class="docEmphasis">N</span>+0+0+. . .+0)/<span class="docEmphasis">M</span> = <span class="docEmphasis">N/M</span>. The real reason that hashing is useful in practice is that <span class="docEmphasis">each</span> list is extremely likely to have about <span class="docEmphasis">N/M</span> items.</p>
<a name="ch14ex05"></a><h5 id="title-IDA2PPLM" class="docExampleTitle">Property 14.2. In a separate-chaining hash table with <span class="docEmphasis">M</span> lists and <span class="docEmphasis">N</span> keys, the probability that the number of keys in each list is within a small constant factor of <span class="docEmphasis">N/M</span> is extremely close to 1</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We briefly consider this classical analysis, for readers who are familiar with basic probabilistic analysis. The probability that a given list will have <span class="docEmphasis">k</span> items on it is</p>
<p class="docText"><img border="0" alt="" id="118095012104" width="185" height="40" src="599equ01.jpg" /></p>
<p class="docText">by an elementary argument. We choose <span class="docEmphasis">k</span> out of the <span class="docEmphasis">N</span> items: Those <span class="docEmphasis">k</span> items hash to the given list with probability 1/<span class="docEmphasis">M</span>, and the other <span class="docEmphasis">N &ndash; k</span> items do not hash to the given list with probability 1 &ndash; (1/<span class="docEmphasis">M</span>). In terms of <span class="docEmphasis">&#945;= N/M</span>, we can rewrite this expression as</p>
<p class="docText"><img border="0" alt="" id="118095012104" width="175" height="38" src="599equ02.jpg" /></p>
<p class="docText">which, by the classical Poisson approximation, is less than</p>
<p class="docText"><img border="0" alt="" id="118095012104" width="65" height="47" src="599equ03.jpg" /></p>
<p class="docText">From this result, it follows that the probability that a list has more than <span class="docEmphasis">t&#945;</span> items on it is less than</p>
<p class="docText"><img border="0" alt="" id="118095012104" width="60" height="25" src="599equ04.jpg" /></p>
<p class="docText">This probability is extremely small for practical ranges of the parameters. For example, if the average length of the lists is 20, the probability that we will hash to some list with more than 40 items on it is less than (40<span class="docEmphasis">e</span>/2)<sup>2</sup><span class="docEmphasis">e</span><sup>-20</sup><img src="U2248.GIF" border="0" />0.0000016.</p>
</td></tr></table></p>
<p class="docText"><a name="iddle1228"></a><a name="iddle1312"></a><a name="iddle1579"></a><a name="iddle1867"></a><a name="iddle1984"></a>The foregoing analysis is an example of a classical <span class="docEmphasis">occupancy problem</span>, where we consider <span class="docEmphasis">N</span> balls thrown randomly into one of <span class="docEmphasis">M</span> urns, and analyze how the balls are distributed among the urns. Classical mathematical analysis of these problems tells us many other interesting facts that are relevant to the study of hashing algorithms. For example, the Poisson approximation tells us that the number of empty lists is about <span class="docEmphasis">e<sup>&ndash;&#945;</sup></span>. A more interesting result tells us that the average number of items inserted before the first collision occurs is about <img border="0" alt="" id="118095012104" width="145" height="20" src="600equ01.jpg" />. This result is the solution to the classical <span class="docEmphasis">birthday problem</span>. For example, the same analysis tells us, for <span class="docEmphasis">M</span> = 365, that the average number of people we need to check before finding two with the same birthday is about 24. A second classical result tells us that the average number of items inserted before each list has at least one item is about <span class="docEmphasis">M</span>H<span class="docEmphasis"><sub>M</sub></span>. This result is the solution to the classical <span class="docEmphasis">coupon collector</span> problem. For example, the same analysis tells us, for <span class="docEmphasis">M</span> = 1280, that we would expect to collect 9898 baseball cards (coupons) before getting one for each of 40 players on each of 32 teams in a series. These results are indicative of the properties of hashing that have been analyzed. In practice, they tell us that we can use separate chaining with great confidence, if the hash function produces values that approximate random ones (<span class="docEmphasis">see reference section</span>).</p>
<p class="docText">In a separate-chaining implementation, we typically choose <span class="docEmphasis">M</span> to be small enough that we are not wasting a huge area of contiguous memory with empty links, but large enough that sequential search is the most efficient method for the lists. Hybrid methods (such as using binary trees instead of linked lists) are probably not worth the trouble. As a rule of thumb, we might choose <span class="docEmphasis">M</span> to be about one-fifth or one-tenth the number of keys expected be be in the table, so that the lists are expected to contain about five or 10 keys each. One of the virtues of separate chaining is that this decision is not critical: if more keys arrive than expected, then searches will take a little longer than if we had chosen a bigger table size ahead of time; if fewer keys are in the table, then we have extra-fast <span class="docEmphasis">search</span> with perhaps a small amount of wasted space. When space is not a critical resource, <span class="docEmphasis">M</span> can be chosen sufficiently large that search time is constant; when space <span class="docEmphasis">is</span> a critical <a name="iddle1397"></a><a name="iddle1598"></a>resource, we still can get a factor of <span class="docEmphasis">M</span> improvement in performance by choosing <span class="docEmphasis">M</span> to be as large as we can afford.</p>
<p class="docText">The comments in the previous paragraph apply to search time. In practice, unordered lists are normally used for separate chaining, for two primary reasons. First, as we have mentioned, <span class="docEmphasis">insert</span> is extremely fast: We compute the hash function, allocate memory for the node, and link in the node at the beginning of the appropriate list. In many applications, the memory-allocation step is not needed (because the items inserted into the symbol table may be existing records with available link fields), and we are left with perhaps three or four machine instructions for <span class="docEmphasis">insert</span>. The second important advantage of using the unordered-list implementation in <a class="docLink" href="#ch14ex03">Program 14.3</a> is that the lists all function as stacks, so we can easily remove the most recently inserted items, which are at the front of the lists (see <a class="docLink" href="#ch14qa2q6">Exercise 14.21</a>). This operation is an important one when we are implementing a symbol table with nested scopes, for example in a compiler.</p>
<p class="docText">As in several previous implementations, we implicitly give the client a choice for handling duplicate keys. A client like <a class="docLink" href="ch12lev1sec7.html#ch12ex21">Program 12.11</a> might <span class="docEmphasis">search</span> to check for duplicates before any <span class="docEmphasis">insert</span>, thus ensuring that the table does not contain any duplicate keys. Another client might avoid the cost of this <span class="docEmphasis">search</span> by leaving duplicates in the table, thus achieving fast <span class="docEmphasis">insert</span> operations.</p>
<p class="docText">Generally, hashing is not appropriate for use in applications where implementations for the <span class="docEmphasis">sort</span> and <span class="docEmphasis">select</span> ADT operations are required. However, hashing is often used for the typical situation where we need to use a symbol table with potentially a large number of <span class="docEmphasis">search</span>, <span class="docEmphasis">insert</span>, and <span class="docEmphasis">remove</span> operations, then to print out the items in order of their keys once, at the end. One example of such an application is a symbol table in a compiler; another is a program to remove duplicates, such as <a class="docLink" href="ch12lev1sec7.html#ch12ex21">Program 12.11</a>. To handle this situation in an unordered-list implementation of separate chaining, we would have to use one of the sorting methods described in <a class="docLink" href="ch06.html#ch06">Chapters 6</a> through <a class="docLink" href="ch14.html#ch14">10</a>; in an ordered-list implementation, we could accomplish the sort in time proportional to <span class="docEmphasis">N</span> lg <span class="docEmphasis">M</span> with list mergesort (see <a class="docLink" href="#ch14qa2q8">Exercise 14.23</a>).</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa2q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">14.16</span> How long could it take in the worst case to insert <span class="docEmphasis">N</span> keys into an initially empty table, using separate chaining with (<span class="docEmphasis">i</span>) unordered lists and (<span class="docEmphasis">ii</span>) ordered lists?</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa2q2"></a><b></b></td><td><p class="docText"><a name="iddle1575"></a><a name="iddle1583"></a><a name="iddle1777"></a><a name="iddle1993"></a><a name="iddle2124"></a><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">14.17</span> Give the contents of the hash table that results when you insert items with the keys E A S Y Q U T I O N in that order into an initially empty table of <span class="docEmphasis">M</span> = 5 lists, using separate chaining with unordered lists. Use the hash function 11<span class="docEmphasis">k</span> mod <span class="docEmphasis">M</span> to transform the <span class="docEmphasis">k</span>th letter of the alphabet into a table index.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa2q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">14.18</span> Answer <a class="docLink" href="#ch14qa2q2">Exercise 14.17</a>, but use ordered lists. Does your answer depend on the order in which you insert the items?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa2q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">14.19</span> Write a program that inserts <span class="docEmphasis">N</span> random integers into a table of size <span class="docEmphasis">N</span>/100 using separate chaining, then finds the length of the shortest and longest lists, for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa2q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.20</span> Modify <a class="docLink" href="#ch14ex03">Program 14.3</a> to eliminate the head links by representing the symbol table as an array of <tt>nodes</tt> (each table entry is the first node in its list).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa2q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.21</span> Modify <a class="docLink" href="#ch14ex03">Program 14.3</a> to include an integer field for each item that is set to the number of items in the table at the time the item is inserted. Then implement a function that deletes all items for which the field is greater than a given integer <span class="docEmphasis">N</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa2q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.22</span> Modify the implementation of <tt>search</tt> in <a class="docLink" href="#ch14ex03">Program 14.3</a> to show all the items with keys equal to a given key, in the same manner as <tt>show</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa2q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.23</span> Develop a symbol-table implementation using separate chaining with ordered lists (with a fixed table of size 97) that includes a destructor, a copy constructor, and an overloaded assignment operator, and supports the <span class="docEmphasis">construct</span>, <span class="docEmphasis">count</span>, <span class="docEmphasis">search</span>, <span class="docEmphasis">insert</span>, <span class="docEmphasis">remove</span>, <span class="docEmphasis">join</span>, <span class="docEmphasis">select</span>, and <span class="docEmphasis">sort</span> operations for a first-class symbol-table ADT, with support for client handles (see <a class="docLink" href="ch12lev1sec1.html#ch12qa1q6">Exercises 12.6</a> and <a class="docLink" href="ch12lev1sec1.html#ch12qa1q7">12.7</a>).</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch14lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch14lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>