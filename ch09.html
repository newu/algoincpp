<html><head><title>Chapter Nine. Priority Queues and Heapsort</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch08lev1sec8.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch09lev1sec1.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch09"></a>
<h2 id="title-IDAJWEWD" class="docChapterTitle">Chapter Nine. Priority Queues and Heapsort</h2>
<p class="docText"><a name="iddle1542"></a><a name="iddle2098"></a><a name="iddle2100"></a><a name="iddle2105"></a><a name="iddle2157"></a>MANY APPLICATIONS require that we process records with keys in order, but not necessarily in full sorted order and not necessarily all at once. Often, we collect a set of records, then process the one with the largest key, then perhaps collect more records, then process the one with the current largest key, and so forth. An appropriate data structure in such an environment supports the operations of inserting a new element and deleting the largest element. Such a data structure is called a <span class="docEmphasis">priority queue</span>. Using priority queues is similar to using queues (remove the oldest) and stacks (remove the newest), but implementing them efficiently is more challenging. The priority queue is the most important example of the generalized queue ADT that we discussed in <a class="docLink" href="ch04lev1sec6.html#ch04lev1sec6">Section 4.6</a>. In fact, the priority queue is a proper generalization of the stack and the queue, because we can implement these data structures with priority queues, using appropriate priority assignments (see <a class="docLink" href="#ch09qa1q3">Exercises 9.3</a> and <a class="docLink" href="#ch09qa1q4">9.4</a>).</p>
<a name="ch09ex01"></a><h5 id="title-IDAWYEWD" class="docExampleTitle">Definition 9.1. A <span class="docEmphasis">priority queue</span> is a data structure of items with keys that supports two basic operations: insert a new item, and remove the item with the largest key</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Applications of priority queues include simulation systems, where the keys might correspond to event times, to be processed in chronological order; job scheduling in computer systems, where the keys might correspond to priorities indicating which users are to be served first; and numerical computations, where the keys might be computational errors, indicating that the largest should be dealt with first.</p>
<p class="docText">We can use any priority queue as the basis for a sorting algorithm by inserting all the records, then successively removing the largest to get the records in reverse order. Later on in this book, we shall see how to use priority queues as building blocks for more advanced algorithms. In Part 5, we shall develop a file-compression algorithm using routines from this chapter; and in Part 7, we shall see how priority queues are an appropriate abstraction for helping us understand the relationships among several fundamental graph-searching algorithms. These are but a few examples of the important role played by the priority queue as a basic tool in algorithm design.</p>
<p class="docText">In practice, priority queues are more complex than the simple definition just given, because there are several other operations that we may need to perform to maintain them under all the conditions that might arise when we are using them. Indeed, one of the main reasons that many priority queue implementations are so useful is their flexibility in allowing client application programs to perform a variety of different operations on sets of records with keys. We want to build and maintain a data structure containing records with numerical keys (<span class="docEmphasis">priorities</span>) that supports some of the following operations:</p>
<ul><li><p class="docList"><span class="docEmphasis">Construct</span> a priority queue from <span class="docEmphasis">N</span> given items.</p></li><li><p class="docList"><span class="docEmphasis">Insert</span> a new item.</p></li><li><p class="docList"><span class="docEmphasis">Remove the maximum</span> item.</p></li><li><p class="docList"><span class="docEmphasis">Change the priority</span> of an arbitrary specified item.</p></li><li><p class="docList"><span class="docEmphasis">Remove</span> an arbitrary specified item.</p></li><li><p class="docList"><span class="docEmphasis">Join</span> two priority queues into one large one.</p></li></ul>
<p class="docText">If records can have duplicate keys, we take &quot;maximum&quot; to mean &quot;any record with the largest key value.&quot; As with many data structures, we also need to add standard <span class="docEmphasis">construct</span>, <span class="docEmphasis">test if empty</span>, and perhaps <span class="docEmphasis">destroy</span> and <span class="docEmphasis">copy</span> operations to this set.</p>
<p class="docText">There is overlap among these operations, and it is sometimes convenient to define other, similar operations. For example, certain clients may need frequently to <span class="docEmphasis">find the maximum</span> item in the priority queue, without necessarily removing it. Or, we might have an operation to <span class="docEmphasis">replace the maximum</span> item with a new item. We could implement operations such as these using our two basic operations as building blocks: <span class="docEmphasis">Find the maximum</span> could be <span class="docEmphasis">remove the maximum</span> followed by <span class="docEmphasis">insert</span>, and <span class="docEmphasis">replace the maximum</span> could be either <span class="docEmphasis">insert</span> followed by <span class="docEmphasis">remove the maximum</span> or <span class="docEmphasis">remove the maximum</span> followed by <span class="docEmphasis">insert</span>. We normally get more efficient code, however, by implementing such operations directly, provided that they are needed and precisely specified. Precise specification is not always as straightforward as it might seem. For example, the two options just given for <span class="docEmphasis">replace the maximum</span> are quite different: the former always makes the priority queue grow temporarily by one item, and the latter always puts the new item on the queue. Similarly, the <span class="docEmphasis">change priority</span> operation could be implemented as a <span class="docEmphasis">remove</span> followed by an <span class="docEmphasis">insert</span>, and <span class="docEmphasis">construct</span> could be implemented with repeated uses of <span class="docEmphasis">insert</span>.</p>
<a name="ch09ex02"></a><h5 id="title-IDAE2EWD" class="docExampleTitle">Program 9.1. Basic priority-queue ADT</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This interface defines operations for the simplest type of priority queue: initialize, test if empty, add a new item, remove the largest item. Elementary implementations of these functions using arrays and linked lists can require linear time in the worst case, but we shall see implementations in this chapter where all operations are guaranteed to run in time at most proportional to the logarithm of the number of items in the queue. As usual, the argument to the constructor specifies the maximum number of items expected in the queue, and may be ignored by some implementations.</p>
<div class="docText"><pre>
    template &lt;class Item&gt;
    class PQ
      {
        private:
          // Implementation-dependent code
        public:
          PQ(int);
          int empty() const;
          void insert(Item);
          Item getmax();
      };</pre></div><br />
</td></tr></table></p>
<p class="docText">For some applications, it might be slightly more convenient to switch around to work with the <span class="docEmphasis">minimum</span>, rather than with the maximum. We stick primarily with priority queues that are oriented toward accessing the maximum key. When we do need the other kind, we shall refer to it (a priority queue that allows us to <span class="docEmphasis">remove the minimum</span> item) as a <span class="docEmphasis">minimum-oriented</span> priority queue.</p>
<p class="docText">The priority queue is a prototypical <span class="docEmphasis">abstract data type (ADT)</span> (see <a class="docLink" href="ch04.html#ch04">Chapter 4</a>): It represents a well-defined set of operations on data, and it provides a convenient abstraction that allows us to separate applications programs (clients) from various implementations that we will consider in this chapter. The interface given in <a class="docLink" href="#ch09ex02">Program 9.1</a> defines the most basic priority-queue operations; we shall consider a more complete interface in <a class="docLink" href="ch09lev1sec5.html#ch09lev1sec5">Section 9.5</a>. Strictly speaking, different subsets of the various operations that we might want to include lead to different abstract data structures, but the priority queue is essentially characterized by the <span class="docEmphasis">remove-the-maximum</span> and <span class="docEmphasis">insert</span> operations, so we shall focus on them.</p>
<p class="docText">Different implementations of priority queues afford different performance characteristics for the various operations to be performed, and different applications need efficient performance for different sets of operations. Indeed, performance differences are, in principle, the <span class="docEmphasis">only</span> differences that can arise in the abstract-data-type concept. This situation leads to cost tradeoffs. In this chapter, we consider a variety of ways of approaching these cost tradeoffs, nearly reaching the ideal of being able to perform the <span class="docEmphasis">remove the maximum</span> operation in logarithmic time and all the other operations in constant time.</p>
<p class="docText">First, we illustrate this point in <a class="docLink" href="ch09lev1sec1.html#ch09lev1sec1">Section 9.1</a> by discussing a few elementary data structures for implementing priority queues. Next, in <a class="docLink" href="ch09lev1sec2.html#ch09lev1sec2">Sections 9.2</a> through <a class="docLink" href="ch09lev1sec4.html#ch09lev1sec4">9.4</a>, we concentrate on a classical data structure called the <span class="docEmphasis">heap</span>, which allows efficient implementations of all the operations but <span class="docEmphasis">join</span>. We also look at an important sorting algorithm that follows naturally from these implementations, in <a class="docLink" href="ch09lev1sec4.html#ch09lev1sec4">Section 9.4</a>. Following this, we look in more detail at some of the problems involved in developing complete priority-queue ADTs, in <a class="docLink" href="ch09lev1sec5.html#ch09lev1sec5">Sections 9.5</a> and <a class="docLink" href="ch09lev1sec6.html#ch09lev1sec6">9.6</a>. Finally, in <a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7">Section 9.7</a>, we examine a more advanced data structure, called the <span class="docEmphasis">binomial queue</span>, that we use to implement all the operations (including <span class="docEmphasis">join</span>) in worst-case logarithmic time.</p>
<p class="docText">During our study of all these various data structures, we shall bear in mind both the basic tradeoffs dictated by linked versus sequential memory allocation (as introduced in <a class="docLink" href="ch03.html#ch03">Chapter 3</a>) and the problems involved with making packages usable by applications programs. In particular, some of the advanced algorithms that appear later in this book are client programs that make use of priority queues.</p>
</td></tr></table></p>
<p class="docText">&nbsp;<a name="iddle2117"></a><a name="iddle1016"></a><a name="iddle1017"></a><a name="iddle2118"></a></p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa1q1"></a><b></b></td><td><p class="docText"><a name="iddle1092"></a><a name="iddle2101"></a><a name="iddle2106"></a><a name="iddle2111"></a><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">9.1</span> A letter means <span class="docEmphasis">insert</span> and an asterisk means <span class="docEmphasis">remove the maximum</span> in the sequence</p>
<p class="docText"><div class="docText"><pre>P R I O * R * * I * T * Y * * * Q U E * * * U * E.</pre></div><br /></p>
<p class="docText">Give the sequence of values returned by the <span class="docEmphasis">remove the maximum</span> operations.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa1q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">9.2</span> Add to the conventions of <a class="docLink" href="#ch09qa1q1">Exercise 9.1</a> a plus sign to mean <span class="docEmphasis">join</span> and parentheses to delimit the priority queue created by the operations within them. Give the contents of the priority queue after the sequence</p>
<p class="docText"><div class="docText"><pre>( ( (P R I O *)+( R * I T * Y * )) * * *) +(Q U E * * * U * E )</pre></div><br />.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa1q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">9.3</span> Explain how to use a priority queue ADT to implement a stack ADT.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa1q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">9.4</span> Explain how to use a priority queue ADT to implement a queue ADT.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch08lev1sec8.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch09lev1sec1.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>