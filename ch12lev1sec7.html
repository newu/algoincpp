<html><head><title>12.7. Index Implementations with Symbol Tables</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12lev1sec6.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch12lev1sec8.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch12lev1sec7"></a>
<h3 id="643999-961" class="docSection1Title">12.7. Index Implementations with Symbol Tables</h3>
<p class="docText">For many applications we want a search structure simply to help us find items, without moving them around. For example, we might have an array of items with keys, and we might want the search method to give us the index into that array of the item matching a certain key. Or we might want to remove the item with a given index from the search structure, but still keep it in the array for some other use. In <a class="docLink" href="ch09lev1sec6.html#ch09lev1sec6">Section 9.6</a>, we considered the advantages of processing index items in priority queues, referring to data in a client array indirectly. For symbol tables, the same concept leads to the familiar <span class="docEmphasis">index</span>: a search structure external to a set of items that provides quick access to items with a given key. In <a class="docLink" href="ch16.html#ch16">Chapter 16</a>, we shall consider the case where the items and perhaps even the index are in external storage; in this section, we briefly consider the case when both the items and the index fit in memory.</p>
<p class="docText">We can adapt binary search trees to build indices in precisely the same manner as we provided indirection for sorting in <a class="docLink" href="ch06lev1sec8.html#ch06lev1sec8">Section 6.8</a> and for heaps in <a class="docLink" href="ch09lev1sec6.html#ch09lev1sec6">Section 9.6</a>: use an <tt>Index</tt> wrapper to define items for the BST, and arrange for keys to be extracted from items via the <tt>key</tt> member function, as usual. Moreover, we can use parallel arrays for the links, as we did for linked lists in <a class="docLink" href="ch03.html#ch03">Chapter 3</a>. We use three arrays, <a name="iddle1725"></a><a name="iddle2447"></a><a name="iddle2451"></a>one each for the items, left links, and right links. The links are array indices (integers), and we replace link references such as</p>
<div class="docText"><pre>x = x-&gt;l</pre></div><br />
<p class="docText">in all our code with array references such as</p>
<div class="docText"><pre>x = l[x].</pre></div><br />
<p class="docText">This approach avoids the cost of dynamic memory allocation for each node&mdash;the items occupy an array without regard to the search function, and we preallocate two integers per item to hold the tree links, recognizing that we will need at least this amount of space when all the items are in the search structure. The space for the links is not always in use, but it is there for use by the search routine without any time overhead for allocation. Another important feature of this approach is that it allows extra arrays (extra information associated with each node) to be added without the tree-manipulation code being changed at all. When the search routine returns the index for an item, it gives a way to access immediately all the information associated with that item, by using the index to access an appropriate array.</p>
<p class="docText">This way of implementing BSTs to aid in searching large arrays of items is sometimes useful, because it avoids the extra expense of copying items into the internal representation of the ADT, and the overhead of allocation and construction by <tt>new</tt>. The use of arrays is not appropriate when space is at a premium and the symbol table grows and shrinks markedly, particularly if it is difficult to estimate the maximum size of the symbol table in advance. If no accurate size prediction is possible, unused links might waste space in the item array.</p>
<p class="docText">An important application of the indexing concept is to provide keyword searching in a string of text (see <a class="docLink" href="#ch12fig11">Figure 12.11</a>). <a class="docLink" href="#ch12ex21">Program 12.11</a> is an example of such an application. It reads a text string from an external file. Then, considering each position in the text string to define a string key starting at that position and going to the end of the string, it inserts all the keys into a symbol table, using string pointers. This use of string keys differs from a string-item type definition such as the one in <a class="docLink" href="ch12lev1sec1.html#ch12qa1q2">Exercise 12.2</a> because no storage allocation is involved. The string keys that we use are arbitrarily long, but we maintain only the pointers to them and we look at only enough characters to decide which of two strings should appear first. No two strings are equal (for example, they are all of different lengths), but if we modify <tt>==</tt> to consider two strings to be equal if one is a prefix of the other, we can use the symbol table to find whether a given query string is in the text, simply by calling <tt>search</tt>.</p>
<a name="ch12fig11"></a><p><center>
<h5 class="docFigureTitle">Figure 12.11. Text string index</h5>
<h5></h5><h5></h5></center></p><p class="docText">In this example of a string index, we define a string key to begin with each word in a text; then, we build a BST, accessing the keys with their string index. The keys are arbitrarily long in principle, but only a few leading characters are generally examined, in practice. For example, to find out whether the phrase <tt>never mind</tt> appears in this text, we compare with <tt>call...</tt> at the root (string index 0), then <tt>me...</tt> at the right child of the root (index 5), then <tt>some...</tt> at the right child of that node (index 16), then we find <tt>never mind</tt> on the left of that node (index 31).</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="185" height="319" src="12fig11.gif" /></p>
<br />
<a name="ch12ex21"></a><h5 id="title-IDAV0CWD" class="docExampleTitle">Program 12.11. Example of indexing a text string</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This program assumes that <tt>Item.cxx</tt> defines a <tt>char*</tt> data representation for string keys in items, an overloaded <tt>operator&lt;</tt> that uses <tt>strcmp</tt>, an overloaded <tt>operator==</tt> that uses <tt>strncmp</tt>, and a conversion operator from <tt>Item</tt> to <tt>char*</tt> (<span class="docEmphasis">see text</span>). The main program reads a text string from a specified file and uses a symbol table to build an index from the strings defined by starting at each character in the text string. Then, it reads query strings from standard input, and prints the position where the query is found in the text (or prints <tt>not found</tt>). With a BST symbol-table implementation, the search is fast, even for huge strings.</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
#include &lt;fstream.h&gt;
#include "Item.cxx"
#include "ST.cxx"
static char text[maxN];
int main(int argc, char *argv[])
  { int N = 0; char t;
    ifstream corpus; corpus.open(*++argv);
    while (N &lt; maxN &amp;&amp; corpus.get(t)) text[N++] = t;
    text[N] = 0;
    ST&lt;Item, Key&gt; st(maxN);
    for (int i = 0; i &lt; N; i++) st.insert(&amp;text[i]);
    char query[maxQ]; Item x, v(query);
    while (cin.getline(query, maxQ))
      if ((x = st.search(v.key())).null())
           cout &lt;&lt; "not found: " &lt;&lt; query &lt;&lt; endl;
      else cout &lt;&lt; x-text &lt;&lt; ": " &lt;&lt; query &lt;&lt; endl;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch12ex21">Program 12.11</a> reads a series of queries from standard input, uses <tt>search</tt> to determine whether each query is in the text, and prints out the text position of the first occurrence of the query. If the symbol table is implemented with BSTs, then we expect from <a class="docLink" href="ch12lev1sec6.html#ch12ex18">Property 12.6</a> that the search will involve about 2<span class="docEmphasis">N</span> ln <span class="docEmphasis">N</span> comparisons. For example, once the index is built, we could find any phrase in a text consisting of about 1 million characters (such as <span class="docEmphasis">Moby Dick</span>) with about 30 string comparisons. This application is the same as indexing, because C string pointers are indices into a character array: If <tt>x</tt> points to <tt>text[i]</tt>, then the difference between the two pointers, <tt>x-text</tt>, is equal to <tt>i</tt>.</p>
<p class="docText">There are many other issues for us to consider when we are building indices in practical applications, and there are many ways that we can take particular advantage of the properties of string keys to speed up our algorithms. More sophisticated methods for string search and for providing indices with useful capabilities for string keys will be primary topics in Part 5.</p>
<p class="docText"><a class="docLink" href="#ch12table02">Table 12.2</a> gives empirical results that support the analytic results that we have been examining, and demonstrates the utility of BSTs for dynamic symbol tables with random keys.</p>
<a name="ch12table02"></a><p><table cellspacing="0" frame="hsides" rules="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 12.2. Empirical study of symbol-table implementations</h5></caption><colgroup align="left" span="11"><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top" colspan="11"><p class="docText">This table gives relative times for constructing a symbol table, then searching for each of the keys in the table. BSTs provide fast implementations of search and insertion; all the other methods require quadratic time for one of the two tasks. Binary search is generally slightly faster than BST search, but cannot be used for huge files unless the table can be presorted. The standard BST implementation allocates memory for each tree node, whereas the index implementation preallocates memory for the whole tree (which speeds up construction) and uses array indices instead of pointers (which slows down searching).</p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="bottomBorder" align="center" valign="top" colspan="5"><p class="docText">construction</p></td><td class="bottomBorder" align="center" valign="top" colspan="5"><p class="docText">search hits</p></td></tr><tr><td class="bottomBorder" align="right" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">A</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">L</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">B</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">T</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">T<a class="docLink" href="#ft_04">*</a></p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">A</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">L</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">B</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">T</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">T<a class="docLink" href="#ft_04">*</a></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">1250</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">5</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">6</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">0</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">6</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">13</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">0</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">1</p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">2500</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">0</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">21</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">24</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">2</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">27</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">52</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">1</p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">5000</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">0</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">87</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">101</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">4</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">3</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">111</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">211</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">2</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">2</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">3</p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">12500</p></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="right" valign="top"><p class="docText">645</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">732</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">12</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">9</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">709</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">1398</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">7</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">8</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">9</p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">25000</p></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="right" valign="top"><p class="docText">2551</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">2917</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">24</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">20</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">2859</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">5881</p></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="right" valign="top"><p class="docText">15</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">21</p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">50000</p></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="right" valign="top"><p class="docText">61</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">50</p></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="right" valign="top"><p class="docText">38</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">48</p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">100000</p></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="right" valign="top"><p class="docText">154</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">122</p></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="right" valign="top"><p class="docText">104</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">122</p></td></tr><tr><td class="bottomBorder" align="right" valign="top"><p class="docText">200000</p></td><td class="bottomBorder" align="left" valign="top">&nbsp;</td><td class="bottomBorder" align="left" valign="top">&nbsp;</td><td class="bottomBorder" align="left" valign="top">&nbsp;</td><td class="bottomBorder" align="right" valign="top"><p class="docText">321</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">275</p></td><td class="bottomBorder" align="left" valign="top">&nbsp;</td><td class="bottomBorder" align="left" valign="top">&nbsp;</td><td class="bottomBorder" align="left" valign="top">&nbsp;</td><td class="bottomBorder" align="right" valign="top"><p class="docText">200</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">272</p></td></tr><tr><td class="docTableCell" align="left" valign="top" colspan="11"><p class="docText"><span class="docEmphasis">Key</span>:</p>
<blockquote><p></p><p class="docList">A Unordered array (<a class="docLink" href="ch12lev1sec3.html#ch12qa3q5">Exercise 12.20</a>)</p></blockquote></td></tr></table></p><p></p><p class="docList">L Ordered linked list (<a class="docLink" href="ch12lev1sec3.html#ch12qa3q6">Exercise 12.21</a>)</p><p></p><p class="docList">B Binary search (<a class="docLink" href="ch12lev1sec4.html#ch12ex13">Program 12.7</a>)T Binary search tree, standard (<a class="docLink" href="ch12lev1sec5.html#ch12ex15">Program 12.8</a>)</p><p></p><p class="docList"><a name="ft_04"></a>T* Binary search tree index (<a class="docLink" href="#ch12qa7q2">Exercise 12.67</a>)</p></td></tr></table><br />
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa7q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.66</span> Modify our BST implementation (<a class="docLink" href="ch12lev1sec5.html#ch12ex15">Program 12.8</a>) to use an indexed array of items, rather than allocated memory. Compare the performance of your program with that of the standard implementation, using one of the drivers in <a class="docLink" href="ch12lev1sec3.html#ch12qa3q8">Exercise 12.23</a> or <a class="docLink" href="ch12lev1sec3.html#ch12qa3q9">Exercise 12.24</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa7q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.67</span> Modify our BST implementation (<a class="docLink" href="ch12lev1sec5.html#ch12ex15">Program 12.8</a>) to support a symbol-table ADT with client item handles (see <a class="docLink" href="ch12lev1sec1.html#ch12qa1q7">Exercise 12.7</a>), using parallel arrays. Compare the performance of your program with that of the standard implementation, using one of the drivers in <a class="docLink" href="ch12lev1sec3.html#ch12qa3q8">Exercise 12.23</a> or <a class="docLink" href="ch12lev1sec3.html#ch12qa3q9">Exercise 12.24</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa7q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.68</span> Modify our BST implementation (<a class="docLink" href="ch12lev1sec5.html#ch12ex15">Program 12.8</a>) to use the following idea to represent BSTs: Keep an array of items with keys and an array of links (one associated with each item) in tree nodes. A left link in the BST corresponds to a move to the next position in the array in the tree node, and a right link in the BST corresponds to a move to another tree node.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa7q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">12.69</span> Give an example of a text string where the number of character comparisons for the index-construction part of <a class="docLink" href="#ch12ex21">Program 12.11</a> is quadratic in the length of the string.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa7q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.70</span> Modify our string index implementation (<a class="docLink" href="#ch12ex21">Program 12.11</a>) to use only the keys that start on word boundaries to build the index (see <a class="docLink" href="#ch12fig11">Figure 12.11</a>). (For <span class="docEmphasis">Moby Dick</span>, this change cuts the size of the index by more than a factor of five.)</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa7q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">12.71</span> Implement a version of <a class="docLink" href="#ch12ex21">Program 12.11</a> that uses binary search on an array of string pointers, using the implementation described in <a class="docLink" href="ch12lev1sec4.html#ch12qa4q5">Exercise 12.38</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa7q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.72</span> Compare the running time of your implementation from <a class="docLink" href="#ch12qa7q6">Exercise 12.71</a> with <a class="docLink" href="#ch12ex21">Program 12.11</a>, to construct an index for a random text string of <span class="docEmphasis">N</span> characters, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>, and to do 1000 (unsuccessful) searches for random keys in each index.</p></td></tr></table></p>
<ul></ul></div></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12lev1sec6.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch12lev1sec8.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table><!--IP User 2--></td></body></head></html>