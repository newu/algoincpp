<html><head><title>9.2. Heap Data Structure</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch09lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch09lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch09lev1sec2"></a>
<h3 id="title-IDALIZWD" class="docSection1Title">9.2. Heap Data Structure</h3>
<p class="docText">The main topic of this chapter is a simple data structure called the <span class="docEmphasis">heap</span> that can efficiently support the basic priority-queue operations. In a heap, the records are stored in an array such that each key is guaranteed to be larger than the keys at two other specific positions. In turn, each of those keys must be larger than two more keys, and so forth. This ordering is easy to see if we view the keys as being in a binary tree structure with edges from each key to the two keys known to be smaller.</p>
<a name="ch09ex04"></a><h5 id="title-IDA2IZWD" class="docExampleTitle">Definition 9.2. </h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><span class="docEmphBoldItalic">A tree is</span> <span class="docEmphStrong">heap-ordered</span> <span class="docEmphBoldItalic">if the key in each node is larger than or equal to the keys in all of that node's children (if any). Equivalently, the key in each node of a heap-ordered tree is smaller than or equal to the key in that node's parent (if any)</span></p>
</td></tr></table></p>
<a name="ch09ex05"></a><h5 id="title-IDAVJZWD" class="docExampleTitle">Property 9.1. No node in a heap-ordered tree has a key larger than the key at the root</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We could impose the heap-ordering restriction on any tree. It is particularly convenient, however, to use a <span class="docEmphasis">complete binary tree</span>. Recall from <a class="docLink" href="ch03.html#ch03">Chapter 3</a> that we can draw such a structure by placing the root node and then proceeding down the page and from left to right, connecting two nodes beneath each node on the previous level until <span class="docEmphasis">N</span> nodes have been placed. We can represent complete binary trees sequentially within an array by simply putting the root at position 1, its children at positions 2 and 3, the nodes at the next level in positions 4, 5, 6 and 7, and so on, as illustrated in <a class="docLink" href="#ch09fig02">Figure 9.2</a>.</p>
</td></tr></table></p>
<a name="ch09fig02"></a><p><center>
<h5 class="docFigureTitle">Figure 9.2. Array representation of a heap-ordered complete binary tree</h5>
<h5></h5><h5></h5></center></p><p class="docText">Considering the element in position <span class="docEmphasis"><img src="U230A.GIF" border="0" />i/2<img src="U230B.GIF" border="0" /></span> in an array to be the parent of the element in position <span class="docEmphasis">i</span>, for <span class="docEmphasis">2 <img src="U2264.GIF" border="0" /> i <img src="U2264.GIF" border="0" /> N</span> (or, equivalently, considering the <span class="docEmphasis">i</span>th element to be the parent of the <span class="docEmphasis">2i</span>th element and the <span class="docEmphasis">(2i + 1)</span>st element), corresponds to a convenient representation of the elements as a tree. This correspondence is equivalent to numbering the nodes in a complete binary tree (with nodes on the bottom as far left as possible) in level order. A tree is <span class="docEmphasis">heap-ordered</span> if the key in any given node is greater than or equal to the keys of that node's children. A <span class="docEmphasis">heap</span> is an array representation of a complete heap-ordered binary tree. The <span class="docEmphasis">i</span>th element in a heap is larger than or equal to both the <span class="docEmphasis">2i</span>th and the <span class="docEmphasis">(2i + 1)</span>st elements.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="220" height="144" src="09fig02.gif" /></p>
<br />
<a name="ch09ex06"></a><h5 id="title-IDALMZWD" class="docExampleTitle">Definition 9.3. A <span class="docEmphasis">heap</span> is a set of nodes with keys arranged in a complete heap-ordered binary tree, represented as an array</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We could use a linked representation for heap-ordered trees, but complete trees provide us with the opportunity to use a compact array representation where we can easily get from a node to its parent and children without needing to maintain explicit links. The parent of the node in position <span class="docEmphasis">i</span> is in position <span class="docEmphasis"><img src="U230A.GIF" border="0" />i/2<img src="U230B.GIF" border="0" /></span>, and, conversely, the two children of the node in position <span class="docEmphasis">i</span> are in positions <span class="docEmphasis">2i</span> and <span class="docEmphasis">2i + 1</span>. This arrangement makes traversal of such a tree even easier than if the tree were implemented with a linked representation, because, in a linked representation, we would need to have three links associated with each key to allow travel up and down the tree (each element would have one pointer to its parent and one to each child). Complete binary trees represented as arrays are rigid structures, but they have just enough flexibility to allow us to implement efficient priority-queue algorithms.</p>
<p class="docText">We shall see in <a class="docLink" href="ch09lev1sec3.html#ch09lev1sec3">Section 9.3</a> that we can use heaps to implement all the priority queue operations (except <span class="docEmphasis">join</span>) such that they require logarithmic time in the worst case. The implementations all operate along some path inside the heap (moving from parent to child toward the bottom or from child to parent toward the top, but not switching directions). As we discussed in <a class="docLink" href="ch03.html#ch03">Chapter 3</a>, all paths in a complete tree of <span class="docEmphasis">N</span> nodes have about lg <span class="docEmphasis">N</span> nodes on them: there are about <span class="docEmphasis">N/2</span> nodes on the bottom, <span class="docEmphasis">N/4</span> nodes with children on the bottom, <span class="docEmphasis">N/8</span> nodes with grandchildren on the bottom, and so forth. Each generation has about one-half as many nodes as the next, and there are at most lg <span class="docEmphasis">N</span> generations.</p>
<p class="docText">We can also use explicit linked representations of tree structures to develop efficient implementations of the priority-queue operations. Examples include triply-linked heap-ordered complete trees (see <a class="docLink" href="ch09lev1sec5.html#ch09lev1sec5">Section 9.5</a>), tournaments (see <a class="docLink" href="ch05lev1sec7.html#ch05ex34">Program 5.19</a>), and binomial queues (see <a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7">Section 9.7</a>). As with simple stacks and queues, one important reason to consider linked representations is that they free us from having to know the maximum queue size ahead of time, as is required with an array representation. We also can make use of the flexibility provided by linked structures to develop efficient algorithms, in certain situations. Readers who are inexperienced with using explicit tree structures are encouraged to read <a class="docLink" href="ch12.html#ch12">Chapter 12</a> to learn basic methods for the even more important symbol-table ADT implementation before tackling the linked tree representations discussed in the exercises in this chapter and in <a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7">Section 9.7</a>. However, careful consideration of linked structures can be reserved for a second reading, because our primary topic in this chapter is the heap (linkless array representation of the heap-ordered complete tree).</p>
</td></tr></table></p>
<p class="docText">&nbsp;<a name="iddle1819"></a></p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa3q1"></a><b></b></td><td><p class="docText"><a name="iddle1606"></a><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">9.17</span> Is an array that is sorted in descending order a heap?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa3q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">9.18</span> The largest element in a heap must appear in position 1, and the second largest element must be in position 2 or position 3. Give the list of positions in a heap of size 15 where the <span class="docEmphasis">k</span>th largest element (<span class="docEmphasis">i</span>) can appear, and (<span class="docEmphasis">ii</span>) cannot appear, for <span class="docEmphasis">k</span> = 2, 3, 4 (assuming the values to be distinct).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa3q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">9.19</span> Answer <a class="docLink" href="#ch09qa3q2">Exercise 9.18</a> for general <span class="docEmphasis">k</span>, as a function of <span class="docEmphasis">N</span>, the heap size.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa3q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">9.20</span> Answer <a class="docLink" href="#ch09qa3q2">Exercises 9.18</a> and <a class="docLink" href="#ch09qa3q3">9.19</a> for the <span class="docEmphasis">k</span>th <span class="docEmphasis">smallest</span> element.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch09lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch09lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>