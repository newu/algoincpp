<html><head><title>5.1. Recursive Algorithms</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch05.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch05lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch05lev1sec1"></a>
<h3 id="title-IDAZMXRE" class="docSection1Title">5.1. Recursive Algorithms</h3>
<p class="docText">A <span class="docEmphasis">recursive algorithm</span> is one that solves a problem by solving one or more smaller instances of the same problem. To implement recursive algorithms in C++, we use <span class="docEmphasis">recursive functions</span>&mdash;a recursive function is one that calls itself. Recursive functions in C++ correspond to recursive definitions of mathematical functions. We begin our study of recursion by examining programs that directly evaluate mathematical functions. The basic mechanisms extend to provide a general-purpose programming paradigm, as we shall see.</p>
<p class="docText"></p><a name="ch05ex01"></a><h5 id="title-IDAONXRE" class="docExampleTitle">Program 5.1. Factorial function (recursive implementation)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1474"></a><a name="iddle1841"></a><a name="iddle1931"></a><a name="iddle2243"></a><a name="iddle2256"></a>This recursive function computes the function <span class="docEmphasis">N</span>!, using the standard recursive definition. It returns the correct value when called with <span class="docEmphasis">N</span> nonnegative and sufficiently small that <span class="docEmphasis">N</span>! can be represented as an <tt>int</tt>.</p>
<div class="docText"><pre>int factorial(int N)
  {
    if (N == 0) return 1;
    return N*factorial(N-1;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">Recurrence relations (see <a class="docLink" href="ch02lev1sec5.html#ch02lev1sec5">Section 2.5</a>) are recursively defined functions. A recurrence relation defines a function whose domain is the nonnegative integers either by some initial values or (recursively) in terms of its own values on smaller integers. Perhaps the most familiar such function is the <span class="docEmphasis">factorial</span> function, which is defined by the recurrence relation</p>
<div class="docText"><pre><span class="docEmphasis">N</span>!=<span class="docEmphasis">N</span> .(<span class="docEmphasis">N</span> &ndash; 1)!,   for <span class="docEmphasis">N</span> <img src="U2265.GIF" border="0" /> 1 with 0! = 1.</pre></div><br />
<p class="docText">This definition corresponds directly to the recursive C++ function in <a class="docLink" href="#ch05ex01">Program 5.1</a>.</p>
<p class="docText"><a class="docLink" href="#ch05ex01">Program 5.1</a> is equivalent to a simple loop. For example, the following <tt>for</tt> loop performs the same computation:</p>
<div class="docText"><pre>for (t = 1, i = 1; i &lt;= N; i++) t *= i;</pre></div><br />
<p class="docText">As we shall see, it is always possible to transform a recursive program into a nonrecursive one that performs the same computation. Conversely, we can express without loops any computation that involves loops, using recursion, as well.</p>
<p class="docText">We use recursion because it often allows us to express complex algorithms in a compact form, without sacrificing efficiency. For example, the recursive implementation of the factorial function obviates the need for local variables. The cost of the recursive implementation is borne by the mechanisms in the programming systems that support function calls, which use the equivalent of a built-in pushdown stack. Most modern programming systems have carefully engineered mechanisms for this task. Despite this advantage, as we shall see, it is all too easy to write a simple recursive function that is extremely inefficient, <a name="iddle1650"></a><a name="iddle2248"></a>and we need to exercise care to avoid being burdened with intractable implementations.</p>
<a name="ch05ex02"></a><h5 id="title-IDABSXRE" class="docExampleTitle">Program 5.2. A questionable recursive program</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">If the argument <span class="docEmphasis">N</span> is odd, this function calls itself with 3<span class="docEmphasis">N</span> + 1 as an argument; if <span class="docEmphasis">N</span> is even, it calls itself with <span class="docEmphasis">N/2</span> as an argument. We cannot use induction to prove that this program terminates, because not every recursive call uses an argument smaller than the one given.</p>
<div class="docText"><pre>int puzzle(int N)
  {
    if (N == 1) return 1;
    if (N % 2 == 0)
         return puzzle(N/2);
    else return puzzle(3*N+1);
  }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch05ex01">Program 5.1</a> illustrates the basic features of a recursive program: it calls itself (with a smaller value of its argument), and it has a termination condition in which it directly computes its result. We can use mathematical induction to convince ourselves that the program works as intended:</p>
<ul><li><p class="docList">It computes <span class="docEmphRoman">0!</span> (basis).</p></li><li><p class="docList">Under the assumption that it computes <span class="docEmphasis">k!</span> for <span class="docEmphasis">k &lt; N</span> (inductive hypothesis), it computes <span class="docEmphasis">N</span>!.</p></li></ul>
<p class="docText">Reasoning like this can provide us with a quick path to developing algorithms that solve complex problems, as we shall see.</p>
<p class="docText">In a programming language such as C++, there are few restrictions on the kinds of programs that we write, but we strive to limit ourselves in our use of recursive functions to those that embody inductive proofs of correctness like the one outlined in the previous paragraph. Although we do not consider formal correctness proofs in this book, we are interested in putting together complicated programs for difficult tasks, and we need to have some assurance that the tasks will be solved properly. Mechanisms such as recursive functions can provide such assurances while giving us compact implementations. Practically speaking, the connection to mathematical induction tells us that we should ensure that our recursive functions satisfy two basic properties:</p>
<p class="docText"></p><a name="ch05ex03"></a><h5 id="title-IDAGUXRE" class="docExampleTitle">Program 5.3. Euclid's algorithm</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1443"></a><a name="iddle2242"></a><a name="iddle2252"></a>One of the oldest-known algorithms, dating back over 2000 years, is this recursive method for finding the greatest common divisors of two integers.</p>
<div class="docText"><pre>int gcd(int m, int n)
  {
    if (n == 0) return m;
    return gcd(n, m % n);
  }</pre></div><br />
</td></tr></table></p>
<ul><li><p class="docList">They must explicitly solve a basis case.</p></li><li><p class="docList">Each recursive call must involve smaller values of the arguments.</p></li></ul>
<p class="docText">These points are vague&mdash;they amount to saying that we should have a valid inductive proof for each recursive function that we write. Still, they provide useful guidance as we develop implementations.</p>
<p class="docText"><a class="docLink" href="#ch05ex02">Program 5.2</a> is an amusing example that illustrates the need for an inductive argument. It is a recursive function that violates the rule that each recursive call must involve smaller values of the arguments, so we cannot use mathematical induction to understand it. Indeed, it is not known whether or not this computation terminates for every <span class="docEmphasis">N</span>, if there are no bounds on the size of <span class="docEmphasis">N</span>. For small integers that can be represented as <tt>ints</tt>, we can check that the program terminates (see <a class="docLink" href="#ch05fig01">Figure 5.1</a> and <a class="docLink" href="#ch05qa1q4">Exercise 5.4</a>), but for large integers (64-bit words, say), we do not know whether or not this program goes into an infinite loop.</p>
<a name="ch05fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 5.1. Example of a recursive call chain</h5>
<h5></h5><h5></h5></center></p><p class="docText">This nested sequence of function calls eventually terminates, but we cannot prove that the recursive function in <a class="docLink" href="#ch05ex02">Program 5.2</a> does not have arbitrarily deep nesting for some argument. We prefer recursive programs that always invoke themselves with smaller arguments.</p>
<p class="docText">
<img border="0" alt="" width="175" height="129" src="05fig01.gif" /></p>
<br />
<p class="docText"><a class="docLink" href="#ch05ex03">Program 5.3</a> is a compact implementation of <span class="docEmphasis">Euclid's algorithm</span> for finding the greatest common divisor of two integers. It is based on the observation that the greatest common divisor of two integers <span class="docEmphasis">x</span> and <span class="docEmphasis">y</span> with <span class="docEmphasis">x &gt; y</span> is the same as the greatest common divisor of <span class="docEmphasis">y</span> and <span class="docEmphasis">x</span> <tt>mod</tt> <span class="docEmphasis">y</span> (the remainder when <span class="docEmphasis">x</span> is divided by <span class="docEmphasis">y</span>). A number <span class="docEmphasis">t</span> divides both <span class="docEmphasis">x</span> and <span class="docEmphasis">y</span> if and only if <span class="docEmphasis">t</span> divides both <span class="docEmphasis">y</span> and <span class="docEmphasis">x</span> <tt>mod</tt> <span class="docEmphasis">y</span>, because <span class="docEmphasis">x</span> is equal to <span class="docEmphasis">x</span> <tt>mod</tt> <span class="docEmphasis">y</span> plus a multiple of <span class="docEmphasis">y</span>. The recursive calls made for an example invocation of this program are shown in <a class="docLink" href="#ch05fig02">Figure 5.2</a>. For Euclid's algorithm, the depth of the recursion depends on arithmetic properties of the arguments (it is known to be logarithmic).</p>
<a name="ch05fig02"></a><p><center>
<h5 class="docFigureTitle">Figure 5.2. Example of Euclid's algorithm</h5>
<h5></h5><h5></h5></center></p><p class="docText">This nested sequence of function calls illustrates the operation of Euclid's algorithm in discovering that 314159 and 271828 are relatively prime.</p>
<p class="docText">
<img border="0" alt="" width="175" height="141" src="05fig02.gif" /></p>
<br />
<p class="docText"><a class="docLink" href="#ch05ex04">Program 5.4</a> is an example with multiple recursive calls. It is another expression evaluator, performing essentially the same computations <a name="iddle2090"></a><a name="iddle2253"></a><a name="iddle2258"></a>as <a class="docLink" href="ch04.html#ch04ex03">Program 4.2</a>, but on prefix (rather than postfix) expressions, and letting recursion take the place of the explicit pushdown stack. In this chapter, we shall see many other examples of recursive programs and equivalent programs that use pushdown stacks. We shall examine the specific relationship between several pairs of such programs in detail.</p>
<a name="ch05ex04"></a><h5 id="title-IDA21XRE" class="docExampleTitle">Program 5.4. Recursive program to evaluate prefix expressions</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">To evaluate a prefix expression, we either convert a number from ASCII to binary (in the <tt>while</tt> loop at the end), or perform the operation indicated by the first character in the expression on the two operands, evaluated recursively. This function is recursive, but it uses a global array containing the expression and an index to the current character in the expression. The index is advanced past each subexpression evaluated.</p>
<div class="docText"><pre>char *a; int i;
int eval()
  { int x = 0;
    while (a[i] == ' ') i++;
    if (a[i] == '+')
      { i++; return eval() + eval(); }
    if (a[i] == '*')
      { i++; return eval() * eval(); }
    while ((a[i] &gt;= '0') &amp;&amp; (a[i] &lt;= '9'))
      x = 10*x + (a[i++]-'0');
    return x;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch05fig03">Figure 5.3</a> shows the operation of <a class="docLink" href="#ch05ex04">Program 5.4</a> on a sample prefix expression. The multiple recursive calls mask a complex series of computations. Like most recursive programs, this program is best understood inductively: Assuming that it works properly for simple expressions, we can convince ourselves that it works properly for complex ones. This program is a simple example of a <span class="docEmphasis">recursive descent parser</span>&mdash;we can use the same process to convert C++ programs into machine code.</p>
<a name="ch05fig03"></a><p><center>
<h5 class="docFigureTitle">Figure 5.3. Prefix expression evaluation example</h5>
<h5></h5><h5></h5></center></p><p class="docText">This nested sequence of function calls illustrates the operation of the recursive prefix-expression&ndash;evaluation algorithm on a sample expression. For simplicity, the expression arguments are shown here. The algorithm itself never explicitly decides the extent of its argument string: rather, it takes what it needs from the front of the string.</p>
<p class="docText">
<img border="0" alt="" width="165" height="245" src="05fig03.gif" /></p>
<br />
<p class="docText">A precise inductive proof that <a class="docLink" href="#ch05ex04">Program 5.4</a> evaluates the expression properly is certainly much more challenging to write than are the proofs for functions with integer arguments that we have been <a name="iddle1800"></a><a name="iddle2238"></a><a name="iddle2250"></a>discussing, and we shall encounter recursive programs and data structures that are even more complicated than this one throughout this book. Accordingly, we do not pursue the idealistic goal of providing complete inductive proofs of correctness for every recursive program that we write. In this case, the ability of the program to &quot;know&quot; how to separate the operands corresponding to a given operator seems mysterious at first (perhaps because we cannot immediately see how to do this separation at the top level), but is actually a straightforward calculation (because the path to pursue at each function call is unambiguously determined by the first character in the expression).</p>
<p class="docText">In principle, we can replace any <tt>for</tt> loop by an equivalent recursive program. Often, the recursive program is a more natural way to express the computation than the <tt>for</tt> loop, so we may as well take advantage of the mechanism provided by the programming system that supports recursion. There is one hidden cost, however, that we need to bear in mind. As is plain from the examples that we examined in <a class="docLink" href="#ch05fig01">Figures 5.1</a> through <a class="docLink" href="#ch05fig03">5.3</a>, when we execute a recursive program, we are nesting function calls, until we reach a point where we do not do a recursive call, and we return instead. In most programming environments, such nested function calls are implemented using the equivalent of built-in pushdown stacks. We shall examine the nature of such implementations throughout this chapter. The <span class="docEmphasis">depth of the recursion</span> is the maximum degree of nesting of the function calls over the course of the computation. Generally, the depth will depend on the input. For example, the depths of the recursions for the examples depicted in <a class="docLink" href="#ch05fig02">Figures 5.2</a> and <a class="docLink" href="#ch05fig03">5.3</a> are 9 and 4, respectively. When using a recursive program, we need to take into account that the programming environment has to maintain a pushdown stack of size proportional to the depth of the recursion. For huge problems, the space needed for this stack might prevent us from using a recursive solution.</p>
<p class="docText">Data structures built from nodes with pointers are inherently recursive. For example, our definition of linked lists in <a class="docLink" href="ch03.html#ch03">Chapter 3</a> (<a class="docLink" href="ch03lev1sec4.html#ch03ex12">Definition 3.3</a>) is recursive. Therefore, recursive programs provide natural implementations of many commonly used functions for manipulating such data structures. <a class="docLink" href="#ch05ex05">Program 5.5</a> comprises four examples. We use such implementations frequently throughout the book, primarily because they are so much easier to understand than are their nonrecursive counterparts. However, we must exercise caution in using programs <a name="iddle2263"></a><a name="iddle2505"></a>such as those in <a class="docLink" href="#ch05ex05">Program 5.5</a> when processing huge lists, because the depth of the recursion for those functions can be proportional to the length of the lists, so the space required for the recursive stack might become prohibitive.</p>
<a name="ch05ex05"></a><h5 id="title-IDAWBYRE" class="docExampleTitle">Program 5.5. Examples of recursive functions for linked lists</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">These recursive functions for simple list-processing tasks are easy to express, but may not be useful for huge lists because the depth of the recursion may be proportional to the length of the list.</p>
<p class="docText">The first function, <tt>count</tt>, counts the number of nodes on the list. The second, <tt>traverse</tt>, calls the function <tt>visit</tt> for each node on the list, from beginning to end. These two functions are both also easy to implement with a <tt>for</tt> or <tt>while</tt> loop. The third function, <tt>traverseR</tt>, does not have a simple iterative counterpart. It calls the function <tt>visit</tt> for every node on the list, but in reverse order.</p>
<p class="docText">The fourth function, <tt>remove</tt>, removes all the nodes having a given item value from a list. The key to the implementation is the link change <tt>x = x-&gt;next</tt> in the predecessor of each node to be deleted, which is made possible by the use of a reference parameter. The structural changes for each iteration of the <tt>while</tt> loop are the same as diagrammed in <a class="docLink" href="ch03lev1sec3.html#ch03fig03">Figure 3.3</a>, but <tt>x</tt> and <tt>t</tt> here both refer to the same node.</p>
<div class="docText"><pre>int count(link x)
  {
    if (x == 0) return 0;
    return 1 + count(x-&gt;next);
  }
void traverse(link h, void visit(link))
  {
    if (h == 0) return;
    visit(h);
    traverse(h-&gt;next, visit);
  }
void traverseR(link h, void visit(link))
  {
    if (h == 0) return;
    traverseR(h-&gt;next, visit);
    visit(h);
  }
void remove(link&amp; x, Item v)
  {
    while (x != 0 &amp;&amp; x-&gt;item == v)
      { link t = x; x = x-&gt;next; delete t; }
    if (x != 0) remove(x-&gt;next, v);
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">Some programming environments automatically detect and eliminate <span class="docEmphasis">tail recursion</span>, when the last action of a function is a recursive call, because it is not strictly necessary to add to the depth of the recursion in such a case. This improvement would effectively transform the count, traversal, and removal functions in <a class="docLink" href="#ch05ex05">Program 5.5</a> into loops, but it does not apply to the reverse-order traversal function.</p>
<p class="docText">In <a class="docLink" href="ch05lev1sec2.html#ch05lev1sec2">Sections 5.2</a> and <a class="docLink" href="ch05lev1sec3.html#ch05lev1sec3">5.3</a>, we consider two families of recursive algorithms that represent essential computational paradigms. Then, in <a class="docLink" href="ch05lev1sec4.html#ch05lev1sec4">Sections 5.4</a> through <a class="docLink" href="ch05lev1sec7.html#ch05lev1sec7">5.7</a>, we consider recursive data structures that serve as the basis for a very large fraction of the algorithms that we consider.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa1q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">5.1</span> Write a recursive program to compute lg(<span class="docEmphasis">N</span>!).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa1q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.2</span> Modify <a class="docLink" href="#ch05ex01">Program 5.1</a> to compute <span class="docEmphasis">N</span>! <tt>mod</tt> <span class="docEmphasis">M</span>, such that overflow is no longer an issue. Try running your program for <span class="docEmphasis"><tt>M</tt></span> <tt>= 997</tt> and <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10</tt><sup><span class="docEmphasis"><tt>5</tt></span></sup>, and <tt>10<sup>6</sup></tt>, to get an indication of how your programming system handles deeply nested recursive calls.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa1q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">5.3</span> Give the sequences of argument values that result when <a class="docLink" href="#ch05ex02">Program 5.2</a> is invoked for each of the integers 1 through 9.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa1q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">5.4</span> Find the value of <span class="docEmphasis"><tt>N</tt></span> <tt>&lt; 10<sup>6</sup></tt> for which <a class="docLink" href="#ch05ex02">Program 5.2</a> makes the maximum number of recursive calls.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa1q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">5.5</span> Provide a nonrecursive implementation of Euclid's algorithm.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa1q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">5.6</span> Give the figure corresponding to <a class="docLink" href="#ch05fig02">Figure 5.2</a> for the result of running Euclid's algorithm for the inputs 89 and 55.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa1q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.7</span> Give the recursive depth of Euclid's algorithm when the input values are two consecutive Fibonacci numbers (<span class="docEmphasis">F<sub>N</sub></span> and <span class="docEmphasis">F</span><span class="docEmphasis"><sub>N</sub></span>+1).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa1q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">5.8</span> Give the figure corresponding to <a class="docLink" href="#ch05fig03">Figure 5.3</a> for the result of recursive prefix-expression evaluation for the input <tt>+ * * 12 12 12 144</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa1q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.9</span> Write a recursive program to evaluate postfix expressions.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa1q10"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.10</span> Write a recursive program to evaluate infix expressions. You may assume that operands are always enclosed in parentheses.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa1q11"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.11</span> Write a recursive program that converts infix expressions to postfix.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa1q12"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.12</span> Write a recursive program that converts postfix expressions to infix.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa1q13"></a><b></b></td><td><p class="docText"><a name="iddle1367"></a><a name="iddle1373"></a><a name="iddle2239"></a><a name="iddle2245"></a><span class="docEmphStrong">5.13</span> Write a recursive program for the Josephus problem (see <a class="docLink" href="ch03lev1sec3.html#ch03lev1sec3">Section 3.3</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa1q14"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.14</span> Write a recursive program that removes the final node of a linked list.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa1q15"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.15</span> Write a recursive program for reversing the order of the nodes in a linked list (see <a class="docLink" href="ch03lev1sec2.html#ch03ex08">Program 3.7</a>). <span class="docEmphasis">Hint</span>: Use a global variable.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch05.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch05lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>