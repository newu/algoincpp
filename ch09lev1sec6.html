<html><head><title>9.6. Priority Queues for Index Items</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch09lev1sec5.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch09lev1sec7.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch09lev1sec6"></a>
<h3 id="title-IDA5W12H" class="docSection1Title">9.6. Priority Queues for Index Items</h3>
<p class="docText">Suppose that the records to be processed in a priority queue are in an existing array. In this case, it makes sense to have the priority-queue routines refer to items through the array index. Moreover, we can use the array index as a handle to implement all the priority-queue operations. An interface along these lines is illustrated in <a class="docLink" href="#ch09ex20">Program 9.11</a>. <a class="docLink" href="#ch09fig13">Figure 9.13</a> shows how this approach might apply in the example we used to examine index sorting in <a class="docLink" href="ch06.html#ch06">Chapter 6</a>. Without copying or making special modifications of records, we can keep a priority queue containing a subset of the records.</p>
<a name="ch09fig13"></a><p><center>
<h5 class="docFigureTitle">Figure 9.13. Index heap data structures</h5>
<h5></h5><h5></h5></center></p><p class="docText">By manipulating indices, rather than the records themselves, we can build a priority queue on a subset of the records in an array. Here, a heap of size 5 in the array <span class="docEmphasis">pq</span> contains the indices to those students with the top five grades. Thus, <span class="docEmphasis">data[pq[1]]</span>.name contains Smith, the name of the student with the highest grade, and so forth. An inverse array <span class="docEmphasis">qp</span> allows the priority-queue routines to treat the array indices as handles. For example, if we need to change Smith's grade to 85, we change the entry in <span class="docEmphasis">data[3].grade</span>, then call <span class="docEmphasis">PQchange(3)</span>. The priority-queue implementation accesses the record at <span class="docEmphasis">pq[qp[3]]</span> (or <span class="docEmphasis">pq[1]</span>, because <span class="docEmphasis">qp[3]=1)</span> and the new key at <span class="docEmphasis">data[pq[1]].name</span> (or <span class="docEmphasis">data[3].name</span>, because <span class="docEmphasis">pq[1]=3)</span>.</p>
<p class="docText">
<img border="0" alt="" width="175" height="254" src="09fig13.gif" /></p>
<br />
<a name="ch09fig14"></a><p><center>
<h5 class="docFigureTitle">Figure 9.14. Changing of the priority of a node in a heap</h5>
<h5></h5><h5></h5></center></p><p class="docText">The top diagram depicts a heap that is known to be heap ordered, except possibly at one given node. If the node is larger than its parent, then it must move up, just as depicted in <a class="docLink" href="ch09lev1sec3.html#ch09fig03">Figure 9.3</a>. This situation is illustrated in the middle diagram, with <span class="docEmphasis">Y</span> moving up the tree (in general, it might stop before hitting the root). If the node is smaller than the larger of its two children, then it must move down, just as depicted in <a class="docLink" href="ch09lev1sec3.html#ch09fig03">Figure 9.3</a>. This situation is illustrated in the bottom diagram, with <span class="docEmphasis">B</span> moving down the tree (in general, it might stop before hitting the bottom). We can use this procedure as the basis for the change priority operation on heaps, to reestablish the heap condition after changing the key in a node; or as the basis for the remove operation on heaps, to reestablish the heap condition after replacing the key in a node with the rightmost key on the bottom level.</p>
<p class="docText">
<img border="0" alt="" width="175" height="259" src="09fig14.gif" /></p>
<br />
<p class="docText">Using indices into an existing array is a natural arrangement, but it leads to implementations with an orientation opposite to that of <a class="docLink" href="ch09lev1sec5.html#ch09ex17">Program 9.8</a>. Now it is the client program that cannot move around information freely, because the priority-queue routine is maintaining indices into data maintained by the client. For its part, the priority queue implementation must not use indices without first being given them by the client.</p>
<p class="docText">To develop an implementation, we use precisely the same approach as we did for index sorting in <a class="docLink" href="ch06lev1sec8.html#ch06lev1sec8">Section 6.8</a>. We manipulate indices and overload <tt>operator&lt;</tt> such that comparisons reference the client's array. There are added complications here, because it is necessary for the priority-queue routine to keep track of the objects, so that it can find them when the client program refers to them by the handle (array index). To this end, we add a second index array to keep track of the position of the keys in the priority queue. To localize the maintenance of this array, we move data only with the <tt>exch</tt> operation, then define <tt>exch</tt> appropriately.</p>
<p class="docText">A full implementation of this approach using heaps is given in <a class="docLink" href="ch09lev1sec3.html#ch09ex12">Program 9.12</a>. This program differs only slightly from <a class="docLink" href="ch09lev1sec3.html#ch09ex09">Program 9.5</a>, but it is well worth studying because it is so useful in practical situations. We refer to the data structure built by this program as an <span class="docEmphasis">index</span> <a name="iddle1093"></a><a name="iddle2102"></a><span class="docEmphasis">heap</span>. We shall use this program as a building block for other algorithms in Parts 5 through 7. As usual, we do no error checking, and we assume (for example) that indices are always in the proper range and that the user does not try to insert anything on a full queue or to remove anything from an empty one. Adding code for such checks is straightforward.</p>
<a name="ch09ex20"></a><h5 id="title-IDAIFACH" class="docExampleTitle">Program 9.11. Priority queue ADT interface for index items</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Instead of building a data structure from the items themselves, this interface provides for building a priority queue using indices into a client array. The <span class="docEmphasis">insert</span>, <span class="docEmphasis">remove the maximum</span>, <span class="docEmphasis">change priority</span>, and <span class="docEmphasis">remove</span> routines all use a handle consisting of an array index, and the client overloads <tt>operator&lt;</tt> to compare two array entries. For example, the client program might define <tt>operator&lt;</tt> so that <tt>i &lt; j</tt> is the result of comparing <tt>data[i].grade</tt> and <tt>data[j].grade</tt>.</p>
<div class="docText"><pre>    template &lt;class Index&gt;
    class PQ
      {
        private:
          // Implementation-dependent code
        public:
          PQ(int);
          int empty() const;
          void insert(Index);
          Index getmax();
          void change(Index);
          void remove(Index);
      };</pre></div><br />
</td></tr></table></p>
<p class="docText">We can use the same approach for any priority queue that uses an array representation (for example, see <a class="docLink" href="#ch09qa7q3">Exercises 9.50</a> and <a class="docLink" href="#ch09qa7q4">9.51</a>). The main disadvantage of using indirection in this way is the extra space used. The size of the index arrays has to be the size of the data array, when the maximum size of the priority queue could be much less. Another approach to building a priority queue on top of existing data in an array is to have the client program make records consisting of a key with its array index as associated information, or to use an index key with a client-supplied overloaded <tt>operator&lt;</tt>. Then, <a name="iddle1560"></a><a name="iddle1961"></a>if the implementation uses a linked-allocation representation such as the one in <a class="docLink" href="ch09lev1sec5.html#ch09ex18">Programs 9.9</a> and <a class="docLink" href="ch09lev1sec5.html#ch09ex19">9.10</a> or <a class="docLink" href="ch09lev1sec5.html#ch09qa6q4">Exercise 9.41</a>, then the space used by the priority queue would be proportional to the maximum number of elements on the queue at any one time. Such approaches would be preferred over <a class="docLink" href="#ch09ex21">Program 9.12</a> if space must be conserved and if the priority queue involves only a small fraction of the data array.</p>
<a name="ch09ex21"></a><h5 id="title-IDAUIACH" class="docExampleTitle">Program 9.12. Index-heap-based priority queue</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This implementation of <a class="docLink" href="#ch09ex20">Program 9.11</a> maintains <tt>pq</tt> as an array of indices into some client array. For example, if the client defines <tt>operator&lt;</tt> for arguments of type <tt>Index</tt> as indicated in the commentary before <a class="docLink" href="#ch09ex20">Program 9.11</a>, then, when <tt>fixUp</tt> compares <tt>pq[j]</tt> with <tt>pq[k]</tt>, it is comparing <tt>data.grade[pq[j]]</tt> with <tt>data.grade[pq[k]]</tt>, as desired. We assume that <tt>Index</tt> is a wrapper class whose object can index arrays, so that we can keep the heap position corresponding to index value <span class="docEmphasis">k</span> in <tt>qp[k]</tt>, which allows us to implement <span class="docEmphasis">change priority</span> and <span class="docEmphasis">remove</span> (see <a class="docLink" href="#ch09qa7q2">Exercise 9.49</a>). We maintain the invariant <tt>pq[qp[k]]=qp[pq[k]]=k</tt> for all <span class="docEmphasis">k</span> in the heap (see <a class="docLink" href="#ch09fig13">Figure 9.13</a>).</p>
<div class="docText"><pre>    template &lt;class Index&gt;
    class PQ
      {
        private:
          int N; Index* pq; int* qp;
          void exch(Index i, Index j)
            { int t;
              t = qp[i]; qp[i] = qp[j]; qp[j] = t;
              pq[qp[i]] = i; pq[qp[j]] = j;
            }
        void fixUp(Index a[], int k);
        void fixDown(Index a[], int k, int N);
        public:
          PQ(int maxN)
            { pq = new Index[maxN+1];
              qp = new int[maxN+1]; N = 0; }
          int empty() const
            { return N == 0; }
          void insert(Index v)
            { pq[++N] = v; qp[v] = N; fixUp(pq, N); }
          Index getmax()
            {
              exch(pq[1], pq[N]);
              fixDown(pq, 1, N-1);
              return pq[N--];
            }
          void change(Index k)
            { fixUp(pq, qp[k]); fixDown(pq, qp[k], N); }
      };</pre></div><br />
</td></tr></table></p>
<p class="docText">Contrasting this approach to providing a complete priority-queue implementation to the approach in <a class="docLink" href="ch09lev1sec5.html#ch09lev1sec5">Section 9.5</a> exposes essential differences in abstract-data-type design. In the first case (<a class="docLink" href="ch09lev1sec5.html#ch09ex17">Program 9.8</a>, for example), it is the responsibility of the priority queue implementation to allocate and deallocate the memory for the keys, to change key values, and so forth. The ADT supplies the client with handles to items, and the client accesses items only through calls to the priority-queue routines, using the handles as arguments. In the second case, (Pro-gram 9.12, for example), the client program is responsible for the keys and records, and the priority-queue routines access this information only through handles provided by the user (array indices, in the case of <a class="docLink" href="#ch09ex21">Program 9.12</a>). Both uses require cooperation between client and implementation.</p>
<p class="docText">Note that, in this book, we are normally interested in cooperation beyond that encouraged by programming language support mechanisms. In particular, we want the performance characteristics of the implementation to match the dynamic mix of operations required by the client. One way to ensure that match is to seek implementations with provable worst-case performance bounds, but we can solve many problems more easily by matching their performance requirements with simpler implementations.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa7q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.48</span> Suppose that an array is filled with the keys E A S Y Q U E S T I O N. Give the contents of the <tt>pq</tt> and <tt>qp</tt> arrays after these keys are inserted into an initially empty heap using <a class="docLink" href="#ch09ex21">Program 9.12</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa7q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">9.49</span> Add a <span class="docEmphasis">remove</span> operation to <a class="docLink" href="#ch09ex21">Program 9.12</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa7q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.50</span> Implement the priority-queue ADT for index items (see <a class="docLink" href="#ch09ex20">Program 9.11</a>) using an ordered-array representation for the priority queue.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa7q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.51</span> Implement the priority-queue ADT for index items (see <a class="docLink" href="#ch09ex20">Program 9.11</a>) using an unordered-array representation for the priority queue.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa7q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">9.52</span> Given an array <tt>a</tt> of <span class="docEmphasis">N</span> elements, consider a complete binary tree of <span class="docEmphasis">2N</span> elements (represented as an array <tt>pq</tt>) containing indices from the array with the <a name="iddle1094"></a><a name="iddle1208"></a><a name="iddle1219"></a><a name="iddle2103"></a><a name="iddle2119"></a><a name="iddle2151"></a>following properties: (<span class="docEmphasis">i</span>) for <span class="docEmphasis">i</span> from 0 to <span class="docEmphasis">N - 1</span>, we have <tt>pq[N+i]=i</tt>; and (<span class="docEmphasis">ii</span>) for <span class="docEmphasis">i</span> from 1 to <tt>N - 1</tt>, we have <tt>pq[i]=pq[2*i]</tt> if <tt>a[pq[2*i]]&gt;a[pq[2*i+1]]</tt>, and we have <tt>pq[i]=pq[2*i+1]</tt> otherwise. Such a structure is called an <span class="docEmphasis">index heap tournament</span> because it combines the features of index heaps and tournaments (see <a class="docLink" href="ch05lev1sec7.html#ch05ex34">Program 5.19</a>). Give the index heap tournament corresponding to the keys E A Q U E S T I O N.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa7q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">9.53</span> Implement the priority-queue ADT for index items (see <a class="docLink" href="#ch09ex21">Program 9.11</a>) using an index heap tournament (see <a class="docLink" href="ch09lev1sec5.html#ch09qa6q8">Exercise 9.45</a>).</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch09lev1sec5.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch09lev1sec7.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>