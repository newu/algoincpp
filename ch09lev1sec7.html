<html><head><title>9.7. Binomial Queues</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch09lev1sec6.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch10.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch09lev1sec7"></a>
<h3 id="643999-915" class="docSection1Title">9.7. Binomial Queues</h3>
<p class="docText">None of the implementations that we have considered admit implementations of <span class="docEmphasis">join</span>, <span class="docEmphasis">remove the maximum</span>, and <span class="docEmphasis">insert</span> that are all efficient in the worst case. Unordered linked lists have fast <span class="docEmphasis">join</span> and <span class="docEmphasis">insert</span>, but slow <span class="docEmphasis">remove the maximum</span>; ordered linked lists have fast <span class="docEmphasis">remove the maximum</span>, but slow <span class="docEmphasis">join</span> and <span class="docEmphasis">insert</span>; heaps have fast <span class="docEmphasis">insert</span> and <span class="docEmphasis">remove the maximum</span>, but slow <span class="docEmphasis">join</span>; and so forth. (See <a class="docLink" href="ch09lev1sec1.html#ch09table01">Table 9.1</a>.) In applications where frequent or large <span class="docEmphasis">join</span> operations play an important role, we need to consider more advanced data structures.</p>
<p class="docText">In this context, we mean by &quot;efficient&quot; that the operations should use no more than logarithmic time in the worst case. This restriction would seem to rule out array representations, because we can join two large arrays apparently only by moving all the elements in at least one of them. The unordered doubly linked-list representation of <a class="docLink" href="ch09lev1sec5.html#ch09ex18">Program 9.9</a> does the <span class="docEmphasis">join</span> in constant time, but requires that we walk through the whole list for <span class="docEmphasis">remove the maximum</span>. Use of a doubly linked ordered list (see <a class="docLink" href="ch09lev1sec5.html#ch09qa6q2">Exercise 9.39</a>) gives a constant-time <span class="docEmphasis">remove the maximum</span>, but requires linear time to merge lists for <span class="docEmphasis">join</span>.</p>
<p class="docText">Numerous data structures have been developed that can support efficient implementations of all the priority-queue operations. Most of them are based on direct linked representation of heap-ordered trees. Two links are needed for moving down the tree (either to both children in a binary tree or to the first child and next sibling in a binary tree representation of a general tree) and one link to the parent is needed for moving up the tree. Developing implementations of the heap-ordering operations that work for any (heap-ordered) tree shape with explicit nodes and links or other representation is generally straightforward. The difficulty lies in dynamic operations such as <span class="docEmphasis">insert</span>, <span class="docEmphasis">remove</span>,and <span class="docEmphasis">join</span>, which require us to modify the tree structure.</p>
<p class="docText"><a name="iddle1209"></a><a name="iddle1610"></a><a name="iddle1814"></a><a name="iddle2087"></a><a name="iddle2114"></a><a name="iddle2618"></a>Different data structures are based on different strategies for modifying the tree structure while still maintaining balance in the tree. Generally, the algorithms use trees that are more flexible than are complete trees, but keep the trees sufficiently balanced to ensure a logarithmic time bound.</p>
<p class="docText">The overhead of maintaining a triply linked structure can be burdensome&mdash;ensuring that a particular implementation correctly maintains three pointers in all circumstances can be a significant challenge (see <a class="docLink" href="ch09lev1sec5.html#ch09qa6q3">Exercise 9.40</a>). Moreover, in many practical situations, it is difficult to demonstrate that efficient implementations of <span class="docEmphasis">all</span> the operations are required, so we might pause before taking on such an implementation. On the other hand, it is also difficult to demonstrate that efficient implementations are <span class="docEmphasis">not</span> required, and the investment to guarantee that all the priority-queue operations will be fast may be justified. Regardless of such considerations, the next step from heaps to a data structure that allows for efficient implementation of <span class="docEmphasis">join</span>, <span class="docEmphasis">insert</span>,and <span class="docEmphasis">remove the maximum</span> is fascinating and worthy of study in its own right.</p>
<p class="docText">Even with a linked representation for the trees, the heap condition and the condition that the heap-ordered binary tree be complete are too strong to allow efficient implementation of the <span class="docEmphasis">join</span> operation. Given two heap-ordered trees, how do we merge them together into just one tree? For example, if one of the trees has 1023 nodes and the other has 255 nodes, how can we merge them into a tree with 1278 nodes, without touching more than 10 or 20 nodes? It seems impossible to merge heap-ordered trees in general if the trees are to be heap ordered and complete, but various advanced data structures have been devised that weaken the heap-order and balance conditions to get the flexibility that we need to devise an efficient <span class="docEmphasis">join</span>. Next, we consider an ingenious solution to this problem, called the <span class="docEmphasis">binomial queue</span>, that was developed by Vuillemin in 1978.</p>
<p class="docText">To begin, we note that the <span class="docEmphasis">join</span> operation is trivial for one particular type of tree with a relaxed heap-ordering restriction.</p>
<a name="ch09ex22"></a><h5 id="title-IDANXDYE" class="docExampleTitle">Definition 9.4. </h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><span class="docEmphBoldItalic">A binary tree comprising nodes with keys is said to be</span> <span class="docEmphStrong">left heap ordered</span> <span class="docEmphBoldItalic">if the key in each node is larger than or equal to all the keys in that node's left subtree (if any)</span></p>
</td></tr></table></p>
<a name="ch09ex23"></a><h5 id="title-IDAMYDYE" class="docExampleTitle">Definition 9.5. A <span class="docEmphasis">power-of-2 heap</span> is a left-heap-ordered tree consisting of a root node with an empty right subtree and a complete left subtree. The tree corresponding to a power-of-2 heap by the left-child, right-sibling correspondence is called a <span class="docEmphasis">binomial tree</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Binomial trees and power-of-2 heaps are equivalent. We work with both representations because binomial trees are slightly easier to visualize, whereas the simple representation of power-of-2 heaps leads to simpler implementations. In particular, we depend upon the following facts, which are direct consequences of the definitions.</p>
<ul><li><p class="docList">The number of nodes in a power-of-2 heap is a power of 2.</p></li><li><p class="docList">No node has a key larger than the key at the root.</p></li><li><p class="docList">Binomial trees are heap-ordered.</p></li></ul>
<p class="docText">The trivial operation upon which binomial queue algorithms are based is that of joining two power-of-2 heaps that have an equal number of nodes. The result is a heap with twice as many nodes that is easy to create, as illustrated in <a class="docLink" href="#ch09fig16">Figure 9.16</a>. The root node with the larger key becomes the root of the result (with the other original root as the result root's left child), with its left subtree becoming the right subtree of the other root node. Given a linked representation for the trees, the join is a constant-time operation: We simply adjust two links at the top. An implementation is given in <a class="docLink" href="#ch09ex25">Program 9.13</a>. This basic operation is at the heart of Vuillemin's general solution to the problem of implementing priority queues with no slow operations.</p>
</td></tr></table></p>
<p class="docText">&nbsp;<a name="iddle1220"></a><a name="iddle1226"></a><a name="iddle2152"></a><a name="iddle2538"></a><a name="iddle2619"></a></p>
<a name="ch09ex24"></a><h5 id="title-IDAI1DYE" class="docExampleTitle">Definition 9.6. A <span class="docEmphasis">binomial queue</span> is a set of power-of-2 heaps, no two of the same size. The structure of a binomial queue is determined by that queue's number of nodes, by correspondence with the binary representation of integers</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">A binomial queue of <span class="docEmphasis">N</span> elements has one power-of-2 heap for each 1 bit in the binary representation of <span class="docEmphasis">N</span>. For example, a binomial queue of 13 nodes comprises an 8-heap, a 4-heap, and a 1-heap, as illustrated in <a class="docLink" href="#ch09fig15">Figure 9.15</a>. There are at most lg <span class="docEmphasis">N</span> power-of-2 heaps in a binomial queue of size <span class="docEmphasis">N</span>, all of height no greater than lg <span class="docEmphasis">N</span>.</p>
<a name="ch09fig15"></a><p><center>
<h5 class="docFigureTitle">Figure 9.15. A binomial queue of size 13</h5>
<h5></h5><h5></h5></center></p><p class="docText">A binomial queue of size N is a list of left-heap-ordered power-of-2 heaps, one for each bit in the binary representation of N. Thus, a binomial queue of size 13 = 1101<sub>2</sub> consists of an 8-heap, a 4-heap, and a 1-heap. Shown here are the left-heap-ordered power-of-2 heap representation (top) and the heap-ordered binomial-tree representation (bottom) of the same binomial queue.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="175" height="150" src="09fig15.gif" /></p>
</td></tr></table></p><br />
<a name="ch09fig16"></a><p><center>
<h5 class="docFigureTitle">Figure 9.16. Joining of two equal-sized power-of-2 heaps</h5>
<h5></h5><h5></h5></center></p><p class="docText">We join two power-of-two heaps (top) by putting the larger of the roots at the root, with that root's (left) subtree as the right subtree of the other original root. If the operands have <span class="docEmphasis">2</span><sup>n</sup> nodes, the result has <span class="docEmphasis">2</span><sup>n</sup>+1 nodes. If the operands are left-heap ordered, then so is the result, with the largest key at the root. The heap-ordered binomial-tree representation of the same operation is shown below the line.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="185" height="402" src="09fig16.gif" /></p>
<br />
<p class="docText">In accordance with <a class="docLink" href="#ch09ex23">Definitions 9.5</a> and <a class="docLink" href="#ch09ex24">9.6</a>, we represent power-of-2 heaps (and handles to items) as links to nodes containing keys and two links (like the explicit tree representation of tournaments in <a class="docLink" href="ch05lev1sec2.html#ch05fig10">Figure 5.10</a>); and we represent binomial queues as arrays of power-of-2 heaps, by including the following code as the private part of <a class="docLink" href="ch09lev1sec5.html#ch09ex17">Program 9.8</a>:</p>
<div class="docText"><pre>    struct node
      { Item item; node *l, *r;
        node(Item v)
          { item = v; l = 0; r = 0; }
      };
    typedef node *link;
    link* bq;</pre></div><br />
<a name="ch09ex25"></a><h5 id="title-IDAS5DYE" class="docExampleTitle">Program 9.13. Joining of two equal-sized power-of-2 heaps</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We need to change only a few links to combine two equal-sized power-of-2 heaps into one power-of-2 heap that is twice that size. This function, which we define as a private member funciton in the implementation, is one key to the efficiency of the binomial queue algorithm.</p>
<div class="docText"><pre>
    static link pair(link p, link q)
      {
        if (p-&gt;item &lt; q-&gt;item)
          { p-&gt;r = q-&gt;l; q-&gt;l = p; return q; }
        else { q-&gt;r = p-&gt;l; p-&gt;l = q; return p; }
     }</pre></div><br />
</td></tr></table></p>
<p class="docText">The arrays are not large and the trees are not high; and this representation is sufficiently flexible to allow implementation of all the priority-queue operations in less than lg <span class="docEmphasis">N</span> steps, as we shall now see.</p>
<p class="docText">To begin, let us consider the <span class="docEmphasis">insert</span> operation. The process of inserting a new item into a binomial queue mirrors precisely the process of incrementing a binary number. To increment a binary number, we move from right to left, changing 1s to 0s because of the carry associated with 1 + 1 = 10<sub>2</sub>, until finding the rightmost 0, which we change to 1. In the analogous way, to add a new item to a binomial queue, we move from right to left, merging heaps corresponding to 1 bits with a carry heap, until finding the rightmost empty position to put the carry heap.</p>
<p class="docText">Specifically, to insert a new item into a binomial queue, we make the new item into a 1-heap. Then, if <span class="docEmphasis">N</span> is even (rightmost bit 0), we just put this 1-heap in the empty rightmost position of the binomial queue. If <span class="docEmphasis">N</span> is odd (rightmost bit 1), we join the 1-heap corresponding to the new item with the 1-heap in the rightmost position of the binomial queue to make a carry 2-heap. If the position corresponding to 2 in the binomial queue is empty, we put the carry heap there; otherwise, we merge the carry 2-heap with the 2-heap from the binomial queue to make a carry 4-heap, and so forth, continuing until we get to an empty position in the binomial queue. This process is depicted in <a class="docLink" href="#ch09fig17">Figure 9.17</a> <a class="docLink" href="#ch09ex26">Program 9.14</a> is an implementation.</p>
<a name="ch09fig17"></a><p><center>
<h5 class="docFigureTitle">Figure 9.17. Insertion of a new element into a binomial queue</h5>
<h5></h5><h5></h5></center></p><p class="docText">Adding an element to a binomial queue of seven nodes is analogous to performing the binary addition 111<sub>2</sub> + 1 = 1000<sub>2</sub>, with carries at each bit. The result is the binomial queue at the bottom, with an 8-heap and null 4-, 2-, and 1-heaps.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="391" height="551" src="09fig17.jpg" /></p>
<br />
<a name="ch09ex26"></a><h5 id="title-IDANCEYE" class="docExampleTitle">Program 9.14.  Insertion into a binomial queue</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">To insert a node into a binomial queue, we first make the node into a 1-heap, identify it as a carry 1-heap, and then iterate the following process starting at <tt>i = 0</tt>. If the binomial queue has no 2<sup>i</sup>-heap, we put the carry 2<sup>i</sup>-heap into the queue. If the binomial queue has a 2<sup>i</sup>-heap, we combine that with the new one (using the <tt>pair</tt> function from <a class="docLink" href="#ch09ex25">Program 9.13</a>) to make a 2<sup>i</sup>+1-heap, increment <tt>i</tt>, and iterate until finding an empty heap position in the binomial queue.</p>
<div class="docText"><pre>
      handle insert(Item v)
        { link t = new node(v), c = t;
          for (int i = 0; i &lt; maxBQsize; i++)
            {
              if (c == 0) break;
              if (bq[i] == 0) { bq[i] = c; break; }
              c = pair(c, bq[i]); bq[i] = 0;
            }
          return t;
        }</pre></div><br />
</td></tr></table></p>
<p class="docText">Other binomial-queue operations are also best understood by analogy with binary arithmetic. As we shall see, implementing <span class="docEmphasis">join</span> corresponds to implementing addition for binary numbers.</p>
<p class="docText">For the moment, assume that we have an (efficient) function for <span class="docEmphasis">join</span> that is organized to merge the priority-queue reference in its second operand with the priority-queue reference in its first operand (leaving the result in the first operand). Using this function, we could implement the <span class="docEmphasis">insert</span> operation with a call to the <span class="docEmphasis">join</span> function where one of the operands is a binomial queue of size 1 (see <a class="docLink" href="#ch09qa8q10">Exercise 9.63</a>).</p>
<p class="docText">We can also implement the <span class="docEmphasis">remove the maximum</span> operation with one call to <span class="docEmphasis">join</span>. To find the maximum item in a binomial queue, we scan the queue's power-of-2 heaps. Each of these heaps is left-heap-ordered, so it has its maximum element at the root. The largest of the items in the roots is the largest element in the binomial queue. Because there are no more than lg <span class="docEmphasis">N</span> heaps in the binomial queue, the total time to find the maximum element is less than lg <span class="docEmphasis">N</span>.</p>
<a name="ch09ex27"></a><h5 id="title-IDA0EEYE" class="docExampleTitle">Program 9.15. Removal of the maximum in a binomial queue</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We first scan the root nodes to find the maximum, and remove the power-of-2 heap containing the maximum from the binomial queue. We then remove the root node containing the maximum from its power-of-2 heap and temporarily build a binomial queue that contains the remaining constituent parts of the power-of-2 heap. Finally, we use the <span class="docEmphasis">join</span> operation to merge this binomial queue back into the original binomial queue.</p>
<div class="docText"><pre>
      Item getmax()
        { int i, max; Item v = 0;
          link* temp = new link[maxBQsize];
          for (i = 0, max = -1; i &lt; maxBQsize; i++)
            if (bq[i] != 0)
              if ((max == -1) || (v &lt; bq[i]-&gt;item))
                { max = i; v = bq[max]-&gt;item; }
          link x = bq[max]-&gt;l;
          for (i = max; i &lt; maxBQsize; i++) temp[i] = 0;
          for (i = max ; i &gt; 0; i--)
             { temp[i-1] = x; x = x-&gt;r; temp[i-1]-&gt;r = 0; }
          delete bq[max]; bq[max] = 0;
          BQjoin(bq, temp);
          delete temp;
          return v;
        }</pre></div><br />
</td></tr></table></p>
<p class="docText">To perform the <span class="docEmphasis">remove the maximum</span> operation, we note that removing the root of a left-ordered 2<sup>k</sup>-heap leaves <span class="docEmphasis">k</span> left-ordered power-of-2 heaps&mdash;a 2<sup>k&ndash;1</sup>-heap, a 2<sup>k&ndash;2</sup>-heap, and so forth&mdash;which we can easily restructure into a binomial queue of size 2<sup>k</sup> &ndash; 1, as illustrated in <a class="docLink" href="#ch09fig18">Figure 9.18</a>. Then, we can use the <span class="docEmphasis">join</span> operation to combine this binomial queue with the rest of the original queue, to complete the <span class="docEmphasis">remove the maximum</span> operation. This implementation is given in <a class="docLink" href="#ch09ex27">Program 9.15</a>.</p>
<a name="ch09fig18"></a><p><center>
<h5 class="docFigureTitle">Figure 9.18. Removal of the maximum in a power-of-2 heap</h5>
<h5></h5><h5></h5></center></p><p class="docText">Taking away the root gives a forest of power-of-2 heaps, all left-heap ordered, with roots from the right spine of the tree. This operation leads to a way to remove the maximum element from a binomial queue: Take away the root of the power-of-2 heap that contains the largest element, then use the join operation to merge the resulting binomial queue with remaining power-of-2 heaps in the original binomial queue.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="175" height="158" src="09fig18.gif" /></p>
<br />
<p class="docText">How do we join two binomial queues? First, we note that the operation is trivial if they do not contain two power-of-2 heaps of the same size, as illustrated in <a class="docLink" href="#ch09fig19">Figure 9.19</a>: we simply merge the heaps from the two binomial queues to make one binomial queue. A queue of size 10 (consisting of an 8-heap and a 2-heap) and a queue of size 5 (consisting of a 4-heap and a 1-heap) simply merge together to make a queue of size 15 (consisting of an 8-heap, a 4-heap, a 2-heap, and a 1-heap). The more general case follows by direct analogy with performing addition on two binary numbers, complete with carry, as illustrated in <a class="docLink" href="#ch09fig20">Figure 9.20</a>.</p>
<a name="ch09fig19"></a><p><center>
<h5 class="docFigureTitle">Figure 9.19. Joining of two binomial queues (no carry)</h5>
<h5></h5><h5></h5></center></p><p class="docText">When two binomial queues to be joined do not have any power-of-2 heaps of the same size, the join operation is a simple merge. Doing this operation is analogous to adding two binary numbers without ever encountering 1 + 1 (no carry). Here, a binomial queue of 10 nodes is merged with one of 5 nodes to make one of 15 nodes, corresponding to 1010<sub>2</sub> + 0101<sub>2</sub> = 1111<sub>2</sub>.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="300" height="382" src="09fig19.jpg" /></p>
<br />
<a name="ch09fig20"></a><p><center>
<h5 class="docFigureTitle">Figure 9.20. Joining of two binomial queues</h5>
<h5></h5><h5></h5></center></p><p class="docText">Adding a binomial queue of 3 nodes to one of 7 nodes gives one of 10 nodes through a process that mimics the binary addition 011<sub>2</sub> + 111<sub>2</sub> = 1010<sub>2</sub>. Adding <span class="docEmphasis">N</span> to E gives an empty 1-heap in the result with a carry 2-heap containing <span class="docEmphasis">N</span> and <span class="docEmphasis">E</span>. Then adding the three 2-heaps leaves a 2-heap in the result with a carry 4-heap containing <span class="docEmphasis">T N E I</span>. This 4-heap is added to the other 4-heap, producing the binomial queue at the bottom. Few nodes are touched in the process.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="300" height="424" src="09fig20.jpg" /></p>
<br />
<p class="docText">For example, when we add a queue of size 7 (consisting of a 4-heap, a 2-heap, and a 1-heap) to a queue of size 3 (consisting of a 2-heap and a 1-heap), we get a queue of size 10 (consisting of an 8-heap and a 2-heap); to do the addition, we need to merge the 1-heaps and carry a 2-heap, then merge the 2-heaps and carry a 4-heap, then merge the 4-heaps to get an 8-heap result, in a manner precisely analogous to the binary addition 011<sub>2</sub> + 111<sub>2</sub> = 1010<sub>2</sub>. The example of <a class="docLink" href="#ch09fig19">Figure 9.19</a> is simpler than <a class="docLink" href="#ch09fig20">Figure 9.20</a> because it is analogous to 1010<sub>2</sub> + 0101<sub>2</sub> = 1111<sub>2</sub>, with no carry.</p>
<p class="docText">This direct analogy with binary arithmetic carries through to give us a natural implementation for the <span class="docEmphasis">join</span> operation (see <a class="docLink" href="#ch09ex29">Program 9.16</a>). For each bit, there are eight cases to consider, based on all the possible different values for the 3 bits involved (carry and two bits in the operands). The code is more complicated than that for plain addition, because we are dealing with distinguishable heaps, rather than with indistinguishable bits, but each case is straightforward. For example, if all 3 bits are 1, we need to leave a heap in the result binomial queue, and to join the other two heaps for the carry into the next position. Indeed, this operation brings us full cycle on abstract data types: we (barely) resist the temptation to cast <a class="docLink" href="#ch09ex29">Program 9.16</a> as a purely abstract binary addition procedure, with the binomial queue implementation nothing more than a client program using the more complicated bit addition procedure in <a class="docLink" href="#ch09ex25">Program 9.13</a>.</p>
<a name="ch09ex28"></a><h5 id="title-IDAFMEYE" class="docExampleTitle">Property 9.7. All the operations for the priority-queue ADT can be implemented with binomial queues such that <span class="docEmphasis">O(lg N)</span> steps are required for any operations performed on an <span class="docEmphasis">N</span>-item queue</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">These performance bounds are the goal of the design of the data structure. They are direct consequences of the fact that the implementations all have only one or two loops that iterate through the roots of the trees in the binomial queue.</p>
<p class="docText">For simplicity, our implementations loop through all the trees, so their running time is proportional to the logarithm of the maximum size of the binomial queue. We can make them meet the stated bound for the case when the actual queue size is substantially less than the maximum queue size by keeping track of the size of the queue, or by using a sentinel pointer value to mark the point where the loops should terminate (see <a class="docLink" href="#ch09qa8q8">Exercises 9.61</a> and <a class="docLink" href="#ch09qa8q9">9.62</a>). This change may not be worth the effort in many situations, since the maximum queue size is exponentially larger than the maximum number of times that the loop iterates. For example, if we set the maximum size to be 2<sup>16</sup> and the queue normally has thousands of items, then our simpler implementations iterate the loop 15 times, whereas the more complicated methods still need to iterate perhaps 11 or 12 times, and they incur extra cost for maintaining the size or the sentinel. On the other hand, blindly setting a large maximum might cause our programs to run more slowly than expected for tiny queues.</p>
</td></tr></table></p>
<a name="ch09ex29"></a><h5 id="title-IDAONEYE" class="docExampleTitle">Program 9.16. Joining (merging) of two binomial queues</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This code mimics the operation of adding two binary numbers. Proceeding from right to left with an initial carry bit of 0, we treat the eight possible cases (all possible values of the operands and carry bits) in a straightforward manner. For example, case 3 corresponds to the operand bits being both 1 and the carry 0. Then, the result is 0, but the carry is 1 (the result of adding the operand bits).</p>
<p class="docText">Like <tt>pair</tt>, this function is a private member function in the implementation, which is called by <tt>getmax</tt> and <tt>join</tt>. The ADT function <tt>join(PQ&lt;Item&gt;&amp; p)</tt> is implemented as the call <tt>BQjoin(bq, p.bq).</tt></p>
<div class="docText"><pre>
      static inline int test(int C, int B, int A)
        { return 4*C + 2*B + 1*A; }
      static void BQjoin(link *a, link *b)
        { link c = 0;
          for (int i = 0; i &lt; maxBQsize; i++)
            switch(test(c != 0, b[i] != 0, a[i] != 0))
              {
                case 2: a[i] = b[i]; break;
                case 3: c = pair(a[i], b[i]);
                        a[i] = 0; break;
                case 4: a[i] = c; c = 0; break;
                case 5: c = pair(c, a[i]);
                        a[i] = 0; break;
                case 6:
                case 7: c = pair(c, b[i]); break;
              }
        }</pre></div><br />
</td></tr></table></p>
<a name="ch09ex30"></a><h5 id="title-IDATOEYE" class="docExampleTitle">Property 9.8. Construction of a binomial queue with <span class="docEmphasis">N</span> insert operations on an initially empty queue requires <span class="docEmphasis">O(N)</span> comparisons in the worst case</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">For one-half the insertions (when the queue size is even and there is no 1-heap) no comparisons are required; for one-half the remaining insertions (when there is no 2-heap) only 1 comparison is required; when there is no 4-heap, only 2 comparisons are required; and so forth. Thus, the total number of comparisons is less than <span class="docEmphasis">0 . N/2 + 1 . N/4 + 2. N/8 +...&lt; N</span>. As for <a class="docLink" href="#ch09ex28">Property 9.7</a>, we also need one of the modifications discussed in <a class="docLink" href="#ch09qa8q8">Exercises 9.61</a> and <a class="docLink" href="#ch09qa8q9">9.62</a> to get the stated linear worst-case time bound.</p>
</td></tr></table></p>
<p class="docText">As discussed in <a class="docLink" href="ch04lev1sec8.html#ch04lev1sec8">Section 4.8</a>, we have not considered memory allocation in the implementation of <span class="docEmphasis">join</span> in <a class="docLink" href="#ch09ex29">Program 9.16</a>, so it has a memory leak, and therefore may be unusable in some situations. To correct this defect, we need to pay proper attention to memory allocation for the arguments and return value of the function that implements <span class="docEmphasis">join</span> (see <a class="docLink" href="#ch09qa8q12">Exercise 9.65</a>).</p>
<p class="docText">Binomial queues provide guaranteed fast performance, but data structures have been designed with even better theoretical performance characteristics, providing guaranteed constant-time performance for certain operations. This problem is an interesting and active area of data-structure design. On the other hand, the practical utility of many of these esoteric structures is dubious, and we need to be certain that performance bottlenecks exist that we can relieve only by reducing the running time of some priority-queue operation, before we delve into complex data-structure solutions. Indeed, for practical applications, we should prefer a trivial structure for debugging and for small queues; then, we should use heaps to speed up the operations unless fast <span class="docEmphasis">join</span> operations are required; finally, we should use binomial queues to guarantee logarithmic performance for all operations. All things considered, however, a priority-queue package based on binomial queues is a valuable addition to a software library.</p>
</td></tr></table>
<p class="docText">&nbsp;<a name="iddle1221"></a><a name="iddle1222"></a><a name="iddle1225"></a><a name="iddle1224"></a><a name="iddle1223"></a><a name="iddle1862"></a></p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa8q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">9.54</span> Draw a binomial queue of size 29, using the binomial-tree representation.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa8q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">9.55</span> Write a program to draw the binomial-tree representation of a binomial queue, given the size <span class="docEmphasis">N</span> (just nodes connected by edges, no keys).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa8q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.56</span> Give the binomial queue that results when the keys E A S Y Q U E S T I O N are inserted into an initially empty binomial queue.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa8q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.57</span> Give the binomial queue that results when the keys EASY are inserted into an initially empty binomial queue, and give the binomial queue that results when the keys Q U E S T I O N are inserted into an initially empty binomial queue. Then give the result of <span class="docEmphasis">remove the maximum</span> for each queue. Finally, give the result when the <span class="docEmphasis">join</span> operation is performed on the resulting queues.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa8q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.58</span> Using the conventions of <a class="docLink" href="ch09.html#ch09qa1q1">Exercise 9.1</a> give the sequence of binomial queues produced when the operations <div class="docText"><pre>P R I O * R * * I * T * Y * * * Q U E * * * U * E</pre></div><br /> are performed on an initially empty binomial queue.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa8q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.59</span> Using the conventions of <a class="docLink" href="ch09.html#ch09qa1q2">Exercise 9.2</a> give the sequence of binomial queues produced when the operations <div class="docText"><pre>( ( ( P R I O *) + ( R * I T * Y * ) ) * * * ) + ( Q U E * * * U * E )</pre></div><br /> are performed on an initially empty binomial queue.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa8q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.60</span> Prove that a binomial tree with 2<sup>n</sup> nodes has <img border="0" alt="" id="118095012104" width="20" height="23" src="415equ01.jpg" />nodes at level <span class="docEmphasis">i</span> for <span class="docEmphasis">0 <img src="U2264.GIF" border="0" /> i <img src="U2264.GIF" border="0" /> n</span>. (This fact is the origin of the name <span class="docEmphasis">binomial tree</span>.)</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa8q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">9.61</span> Implement binomial queues such that <a class="docLink" href="#ch09ex28">Property 9.7</a> holds, by modifying the binomial-queue data type to include the queue size, then using the size to control the loops.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa8q9"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">9.62</span> Implement binomial queues such that <a class="docLink" href="#ch09ex28">Property 9.7</a> holds, by maintaining a sentinel pointer to mark the point where the loops should terminate.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa8q10"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">9.63</span> Implement <span class="docEmphasis">insert</span> for binomial queues by just using the <span class="docEmphasis">join</span> operation explicitly.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa8q11"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">9.64</span> Implement <span class="docEmphasis">change priority</span> and <span class="docEmphasis">remove</span> for binomial queues. <span class="docEmphasis">Note</span>: You will need to add a third link, which points up the tree, to the nodes.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa8q12"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">9.65</span> Add implementations of a destructor, a copy constructor, and an overloaded assignment operator to the binomial queue implementations (<a class="docLink" href="#ch09ex25">Program 9.13</a> through <a class="docLink" href="#ch09ex29">9.16</a>) in the text to develop an implementation for the first-class ADT of <a class="docLink" href="ch09lev1sec5.html#ch09qa6q6">Exercises 9.43</a> and write a driver program that tests your interface and implementation.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa8q13"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">9.66</span> Empirically compare binomial queues against heaps as the basis for sorting, as in <a class="docLink" href="ch09lev1sec3.html#ch09ex12">Program 9.6</a>, for randomly ordered keys with <span class="docEmphasis">N</span> = 1000, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>. <span class="docEmphasis">Note</span>: See <a class="docLink" href="#ch09qa8q8">Exercises 9.61</a> and <a class="docLink" href="#ch09qa8q9">9.62</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa8q14"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">9.67</span> Develop an in-place sorting method like heapsort, but based on binomial queues. <span class="docEmphasis">Hint</span>: See <a class="docLink" href="#ch09qa8q14">Exercises 9.67</a>.</p></td></tr></table></p>
<ul></ul></div></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch09lev1sec6.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch10.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table><!--IP User 2--></td></body></head></html>