<html><head><title>10.2. Binary Quicksort</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch10lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch10lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch10lev1sec2"></a>
<h3 id="643999-816" class="docSection1Title">10.2. Binary Quicksort</h3>
<p class="docText">Suppose that we can rearrange the records of a file such that all those whose keys begin with a 0 bit come before all those whose keys begin with a 1 bit. Then, we can use a recursive sorting method that is a variant of quicksort (see <a class="docLink" href="ch07.html#ch07">Chapter 7</a>): Partition the file in this way, then sort the two subfiles independently. To rearrange the file, scan from the left to find a key that starts with a 1 bit, scan from the right to find a key that starts with a 0 bit, exchange, and continue until the scanning pointers cross. This method is often called <span class="docEmphasis">radix-exchange sort</span> in the literature (including in earlier editions of this book); here, we shall use the name <span class="docEmphasis">binary quicksort</span> to emphasize that it is a simple variant of the algorithm invented by Hoare, even though it was actually discovered before quicksort was (<span class="docEmphasis">see reference section</span>).</p>
<p class="docText"><a class="docLink" href="#ch10ex03">Program 10.1</a> is a full implementation of this method. The partitioning process is essentially the same as <a class="docLink" href="ch07lev1sec1.html#ch07ex02">Program 7.2</a>, except that the number 2<span class="docEmphasis"><sup>b</sup></span>, instead of some key from the file, is used as the partitioning element. Because 2<span class="docEmphasis"><sup>b</sup></span> may not be in the file, there can be no guarantee that an element is put into its final place during partitioning. The algorithm also differs from normal quicksort because the recursive calls are for keys with 1 fewer bit. This difference has important implications for performance. For example, when a degenerate partition occurs for a file of <span class="docEmphasis">N</span> elements, a recursive call for a subfile of size <span class="docEmphasis">N</span> will result, for keys with 1 fewer bit. Thus, the number of such calls is limited by the number of bits in the keys. By contrast, consistent use of partitioning values not in the file in a standard quicksort could result in an infinite recursive loop.</p>
<p class="docText">As there are with standard quicksort, various options are available in implementing the inner loop. In <a class="docLink" href="#ch10ex03">Program 10.1</a>, tests for whether the pointers have crossed are included in both inner loops. This arrangement <a name="iddle1231"></a>results in an extra exchange for the case <span class="docEmphasis">i = j</span>, which could be avoided with a <tt>break</tt>, as is done in <a class="docLink" href="ch07lev1sec1.html#ch07ex02">Program 7.2</a>, although in this case the exchange of <tt>a[i]</tt> with itself is harmless. Another alternative is to use sentinel keys.</p>
<a name="ch10ex03"></a><h5 id="title-IDAQ1AJF" class="docExampleTitle">Program 10.1. Binary quicksort</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This Program partitions a file on the leading bits of the keys, and then sorts the subfiles recursively. The variable <tt>d</tt> keeps track of the bit being examined, starting at <tt>0</tt> (leftmost). The partitioning stops with <tt>j</tt> equal to <tt>i</tt>, and all elements to the right of <tt>a[i]</tt> having 1 bits in the <tt>d</tt>th position and all elements to the left of <tt>a[i]</tt> having 0 bits in the <tt>d</tt>th position. The element <tt>a[i]</tt> itself will have a 1 bit <span class="docEmphasis">unless</span> all keys in the file have a 0 in position <tt>d</tt>. An extra test just after the partitioning loop covers this case.</p>
<div class="docText"><pre>template &lt;class Item&gt;
void quicksortB(Item a[], int l, int r, int d)
  { int i = l, j = r;
    if (r &lt;= l || d &gt; bitsword) return;
    while (j != i)
      {
        while (digit(a[i], d) == 0 &amp;&amp; (i &lt; j)) i++;
        while (digit(a[j], d) == 1 &amp;&amp; (j &gt; i)) j--;
        exch(a[i], a[j]);
      }
    if (digit(a[r], d) == 0) j++;
    quicksortB(a, l, j-1, d+1);
    quicksortB(a, j, r, d+1);
  }
template &lt;class Item&gt;
void sort(Item a[], int l, int r)
  { quicksortB(a, l, r, 0); }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch10fig02">Figure 10.2</a> depicts the operation of <a class="docLink" href="#ch10ex03">Program 10.1</a> on a small sample file, for comparison with <a class="docLink" href="ch07lev1sec1.html#ch07fig01">Figure 7.1</a> for quicksort. This figure shows what the data movement is, but not <span class="docEmphasis">why</span> the various moves are made&mdash;that depends on the binary representation of the keys. A more detailed view for the same example is given in <a class="docLink" href="#ch10fig03">Figure 10.3</a>. This example assumes that the letters are encoded with a simple 5-bit code, with the <span class="docEmphasis">i</span>th letter of the alphabet represented by the binary representation <a name="iddle2031"></a>of the number <span class="docEmphasis">i</span>. This encoding is a simplified version of real character codes, which use more bits (7, 8, or even 16) to represent more characters (uppercase or lowercase letters, numbers, and special symbols).</p>
<a name="ch10fig02"></a><p><center>
<h5 class="docFigureTitle">Figure 10.2. Binary quicksort example</h5>
<h5></h5><h5></h5></center></p><p class="docText">Partitioning on the leading bit does not guarantee that one value will be put into place; it guarantees only that all keys with leading 0 bits come before all keys with leading 1 bits. We can compare this diagram with <a class="docLink" href="ch07lev1sec1.html#ch07fig01">Figure 7.1</a> for quicksort, although the operation of the partitioning method is completely opaque without the binary representation of the keys. <a class="docLink" href="#ch10fig03">Figure 10.3</a> gives the details that explain the partition positions precisely.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="190" height="234" src="10fig02.gif" /></p>
<br />
<a name="ch10fig03"></a><p><center>
<h5 class="docFigureTitle">Figure 10.3. Binary quicksort example (key bits exposed)</h5>
<h5></h5><h5></h5></center></p><p class="docText">We derive this figure from <a class="docLink" href="#ch10fig02">Figure 10.2</a> by translating the keys to their binary encoding, compressing the table such that the independent subfile sorts are shown as though they happen in parallel, and transposing rows and columns. The first stage splits the file into a subfile with all keys beginning with 0, and a subfile with all keys beginning with 1. Then, the first subfile is split into one subfile with all keys beginning with 00, and another with all keys beginning with 01; independently, at some other time, the other subfile is split into one subfile with all keys beginning with 10, and another with all keys beginning with 11. The process stops when the bits are exhausted (for duplicate keys, in this example) or the subfiles are of size 1.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="500" height="239" src="10fig03.gif" /></p>
<br />
<p class="docText">For full-word keys consisting of random bits, the starting point in <a class="docLink" href="#ch10ex03">Program 10.1</a> should be the leftmost bit of the words, or bit 0. In general, the starting point that should be used depends in a straightforward way on the application, on the number of bits per word in the machine, and on the machine representation of integers and negative numbers. For the one-letter 5-bit keys in <a class="docLink" href="#ch10fig02">Figures 10.2</a> and <a class="docLink" href="#ch10fig03">10.3</a>, the starting point on a 32-bit machine would be bit 27.</p>
<p class="docText">This example highlights a potential problem with binary quicksort in practical situations: Degenerate partitions (partitions with all keys having the same value for the bit being used) can happen frequently. It is not uncommon to sort small numbers (with many leading zeros) as in our examples. The problem also occurs in keys comprising characters: for example, suppose that we make up 32-bit keys from four characters by encoding each in a standard 8-bit code and then putting them together. Then, degenerate partitions are likely to occur at the beginning of each character position, because, for example, lowercase letters all begin with the same bits in most character codes. This problem is typical of the effects that we need to address when sorting encoded data, and similar problems arise in other radix sorts.</p>
<p class="docText">Once a key is distinguished from all the other keys by its left bits, no further bits are examined. This property is a distinct advantage in some situations; it is a disadvantage in others. When the keys are <a name="iddle2575"></a>truly random bits, only about lg <span class="docEmphasis">N</span> bits per key are examined, and that could be many fewer than the number of bits in the keys. This fact is discussed in <a class="docLink" href="ch10lev1sec6.html#ch10lev1sec6">Section 10.6</a>; see also <a class="docLink" href="ch10lev1sec1.html#ch10qa1q5">Exercise 10.5</a> and <a class="docLink" href="ch10.html#ch10fig01">Figure 10.1</a>. For example, sorting a file of 1000 records with random keys might involve examining only about 10 or 11 bits from each key (even if the keys are, say, 64-bit keys). On the other hand, all the bits of equal keys are examined. Radix sorting simply does not work well on files that contain huge numbers of duplicate keys that are not short. Binary quicksort and the standard method are both fast if keys to be sorted comprise truly random bits (the difference between them is primarily determined by the difference in cost between the bit-extraction and comparison operations), but the standard quicksort algorithm can adapt better to nonrandom sets of keys, and 3-way quicksort is ideal when duplicate keys predominate.</p>
<p class="docText">As it was with quicksort, it is convenient to describe the partitioning structure with a binary tree (as depicted in <a class="docLink" href="#ch10fig04">Figure 10.4</a>): The root corresponds to a subfile to be sorted, and its two subtrees correspond to the two subfiles after partitioning. In standard quicksort, we know that at least one record is put into position by the partitioning process, so we put that key into the root node; in binary quicksort, we know that keys are in position only when we get to a subfile of size 1 or we have exhausted the bits in the keys, so we put the keys at the bottom of the tree. Such a structure is called a <span class="docEmphasis">binary trie</span>&mdash;properties of tries are covered in detail in <a class="docLink" href="ch15.html#ch15">Chapter 15</a>. For example, one important property of interest is that the structure of the trie is completely determined by the key values, rather than by their order.</p>
<a name="ch10fig04"></a><p><center>
<h5 class="docFigureTitle">Figure 10.4. Binary quicksort partitioning trie</h5>
<h5></h5><h5></h5></center></p><p class="docText">This tree describes the partitioning structure for binary quicksort, corresponding to <a class="docLink" href="#ch10fig02">Figures 10.2</a> and <a class="docLink" href="#ch10fig03">10.3</a>. Because no item is necessarily put into position, the keys correspond to external nodes in the tree. The structure has the following property: Following the path from the root to any key, taking 0 for left branches and 1 for right branches, gives the leading bits of the key. These are precisely the bits that distinguish the key from other keys during the sort. The small black squares represent the null partitions (when all the keys go to the other side because their leading bits are the same). This happens only near the bottom of the tree in this example, but could happen higher up in the tree: For example, if <span class="docEmphasis">I</span> or <span class="docEmphasis">X</span> were not among the keys, their node would be replaced by a null node in this drawing. Note that duplicated keys (<span class="docEmphasis">A</span> and <span class="docEmphasis">E</span>) cannot be partitioned (the sort puts them in the same subfile only after all their bits are exhausted).</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="175" height="109" src="10fig04.gif" /></p>
<br />
<p class="docText">Partitioning divisions in binary quicksort depend on the binary representation of the range and number of items being sorted. For example, if the files are random permutations of the integers less than 171 = 10101011<sub>2</sub>, then partitioning on the first bit is equivalent to partitioning about the value 128, so the subfiles are unequal (one of size 128 and the other of size 43). The keys in <a class="docLink" href="#ch10fig05">Figure 10.5</a> are random 8-bit values, so this effect is absent there, but the effect is worthy of note now, lest it come as a surprise when we encounter it in practice.</p>
<a name="ch10fig05"></a><p><center>
<h5 class="docFigureTitle">Figure 10.5. Dynamic characteristics of binary quicksort on a large file</h5>
<h5></h5><h5></h5></center></p><p class="docText">Partitioning divisions in binary quicksort are less sensitive to key order than they are in standard quicksort. Here, two different random 8-bit files lead to virtually identical partitioning profiles.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="150" height="488" src="10fig05.gif" /></p>
<br />
<p class="docText">We can improve the basic recursive implementation in <a class="docLink" href="#ch10ex03">Program 10.1</a> by removing recursion and treating small subfiles differently, just as we did for standard quicksort in <a class="docLink" href="ch07.html#ch07">Chapter 7</a>.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa2q1"></a><b></b></td><td><p class="docText"><a name="iddle1139"></a><a name="iddle1245"></a><a name="iddle1923"></a><a name="iddle2193"></a><a name="iddle2206"></a><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">10.8</span> Draw the trie in the style of <a class="docLink" href="#ch10fig02">Figure 10.2</a> that corresponds to the partitioning process in radix quicksort for the key <tt>E A S Y Q U E S T I O N</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa2q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.9</span> Compare the number of exchanges used by binary quicksort with the number used by the normal quicksort for the file of 3-bit binary numbers <tt>001, 011, 101, 110, 000, 001, 010, 111, 110, 010</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa2q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">10.10</span> Why is it not as important to sort the smaller of the two subfiles first in binary quicksort as it was for normal quicksort?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa2q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">10.11</span> Describe what happens on the second level of partitioning (when the left subfile is partitioned and when the right subfile is partitioned) when we use binary quicksort to sort a random permutation of the nonnegative integers less than 171.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa2q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.12</span> Write a program that, in one preprocessing pass, identifies the number of leading bit positions where all keys are equal, then calls a binary quicksort that is modified to ignore those bit positions. Compare the running time of your program with that of the standard implementation for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup> when the input is 32-bit words of the following format: The rightmost 16 bits are uniformly random, and the leftmost 16 bits are all 0 except with a 1 in position <span class="docEmphasis">i</span> if there are <span class="docEmphasis">i</span> 1s in the right half.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa2q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.13</span> Modify binary quicksort to check explicitly for the case that all keys are equal. Compare the running time of your program with that of the standard implementation for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup> with the input described in <a class="docLink" href="#ch10qa2q5">Exercise 10.12</a>.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch10lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch10lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>