<html><head><title>12.3. Sequential Search</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch12lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch12lev1sec3"></a>
<h3 id="title-IDANHB5C" class="docSection1Title">12.3. Sequential Search</h3>
<p class="docText">For general key values from too large a range for them to be used as indices, one simple approach for a symbol-table implementation is to store the items contiguously in an array, in order. When a new item is to be inserted, we put it into the array by moving larger elements over one position as we did for insertion sort; when a search is to be <a name="iddle1721"></a><a name="iddle1816"></a><a name="iddle2339"></a>performed, we look through the array sequentially. Because the array is in order, we can report a search miss when we encounter a key larger than the search key. Moreover, since the array is in order, both <span class="docEmphasis">select</span> and <span class="docEmphasis">sort</span> are trivial to implement. <a class="docLink" href="#ch12ex07">Program 12.5</a> is a symbol-table implementation that is based on this approach.</p>
<a name="ch12ex07"></a><h5 id="title-IDAGJB5C" class="docExampleTitle">Program 12.5. Array-based symbol table (ordered)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Like <a class="docLink" href="ch12lev1sec2.html#ch12ex06">Program 12.4</a>, this implementation uses an array of items, but it does not require the keys to be small integers. We keep the array in order when inserting a new item by moving larger items to make room, in the same manner as insertion sort. Then, the <tt>search</tt> function can scan through the array to look for an item with the specified key, returning <tt>nullItem</tt> when encountering an item with a larger key. The <tt>select</tt> and <tt>sort</tt> functions are trivial, and the implementation of <tt>remove</tt> is left as an exercise (see <a class="docLink" href="#ch12qa3q1">Exercise 12.16</a>).</p>
<div class="docText"><pre>template &lt;class Item, class Key&gt;
class ST
  {
   private:
     Item nullItem, *st;
     int N;
   public:
     ST(int maxN)
       { st = new Item[maxN+1]; N = 0; }
     int count()
       { return N; }
     void insert(Item x)
       { int i = N++; Key v = x.key();
         while (i &gt; 0 &amp;&amp; v &lt; st[i-1].key())
           { st[i] = st[i-1]; i--; }
         st[i] = x;
       }
     Item search(Key v)
       {
         for (int i = 0; i &lt; N; i++)
           if (!(st[i].key() &lt; v)) break;
         if (v == st[i].key()) return st[i];
         return nullItem;
       }
     Item select(int k)
       { return st[k]; }
     void show(ostream&amp; os)
       { int i = 0;
         while (i &lt; N) st[i++].show(os); }
  };</pre></div><br />
</td></tr></table></p>
<p class="docText">We could slightly improve the inner loop in the implementation of <span class="docEmphasis">search</span> in <a class="docLink" href="#ch12ex07">Program 12.5</a> by using a sentinel to eliminate the test for running off the end of the array in the case that no item in the table has the search key. Specifically, we could reserve the position after the end of the array as a sentinel, then fill its key field with the search key before a search. Then the search will always terminate with an item containing the search key, and we can determine whether or not the key was in the table by checking whether that item is the sentinel.</p>
<p class="docText">Alternatively, we could develop an implementation where we do not insist that the items in the array be kept in order. When a new item is to be inserted, we put it at the end of the array; when a search is to be performed we look through the array sequentially. The characteristic property of this approach is that <span class="docEmphasis">insert</span> is fast but <span class="docEmphasis">select</span> and <span class="docEmphasis">sort</span> require substantially more work (they each require one of the methods in <a class="docLink" href="ch07.html#ch07">Chapters 7</a> through <a class="docLink" href="ch10.html#ch10">10</a>). We can <span class="docEmphasis">remove</span> an item with a specified key by doing a search for it, then moving the final item in the array to its position and decrementing the size by 1; and we can <span class="docEmphasis">remove</span> all items with a specified key by iterating this operation. If a handle giving the index of an item in the array is available, the search is unnecessary and <span class="docEmphasis">remove</span> takes constant time.</p>
<p class="docText">Another straightforward option for a symbol-table implementation is to use a linked list. Again, we can choose to keep the list in order, to be able to easily support the <span class="docEmphasis">sort</span> operation, or to leave it unordered, so that <span class="docEmphasis">insert</span> can be fast. <a class="docLink" href="#ch12ex08">Program 12.6</a> is an implementation of the latter. As usual, the advantage of using linked lists over arrays is that we do not have to predict the maximum size of the table in advance; the disadvantages are that we need extra space (for the links) and we cannot support <span class="docEmphasis">select</span> efficiently.</p>
<p class="docText">The unordered-array and ordered-list approaches are left for exercises (see <a class="docLink" href="#ch12qa3q5">Exercise 12.20</a> and <a class="docLink" href="#ch12qa3q6">Exercise 12.21</a>). These four implementation approaches (array or list, ordered or unordered) could be used interchangeably in applications, differing only (we expect) in time and space requirements. In this and the next several chapters, <a name="iddle1817"></a><a name="iddle2324"></a><a name="iddle2488"></a><a name="iddle2493"></a><a name="iddle2496"></a>we will examine numerous different approaches to the symbol-table&ndash;implementation problem.</p>
<a name="ch12ex08"></a><h5 id="title-IDAKOB5C" class="docExampleTitle">Program 12.6. Linked-list-based symbol table (unordered)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This implementation of <span class="docEmphasis">construct</span>, <span class="docEmphasis">count</span>, <span class="docEmphasis">search</span>, and <span class="docEmphasis">insert</span> uses a singly-linked list with each node containing an item with a key and a link. The <tt>insert</tt> function puts the new item at the beginning of the list, and takes constant time. The <tt>search</tt> member function uses a private recursive function <tt>searchR</tt> to scan through the list.</p>
<p class="docText">Since the list is not in order, the <span class="docEmphasis">sort</span> and <span class="docEmphasis">select</span> implementations are omitted.</p>
<div class="docText"><pre>#include &lt;stdlib.h&gt;
template &lt;class Item, class Key&gt;
class ST
  {
    private:
      Item nullItem;
      struct node
        { Item item; node* next;
          node(Item x, node* t)
            { item = x; next = t; }
        };
      typedef node *link;
      int N;
      link head;
      Item searchR(link t, Key v)
        { if (t == 0) return nullItem;
          if (t-&gt;item.key() == v) return t-&gt;item;
          return searchR(t-&gt;next, v);
        }
    public:
      ST(int maxN)
        { head = 0; N = 0; }
      int count()
        { return N; }
      Item search(Key v)
        { return searchR(head, v); }
      void insert(Item x)
        { head = new node(x, head); N++; }
   };</pre></div><br />
</td></tr></table></p>
<p class="docText">Keeping the items in order is an illustration of the general idea that symbol-table implementations generally use the keys to structure the data in some way to provide for fast search. The structure might allow fast implementations of some of the other operations, but this savings has to be balanced against the cost of maintaining the structure, which might be slowing down other operations. We shall see many examples of this phenomenon. For example, in an application where the <span class="docEmphasis">sort</span> function is needed frequently, we would choose an ordered (array or list) representation because the chosen structure of the table makes the <span class="docEmphasis">sort</span> function trivial, as opposed to it needing a full sort implementation. In an application where we know that the <span class="docEmphasis">select</span> operation might be performed frequently, we would choose an ordered array representation because this structure of the table makes <span class="docEmphasis">select</span> constant-time. By contrast, <span class="docEmphasis">select</span> takes linear time in a linked list, even an ordered one.</p>
<p class="docText">To analyze the performance of sequential search for random keys in more detail, we begin by considering the cost of inserting new keys and by considering separately the costs of <span class="docEmphasis">successful</span> and <span class="docEmphasis">unsuccessful</span> searches. We often refer to the former as a <span class="docEmphasis">search hit</span>, and to the latter as a <span class="docEmphasis">search miss</span>. We are interested in the costs for both hits and misses, on the average and in the worst case. Strictly speaking, our ordered-array implementation (see <a class="docLink" href="#ch12ex07">Program 12.5</a>) uses two comparisons for each item examined (one <tt>==</tt> and one <tt>&lt;</tt>). For the purposes of analysis, we regard such a pair as a single comparison throughout <a class="docLink" href="ch12.html#ch12">Chapters 12</a> through <a class="docLink" href="ch16.html#ch16">16</a>, since we normally can do low-level optimizations to effectively combine them.</p>
<a name="ch12ex09"></a><h5 id="title-IDAKRB5C" class="docExampleTitle">Property 12.2. <span class="docEmphasis">Sequential search in a symbol table with N items uses about N/<span class="docEmphRoman">2</span> comparisons for search hits (on the average)</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">See <a class="docLink" href="ch02lev1sec6.html#ch02ex03">Property 2.1</a>. The argument applies for arrays or linked lists, ordered or unordered.</p>
</td></tr></table></p>
<a name="ch12ex10"></a><h5 id="title-IDAJSB5C" class="docExampleTitle">Property 12.3. <span class="docEmphasis">Sequential search in a symbol table of N unordered items uses a constant number of steps for inserts and N comparisons for search misses (always)</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">These facts are true for both the array and linked-list representations, and are immediate from the implementations (see <a class="docLink" href="#ch12qa3q5">Exercise 12.20</a> and <a class="docLink" href="#ch12ex08">Program 12.6</a>).</p>
</td></tr></table></p>
<a name="ch12ex11"></a><h5 id="title-IDALTB5C" class="docExampleTitle">Property 12.4. <span class="docEmphasis">Sequential search in a symbol table of N ordered items uses about N/<span class="docEmphRoman">2</span> comparisons for insertion, search hits, and search misses (on the average)</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">See <a class="docLink" href="ch02lev1sec6.html#ch02ex04">Property 2.2</a>. Again, these facts are true for both the array and linked-list representations, and are immediate from the implementations (see <a class="docLink" href="#ch12ex07">Program 12.5</a> and <a class="docLink" href="#ch12qa3q6">Exercise 12.21</a>).</p>
</td></tr></table></p>
<p class="docText"><a name="iddle1818"></a>Building an ordered table by successive insertion is essentially equivalent to running the insertion-sort algorithm of <a class="docLink" href="ch06lev1sec2.html#ch06lev1sec2">Section 6.2</a>. The total running time to build the table is quadratic, so we would not use this method for large tables. If we have a huge number of <span class="docEmphasis">search</span> operations in a small table, then keeping the items in order is worthwhile, because <a class="docLink" href="#ch12ex10">Properties 12.3</a> and <a class="docLink" href="#ch12ex11">12.4</a> tell us that this policy can save a factor of 2 in the time for search misses. If items with duplicate keys are not to be kept in the table, the extra cost of keeping the table in order is not as burdensome as it might seem, because an insertion happens only after a search miss, so the time for insertion is proportional to the time for search. On the other hand, if items with duplicate keys may be kept in the table, we can have a constant-time <span class="docEmphasis">insert</span> implementation with an unordered table. The use of an unordered table is preferred for applications where we have a huge number of <span class="docEmphasis">insert</span> operations and relatively few <span class="docEmphasis">search</span> operations.</p>
<p class="docText">Beyond these differences, we have the standard tradeoff that linked-list implementations use space for the links, whereas array implementations require that the maximum table size be known ahead of time or that the table undergo amortized growth (see <a class="docLink" href="ch14lev1sec5.html#ch14lev1sec5">Section 14.5</a>). Also, as discussed in <a class="docLink" href="ch12lev1sec9.html#ch12lev1sec9">Section 12.9</a>, a linked-list implementation has the flexibility to allow efficient implementation of other operations such as <span class="docEmphasis">join</span> and <span class="docEmphasis">remove</span>.</p>
<p class="docText"><a class="docLink" href="#ch12table01">Table 12.1</a> summarizes these results, and puts them in context with other search algorithms discussed later in this chapter and in <a class="docLink" href="ch13.html#ch13">Chapters 13</a> and <a class="docLink" href="ch14.html#ch14">14</a>. In <a class="docLink" href="ch12lev1sec4.html#ch12lev1sec4">Section 12.4</a> we consider <span class="docEmphasis">binary search</span>, which brings the search time down to lg <span class="docEmphasis">N</span> and is therefore widely used for static tables (when insertions are relatively infrequent).</p>
<a name="ch12table01"></a><p><table cellspacing="0" frame="hsides" rules="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 12.1. Costs of insertion and search in symbol tables</h5></caption><colgroup align="left" span="7"><col width="150"></col><col width="50"></col><col width="50"></col><col width="100"></col><col width="100"></col><col width="50"></col><col width="50"></col></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top" colspan="7"><p class="docText">The entries in this table are running times within a constant factor as a function of <span class="docEmphasis">N</span>, the number of items in the table, and <span class="docEmphasis">M</span>, the size of the table (if different from <span class="docEmphasis">N</span>), for implementations where we can <span class="docEmphasis">insert</span> new items without regard to whether items with duplicate keys are in the table. Elementary methods (first four lines) require constant time for some operations and linear time for others; more advanced methods yield guaranteed logarithmic or constant-time performance for most or all operations. The <span class="docEmphasis">N</span> lg <span class="docEmphasis">N</span> entries in the column for <span class="docEmphasis">select</span> represent the cost of sorting the items&mdash;a linear-time <span class="docEmphasis">select</span> for an unordered set of items is possible in theory, but is not practical (see <a class="docLink" href="ch07lev1sec8.html#ch07lev1sec8">Section 7.8</a>). Starred entries indicate worst-case events that are extremely unlikely.</p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="bottomBorder" align="center" valign="top" colspan="3"><p class="docText">worst case</p></td><td class="bottomBorder" align="center" valign="top" colspan="3"><p class="docText">average case</p></td></tr><tr><td class="bottomBorder" align="left" valign="top">&nbsp;</td><td class="bottomBorder" align="center" valign="bottom"><p class="docText">insert</p></td><td class="bottomBorder" align="center" valign="bottom"><p class="docText">search</p></td><td class="bottomBorder" align="center" valign="bottom"><p class="docText">select</p></td><td class="bottomBorder" align="center" valign="bottom"><p class="docText">insert</p></td><td class="bottomBorder" align="center" valign="bottom"><p class="docText">search hit</p></td><td class="bottomBorder" align="center" valign="bottom"><p class="docText">search miss</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">key-indexed array</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">M</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">ordered array</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N/</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N/</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N/</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">ordered linked list</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N/</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N/</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N/</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">unordered array</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">2</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span> lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">2</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N/</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">unordered linked list</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">2</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span> lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">2</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N/</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">binary search</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">2</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N/</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">binary search tree</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">red-black tree</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">randomized tree</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span><sup>*</sup></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span><sup>*</sup></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span><sup>*</sup></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">hashing</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">2</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span><sup>*</sup></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span> lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">2</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">2</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">2</p></td></tr></table></p><br />
<p class="docText">In <a class="docLink" href="ch12lev1sec5.html#ch12lev1sec5">Sections 12.5</a> through <a class="docLink" href="ch12lev1sec9.html#ch12lev1sec9">12.9</a>, we consider <span class="docEmphasis">binary search trees</span>, which have the flexibility to admit search and insertion in time proportional to lg <span class="docEmphasis">N</span>, but only on the average. In <a class="docLink" href="ch13.html#ch13">Chapter 13</a>, we shall consider <span class="docEmphasis">red-black trees</span> and <span class="docEmphasis">randomized binary search trees</span>, which guarantee logarithmic performance or make it extremely likely, respectively. In <a class="docLink" href="ch14.html#ch14">Chapter 14</a>, we shall consider <span class="docEmphasis">hashing</span>, which provides constant-time search and insertion, on the average, but does not efficiently support <span class="docEmphasis">sort</span> and some other operations. In <a class="docLink" href="ch15.html#ch15">Chapter 15</a>, we shall consider the radix search methods that are analogous to the radix sorting methods of <a class="docLink" href="ch10.html#ch10">Chapter 10</a>; in <a class="docLink" href="ch16.html#ch16">Chapter 16</a>, we shall consider methods that are appropriate for files that are stored externally.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">12.16</span> Add an implementation for the <span class="docEmphasis">remove</span> operation to our ordered-array&ndash;based symbol-table implementation (<a class="docLink" href="#ch12ex07">Program 12.5</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">12.17</span> Implement <tt>searchinsert</tt> functions for our list-based (<a class="docLink" href="#ch12ex08">Program 12.6</a>) and array-based (<a class="docLink" href="#ch12ex07">Program 12.5</a>) symbol-table implementations. They should search the symbol table for items with the same key as a given item, then insert the item if there is none.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.18</span> Implement a <span class="docEmphasis">select</span> operation for our list-based symbol-table implementation (<a class="docLink" href="#ch12ex08">Program 12.6</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.19</span> Give the number of comparisons required to put the keys <tt>E A S Y Q U E S T I O N</tt> into an initially empty table using ADTs that are implemented with each of the four elementary approaches: ordered or unordered array or list. Assume that a search is performed for each key, then an insertion is done for search misses, as in <a class="docLink" href="#ch12qa3q2">Exercise 12.17</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.20</span> Implement the <span class="docEmphasis">construct</span>, <span class="docEmphasis">search</span>, and <span class="docEmphasis">insert</span> operations for the symbol-table interface in <a class="docLink" href="ch12lev1sec1.html#ch12ex03">Program 12.2</a>, using an unordered array to represent the symbol table. Your program should match the performance characteristics set forth in <a class="docLink" href="#ch12table01">Table 12.1</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">12.21</span> Implement the <span class="docEmphasis">construct</span>, <span class="docEmphasis">search</span>, and <span class="docEmphasis">insert</span>, and <span class="docEmphasis">sort</span> operations for the symbol-table interface in <a class="docLink" href="ch12lev1sec1.html#ch12ex03">Program 12.2</a>, using an ordered linked list to represent the symbol table. Your program should meet the performance characteristics set forth in <a class="docLink" href="#ch12table01">Table 12.1</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">12.22</span> Change our list-based symbol-table implementations (<a class="docLink" href="#ch12ex08">Program 12.6</a>) to support client item handles (see <a class="docLink" href="ch12lev1sec1.html#ch12qa1q7">Exercise 12.7</a>); add implementations of a destructor, a copy constructor, and an overloaded assignment operator (see <a class="docLink" href="ch12lev1sec1.html#ch12qa1q6">Exercise 12.6</a>); add <span class="docEmphasis">remove</span> and <span class="docEmphasis">join</span> operations; and write a driver program that tests your first-class symbol table ADT interface and implementation.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.23</span> Write a performance driver program that uses <tt>insert</tt> to fill a symbol table, then uses <tt>select</tt> and <tt>remove</tt> to empty it, doing so multiple times on <a name="iddle2480"></a>random sequences of keys of various lengths ranging from small to large; measures the time taken for each run; and prints out or plots the average running times.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.24</span> Write a performance driver program that uses <tt>insert</tt> to fill a symbol table, then uses <tt>search</tt> such that each item in the table is hit an average of 10 times and there is about the same number of misses, doing so multiple times on random sequences of keys of various lengths ranging from small to large; measures the time taken for each run; and prints out or plots the average running times.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q10"></a><b></b></td><td><p class="docText"><a name="iddle1147"></a><a name="iddle2319"></a><a name="iddle2479"></a><span class="docEmphStrong">12.25</span> Write an exercise driver program that uses the functions in our symbol-table interface <a class="docLink" href="ch12lev1sec1.html#ch12ex03">Program 12.2</a> on difficult or pathological cases that might turn up in practical applications. Simple examples include files that are already in order, files in reverse order, files where all keys are the same, and files consisting of only two distinct values.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q11"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">12.26</span> Which symbol-table implementation would you use for an application that does <tt>10<sup>2</sup></tt> <span class="docEmphasis">insert</span> operations, <tt>10<sup>3</sup></tt> <span class="docEmphasis">search</span> operations, and <tt>10<sup>4</sup></tt> <span class="docEmphasis">select</span> operations, randomly intermixed? Justify your answer.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q12"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">12.27</span> (This exercise is five exercises in disguise.) Answer <a class="docLink" href="#ch12qa3q11">Exercise 12.26</a> for the other five possibilities of matching up operations and frequency of use.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q13"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.28</span> A <span class="docEmphasis">self-organizing</span> search algorithm is one that rearranges items to make those that are accessed frequently likely to be found early in the search. Modify your <span class="docEmphasis">search</span> implementation for <a class="docLink" href="#ch12qa3q5">Exercise 12.20</a> to perform the following action on every search hit: move the item found to the beginning of the list, moving all items between the beginning of the list and the vacated position to the right one position. This procedure is called the <span class="docEmphasis">move-to-front</span> heuristic.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q14"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">12.29</span> Give the order of the keys after items with the keys <tt>E A S Y Q U E S T I O N</tt> have been put into an initially empty table with <span class="docEmphasis">search</span>, then <span class="docEmphasis">insert</span> on search miss, using the move-to-front self-organizing search heuristic (see <a class="docLink" href="#ch12qa3q13">Exercise 12.28</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q15"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.30</span> Write a driver program for self-organizing search methods that uses <tt>insert</tt> to fill a symbol table with <span class="docEmphasis">N</span> keys, then does <tt>10</tt><span class="docEmphasis"><tt>N</tt></span> searches to hit items according to a predefined probability distribution.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q16"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.31</span> Use your solution to <a class="docLink" href="#ch12qa3q15">Exercise 12.30</a> to compare the running time of your implementation from <a class="docLink" href="#ch12qa3q5">Exercise 12.20</a> with your implementation from <a class="docLink" href="#ch12qa3q13">Exercise 12.28</a>, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10, 100</tt>, and <tt>1000</tt>, using the probability distribution where <span class="docEmphasis">search</span> is for the <span class="docEmphasis"><tt>i</tt></span>th largest key with probability <tt>1/2</tt><span class="docEmphasis"><tt><sup>i</sup></tt></span> for <tt>1 <img src="U2264.GIF" border="0" /></tt> <span class="docEmphasis"><tt>i</tt></span> <tt><img src="U2264.GIF" border="0" /></tt> <span class="docEmphasis"><tt>N</tt></span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q17"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.32</span> Do <a class="docLink" href="#ch12qa3q16">Exercise 12.31</a> for the probability distribution where <span class="docEmphasis">search</span> is for the <span class="docEmphasis">i</span>th largest key with probability <span class="docEmphasis"><tt>H<sub>N</sub>/i</tt></span> for <tt>1 <img src="U2264.GIF" border="0" /> i <img src="U2264.GIF" border="0" /></tt> <span class="docEmphasis"><tt>N</tt></span>. This distribution is called <span class="docEmphasis">Zipf's law</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa3q18"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.33</span> Compare the move-to-front heuristic with the optimal arrangement for the distributions in <a class="docLink" href="#ch12qa3q16">Exercise 12.31</a> and <a class="docLink" href="#ch12qa3q17">12.32</a>, which is to keep the keys in increasing order (decreasing order of their expected frequency). That is, use <a class="docLink" href="#ch12ex07">Program 12.5</a>, instead of your solution to <a class="docLink" href="#ch12qa3q5">Exercise 12.20</a>, in <a class="docLink" href="#ch12qa3q16">Exercise 12.31</a>.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch12lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>