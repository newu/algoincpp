<html><head><title>6.7. Sorting of Other Types of Data</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch06lev1sec6.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch06lev1sec8.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch06lev1sec7"></a>
<h3 id="title-IDAY4OBF" class="docSection1Title">6.7. Sorting of Other Types of Data</h3>
<p class="docText">Although it is reasonable to learn most algorithms by thinking of them as simply sorting arrays of numbers into numerical order or characters into alphabetical order, it is also worthwhile to recognize that the algorithms are largely independent of the type of items being sorted, and that is not difficult to move to a more general setting. We have talked in detail about breaking our programs into independent modules to implement data types, and abstract data types (see <a class="docLink" href="ch03.html#ch03">Chapters 3</a> and <a class="docLink" href="ch04.html#ch04">4</a>); <a name="iddle1079"></a><a name="iddle1336"></a><a name="iddle1389"></a><a name="iddle1688"></a><a name="iddle2373"></a><a name="iddle2392"></a>in this section, we consider ways in which we can apply the concepts discussed there to build implementations, interfaces, and client programs for sorting algorithms. Specifically, we consider interfaces for:</p>
<ul><li><p class="docList"><span class="docEmphasis">Items</span>, or generic objects to be sorted</p></li><li><p class="docList"><span class="docEmphasis">Arrays</span> of items</p></li></ul>
<a name="ch06ex19"></a><h5 id="title-IDAZBPBF" class="docExampleTitle">Program 6.6. Sort driver for arrays</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This driver for basic array sorts uses three explicit interfaces: the first for a data type that encapsulates the operations that we perform on generic items; the second for the slightly higher level <tt>exch</tt> and <tt>compexch</tt> functions used by our sort implementations; and the third for the functions that initialize and print (and sort!) arrays. Breaking our driver into modules in this way allows us to use each sort implementation to sort various types of data without any modification, to share the exchange and compare-exchange implementations, and to compile the functions for arrays separately (perhaps for use in other drivers).</p>
<div class="docText"><pre>#include &lt;stdlib.h&gt;
#include "Item.h"
#include "exch.h"
#include "Array.h"
main(int argc, char *argv[])
  { int N = atoi(argv[1]), sw = atoi(argv[2]);
    Item *a = new Item[N];
    if (sw) rand(a, N); else scan(a, N);
    sort(a, 0, N-1);
    show(a, 0, N-1);
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">The item data type provides us with a way to use our sort code for any type of data for which certain basic operations are defined. The approach is effective both for simple data types and for abstract data types, and we shall consider numerous implementations. The array interface is less critical to our mission; we include it to give us an example of a mutiple-module program that uses multiple data types. We consider just one (straightforward) implementation of the array interface.</p>
<p class="docText"><a class="docLink" href="#ch06ex19">Program 6.6</a> is a client program with the same general functionality of the main program in <a class="docLink" href="ch06lev1sec1.html#ch06ex01">Program 6.1</a>, but with the code for manipulating arrays and items encapsulated in separate modules. This gives us, in particular, the ability to test various sort programs on various different types of data, by substituting various different modules, but without changing the client program at all. <a class="docLink" href="#ch06ex19">Program 6.6</a> also refers to an interface for the <tt>exch</tt> and <tt>compexch</tt> operations used by our sort implementations. We might insist that these be included with the <tt>Item.h</tt> interface, but the implementations in <a class="docLink" href="ch06lev1sec1.html#ch06ex01">Program 6.1</a> serve our purposes with well-understood semantics when assignment and <tt>operator&lt;</tt> are defined, so it is simpler to keep them in a single module where they can be used by all our sort implementations for all our item data types. To complete the implementation, we need to define the <span class="docEmphasis">array</span> and <span class="docEmphasis">item</span> data type interfaces precisely, then provide implementations.</p>
<a name="ch06ex20"></a><h5 id="title-IDABEPBF" class="docExampleTitle">Program 6.7. Interface for array data type</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This <tt>Array.h</tt> interface defines high-level functions for arrays of abstract items: initialize random values, initialize values read from standard input, print the contents, and sort the contents.</p>
<div class="docText"><pre>template &lt;class Item&gt;
  void rand(Item a[], int N);
template &lt;class Item&gt;
  void scan(Item a[], int &amp;N);
template &lt;class Item&gt;
  void show(Item a[], int l, int r);
template &lt;class Item&gt;
  void sort(Item a[], int l, int r);</pre></div><br />
</td></tr></table></p>
<p class="docText">The interface in <a class="docLink" href="#ch06ex20">Program 6.7</a> defines examples of high-level operations that we might want to perform on arrays. We want to be able to initialize an array with key values, either randomly or from the standard input; we want to be able to sort the entries (of course!); and we want to be able to print out the contents. These are but a few examples; in a particular application, we might want to define various other operations (the <tt>Vector</tt> class in the Standard Template Library is one approach to providing a general interface of this kind). Using <a class="docLink" href="#ch06ex20">Program 6.7</a> allows us to substitute different implementations of the various operations without having to change the client program that uses the interface&mdash;<tt>main</tt> in <a class="docLink" href="#ch06ex19">Program 6.6</a>, in this case. The various sort implementations that we are studying can serve as implementations for the <tt>sort</tt> function. <a class="docLink" href="#ch06ex21">Program 6.8</a> has simple implementations for the other functions. The modular organization allows us to substitute other implementations, depending on the application. For example, we might use an implementation of <tt>show</tt> that prints out only part of the array when testing sorts on huge arrays.</p>
<a name="ch06ex21"></a><h5 id="title-IDAAGPBF" class="docExampleTitle">Program 6.8. Implementation of array data type</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This code provides implementations of the functions defined in <a class="docLink" href="#ch06ex20">Program 6.7</a>, using the item types and basic functions for processing them that are defined in a separate interface (see <a class="docLink" href="#ch06ex22">Program 6.9</a>).</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
#include "Array.h"
template &lt;class Item&gt;
  void rand(Item a[], int N)
    { for (int i = 0; i &lt; N; i++) rand(a[i]); }
template &lt;class Item&gt;
  void scan(Item a[], int &amp;N)
    { for (int i = 0; i &lt; N; i++)
        if (!scan(a[i])) break;
      N = i;
    }
template &lt;class Item&gt;
  void show(Item a[], int l, int r)
    { for (int i = l; i &lt;=r; i++)
          show(a[i]);
      cout &lt;&lt; endl;
    }</pre></div><br />
</td></tr></table></p>
<p class="docText">In a similar manner, to work with particular types of items and keys, we define their types and declare all the relevant operations on them in an explicit interface, then provide implementations of the operations defined in the item interface. For example, consider an accounting application, where we might have a key corresponding to a customer's account number and a floating-point number corresponding to that customer's account balance. <a class="docLink" href="#ch06ex22">Program 6.9</a> is an example of an interface that defines a data type for such an application. The interface code declares the <tt>&lt;</tt> operation that we need to compare keys, as well as functions to generate a random key, to read a key, and to print out the value of a key. <a class="docLink" href="#ch06ex23">Program 6.10</a> has implementations of these functions for this simple example. Clearly, we can tailor such implementations to specific applications. For example, <tt>Item</tt> could be an ADT defined as a C++ class, and a key could be a member function of a class object, rather than a data member of a structure. We shall consider such an ADT in <a class="docLink" href="ch12.html#ch12">Chapter 12</a>.</p>
<a name="ch06ex22"></a><h5 id="title-IDADIPBF" class="docExampleTitle">Program 6.9. Sample interface for item data type</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The file <tt>Item.h</tt> that is included in <a class="docLink" href="#ch06ex22">Program 6.9</a> defines the data type for the items to be sorted. In this example, the items are small records consisting of integer keys and associated floating-point information. We declare that the overloaded <tt>operator&lt;</tt> will be implemented separately, as will the three functions <tt>scan</tt> (read an <tt>Item</tt> into its argument), <tt>rand</tt> (store a random <tt>Item</tt> in its argument), and <tt>show</tt> (print an <tt>Item</tt>).</p>
<div class="docText"><pre>typedef struct record { int key; float info;} Item;
 int operator&lt;(const Item&amp;, const Item&amp;);
 int scan(Item&amp;);
void rand(Item&amp;);
void show(const Item&amp;);</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch06ex19">Programs 6.6</a> through <a class="docLink" href="#ch06ex23">6.10</a> together with any of the sorting routines <span class="docEmphasis">as is</span> in <a class="docLink" href="ch06lev1sec2.html#ch06lev1sec2">Sections 6.2</a> through <a class="docLink" href="ch06lev1sec6.html#ch06lev1sec6">6.6</a> provide a test of the sort for our small records. By providing similar interfaces and implementations for other types of data, we can put our sorts to use for a variety of data&mdash;such as complex numbers (see <a class="docLink" href="#ch06qa7q2">Exercise 6.50</a>), vectors (see <a class="docLink" href="#ch06qa7q7">Exercise 6.55</a>), or polynomials (see <a class="docLink" href="#ch06qa7q8">Exercise 6.56</a>)&mdash;without changing the sort code at all. For more complicated types of items, the interfaces and implementations have to be more complicated, but this implementation work is completely separated from the algorithm-design questions that we have been considering. We can use these same mechanisms with most of the sorting methods that we consider in this chapter and with those that we shall study in <a class="docLink" href="ch07.html#ch07">Chapters 7</a> through <a class="docLink" href="ch09.html#ch09">9</a>, as well. We consider in detail one important exception in <a class="docLink" href="ch06lev1sec10.html#ch06lev1sec10">Section 6.10</a>&mdash;it leads to a whole family of important sorting algorithms that have to be packaged differently, the subject of <a class="docLink" href="ch10.html#ch10">Chapter 10</a>.</p>
<p class="docText">The approach that we have discussed in this section is a middle road between <a class="docLink" href="ch06lev1sec1.html#ch06ex01">Program 6.1</a> and an industrial-strength fully abstract set of implementations complete with error checking, memory management, and even more general capabilities. Packaging issues of this sort are of increasing importance in some modern programming and applications environments. We will necessarily leave some questions unanswered. Our primary purpose is to demonstrate, through the relatively simple mechanisms that we have examined, that the sorting implementations that we are studying are widely applicable.</p>
<a name="ch06ex23"></a><h5 id="title-IDAJMPBF" class="docExampleTitle">Program 6.10. Sample implementation for item data type</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This code implements the overloaded <tt>operator&lt;</tt> and the functions <tt>scan</tt>, <tt>rand</tt>, and <tt>show</tt> that are declared in <a class="docLink" href="#ch06ex22">Program 6.9</a>. Since the records are small structures, we can have <tt>exch</tt> use the built-in assignment operator without undue worry about the expense of copying items.</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
#include "Item.h"
int operator&lt;(const Item&amp; A, const Item&amp; B)
  { return A.key &lt; B.key;}
int scan(Item&amp; x)
  { return (cin &gt;&gt; x.key &gt;&gt; x.info) != 0; }
void rand(Item&amp; x)
  { x.key = 1000*(1.0*rand()/RAND_MAX);
    x.info = 1.0*rand()/RAND_MAX; }
void show(const Item&amp; x)
  { cout &lt;&lt; x.key &lt;&lt; " " &lt;&lt; x.info &lt;&lt; endl; }</pre></div><br />
</td></tr></table></p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa7q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.49</span> Write versions of <a class="docLink" href="#ch06ex22">Programs 6.9</a> and <a class="docLink" href="#ch06ex23">6.10</a>) that overload <tt>operator&lt;&lt;</tt> and <tt>operator&gt;&gt;</tt> rather than using <tt>scan</tt> and <tt>show</tt>, and modify <a class="docLink" href="#ch06ex21">Program 6.8</a> to use your interface.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa7q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.50</span> Write an interface and implementation for the generic item data type to support having the sorting methods sort complex numbers <tt>x + iy</tt> using the magnitude <img border="0" alt="" width="65" height="21" src="298equ01.jpg" />for the key. <span class="docEmphasis">Note</span>: Ignoring the square root is likely to improve efficiency.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa7q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">6.51</span> Write an interface that defines a first-class <span class="docEmphasis">abstract</span> data type for generic items (see <a class="docLink" href="ch04lev1sec8.html#ch04lev1sec8">Section 4.8</a>), and provide an implementation where the items are complex numbers, as in the previous exercise. Test your program with <a class="docLink" href="ch06lev1sec3.html#ch06ex04">Programs 6.3</a> and <a class="docLink" href="#ch06ex19">6.6</a>.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa7q4"></a><b></b></td><td><p class="docText"><a name="iddle1272"></a><a name="iddle1722"></a><a name="iddle1758"></a><a name="iddle2001"></a><a name="iddle2018"></a><a name="iddle2071"></a><a name="iddle2403"></a><a name="iddle2415"></a><a name="iddle2448"></a><a name="iddle2466"></a><a name="iddle2628"></a><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">6.52</span> Add a function <tt>check</tt> to the array data type in <a class="docLink" href="#ch06ex21">Programs 6.8</a> and <a class="docLink" href="#ch06ex20">6.7</a>, which tests whether or not the array is in sorted order.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa7q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">6.53</span> Add a function <tt>testinit</tt> to the array data type in <a class="docLink" href="#ch06ex21">Programs 6.8</a> and <a class="docLink" href="#ch06ex20">6.7</a>, which generates test data according to distributions similar to those illustrated in <a class="docLink" href="ch06lev1sec6.html#ch06fig13">Figure 6.13</a>. Provide an integer argument for the client to use to specify the distribution.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa7q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">6.54</span> Change <a class="docLink" href="#ch06ex20">Programs 6.7</a> and <a class="docLink" href="#ch06ex21">6.8</a> to implement an <span class="docEmphasis">abstract</span> data type. (Your implementation should allocate and maintain the array, as in our implementations for stacks and queues in <a class="docLink" href="ch03.html#ch03">Chapter 3</a>.)</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa7q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">6.55</span> Write an interface and implementation for the generic item data type for use in having the sorting methods sort multidimensional vectors of <span class="docEmphasis">d</span> integers, putting the vectors in order by first component, those with equal first component in order by second component, those with equal first and second components in order by third component, and so forth.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa7q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.56</span> Write an interface and implementation for the generic item data type for use in having the sorting methods sort polynomials (see <a class="docLink" href="ch04lev1sec9.html#ch04lev1sec9">Section 4.9</a>). Part of your task is to define an appropriate ordering.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch06lev1sec6.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch06lev1sec8.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>