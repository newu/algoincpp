<html><head><title>16.5. Perspective</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch16lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch16lev2sec1.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch16lev1sec5"></a>
<h3 id="title-IDA1OT1" class="docSection1Title">16.5. Perspective</h3>
<p class="docText">The most important application of the methods discussed in this chapter is to construct indexes for huge databases that are maintained on external memory&mdash;for example, in disk files. Although the underlying algorithms that we have discussed are powerful, developing a file-system implementation based on B trees or on extendible hashing is a complex task. First, we cannot use the C++ programs in this section directly&mdash;they have to be modified to read and refer to disk files. Second, we have to be sure that the algorithm parameters (page and directory size, for example) are tuned properly to the characteristics of the particular hardware that we are using. Third, we have to pay attention to reliability, and to error detection and correction. For example, we need to be able to check that the data structure is in a consistent state, and to consider how we might proceed to correct any of the scores of errors that might crop up. Systems considerations of this kind are critical&mdash;and are beyond the scope of this book.</p>
<p class="docText"><a name="iddle1251"></a><a name="iddle1458"></a>On the other hand, if we have a programming system that supports virtual memory, we can put to direct use the C++ implementations that we have considered here in a situation where we have a huge number of symbol-table operations to perform on a huge table. Roughly, each time that we access a page, such a system will put that page in a <span class="docEmphasis">cache</span>, where references to data on that page are handled efficiently. If we refer to a page that is not in the cache, the system has to read the page from external memory, so we can think of cache misses as roughly equivalent to the probe cost measure that we have been using.</p>
<p class="docText">For B trees, every search or insertion references the root, so the root will always be in the cache. Otherwise, for sufficiently large <span class="docEmphasis">M</span>, typical searches and insertions involve at most two cache misses. For a large cache, there is a good chance that the first page (the child of the root) that is accessed on a search is already in the cache, so the average cost per search is likely to be significantly less than two probes.</p>
<p class="docText">For extendible hashing, it is unlikely that the whole directory will be in the cache, so we expect that both the directory access and the page access might involve a cache miss (this case is the worst case). That is, two probes are required for a search in a huge table, one to access the appropriate part of the directory and one to access the appropriate page.</p>
<p class="docText">These algorithms form an appropriate subject on which to close our discussion of searching, because, to use them effectively, we need to understand basic properties of binary search, BSTs, balanced trees, hashing, and tries&mdash;the basic searching algorithms that we have studied in <a class="docLink" href="ch12.html#ch12">Chapters 12</a> through <a class="docLink" href="ch15.html#ch15">15</a>. As a group, these algorithms provide us with solutions to the symbol-table implementation problem in a broad variety of situations: they constitute an outstanding example of the power of algorithmic technology.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa6q1"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />

16.46 Develop a symbol-table implementation using B trees that includes a destructor, a copy constructor, and an overloaded assignment operator, and supports the <span class="docEmphasis">construct</span>, <span class="docEmphasis">count</span>, <span class="docEmphasis">search</span>, <span class="docEmphasis">insert</span>, <span class="docEmphasis">remove</span>, and <span class="docEmphasis">join</span> operations for a first-class symbol-table ADT, with support for client handles (see <a class="docLink" href="ch12lev1sec1.html#ch12qa1q6">Exercises 12.6</a> and <a class="docLink" href="ch12lev1sec1.html#ch12qa1q7">12.7</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa6q2"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />

16.47 Develop a symbol-table implementation using extendible hashing that includes a destructor, a copy constructor, and an overloaded assignment operator, and supports the <span class="docEmphasis">construct</span>, <span class="docEmphasis">count</span>, <span class="docEmphasis">search</span>, <span class="docEmphasis">insert</span>, <span class="docEmphasis">remove</span>, and <span class="docEmphasis">join</span>operations for a first-class symbol-table ADT, with support for client handles (see <a class="docLink" href="ch12lev1sec1.html#ch12qa1q6">Exercises 12.6</a> and <a class="docLink" href="ch12lev1sec1.html#ch12qa1q7">12.7</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa6q3"></a><b></b></td><td><p class="docText">16.48 Modify the B-tree implementation in <a class="docLink" href="ch16lev1sec3.html#ch16lev1sec3">Section 16.3</a> <a class="docLink" href="ch16lev1sec3.html#ch16ex04">Programs 16.1</a> through <a class="docLink" href="ch16lev1sec3.html#ch16ex07">16.3</a> to use an ADT for page references.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa6q4"></a><b></b></td><td><p class="docText">16.49 Modify the extendible-hashing implementation in <a class="docLink" href="ch16lev1sec4.html#ch16lev1sec4">Section 16.4</a> (<a class="docLink" href="ch16lev1sec4.html#ch16ex10">Programs 16.5</a> through <a class="docLink" href="ch16lev1sec4.html#ch16ex15">16.8</a>) to use an ADT for page references.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa6q5"></a><b></b></td><td><p class="docText">16.50 Estimate the average number of probes per search in a B tree for S random searches, in a typical cache system, where the T most-recently-accessed pages are kept in memory (and therefore add 0 to the probe count). Assume that S is much larger than T.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa6q6"></a><b></b></td><td><p class="docText">16.51 Estimate the average number of probes per search in an extendible hash table, for the cache model described in <a class="docLink" href="#ch16qa6q5">Exercise 16.50</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa6q7"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="circle.jpg" />

16.52 If your system supports virtual memory, design and conduct experiments to compare the performance of B trees with that of binary search, for random searches in a huge symbol table.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa6q8"></a><b></b></td><td><p class="docText">16.53 Implement a priority-queue ADT that supports <span class="docEmphasis">construct</span> for a huge number of items, followed by a huge number of <span class="docEmphasis">insert</span> and <span class="docEmphasis">remove the maximum</span> operations (see <a class="docLink" href="ch09.html#ch09">Chapter 9</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa6q9"></a><b></b></td><td><p class="docText">16.54 Develop an external symbol-table ADT based on a skip-list representation of B trees (see <a class="docLink" href="ch13lev1sec5.html#ch13qa6q6">Exercise 13.80</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa6q10"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">16.55</span> If your system supports virtual memory, run experiments to determine the value of M that leads to the fastest search times for a B tree implementation supporting random <span class="docEmphasis">search</span> operations in a huge symbol table. (It may be worthwhile for you to learn basic properties of your system before conducting such experiments, which can be costly.)</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa6q11"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" />
<span class="docEmphStrong">16.56</span> Modify the B-tree implementation in <a class="docLink" href="ch16lev1sec3.html#ch16lev1sec3">Section 16.3</a> (<a class="docLink" href="ch16lev1sec3.html#ch16ex04">Program 16.1</a>) through <a class="docLink" href="ch16lev1sec3.html#ch16ex07">16.3</a>) to operate in an environment where the table resides on external storage. If your system allows nonsequential file access, put the whole table on a single (huge) file, and use offsets within the file in place of pointers in the data structure. If your system allows you to access pages on external devices directly, use page addresses in place of pointers in the data structure. If your system allows both, choose the approach that you determine to be most reasonable for implementing a huge symbol table.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa6q12"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" />
<span class="docEmphStrong">16.57</span> Modify the extendible-hashing implementation in <a class="docLink" href="ch16lev1sec4.html#ch16lev1sec4">Section 16.4</a> (<a class="docLink" href="ch16lev1sec4.html#ch16ex10">Programs 16.5</a> through <a class="docLink" href="ch16lev1sec4.html#ch16ex15">16.8</a>) to operate in an environment where the table resides on external storage. Explain the reasons for the approach that you choose for allocating the directory and the pages to files (see <a class="docLink" href="#ch16qa6q11">Exercise 16.56</a>).</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch16lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch16lev2sec1.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>