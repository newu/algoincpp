<html><head><title>7.8. Selection</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch07lev1sec7.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch08.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch07lev1sec8"></a>
<h3 id="title-IDADGNWD" class="docSection1Title">7.8. Selection</h3>
<p class="docText">An important application related to sorting but for which a full sort is not required is the operation of finding the median of a set of numbers. This operation is a common computation in statistics and in various other data-processing applications. One way to proceed would be to sort the numbers and to look at the middle one, but we can do better, using the quicksort partitioning process.</p>
<p class="docText">The operation of finding the median is a special case of the operation of <span class="docEmphasis">selection</span>: finding the <span class="docEmphasis">k</span>th smallest of a set of numbers. Because an algorithm cannot guarantee that a particular item is the <span class="docEmphasis">k</span>th smallest without having examined and identified the <span class="docEmphasis">k</span> - 1 elements that are smaller and the <span class="docEmphasis">N</span> - <span class="docEmphasis">k</span> elements that are larger, most selection algorithms can return all the <span class="docEmphasis">k</span> smallest elements of a file without a great deal of extra calculation.</p>
<p class="docText">Selection has many applications in the processing of experimental and other data. The use of the median and other <span class="docEmphasis">order statistics</span> to divide a file into smaller groups is common. Often, only a small part of a large file is to be saved for further processing; in such cases, a program that can select, say, the top 10 percent of the elements of the file might be more appropriate than a full sort. Another important example is the use of partitioning about the median as a first step in many divide-and-conquer algorithms.</p>
<a name="ch07ex09"></a><h5 id="title-IDAJHNWD" class="docExampleTitle">Program 7.6. Selection</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This procedure partitions an array about the (<tt>k-l</tt>)th smallest element (the one in <tt>a[k]</tt>): It rearranges the array to leave <tt>a[l]</tt>, <tt>...</tt>, <tt>a[k-1]</tt> less than or equal to <tt>a[k]</tt>, and <tt>a[k+1]</tt>, <tt>...</tt>, <tt>a[r]</tt> greater than or equal to <tt>a[k]</tt>.</p>
<p class="docText">For example, we could call <tt>select(a, 0, N-1, N/2)</tt> to partition the array on the median value, leaving the median in <tt>a[N/2]</tt>.</p>
<div class="docText"><pre>    template &lt;class Item&gt;
    void select(Item a[], int l, int r, int k)
      {
        if (r &lt;= l) return;
        int i = partition(a, l, r);
        if (i &gt; k) select(a, l, i-1, k);
        if (i &lt; k) select(a, i+1, r, k);
      }</pre></div><br />
</td></tr></table></p>
<p class="docText">We have already seen an algorithm that we can adapt directly to selection. If <span class="docEmphasis">k</span> is extremely small, then selection sort (see <a class="docLink" href="ch06.html#ch06">Chapter 6</a>) will work well, requiring time proportional to <span class="docEmphasis">Nk</span>: first find the smallest element, then find the second smallest by finding the smallest of the remaining items, and so forth. For slightly larger <span class="docEmphasis">k</span>, we shall see methods in <a class="docLink" href="ch09.html#ch09">Chapter 9</a> that we could adapt to run in time proportional to <span class="docEmphasis">N log k</span>.</p>
<p class="docText">A selection method that runs in linear time on the average for all values of <span class="docEmphasis">k</span> follows directly from the partitioning procedure used in quicksort. Recall that quicksort's partitioning method rearranges an array <tt>a[l]</tt>, <tt>...</tt>, <tt>a[r]</tt> and returns an integer <tt>i</tt> such that <tt>a[l]</tt> through <tt>a[i-1]</tt> are less than or equal to <tt>a[i]</tt>, and <tt>a[i+1]</tt> through <tt>a[r]</tt> are greater than or equal to <tt>a[i]</tt>. If <tt>k</tt> is equal to <tt>i</tt>, then we are done. Otherwise, if <tt>k &lt; i</tt>, then we need to continue working in the left subfile; if <tt>k &gt; i</tt>, then we need to continue working in the right subfile. This approach leads immediately to the recursive program for selection that is <a class="docLink" href="#ch07ex09">Program 7.6</a>. An example of this procedure in operation on a small file is given in <a class="docLink" href="#ch07fig13">Figure 7.13</a>.</p>
<a name="ch07fig13"></a><p><center>
<h5 class="docFigureTitle">Figure 7.13. Selection of the median</h5>
<h5></h5><h5></h5></center></p><p class="docText">For the keys in our sorting example, partitioning-based selection uses only three recursive calls to find the median. On the first call, we seek the eighth smallest in a file of size 15, and partioning gives the fourth smallest (the <span class="docEmphasis">E</span>); so on the second call, we seek the fourth smallest in a file of size 11, and partitioning gives the eighth smallest (the <span class="docEmphasis">R</span>); so on the third call, we seek the fourth smallest in a file of size 7, and find it (the <span class="docEmphasis">M</span>). The file is rearranged such that the median is in place, with smaller elements to the left and larger elements to the right (equal elements could be on either side), but it is not fully sorted.</p>
<p class="docText">
<img border="0" alt="" width="200" height="63" src="07fig13.gif" /></p>
<br />
<p class="docText"></p><a name="ch07ex10"></a><h5 id="title-IDAJMNWD" class="docExampleTitle">Program 7.7. Nonrecursive selection</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">A nonrecursive implementation of selection simply does a partition, then moves the left pointer in if the partition fell to the left of the position sought, or moves the right pointer in if the partition fell to the right of the position sought.</p>
<div class="docText"><pre>    template &lt;class Item&gt;
    void select(Item a[], int l, int r, int k)
      {
        while (r &gt; l)
          { int i = partition(a, l, r);
            if (i &gt;= k) r = i-1;
            if (i &lt;= k) l = i+1;
          }
      }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch07ex10">Program 7.7</a> is a nonrecursive version that follows directly from the recursive version in <a class="docLink" href="#ch07ex09">Program 7.6</a>. Since that program always ends with a single call on itself, we simply reset the parameters and go back to the beginning. That is, we remove the recursion without needing a stack, also eliminating the calculations involving <tt>k</tt> by keeping <tt>k</tt> as an array index.</p>
<a name="ch07ex11"></a><h5 id="title-IDASNNWD" class="docExampleTitle">Property 7.4. <span class="docEmphasis">Quicksort-based selection is linear time on the average</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">As we did for quicksort, we can argue (roughly) that, on an extremely large file, each partition should roughly split the array in half, so the whole process should require about <span class="docEmphasis">N</span> + <span class="docEmphasis">N</span>/2 + <span class="docEmphasis">N</span>/4 + <span class="docEmphasis">N</span>/8 + ... = 2<span class="docEmphasis">N</span> comparisons. And, as it was for quicksort, this rough argument is not far from the truth. An analysis similar to, but significantly more complex than, that given in <a class="docLink" href="ch07lev1sec2.html#ch07lev1sec2">Section 7.2</a> for quicksort (<span class="docEmphasis">see reference section</span>) leads to the result that the average number of comparisons is about</p>
<div class="docText"><pre>2N + 2k ln(N/k) + 2(N - k) ln(N/(N - k)),</pre></div><br />
<p class="docText">which is linear for any allowed value of <span class="docEmphasis">k</span>. For <span class="docEmphasis">k</span> = <span class="docEmphasis">N</span>/2, this formula evaluates to give the result that about (<tt>2 + 2ln 2</tt>)<span class="docEmphasis">N</span> comparisons are required to find the median.</p>
</td></tr></table></p>
<p class="docText">An example showing how this method finds the median in a large file is depicted in <a class="docLink" href="#ch07fig14">Figure 7.14</a>. There is only one subfile, which is cut down in size by a constant factor on each call, so the procedure finishes in <span class="docEmphasis">O(log N)</span> steps. We can speed up the program with sampling, but we need to exercise care in doing so (see <a class="docLink" href="#ch07qa11q7">Exercise 7.45</a>).</p>
<a name="ch07fig14"></a><p><center>
<h5 class="docFigureTitle">Figure 7.14. Selection of the median by partitioning</h5>
<h5></h5><h5></h5></center></p><p class="docText">The selection process involves partitioning the subfile that contains the element sought, moving the left pointer to the right or the right pointer to the left depending on where the partition falls.</p>
<p class="docText">
<img border="0" alt="" width="400" height="363" src="07fig14.gif" /></p>
<br />
<p class="docText">The worst case is about the same as for quicksort&mdash;using this method to find the smallest element in a file that is already in sorted order would result in a quadratic running time. It is possible to modify this quicksort-based selection procedure such that its running time is <span class="docEmphasis">guaranteed</span> to be linear. These modifications, although theoretically important, are extremely complex and are not at all practical.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa10q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">7.41</span> About how many comparisons are required, on the average, to find the smallest of <span class="docEmphasis">N</span> elements using <tt>select</tt>?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa11q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">7.42</span> About how many comparisons are required, on the average, to find the <span class="docEmphasis">&#945;N</span> th smallest element using <tt>select</tt>, for <tt>&#945; = 0.1</tt>, <tt>0.2</tt>, <tt>...</tt>, <tt>0.9</tt>?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa11q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">7.43</span> How many comparisions are required in the worst case to find the median of <span class="docEmphasis">N</span> elements using <tt>select</tt>?</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa11q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">7.44</span> Write an efficient program to rearrange a file such that all the elements with keys equal to the median are in place, with smaller elements to the left and larger elements to the right.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa11q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">7.45</span> Investigate the idea of using sampling to improve selection. <span class="docEmphasis">Hint</span>: Using the median may not always be helpful.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa11q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">7.46</span> Implement a selection algorithm based on three-way partitioning for large random files with keys having <span class="docEmphasis">t</span> distinct values for <span class="docEmphasis">t</span> = <span class="docEmphRoman">2, 5,</span> and <span class="docEmphRoman">10</span>.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch07lev1sec7.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch08.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>