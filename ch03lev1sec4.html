<html><head><title>3.4. Elementary List Processing</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch03lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch03lev1sec4"></a>
<h3 id="title-IDAXOV5H" class="docSection1Title">3.4. Elementary List Processing</h3>
<p class="docText">Linked lists bring us into a world of computing that is markedly different from that of arrays and structures. With arrays and structures, we save an item in memory and later refer to it by name (or by index) in much the same manner as we might put a piece of information in a file drawer or an address book; with linked lists, the manner in which we save information makes it more difficult to access but easier to rearrange. Working with data that are organized in linked lists is called <span class="docEmphasis">list processing</span>.</p>
<p class="docText">When we use arrays, we are susceptible to program bugs involving out-of-bounds array accesses. The most common bug that we encounter when using linked lists is a similar bug where we reference an undefined pointer. Another common mistake is to use a pointer that we have changed unknowingly. One reason that this problem <a name="iddle1789"></a><a name="iddle1832"></a><a name="iddle1834"></a>arises is that we may have multiple pointers to the same node without necessarily realizing that that is the case. <a class="docLink" href="ch03lev1sec3.html#ch03ex11">Program 3.9</a> avoids several such problems by using a circular list that is never empty, so that each link always refers to a well-defined node, and each link can also be interpreted as referring to the list.</p>
<p class="docText">Developing correct and efficient code for list-processing applications is an acquired programming skill that requires practice and patience to develop. In this section, we consider examples and exercises that will increase our comfort with working with list-processing code. We shall see numerous other examples throughout the book, because linked structures are at the heart of some of our most successful algorithms.</p>
<p class="docText">As mentioned in <a class="docLink" href="ch03lev1sec3.html#ch03lev1sec3">Section 3.3</a>, we use a number of different conventions for the first and final pointers in a list. We consider some of them in this section, even though we adopt the policy of reserving the term <span class="docEmphasis">linked list</span> to describe the simplest situation.</p>
<a name="ch03ex12"></a><h5 id="title-IDAARV5H" class="docExampleTitle">Definition 3.3. A linked list is either a null link or a link to a node that contains an item and a link to a linked list</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This definition is more restrictive than <a class="docLink" href="ch03lev1sec3.html#ch03ex10">Definition 3.2</a>, but it corresponds more closely to the mental model that we have when we write list-processing code. Rather than exclude all the other various conventions by using only this definition, and rather than provide specific definitions corresponding to each convention, we let both stand, with the understanding that it will be clear from the context which type of linked list we are using.</p>
<p class="docText">One of the most common operations that we perform on lists is to <span class="docEmphasis">traverse</span> them: We scan through the items on the list sequentially, performing some operation on each. For example, if <tt>x</tt> is a pointer to the first node of a list, the final node has a null pointer, and <tt>visit</tt> is a procedure that takes an item as an argument, then we might write</p>
<div class="docText"><pre>for (link t = x; t != 0; t = t-&gt;next) visit(t-&gt;item);</pre></div><br />
<p class="docText">to traverse the list. This loop (or its equivalent <tt>while</tt> form) is as ubiquitous in list-processing programs as is the corresponding loop of the form <tt>for (int i = 0; i &lt; N; i++)</tt> in array-processing programs.</p>
<p class="docText"><a class="docLink" href="#ch03ex13">Program 3.10</a> is an implementation of a simple list-processing task, reversing the order of the nodes on a list. It takes a linked list as an argument, and returns a linked list comprising the same nodes, but with the order reversed. <a class="docLink" href="#ch03fig07">Figure 3.7</a> shows the change that the function makes for each node in its main loop. Such a diagram makes it easier for us to check each statement of the program to be sure that the code changes the links as intended, and programmers typically use these diagrams to understand the operation of list-processing implementations.</p>
<a name="ch03fig07"></a><p><center>
<h5 class="docFigureTitle">Figure 3.7. List reversal</h5>
<h5></h5><h5></h5></center></p><p class="docText">To reverse the order of a list, we maintain a pointer <span class="docEmphasis">r</span> to the portion of the list already processed, and a pointer <span class="docEmphasis">y</span> to the portion of the list not yet seen. This diagram shows how the pointers change for each node in the list. We save a pointer to the node following <span class="docEmphasis">y</span> in <span class="docEmphasis">t</span>, change <span class="docEmphasis">y</span>'s link to point to <span class="docEmphasis">r</span>, and then move <span class="docEmphasis">r</span> to <span class="docEmphasis">y</span> and <span class="docEmphasis">y</span> to <span class="docEmphasis">t</span>.</p>
<p class="docText">
<img border="0" alt="" width="200" height="222" src="03fig07.gif" /></p>
</td></tr></table></p><br />
<a name="ch03ex13"></a><h5 id="title-IDAQUV5H" class="docExampleTitle">Program 3.10. List reversal</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This function reverses the links in a list, returning a pointer to the final node, which then points to the next-to-final node, and so forth, with the link in the first node of the original list set to <tt>0</tt>, the null pointer. To accomplish this task, we need to maintain links to three consecutive nodes in the list.</p>
<div class="docText"><pre>link reverse(link x)
  { link t, y = x, r = 0;
    while (y != 0)
      { t = y-&gt;next; y-&gt;next = r; r = y; y = t; }
    return r;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch03ex14">Program 3.11</a> is an implementation of another list-processing task: rearranging the nodes of a list to put their items in sorted order. It generates <span class="docEmphasis">N</span> random integers, puts them into a list in the order that they were generated, rearranges the nodes to put their items in sorted order, and prints out the sorted sequence. As we discuss in <a class="docLink" href="ch06.html#ch06">Chapter 6</a>, the expected running time of this program is proportional to <span class="docEmphasis">N<sup>2</sup></span>, so the program is not useful for large <span class="docEmphasis">N</span>. Beyond this observation, we defer discussing the sort aspect of this program to <a class="docLink" href="ch06.html#ch06">Chapter 6</a>, because we shall see a great many methods for sorting in <a class="docLink" href="ch06.html#ch06">Chapters 6</a> through <a class="docLink" href="ch10.html#ch10">10</a>. Our purpose now is to present the implementation as an example of a list-processing application.</p>
<p class="docText">The lists in <a class="docLink" href="#ch03ex14">Program 3.11</a> illustrate another commonly used convention: We maintain a dummy node called a <span class="docEmphasis">head node</span> at the beginning of each list. We ignore the item field in a list's head node, but maintain its link as the pointer to the node containing the first item in the list. The program uses two lists: one to collect the random input in the first loop, and the other to collect the sorted output in the second loop. <a class="docLink" href="#ch03fig08">Figure 3.8</a> diagrams the changes that <a class="docLink" href="#ch03ex14">Program 3.11</a> makes during one iteration of its main loop. We take the next node off the input list, find where it belongs in the output list, and link it into position.</p>
<a name="ch03fig08"></a><p><center>
<h5 class="docFigureTitle">Figure 3.8. Linked-list sort</h5>
<h5></h5><h5></h5></center></p><p class="docText">This diagram depicts one step in transforming an unordered linked list (pointed to by <span class="docEmphasis">a</span>) into an ordered one (pointed to by <span class="docEmphasis">b</span>), using insertion sort. We take the first node of the unordered list, keeping a pointer to it in <span class="docEmphasis">t</span> <span class="docEmphasis">(top)</span>. Then, we search through <span class="docEmphasis">b</span> to find the first node <span class="docEmphasis">x</span> with <span class="docEmphasis">x-&gt;next-&gt;item &gt; t-&gt;item</span> (or <span class="docEmphasis">x-&gt;next = NULL</span>), and insert <span class="docEmphasis">t</span> into the list following <span class="docEmphasis">x</span> <span class="docEmphasis">(center)</span>. These operations reduce the length of <span class="docEmphasis">a</span> by one node, and increase the length of <span class="docEmphasis">b</span> by one node, keeping <span class="docEmphasis">b</span> in order (bottom). Iterating, we eventually exhaust <span class="docEmphasis">a</span> and have the nodes in order in <span class="docEmphasis">b</span>.</p>
<p class="docText">
<img border="0" alt="" width="400" height="408" src="03fig08.gif" /></p>
<br />
<a name="ch03ex14"></a><h5 id="title-IDAQZV5H" class="docExampleTitle">Program 3.11. List insertion sort</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This code generates <span class="docEmphasis">N</span> random integers between 0 and 999, builds a linked list with one number per node (first <tt>for</tt> loop), and then rearranges the nodes so that the numbers appear in order when we traverse the list (second <tt>for</tt> loop). To accomplish the sort, we maintain two lists, an input (unsorted) list and an output (sorted) list. On each iteration of the loop, we remove a node from the input and insert it into position in the output. The code is simplified by the use of head nodes for each list, that contain the links to the first nodes on the lists. The declarations of the head nodes use the constructor, so that their data members are initialized when they are created.</p>
<div class="docText"><pre>node heada(0, 0); link a = &amp;heada, t = a;
for (int i = 0; i &lt; N; i++)
  t = (t-&gt;next = new node(rand() % 1000, 0));
node headb(0, 0); link u, x, b = &amp;headb;
for (t = a-&gt;next; t != 0; t = u)
  {
    u = t-&gt;next;
    for (x = b; x-&gt;next != 0; x = x-&gt;next)
      if (x-&gt;next-&gt;item &gt; t-&gt;item) break;
    t-&gt;next = x-&gt;next; x-&gt;next = t;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">The primary reason to use the head node at the beginning becomes clear when we consider the process of adding the <span class="docEmphasis">first</span> node to the sorted list. This node is the one in the input list with the smallest item, and it could be anywhere on the list. We have three options:</p>
<ul><li><p class="docList">Duplicate the <tt>for</tt> loop that finds the smallest item and set up a one-node list in the same manner as in <a class="docLink" href="ch03lev1sec3.html#ch03ex11">Program 3.9</a>.</p></li><li><p class="docList">Test whether the output list is empty every time that we wish to insert a node.</p></li><li><p class="docList">Use a dummy head node whose link points to the first node on the list, as in the given implementation.</p></li></ul>
<p class="docText">The first option is inelegant and requires extra code; the second is also inelegant and requires extra time.</p>
<p class="docText">The use of a head node does incur some cost (the extra node), and we can avoid the head node in many common applications. For example, we can also view <a class="docLink" href="#ch03ex13">Program 3.10</a> as having an input list (the original list) and an output list (the reversed list), but we do not need to use a head node in that program because all insertions into the output list are at the beginning. We shall see still other applications that are more simply coded when we use a dummy node, rather than a null link, at the <span class="docEmphasis">tail</span> of the list. There are no hard-and-fast rules about whether or not to use dummy nodes&mdash;the choice is a matter of style combined with an understanding of effects on performance. Good programmers enjoy the challenge of picking the convention that most simplifies the task at hand. We shall see several such tradeoffs throughout this book.</p>
<p class="docText">For reference, a number of options for linked-list conventions are laid out in <a class="docLink" href="#ch03table01">Table 3.1</a>; others are discussed in the exercises. In all the cases in <a class="docLink" href="#ch03table01">Table 3.1</a>, we use a pointer <tt>head</tt> to refer to the list, and we maintain a consistent stance that our program manages links to nodes, using the given code for various operations. Allocating and freeing memory for nodes and filling them with information is the same for all the conventions. Robust functions implementing the same operations would have extra code to check for error conditions. The purpose of the table is to expose similarities and differences among the various options.</p>
<a name="ch03table01"></a><p><table cellspacing="0" frame="hsides" rules="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 3.1. Head and tail conventions in linked lists</h5></caption><colgroup align="left" span="2"><col width="100"></col><col width="450"></col></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top" colspan="2"><p class="docText">This table gives implementations of basic list-processing operations with five commonly used conventions. This type of code is used in simple applications where the list-processing code is inline.</p></td></tr><tr><td class="docTableCell" align="left" valign="top" colspan="2"><p class="docText"><span class="docEmphStrong">Circular, never empty</span></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">first insert</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>head-&gt;next = head;</tt></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">insert t after x</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>t-&gt;next = x-&gt;next; x-&gt;next = t;</tt></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">remove after x</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>x-&gt;next = x-&gt;next-&gt;next;</tt></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">traversal loop</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>t = head;</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>do { ... t = t-&gt;next; } while (t != head);</tt></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">test if one item</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>if (head-&gt;next == head)</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top" colspan="2"><p class="docText"><span class="docEmphStrong">Head pointer, null tail</span></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">initialize</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>head = 0;</tt></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">insert t after x</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>if (x == 0) { head = t; head-&gt;next = 0; }</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>else { t-&gt;next = x-&gt;next; x-&gt;next = t; }</tt></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">remove after x</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>t = x-&gt;next; x-&gt;next = t-&gt;next;</tt></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">traversal loop</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>for (t = head; t != 0; t = t-&gt;next)</tt></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">test if empty</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>if (head == 0)</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top" colspan="2"><p class="docText"><span class="docEmphStrong">Dummy head node, null tail</span></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">initialize</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>head = new node;</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>head-&gt;next = 0;</tt></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">insert t after x</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>t-&gt;next = x-&gt;next; x-&gt;next = t;</tt></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">remove after x</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>t = x-&gt;next; x-&gt;next = t-&gt;next;</tt></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">traversal loop</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>for (t = head-&gt;next; t != 0; t = t-&gt;next)</tt></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">test if empty</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>if (head-&gt;next == 0)</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top" colspan="2"><p class="docText"><span class="docEmphStrong">Dummy head and tail nodes</span></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">initialize</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>head = new node;</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>z = new node;</tt></p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>head-&gt;next = z; z-&gt;next = z;</tt></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">insert t after x</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>t-&gt;next = x-&gt;next; x-&gt;next = t;</tt></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">remove after x</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>x-&gt;next = x-&gt;next-&gt;next;</tt></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">traversal loop</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>for (t = head-&gt;next; t != z; t = t-&gt;next)</tt></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText"><span class="docEmphasis">test if empty</span>:</p></td><td class="docTableCell" align="left" valign="top"><p class="docText"><tt>if (head-&gt;next == z)</tt></p></td></tr></table></p><br />
<a name="ch03ex15"></a><h5 id="title-IDARLW5H" class="docExampleTitle">Program 3.12. List-processing interface</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">In this code, which we might keep in an interface file <tt>list.h</tt>, we define the types of nodes and links, including the operations we want to perform on them. We declare our own functions for allocating and freeing memory for list nodes. The function <tt>construct</tt> is for the convenience of the implementation. These definitions <span class="docEmphasis">allow</span> clients to use <tt>Node</tt>s and associated operations without dependence upon implementation details. As we shall see in <a class="docLink" href="ch04.html#ch04">Chapter 4</a>, a slightly different interface based on C++ classes can <span class="docEmphasis">ensure</span> that client programs do not depend on implementation details.</p>
<div class="docText"><pre>typedef int Item;
struct node { Item item; node *next; };
typedef node *link;
typedef link Node;

void construct(int);
Node newNode(int);
void deleteNode(Node);
void insert(Node, Node);
Node remove(Node);
Node next(Node);
Item item(Node);</pre></div><br />
</td></tr></table></p>
<p class="docText">Another important situation in which it is sometimes convenient to use head nodes occurs when we want to pass pointers to lists as arguments to functions that may modify the list, in the same way that we do for arrays. Using a head node allows the function to accept or return an empty list. If we do not have a head node, we need a mechanism for the function to inform the calling function when it leaves an empty list. One solution in C++ is to pass the list pointer as a reference parameter. Another mechanism&mdash;the one used for the function in <a class="docLink" href="#ch03ex13">Program 3.10</a>&mdash;is to have list-processing functions take pointers to input lists as arguments and return pointers to output lists. With this convention, we do not need to use head nodes. Furthermore, it is well suited to recursive list processing, which we use extensively throughout the book (see <a class="docLink" href="ch05lev1sec1.html#ch05lev1sec1">Section 5.1</a>).</p>
<a name="ch03ex16"></a><h5 id="title-IDAMNW5H" class="docExampleTitle">Program 3.13. List allocation for the Josephus problem</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This program for the Josephus problem is an example of a client program utilizing the list-processing primitives declared in <a class="docLink" href="#ch03ex15">Program 3.12</a> and implemented in <a class="docLink" href="ch03lev1sec5.html#ch03ex17">Program 3.14</a>.</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
#include "list.h"
int main(int argc, char *argv[])
  { int i, N = atoi(argv[1]), M = atoi(argv[2]);
    Node t, x;
    construct(N);
    for (i = 2, x = newNode(1); i &lt;= N; i++)
      { t = newNode(i); insert(x, t); x = t; }
    while (x != next(x))
      {
        for (i = 1; i &lt; M; i++) x = next(x);
        deleteNode(remove(x));
      }
    cout &lt;&lt; item(x) &lt;&lt; endl;
    return 0;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch03ex15">Program 3.12</a> declares a set of black-box functions that implement basic list operations, so we can avoid repeating code inline and depending upon implementation details. <a class="docLink" href="#ch03ex16">Program 3.13</a> is our Josephus-election program (<a class="docLink" href="ch03lev1sec3.html#ch03ex11">Program 3.9</a>) recast as a client program that uses this interface. Identifying the important operations that we use in a computation and defining them in an interface gives us the flexibility to consider different concrete implementations of critical operations and to test their effectiveness. We consider one implementation for the operations defined in <a class="docLink" href="#ch03ex15">Program 3.12</a> in <a class="docLink" href="ch03lev1sec5.html#ch03lev1sec5">Section 3.5</a> (see <a class="docLink" href="ch03lev1sec5.html#ch03ex17">Program 3.14</a>), but we could also try other alternatives without changing <a class="docLink" href="#ch03ex16">Program 3.13</a> at all (see <a class="docLink" href="ch03lev1sec5.html#ch03qa5q6">Exercise 3.51</a>). This theme will recur throughout the book. C++ includes several mechanisms designed specifically to make it easier to develop encapsulated implementations, as discussed in <a class="docLink" href="ch04.html#ch04">Chapter 4</a>.</p>
<p class="docText">Some programmers prefer to encapsulate all operations on low-level data structures such as linked lists by defining functions for every low-level operation in interfaces like <a class="docLink" href="#ch03ex15">Program 3.12</a>. Indeed, as we shall see in <a class="docLink" href="ch04.html#ch04">Chapter 4</a>, the C++ class mechanism makes it easy to do so. However, that extra layer of abstraction sometimes masks the fact that just a few low-level operations are involved. In this book, when we are implementing higher-level interfaces, we usually write low-level operations on linked structures directly, to clearly expose the essential details of our algorithms and data structures. We shall see many examples in <a class="docLink" href="ch04.html#ch04">Chapter 4</a>.</p>
<p class="docText">By adding more links, we can add the capability to move backward through a linked list. For example, we can support the operation &quot;find the item <span class="docEmphasis">before</span> a given item&quot; by using a <span class="docEmphasis">doubly linked list</span> in which we maintain two links for each node: one (<tt>prev</tt>) to the item before, and another (<tt>next</tt>) to the item after. With dummy nodes or a circular list, we can ensure that <tt>x</tt>, <tt>x-&gt;next-&gt;prev</tt>, and <tt>x-&gt;prev-&gt;next</tt> are the same for every node in a doubly linked list. <a class="docLink" href="#ch03fig09">Figures 3.9</a> and <a class="docLink" href="#ch03fig10">3.10</a> show the basic link manipulations required to implement <span class="docEmphasis">remove</span>, <span class="docEmphasis">insert after</span>, and <span class="docEmphasis">insert before</span>, in a doubly linked list. Note that, for <span class="docEmphasis">remove</span>, we do not need extra information about the node before it (or the node after it) in the list, as we did for singly linked lists&mdash;that information is contained in the node itself.</p>
<a name="ch03fig09"></a><p><center>
<h5 class="docFigureTitle">Figure 3.9. Removal in a doubly-linked list</h5>
<h5></h5><h5></h5></center></p><p class="docText">In a doubly-linked list, a pointer to a node is sufficient information for us to be able to remove it, as diagrammed here. Given <span class="docEmphasis">t</span>, we set <span class="docEmphasis">t-&gt;next-&gt;prev</span> to <span class="docEmphasis">t-&gt;prev</span> <span class="docEmphasis">(center)</span> and <span class="docEmphasis">t-&gt;prev-&gt;next</span> to <span class="docEmphasis">t-&gt;next</span> <span class="docEmphasis">(bottom)</span>.</p>
<p class="docText">
<img border="0" alt="" width="175" height="293" src="03fig09.jpg" /></p>
<br />
<a name="ch03fig10"></a><p><center>
<h5 class="docFigureTitle">Figure 3.10. Insertion in a doubly-linked list</h5>
<h5></h5><h5></h5></center></p><p class="docText">To insert a node into a doubly-linked list, we need to set four pointers. We can insert a new node after a given node (diagrammed here) or before a given node. We insert a given node <span class="docEmphasis">t</span> after another given node <span class="docEmphasis">x</span> by setting <span class="docEmphasis">t-&gt;next</span> to <span class="docEmphasis">x-&gt;next</span> and <span class="docEmphasis">x-&gt;next-&gt;prev</span> to <span class="docEmphasis">t</span><span class="docEmphasis">(center)</span>, and then setting <span class="docEmphasis">x-&gt;next</span> to <span class="docEmphasis">t</span> and <span class="docEmphasis">t-&gt;prev</span> to <span class="docEmphasis">x</span> <span class="docEmphasis">(bottom)</span>.</p>
<p class="docText">
<img border="0" alt="" width="200" height="506" src="03fig10.gif" /></p>
<br />
<p class="docText">Indeed, the primary significance of doubly linked lists is that they allow us to remove a node when the <span class="docEmphasis">only</span> information that we have about that node is a link to it. Typical situations are when the link is passed as an argument in a function call, and when the node has other links and is also part of some other data structure. Providing this extra capability doubles the space needed for links in each node and doubles the number of link manipulations per basic operation, so doubly linked lists are not normally used unless specifically called for. We defer considering detailed implementations to a few specific situations where we have such a need&mdash;for example in <a class="docLink" href="ch09lev1sec5.html#ch09lev1sec5">Section 9.5</a>.</p>
<p class="docText">We use linked lists throughout this book, first for basic ADT implementations (see <a class="docLink" href="ch04.html#ch04">Chapter 4</a>), then as components in more complex data structures. Linked lists are many programmers' first exposure to an abstract data structure that is under the programmers' direct control. They represent an essential tool for our use in developing the high-level abstract data structures that we need for a host of important problems, as we shall see.</p>
</td></tr></table>
<p class="docText">&nbsp;<a name="iddle1392"></a><a name="iddle1603"></a><a name="iddle1803"></a><a name="iddle1833"></a><a name="iddle1950"></a><a name="iddle1953"></a><a name="iddle2394"></a><a name="iddle1665"></a><a name="iddle2012"></a><a name="iddle1666"></a><a name="iddle1964"></a><a name="iddle2013"></a><a name="iddle2503"></a><a name="iddle1258"></a><a name="iddle1796"></a><a name="iddle1825"></a><a name="iddle1965"></a><a name="iddle2504"></a><a name="iddle2061"></a><a name="iddle1429"></a><a name="iddle1698"></a><a name="iddle1385"></a><a name="iddle1791"></a></p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa4q1"></a><b></b></td><td><p class="docText"><a name="iddle1405"></a><a name="iddle1794"></a><a name="iddle1870"></a><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">3.33</span> Write a function that moves the largest item on a given list to be the final node on the list.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa4q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.34</span> Write a function that moves the smallest item on a given list to be the first node on the list.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa4q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.35</span> Write a function that rearranges a linked list to put the nodes in even positions after the nodes in odd positions in the list, preserving the relative order of both the evens and the odds.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa4q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.36</span> Implement a code fragment for a linked list that exchanges the positions of the nodes after the nodes referenced by two given links <tt>t</tt> and <tt>u</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa4q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">3.37</span> Write a function that takes a link to a list as argument and returns a link to a copy of the list (a new list that contains the same items, in the same order).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa4q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.38</span> Write a function that takes two arguments&mdash;a link to a list and a function that takes a link as argument&mdash;and removes all items on the given list for which the function returns a nonzero value.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa4q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.39</span> Solve <a class="docLink" href="#ch03qa4q6">Exercise 3.38</a>, but make copies of the nodes that pass the test and return a link to a list containing those nodes, in the order that they appear in the original list.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa4q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.40</span> Implement a version of <a class="docLink" href="#ch03ex13">Program 3.10</a> that uses a head node.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa4q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.41</span> Implement a version of <a class="docLink" href="#ch03ex14">Program 3.11</a> that does not use head nodes.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa4q10"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.42</span> Implement a version of <a class="docLink" href="ch03lev1sec3.html#ch03ex11">Program 3.9</a> that uses a head node.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa4q11"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.43</span> Implement a function that exchanges two given nodes on a doubly linked list.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa4q12"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">3.44</span> Give an entry for <a class="docLink" href="#ch03table01">Table 3.1</a> for a list that is never empty, is referred to with a pointer to the first node, and for which the final node has a pointer to itself.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa4q13"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.45</span> Give an entry for <a class="docLink" href="#ch03table01">Table 3.1</a> for a circular list that has a dummy node, which serves as both head and tail.</p></td></tr></table></p>
<a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></div></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch03lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table><!--IP User 2--></td></body></head></html>