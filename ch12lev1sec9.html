<html><head><title>12.9. BST Implementations of Other ADT Functions</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12lev1sec8.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch13.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch12lev1sec9"></a>
<h3 id="title-IDATYIZH" class="docSection1Title">12.9. BST Implementations of Other ADT Functions</h3>
<p class="docText">The recursive implementations given in <a class="docLink" href="ch12lev1sec5.html#ch12lev1sec5">Section 12.5</a> for the fundamental <span class="docEmphasis">search</span>, <span class="docEmphasis">insert</span>, and <span class="docEmphasis">sort</span> functions using binary tree structures are straightforward. In this section, we consider implementations of <span class="docEmphasis">select</span>, <span class="docEmphasis">join</span>, and <span class="docEmphasis">remove</span>. One of these, <span class="docEmphasis">select</span>, also has a natural recursive implementation, but the others can be cumbersome to implement, and can lead to performance problems. The <span class="docEmphasis">select</span> operation is important to consider because the ability to support <span class="docEmphasis">select</span> and <span class="docEmphasis">sort</span> efficiently is one reason that BSTs are preferred over competing structures for many applications. Some programmers avoid using BSTs to avoid having to deal with the <span class="docEmphasis">remove</span> operation; in this section, we shall see a compact implementation that ties together these operations and uses the rotation-to-the-root technique of <a class="docLink" href="ch12lev1sec8.html#ch12lev1sec8">Section 12.8</a>.</p>
<p class="docText">Generally, the operations involve moving down a path in the tree; so, for random BSTs, we expect the costs to be logarithmic. However, we cannot take for granted that BSTs will stay random when multiple operations are performed on the trees. We shall return to this issue at the end of this section.</p>
<p class="docText"><a name="iddle1151"></a><a name="iddle1165"></a><a name="iddle1187"></a><a name="iddle1309"></a><a name="iddle2032"></a><a name="iddle2277"></a>To implement <span class="docEmphasis">select</span>, we can use a recursive procedure that is analogous to the quicksort-based selection method that is described in <a class="docLink" href="ch07lev1sec8.html#ch07lev1sec8">Section 7.8</a>. To find the item with the <span class="docEmphasis">k</span>th smallest key in a BST, we check the number of nodes in the left subtree. If there are <span class="docEmphasis">k</span> nodes there, then we return the item at the root. Otherwise, if the left subtree has more than <span class="docEmphasis">k</span> nodes, we (recursively) look for the <span class="docEmphasis">k</span>th smallest node there. If neither of these conditions holds, then the left subtree has <span class="docEmphasis">t</span> elements with <span class="docEmphasis">t &lt; k</span>, and the <span class="docEmphasis">k</span>th smallest element in the BST is the <span class="docEmphasis">(k - t - l)</span>st smallest in the right subtree. <a class="docLink" href="#ch12ex24">Program 12.14</a> is a direct implementation of this method. As usual, since each execution of the function ends with at most one recursive call, a nonrecursive version is immediate (see <a class="docLink" href="#ch12qa9q1">Exercise 12.78</a>).</p>
<p class="docText">The primary algorithmic reason for including the count field in BST nodes is to support the implementation of <span class="docEmphasis">select</span>. It also allows us to support a trivial implementation of the <span class="docEmphasis">count</span> operation (return the count field in the root), and we shall see another use in <a class="docLink" href="ch13.html#ch13">Chapter 13</a>. The drawbacks to having the count field are that it uses extra space in every node, and that every function that changes the tree needs to update the field. Maintaining the count field may not be worth the trouble in some applications where <span class="docEmphasis">insert</span> and <span class="docEmphasis">search</span> are the primary operations, but it might be a small price to pay if it will be important to support the <span class="docEmphasis">select</span> operation in a dynamic symbol table.</p>
<p class="docText">We can change this implementation of the <span class="docEmphasis">select</span> operation into a <span class="docEmphasis">partition</span> operation, which rearranges the tree to put the <span class="docEmphasis">k</span>th smallest element at the root, with precisely the same recursive technique that we used for root insertion in <a class="docLink" href="ch12lev1sec8.html#ch12lev1sec8">Section 12.8</a>: If we (recursively) put the desired node at the root of one of the subtrees, we can then make it the root of the whole with a single rotation. <a class="docLink" href="#ch12ex25">Program 12.15</a> gives an implementation of this method. Like rotations, partitioning is not an ADT operation because it is a function that transforms a particular symbol-table representation and should be transparent to clients. Rather, it is an auxiliary routine that we can use to implement ADT operations or to make them run more efficiently. <a class="docLink" href="#ch12fig17">Figure 12.17</a> depicts an example showing how, in the same way as in <a class="docLink" href="ch12lev1sec8.html#ch12fig14">Figure 12.14</a>, this process is equivalent to proceeding down the path from the root to the desired node in the tree, then climbing back up, performing rotations to bring the node up to the root.</p>
<a name="ch12fig17"></a><p><center>
<h5 class="docFigureTitle">Figure 12.17. Partitioning of a BST</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts the result (bottom) of partitioning an example BST (top) about the median key, using (recursive) rotation in the same manner as for root insertion.</p>
<p class="docText">
<img border="0" alt="" width="145" height="501" src="12fig17.gif" /></p>
<br />
<p class="docText"></p><a name="ch12ex24"></a><h5 id="title-IDAX5IZH" class="docExampleTitle">Program 12.14. Selection with a BST</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1175"></a>This procedure assumes that the subtree size is maintained for each tree node. Compare the program with quicksort-based selection in an array (<a class="docLink" href="ch09lev1sec3.html#ch09ex12">Program 9.6</a>).</p>
<div class="docText"><pre>private:
   Item selectR(link h, int k)
     { if (h == 0) return nullItem;
       int t = (h-&gt;l == 0) ? 0: h-&gt;l-&gt;N;
       if (t &gt; k) return selectR(h-&gt;l, k);
       if (t &lt; k) return selectR(h-&gt;r, k-t-1);
       return h-&gt;item;
     }
public:
  Item select(int k)
    { return selectR(head, k); }</pre></div><br />
</td></tr></table></p>
<p class="docText">To <span class="docEmphasis">remove</span> a node with a given key from a BST, we first check whether the node is in one of the subtrees. If it is, we replace that subtree with the result of (recursively) removing the node from it. If the node to be removed is at the root, we replace the tree with the result of combining the two subtrees into one tree. Several options are available for accomplishing the combination. One approach is illustrated in <a class="docLink" href="#ch12fig18">Figure 12.18</a>, and an implementation is given in <a class="docLink" href="#ch12ex26">Program 12.16</a>. To combine two BSTs with all keys in the second known to be larger than all keys in the first, we apply the <span class="docEmphasis">partition</span> operation on the second tree, to bring the smallest element in that tree to the root. At this point, the left subtree of the root must be empty (else there would be a smaller element than the one at the root&mdash;a contradiction), and we can finish the job by replacing that link with a link to the first tree. <a class="docLink" href="#ch12fig19">Figure 12.19</a> shows a series of removals in an example tree, which illustrate some of the situations that can arise.</p>
<a name="ch12fig18"></a><p><center>
<h5 class="docFigureTitle">Figure 12.18. Removal of the root in a BST</h5>
<h5></h5><h5></h5></center></p><p class="docText">This diagram shows the result (bottom) of removing the root of an example BST (top). First, we remove the node, leaving two subtrees (second from top). Then, we partition the right subtree to put its smallest element at the root (third from top), leaving the left link pointing to an empty subtree. Finally, we replace this link with a link to the left subtree of the original tree (bottom).</p>
<p class="docText">
<img border="0" alt="" width="175" height="268" src="12fig18.gif" /></p>
<br />
<a name="ch12fig19"></a><p><center>
<h5 class="docFigureTitle">Figure 12.19. BST node removal</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts the result of removingthe nodes with keys <tt>L</tt>, <tt>H</tt>, and <tt>E</tt> from the BST at the top. First, the <tt>L</tt> is simply removed, since it is at the bottom. Second, the <tt>H</tt> is replaced with its right child, the <tt>I</tt>, since the left child of <tt>I</tt> is empty. Finally, the <tt>E</tt> is replaced with its successor in the tree, the <tt>G</tt>.</p>
<p class="docText">
<img border="0" alt="" width="165" height="486" src="12fig19.gif" /></p>
<br />
<p class="docText">This approach is asymmetric and is <span class="docEmphasis">ad hoc</span> in one sense: Why use the smallest key in the second tree as the root for the new tree, rather than the largest key in the first tree? That is, why do we choose to replace the node that we are removing with the <span class="docEmphasis">next</span> node in the inorder traversal of the tree, rather than the <span class="docEmphasis">previous</span> node? We also might want to consider other approaches. For example, if the node to be <a name="iddle1166"></a><a name="iddle1959"></a><a name="iddle2033"></a>removed has a null left link, why not just make its right child the new root, rather than using the node with smallest key in the right subtree? Various similar modifications to the basic remove procedure have been suggested. Unfortunately, they all suffer from a similar flaw: The tree remaining after removal is not random, even if the tree was random beforehand. Moreover, it has been shown that <a class="docLink" href="#ch12ex26">Program 12.16</a> tends to leave a tree slightly unbalanced (average height proportional to <img border="0" alt="" width="22" height="13" src="soquarerootn.jpg" />) if the tree is subjected to a large number of random remove&ndash;insert pairs (see <a class="docLink" href="#ch12qa9q7">Exercise 12.84</a>).</p>
<a name="ch12ex25"></a><h5 id="title-IDAAGJZH" class="docExampleTitle">Program 12.15. Partitioning of a BST</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Adding rotations after the recursive calls transforms the selection function of <a class="docLink" href="#ch12ex24">Program 12.14</a> into a function that puts the <span class="docEmphasis">k</span>th smallest node in the BST at the root.</p>
<div class="docText"><pre>void partR(link&amp; h, int k)
  { int t = (h-&gt;l == 0) ? 0: h-&gt;l-&gt;N;
    if (t &gt; k )
      { partR(h-&gt;l, k); rotR(h); }
    if (t &lt; k )
      { partR(h-&gt;r, k-t-1); rotL(h); }
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">These differences may not be noticed in practical applications unless <span class="docEmphasis">N</span> is huge. Still, this combination of an inelegant algorithm with undesirable performance characteristics is unsatisfying. In <a class="docLink" href="ch13.html#ch13">Chapter 13</a>, we shall examine two different ways to address this situation.</p>
<p class="docText">It is typical of search algorithms to require significantly more complicated implementations for removal than for search. The key values play an integral role in shaping the structure, so removal of a key can involve complicated repairs. One alternative is to use a lazy removal strategy, leaving removed nodes in the data structure but marking them as &quot;removed&quot; so that they can be ignored in searches. In the search implementation in <a class="docLink" href="ch12lev1sec5.html#ch12ex15">Program 12.8</a>, we can implement this strategy by skipping the equality test for such nodes. We must make sure that large numbers of marked nodes do not lead to excessive waste of time or space, but if removals are infrequent, the extra cost may not be significant. We could reuse the marked nodes on future insertions when convenient (for example, it would be easy to do so for nodes at <a name="iddle1161"></a><a name="iddle1561"></a> the bottom of the tree). Or, we could periodically rebuild the entire data structure, leaving out the marked nodes. These considerations apply to <span class="docEmphasis">any</span> data structure involving insertions and removals&mdash;they are not peculiar to symbol tables.</p>
<p class="docText">We conclude this chapter by considering the implementation of <span class="docEmphasis">remove</span> with handles and <span class="docEmphasis">join</span> for symbol-table ADT implementations that use BSTs. We assume that handles are links and omit further discussion about packaging issues, so that we can concentrate on the two basic algorithms.</p>
<p class="docText">The primary challenge in implementing a function to <span class="docEmphasis">remove</span> a node with a given handle (link) is the same as it was for linked lists: We need to change the pointer in the structure that points <span class="docEmphasis">to</span> the node being removed. There are at least four ways to address this problem. First, we could add a third link in each tree node, pointing to its parent. The disadvantage of this arrangement is that it is cumbersome to maintain extra links, as we have noted before on several occasions. Second, we could use the key in the item to search in the tree, stopping when we find a matching pointer. This approach suffers from the disadvantage that the average position of a node is near the bottom of the tree, and this approach therefore requires an unnecessary trip through the tree. Third, we could use a reference or a pointer to the pointer to the node as the handle. This method is a solution in C++ and in C, but not in many other languages. Fourth, we could adopt a lazy approach, marking removed nodes and periodically rebuilding the data structure, as just described.</p>
<p class="docText">The last operation for first-class symbol-table ADTs that we need to consider is the <span class="docEmphasis">join</span> operation. In a BST implementation, this amounts to merging two trees. How do we join two BSTs into one? Various algorithms present themselves to do the job, but each has certain disadvantages. For example, we could traverse the first BST, inserting each of its nodes into the second BST (this algorithm is a one-liner: use <tt>insert</tt> into the second BST as a function parameter to a traversal of the first BST). This solution does not have linear running time, since each insertion could take linear time. Another idea is to traverse both BSTs, to put the items into an array, to merge them, and then to build a new BST. This operation can be done in linear time, but it also uses a potentially large array.</p>
<p class="docText"></p><a name="ch12ex26"></a><h5 id="title-IDAFRJZH" class="docExampleTitle">Program 12.16. Removal of a node with a given key in a BST</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1176"></a>This implementation of the <span class="docEmphasis">remove</span> operation removes the first node with key <span class="docEmphasis">v</span> encountered in the BST. Working top down, it makes recursive calls for the appropriate subtree until the node to be removed is at the root. Then, it replaces the node with the result of combining its two subtrees&mdash;the smallest node in the right subtree becomes the root, then its left link is set to point to the left subtree.</p>
<div class="docText"><pre>private:
  link joinLR(link a, link b)
    {
      if (b == 0) return a;
      partR(b, 0); b-&gt;l = a;
      return b;
    }
  void removeR(link&amp; h, Key v)
    { if (h == 0) return;
      Key w = h-&gt;item.key();
      if (v &lt; w) removeR(h-&gt;l, v);
      if (w &lt; v) removeR(h-&gt;r, v);
      if (v == w)
        { link t = h;
          h = joinLR(h-&gt;l, h-&gt;r); delete t; }
    }
public:
  void remove(Item x)
    { removeR(head, x.key()); }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch12ex27">Program 12.17</a> is a compact linear-time recursive implementation of the <span class="docEmphasis">join</span> operation. First, we insert the root of the first BST into the second BST, using root insertion. This operation gives us two subtrees with keys known to be smaller than this root, and two subtrees with keys known to be larger than this root, so we get the result by (recursively) combining the former pair to be the left subtree of the root and the latter to be the right subtree of the root (!). Each node can be the root node on a recursive call at most once, so the total time is linear.</p>
<p class="docText"></p><a name="ch12ex27"></a><h5 id="title-IDAWSJZH" class="docExampleTitle">Program 12.17. Joining of two BSTs</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1152"></a><a name="iddle1310"></a>If either BST is empty, the other is the result. Otherwise, we combine the two BSTs by (arbitrarily) choosing the root of the first as the root, root inserting that root into the second, then (recursively) combining the pair of left subtrees and the pair of right subtrees.</p>
<div class="docText"><pre>private:
  link joinR(link a, link b)
    {
      if (b == 0) return a;
      if (a == 0) return b;
      insertT(b, a-&gt;item);
      b-&gt;l = joinR(a-&gt;l, b-&gt;l);
      b-&gt;r = joinR(a-&gt;r, b-&gt;r);
      delete a; return b;
    }
public:
  void join(ST&lt;Item, Key&gt;&amp; b)
    { head = joinR(head, b.head); }</pre></div><br />
</td></tr></table></p>
<p class="docText">An example is shown in <a class="docLink" href="#ch12fig20">Figure 12.20</a>. Like removal, this process is asymmetric and can lead to trees that are not well balanced, but randomization provides a simple fix, as we shall see in <a class="docLink" href="ch13.html#ch13">Chapter 13</a>. Note that the number of comparisons used for <span class="docEmphasis">join</span> must be at least linear in the worst case; otherwise we could develop a sorting algorithm that uses fewer than <span class="docEmphasis">N</span> lg <span class="docEmphasis">N</span> comparisons, using an approach such as bottom-up mergesort (see <a class="docLink" href="#ch12qa9q11">Exercise 12.88</a>).</p>
<a name="ch12fig20"></a><p><center>
<h5 class="docFigureTitle">Figure 12.20. Joining of two BSTs</h5>
<h5></h5><h5></h5></center></p><p class="docText">This diagram shows the result (bottom) of combining two example BSTs (top). First, we insert the root <tt>G</tt> of the first tree into the second tree, using root insertion (second from top). We are left with two subtrees with keys less than <tt>G</tt> and two subtrees with keys greater than <tt>G</tt>. Combining both pairs (recursively) gives the result (bottom).</p>
<p class="docText">
<img border="0" alt="" width="185" height="231" src="12fig20.gif" /></p>
<br />
<p class="docText">We have not included the code necessary to maintain the count field in BST nodes during the transformations for <span class="docEmphasis">join</span> and <span class="docEmphasis">remove</span>, which is necessary for applications where we want to support <span class="docEmphasis">select</span>(<a class="docLink" href="#ch12ex24">Program 12.14</a>) as well. This task is conceptually simple, but requires some care. One systematic way to proceed is to implement a small utility routine that sets the count field in a node with a value one greater than the sum of the count fields of its children, then call that routine for every node whose links are changed. Specifically, we can do so for both nodes in <tt>rotL</tt> and <tt>rotR</tt> in <a class="docLink" href="ch12lev1sec8.html#ch12ex22">Program 12.12</a>, which suffices for the transformations in <a class="docLink" href="ch12lev1sec8.html#ch12ex23">Program 12.13</a> and <a class="docLink" href="#ch12ex25">Program 12.15</a>, since they transform trees solely with rotations. For <tt>joinLR</tt> and <tt>removeR</tt> <a name="iddle1163"></a><a name="iddle1861"></a>in <a class="docLink" href="#ch12ex26">Program 12.16</a> and <tt>join</tt> in <a class="docLink" href="#ch12ex27">Program 12.17</a> it suffices to call the node-count update routine for the node to be returned, just before the <tt>return</tt> statement.</p>
<p class="docText">The basic <span class="docEmphasis">search</span>, <span class="docEmphasis">insert</span>, and <span class="docEmphasis">sort</span> operations for BSTs are easy to implement and perform well with even a modicum of randomness in the sequence of operations, so BSTs are widely used for dynamic symbol tables. They also admit simple recursive solutions to support other kinds of operations, as we have seen for <span class="docEmphasis">select</span>, <span class="docEmphasis">remove</span>, and <span class="docEmphasis">join</span>in this chapter, and as we shall see for many examples later in the book.</p>
<p class="docText">Despite their utility, there are two primary drawbacks to using BSTs in applications. The first is that they require a substantial amount of space for links. We often think of links and records as being about the same size (say one machine word)&mdash;if that is the case, then a BST implementation uses two-thirds of its allocated memory for links and only one-third for keys. This effect is less important in applications with large records and more important in environments where pointers are large. If memory is at a premium, we may prefer one of the open-addressing hashing methods of <a class="docLink" href="ch14.html#ch14">Chapter 14</a> to using BSTs.</p>
<p class="docText">The second drawback of using BSTs is the distinct possibility that the trees could become poorly balanced and lead to slow performance. In <a class="docLink" href="ch13.html#ch13">Chapter 13</a>, we examine several approaches to providing performance guarantees. If memory space for links is available, these algorithms make BSTs an attractive choice to serve as the basis for implementation of symbol-table ADTs, because they lead to guaranteed fast performance for a large set of useful ADT operations.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa9q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">12.78</span> Implement a nonrecursive BST <span class="docEmphasis">select</span> function (see <a class="docLink" href="#ch12ex24">Program 12.14</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa9q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">12.79</span> Draw the BST that results when you insert items with the keys <tt>E A S Y Q U T I O N</tt> into an initially empty tree, then remove the <tt>Q</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa9q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">12.80</span> Draw the binary search tree that results when you insert items with the keys <tt>E A S Y</tt> into one initially empty tree, and insert items with the keys <tt>Q U E S T I O N</tt> into another initially empty tree, then combine the result.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa9q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.81</span> Implement a nonrecursive BST <span class="docEmphasis">remove</span> function (see <a class="docLink" href="#ch12ex26">Program 12.16</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa9q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.82</span> Implement a version of <span class="docEmphasis">remove</span> for BSTs (<a class="docLink" href="#ch12ex26">Program 12.16</a>) that removes <span class="docEmphasis">all</span> nodes in the tree that have keys equal to the given key.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa9q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">12.83</span> Change our BST-based symbol-table implementations to support client item handles (see <a class="docLink" href="ch12lev1sec1.html#ch12qa1q7">Exercise 12.7</a>); add implementations of a destructor, a copy constructor, and an overloaded assignment operator (see <a class="docLink" href="ch12lev1sec1.html#ch12qa1q6">Exercise 12.6</a>); add <span class="docEmphasis">remove</span> and <span class="docEmphasis">join</span> operations; and use your driver program from <a class="docLink" href="ch12lev1sec3.html#ch12qa3q7">Exercise 12.22</a> to test your first-class symbol table ADT interface and implementation.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa9q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.84</span> Run experiments to determine how the height of a BST grows as a long sequence of alternating random insertions and removals is made in a random tree of <span class="docEmphasis">N</span> nodes, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10, 100</tt>, and <tt>1000</tt>, and for up to <span class="docEmphasis">N</span><sup>2</sup> insertion&ndash; removal pairs for each <span class="docEmphasis">N</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa9q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.85</span> Implement a version of <tt>remove</tt> (see <a class="docLink" href="#ch12ex26">Program 12.16</a>) that makes a random decision whether to replace the node to be removed with that node's predecessor or successor in the tree. Run experiments as described in <a class="docLink" href="#ch12qa9q7">Exercise 12.84</a> for this version.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa9q9"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">12.86</span> Implement a version of <tt>remove</tt> that uses a recursive function to move the node to be removed to the bottom of the tree through rotations, in the manner of root insertion (<a class="docLink" href="ch12lev1sec8.html#ch12ex23">Program 12.13</a>). Draw the tree produced when your program removes the root from a complete tree of 31 nodes.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa9q10"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">12.87</span> Run experiments to determine how the height of a BST grows as you repeatedly reinsert the item at the root into the tree that results when you combine the subtrees of the root in a random tree of <span class="docEmphasis">N</span> nodes, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10, 100</tt>, and <tt>1000</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa9q11"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">12.88</span> Implement a version of bottom-up mergesort based on the <span class="docEmphasis">join</span> operation: Start by putting keys into <span class="docEmphasis">N</span> one-node trees, then combine the one-node trees in pairs to get <span class="docEmphasis">N</span>/2 two-node trees, then combine the two-node trees in pairs to get <span class="docEmphasis">N</span>/4 four-node trees, and so forth.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa9q12"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.89</span> Implement a version of <tt>join</tt> (see <a class="docLink" href="#ch12ex27">Program 12.17</a>) that makes a random decision whether to use the root of the first tree or the root of the second tree for root of the result tree. Run experiments as described in <a class="docLink" href="#ch12qa9q10">Exercise 12.87</a> for this version.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12lev1sec8.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch13.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>