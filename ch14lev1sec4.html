<html><head><title>14.4. Double Hashing</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch14lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch14lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch14lev1sec4"></a>
<h3 id="title-IDAPAF0B" class="docSection1Title">14.4. Double Hashing</h3>
<p class="docText"><a name="iddle1280"></a><a name="iddle1567"></a><a name="iddle1570"></a>The operative principle of linear probing (and indeed of any hashing method) is a guarantee that, when we are searching for a particular key, we look at every key that hashes to the same table address (in particular, the key itself, if it is in the table). In an open addressing scheme, however, other keys are typically also examined, particularly when the table begins to fill up. In the example depicted in <a class="docLink" href="ch14lev1sec3.html#ch14fig07">Figure 14.7</a>, a search for N involves looking at C, E. R, and I, none of which had the same hash value. What is worse, insertion of a key with one hash value can drastically increase the search times for keys with other hash values: in <a class="docLink" href="ch14lev1sec3.html#ch14fig07">Figure 14.7</a>, the insertion of M caused increased search times for positions 7 &ndash; 12 and 0 &ndash; 1. This phenomenon is called <span class="docEmphasis">clustering</span> because it has to do with the process of cluster formation. It can make linear probing run slowly for nearly full tables.</p>
<p class="docText">Fortunately, there is an easy way to virtually eliminate the clustering problem: <span class="docEmphasis">double hashing</span>. The basic strategy is the same as for linear probing; the only difference is that, instead of examining each successive table position following a collision, we use a second hash function to get a fixed increment to use for the probe sequence. An implementation is given in <a class="docLink" href="#ch14ex09">Program 14.6</a>.</p>
<p class="docText">The second hash function must be chosen with some care, since otherwise the program may not work at all. First, we must exclude the case where the second hash function evaluates to 0, since that would lead to an infinite loop on the very first collision. Second, it is important that the value of the second hash function be relatively prime to the table size, since otherwise some of the probe sequences could be very short (for example, consider the case where the table size is twice the value of the second hash function). One way to enforce this policy is to make <span class="docEmphasis">M</span> prime and to choose a second hash function that returns values that are less than <span class="docEmphasis">M</span>. In practice, a simple second hash function such as</p>
<div class="docText"><pre>inline int hashtwo(Key v) { return (v % 97) + 1; }</pre></div><br />
<p class="docText">will suffice for many hash functions, when the table size is not small. Also in practice, any loss in efficiency that is due to this simplification is not likely to be noticeable, much less to be significant. If the table is huge and sparse, the table size itself does not need to be prime because just a few probes will be used for every search (although we might <a name="iddle1555"></a><a name="iddle2501"></a>want to test for and abort long searches to guard against an infinite loop, if we cut this corner (see <a class="docLink" href="#ch14qa4q8">Exercise 14.38</a>)).</p>
<a name="ch14ex09"></a><h5 id="title-IDAVDF0B" class="docExampleTitle">Program 14.6. Double hashing</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Double hashing is the same as linear probing except that we use a second hash function to determine the search increment to use after each collision. The search increment must be nonzero, and the table size and the search increment should be relatively prime. The <tt>remove</tt> function for linear probing (see <a class="docLink" href="ch14lev1sec3.html#ch14ex08">Program 14.5</a>) does <span class="docEmphasis">not</span> work with double hashing, because any key might be in many different probe sequences.</p>
<div class="docText"><pre>  void insert(Item item)
    { Key v = item.key();
      int i = hash(v, M), k = hashtwo(v, M);
      while (!st[i].null()) i = (i+k) % M;
      st[i] = item; N++;
    }
  Item search(Key v)
    { int i = hash(v, M), k = hashtwo(v, M);
      while (!st[i].null())
      if (v == st[i].key()) return st[i];
        else i = (i+k) % M;
      return nullItem;
    }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch14fig09">Figure 14.9</a> shows the process of building a small table with double hashing; <a class="docLink" href="#ch14fig10">Figure 14.10</a> shows that double hashing results in many fewer clusters (which are therefore much shorter) than the clusters left by linear probing.</p>
<a name="ch14fig09"></a><p><center>
<h5 class="docFigureTitle">Figure 14.9. Double hashing</h5>
<h5></h5><h5></h5></center></p><p class="docText">This diagram shows the process of inserting the keys <span class="docEmphasis">A S E R C H I N G X M P L</span> into an initially empty hash table with open addressing, using the hash values given at the top and resolving collisions with double hashing. The first and second hash values for each key appear in the two rows below that key. As in <a class="docLink" href="ch14lev1sec3.html#ch14fig07">Figure 14.7</a>, table positions that are probed are unshaded. The <span class="docEmphasis">A</span> goes into position 7, then the <span class="docEmphasis">S</span> goes into position 3, then the <span class="docEmphasis">E</span> goes into position 9, as in <a class="docLink" href="ch14lev1sec3.html#ch14fig07">Figure 14.7</a>, but the <span class="docEmphasis">R</span> goes into position 1 after the collision at position 9, using its second hash value of 5 for the probe increment after collision. Similarly, <span class="docEmphasis">P</span> goes into position 6 on the final insertion after collisions at positions 8, 12, 3, 7, 11, and 2, using its second hash value 4 as the probe increment.</p>
<p class="docText">
<img border="0" alt="" width="175" height="242" src="14fig09.gif" /></p>
<br />
<a name="ch14fig10"></a><p><center>
<h5 class="docFigureTitle">Figure 14.10. Clustering</h5>
<h5></h5><h5></h5></center></p><p class="docText">These diagrams show the placement of records as we insert them into a hash table using linear probing (center) and double hashing (bottom), with the key value distribution shown at the top. Each line shows the result of inserting 10 records. As the table fills, the records cluster together into sequences separated by empty table positions. Long clusters are undesirable because the average cost of searching for one of the keys in the cluster is proportional to the cluster length. With linear probing, the longer clusters are, the more likely they are to increase in length, so a few long clusters dominate as the table fills up. With double hashing, this effect is much less pronounced, and the clusters remain relatively short.</p>
<p class="docText">
<img border="0" alt="" width="450" height="205" src="14fig10.gif" /></p>
<br />
<a name="ch14ex10"></a><h5 id="title-IDA2HF0B" class="docExampleTitle">Property 14.4. When collisions are resolved with double hashing, the average number of probes required to search in a hash table of size <span class="docEmphasis">M</span> that contains <span class="docEmphasis">N = &#945;M</span> keys is</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">
<img border="0" alt="" width="75" height="30" src="609equ01.jpg" /></p>
<p class="docText">and</p>
<p class="docText">
<img border="0" alt="" width="35" height="30" src="609equ02.jpg" /></p>
<p class="docText">for hits and misses, respectively.</p>
<p class="docText">These formulas are the result of a deep mathematical analysis done by Guibas and Szemeredi (<span class="docEmphasis">see reference section</span>). The proof is based on showing that double hashing is nearly equivalent to a more complicated <span class="docEmphasis">random hashing</span> algorithm where we use a key-dependent sequence of probe positions with each probe equally likely to hit each table position. This algorithm is only an approximation to double hashing for many reasons: for example, we take pains in double hashing to ensure that we try every table position once, but random hashing could examine the same table position more than once. Still, for sparse tables, the probabilities of collisions for the two methods are similar. We are interested in both: Double hashing is easy to implement, whereas random hashing is easy to analyze.</p>
<p class="docText">The average cost of a search miss for random hashing is given by the equation</p>
<p class="docText">
<img border="0" alt="" width="330" height="31" src="610equ01.jpg" /></p>
<p class="docText">The expression on the left is the sum of the probability that a search miss uses more than <span class="docEmphasis">k</span> probes, for <span class="docEmphasis">k</span> = 0,1,2,... (and is equal to the average from elementary probability theory). A search always uses one probe, then needs a second probe with probability <span class="docEmphasis">N/M</span>, a third probe with probability <span class="docEmphasis">(N/M)<sup>2</sup></span>, and so forth. We can also use this formula to compute the following approximation to the average cost of a search hit in a table with <span class="docEmphasis">N</span> keys:</p>
<p class="docText">
<img border="0" alt="" width="350" height="39" src="610equ02.jpg" /></p>
<p class="docText">Each key in the table is equally likely to be hit; the cost of finding a key is the same as the cost of inserting it; and the cost of inserting the <span class="docEmphasis">j</span>th key in the table is the cost of a search miss in a table of <span class="docEmphasis">j</span> &ndash; 1 keys, so this formula is the average of those costs. Now, we can simplify and evaluate this sum by multiplying the top and bottom of all the fractions by <span class="docEmphasis">M</span>:</p>
<p class="docText"><img border="0" alt="" width="300" height="32" src="610equ03.jpg" /></p>
<p class="docText">and further simplify to get the result</p>
<p class="docText"><img border="0" alt="" width="250" height="35" src="610equ04.jpg" /></p>
<p class="docText">since <span class="docEmphasis">H<sub>M</sub> <img src="U2248.GIF" border="0" /> ln M</span>.</p>
<p class="docText"><a name="iddle1590"></a>The precise nature of the relationship between the performance of double hashing and the random-hashing ideal that was proven by <a name="iddle1281"></a><a name="iddle1556"></a><a name="iddle1568"></a><a name="iddle1576"></a><a name="iddle1778"></a><a name="iddle2502"></a>Guibas and Szemeredi is an asymptotic result that need not be relevant for practical table sizes; moreover, the results rest on the assumption that the hash functions return random values. Still, the asymptotic formulas in <a class="docLink" href="#ch14ex11">Property 14.5</a> are accurate predictors of the performance of double hashing in practice, even when we use an easy-to-compute second hash function such as <tt>(v % 97)+1</tt>. As do the corresponding formulas for linear probing, these formulas approach infinity as <span class="docEmphasis">&#945;</span> approaches 1, but they do so much more slowly.</p>
</td></tr></table></p>
<p class="docText">The contrast between linear probing and double hashing is illustrated clearly in <a class="docLink" href="#ch14fig11">Figure 14.11</a>. Double hashing and linear probing have similar performance for sparse tables, but we can allow the table to become more nearly full with double hashing than we can with linear probing before performance degrades. The following table summarizes the expected number of probes for search hits and misses with double hashing:</p>
<a name="ch14fig11"></a><p><center>
<h5 class="docFigureTitle">Figure 14.11. Costs of open-addressing search</h5>
<h5></h5><h5></h5></center></p><p class="docText">These plots show the costs of building a hash table of size 1000 by inserting keys into an initially empty table using linear probing <span class="docEmphasis">(top)</span> and double hashing <span class="docEmphasis">(bottom)</span>. Each bar represents the cost of 20 keys. The gray curves show the costs predicted by theoretical analysis (see <a class="docLink" href="#ch14ex10">Properties 14.4</a> and <a class="docLink" href="#ch14ex11">14.5</a>).</p>
<p class="docText">
<img border="0" alt="" width="130" height="477" src="14fig11.gif" /></p>
<br />
<p><table cellspacing="0" frame="void" rules="groups" cellpadding="5"><colgroup align="left" span="5"><col width="150"></col><col width="75"></col><col width="75"></col><col width="75"></col><col width="75"></col></colgroup><thead><tr><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">load factor(<span class="docEmphasis">&#945;</span>)</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">1/2</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">2/3</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">3/4</p></th><th class="bottomBorder thead" scope="col" align="left" valign="top"><p class="docText">9/10</p></th></tr></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText">search hit</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">1.4</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">1.6</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">1.8</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">2.6</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText">search miss</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">1.5</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">2.0</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">3.0</p></td><td class="docTableCell" align="left" valign="top"><p class="docText">5.5</p></td></tr></table></p><br />
<p class="docText"><a name="iddle1584"></a><a name="iddle1592"></a><a name="iddle1994"></a>Search misses are always more expensive than hits, and both require only a few probes, on the average, even in a table that is nine-tenths full.</p>
<p class="docText">Looking at the same results in another way, double hashing allows us to use a smaller table than we would need with linear probing to get the same average search times.</p>
<a name="ch14ex11"></a><h5 id="title-IDAMUF0B" class="docExampleTitle">Property 14.5. We can ensure that the average cost of all searches is less than <span class="docEmphasis">t</span> probes by keeping the load factor less than for linear probing and less than 1 &ndash; 1/<span class="docEmphasis">t</span> for double hashing</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Set the equations for search misses in <a class="docLink" href="#ch14ex10">Property 14.4</a> and <a class="docLink" href="#ch14ex11">Property 14.5</a> equal to <span class="docEmphasis">t</span>, and solve for <span class="docEmphasis">&#945;</span>.</p>
</td></tr></table></p>
<p class="docText">For example, to ensure that the average number of probes for a search is less than 10, we need to keep the table at least 32 percent empty for linear probing, but only 10 percent empty for double hashing. If we have 10<sup>5</sup> items to process, we need space for just another 10<sup>4</sup> items to be able to do unsuccessful searches with fewer than 10 probes. By contrast, separate chaining would require more than 10<sup>5</sup> links, and BSTs would require twice that many.</p>
<p class="docText">The method of <a class="docLink" href="ch14lev1sec3.html#ch14ex08">Program 14.5</a> for implementing the <span class="docEmphasis">remove</span> operation (rehash the keys that might have a search path containing the item to be deleted) breaks down for double hashing, because the deleted key might be in many different probe sequences, involving keys throughout the table. Thus, we have to resort to the other method that we considered at the end of <a class="docLink" href="ch12lev1sec3.html#ch12lev1sec3">Section 12.3</a>: We replace the deleted item with a sentinel that marks the table position as occupied but does not match any key (see <a class="docLink" href="#ch14qa4q3">Exercise 14.33</a>).</p>
<p class="docText">Like linear probing, double hashing is not an appropriate basis for implementing a full-function symbol table ADT where we need to support the <span class="docEmphasis">sort</span> or <span class="docEmphasis">select</span> operations.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa4q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">14.31</span> Give the contents of the hash table that results when you insert items with the keys E A S Y Q U T I O N in that order into an initially empty table of size <span class="docEmphasis">M</span> = 16 using double hashing. Use the hash function 11<span class="docEmphasis">k</span> mod <span class="docEmphasis">M</span> for the initial probe and the second hash function (<span class="docEmphasis">k</span> mod 3) + 1 for the search increment (when the key is the <span class="docEmphasis">k</span>th letter of the alphabet).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa4q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">14.32</span> Answer <a class="docLink" href="#ch14qa4q1">Exercise 14.31</a> for <span class="docEmphasis">M</span> = 10</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa4q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.33</span> Implement deletion for double hashing, using a sentinel item.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa4q4"></a><b></b></td><td><p class="docText"><a name="iddle1571"></a><span class="docEmphStrong">14.34</span> Modify your solution to <a class="docLink" href="ch14lev1sec3.html#ch14qa3q4">Exercise 14.27</a> to use double hashing.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa4q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.35</span> Modify your solution to <a class="docLink" href="ch14lev1sec3.html#ch14qa3q5">Exercise 14.28</a> to use double hashing.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa4q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.36</span> Modify your solution to <a class="docLink" href="ch14lev1sec3.html#ch14qa3q6">Exercise 14.29</a> to use double hashing.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa4q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">14.37</span> Implement an algorithm that approximates random hashing, by providing the key as a seed to an in-line random number generator (as in <a class="docLink" href="ch14lev1sec1.html#ch14ex02">Program 14.2</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa4q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.38</span> Suppose that a table of size 10<sup>6</sup> is half full, with occupied positions chosen at random. Estimate the probability that all positions with indices divisible by 100 are occupied.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa4q9"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">14.39</span> Suppose that you have a bug in your double-hashing code such that one or both of the hash functions always return the same value (not 0). Describe what happens in each of these situations: (<span class="docEmphasis">i</span>) when the first one is wrong (<span class="docEmphasis">ii</span>) when the second one is wrong, and (<span class="docEmphasis">iii</span>) when both are wrong.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch14lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch14lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>