<html><head><title>14.1. Hash Functions</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch14.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch14lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch14lev1sec1"></a>
<h3 id="title-IDAC1Z0B" class="docSection1Title">14.1. Hash Functions</h3>
<p class="docText">The first problem that we must address is the computation of the hash function, which transforms keys into table addresses. This arithmetic computation is normally simple to implement, but we must proceed with caution to avoid various subtle pitfalls. If we have a table that can hold <span class="docEmphasis">M</span> items, then we need a function that transforms keys into integers in the range [0,<span class="docEmphasis">M</span> &ndash; 1]. An ideal hash function is easy to compute and approximates a random function: For each input, every output should be in some sense equally likely.</p>
<p class="docText"><a name="iddle1142"></a><a name="iddle1501"></a><a name="iddle1582"></a><a name="iddle1680"></a><a name="iddle1703"></a>The hash function depends on the key type. Strictly speaking, we need a different hash function for each kind of key that might be used. For efficiency, we generally want to avoid explicit type conversion, striving instead for a throwback to the idea of considering the binary representation of keys in a machine word as an integer that we can use for arithmetic computations. Hashing predates high-level languages&mdash;on early computers, it was common practice to view a value as a string key at one moment and an integer the next. Some high-level languages make it difficult to write programs that depend on how keys are represented on a particular computer, because such programs, by their very nature, are machine dependent and therefore are difficult to transfer to a new or different computer. Hash functions generally are dependent on the process of transforming keys to integers, so machine independence and efficiency are sometimes difficult to achieve simultaneously in hashing implementations. We can typically hash simple integer or floating-point keys with just a single machine operation, but string keys and other types of compound keys require more care and more attention to efficiency.</p>
<p class="docText">Perhaps the simplest situation is when the keys are floating-point numbers known to be in a fixed range. For example, if the keys are numbers that are greater than 0 and less than 1, we can just multiply by <span class="docEmphasis">M</span> and round off to the nearest integer to get an address between 0 and <span class="docEmphasis">M</span> &ndash; 1; an example is given in <a class="docLink" href="#ch14fig01">Figure 14.1</a>. If the keys are greater than <span class="docEmphasis">s</span> and less than <span class="docEmphasis">t</span> for any fixed <span class="docEmphasis">s</span> and <span class="docEmphasis">t</span>, we can rescale by subtracting <span class="docEmphasis">s</span> and dividing by <span class="docEmphasis">t&ndash;s</span>, which puts them between 0 and 1, then multiply by <span class="docEmphasis">M</span> to get a table address.</p>
<a name="ch14fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 14.1. Multiplicative hash function for floating-point keys</h5>
<h5></h5><h5></h5></center></p><p class="docText">To transform floating-point numbers between 0 and 1 into table indices for a table of size 97, we multiply by 97. In this example, there are three collisions: at 17, 53, and 76. The most significant bits of the keys determine the hash values; the least significant bits of the keys play no role. One goal of hash-function design is to avoid such imbalance by having each bit of data play a role in the computation.</p><p class="docText">
<img border="0" alt="" width="105" height="421" src="14fig01.gif" /></p>
<br />
<p class="docText">If the keys are <span class="docEmphasis">w</span>-bit integers, we can convert them to floating-point numbers and divide by 2<span class="docEmphasis"><sup>w</sup></span> to get floating-point numbers between 0 and 1, then multiply by <span class="docEmphasis">M</span> as in the previous paragraph. If floating-point operations are expensive and the numbers are not so large as to cause overflow, we can accomplish the same result with integer arithmetic operations: Multiply the key by <span class="docEmphasis">M</span>, then shift right w bits to divide by 2<span class="docEmphasis"><sup>w</sup></span> (or, if the multiply would overflow, shift then multiply). Such functions are not useful for hashing unless the keys are evenly distributed in the range, because the hash value is determined only by the leading digits of the keys.</p>
<p class="docText">A simpler and more efficient method for <span class="docEmphasis">w</span>-bit integers&mdash;one that is perhaps the most commonly used method for hashing&mdash;is to choose <a name="iddle1580"></a><a name="iddle1589"></a><a name="iddle1641"></a>the table size <span class="docEmphasis">M</span> to be prime, and, for any integer key <span class="docEmphasis">k</span>, to compute the remainder when dividing <span class="docEmphasis">k</span> by <span class="docEmphasis">M</span>, or <span class="docEmphasis">h (k) = k</span> mod <span class="docEmphasis">M</span>. Such a function is called a <span class="docEmphasis">modular</span> hash function. It is very easy to compute (<tt>k % M</tt>, in C++), and is effective in dispersing the key values evenly among the values less than <span class="docEmphasis">M</span>. <a class="docLink" href="#ch14fig02">Figure 14.2</a> gives a small example.</p>
<a name="ch14fig02"></a><p><center>
<h5 class="docFigureTitle">Figure 14.2. Modular hash functions for integer keys</h5>
<h5></h5><h5></h5></center></p><p class="docText">The three rightmost columns show the result of hashing the 16-bit keys on the left with these functions: v % 97 (left) v % 100 (center) and (int) (a * v) % 100 (right) where a = .618033. The table sizes for these functions are 97, 100, and 100, respectively. The values appear random (because the keys are random). The center function (v % 100) uses just the rightmost two digits of the keys and is therefore susceptible to bad performance for nonrandom keys.</p><p class="docText">
<img border="0" alt="" width="115" height="373" src="14fig02.gif" /></p>
<br />
<p class="docText">We can also use modular hashing for floating-point keys. If the keys are in a small range, we can scale to convert them to numbers between 0 and 1, multiply by 2<span class="docEmphasis"><sup>w</sup></span> to get a <span class="docEmphasis">w</span>-bit integer result, then use a modular hash function. Another alternative is just to use the binary representation of the key (if available) as the operand for the modular hashing function.</p>
<p class="docText">Modular hashing applies whenever we have access to the bits that our keys comprise, whether they are integers represented in a machine word, a sequence of characters packed into a machine word, or any of a myriad of other possibilities. A sequence of random characters packed into a machine word is not quite the same as a random integer key, because some of the bits are used for encoding purposes, but we can make both (and any other type of key that is encoded so as to fit in a machine word) <span class="docEmphasis">appear</span> to be random indices into a small table.</p>
<p class="docText"><a class="docLink" href="#ch14fig03">Figure 14.3</a> illustrates the primary reason that we choose the hash table size <span class="docEmphasis">M</span> to be prime for modular hashing. In this example, for character data with 7-bit encoding, we treat the key as a base-128 number&mdash;one digit for each character in the key. The word <tt>now</tt> corresponds to the number 1816567, which also can be written as</p>
<div class="docText"><pre>110.128<sup>2</sup> + 111.128<sup>1</sup> + 119.128<sup>0</sup></pre></div><br />
<p class="docText">since the ASCII encodings of <tt>n</tt>, <tt>o</tt>, and <tt>w</tt> are 156<sub>8</sub> = 110, 157<sub>8</sub> = 111, and 167<sub>8</sub>= 119, respectively. Now, the choice of table size <span class="docEmphasis">M</span> = 64 is unfortunate for this type of key, because the value of <span class="docEmphasis">x</span> mod 64 is unaffected by the addition of multiples of 64 (or 128) to <span class="docEmphasis">x&mdash;</span> the hash function of any key is the value of that key's last 6 bits. Surely a good hash function should take into account all the bits of a key, particularly for keys made up of characters. Similar effects can arise whenever <span class="docEmphasis">M</span> has a factor that is a power of 2. The simplest way to avoid such effects is to make <span class="docEmphasis">M</span> prime.</p>
<a name="ch14fig03"></a><p><center>
<h5 class="docFigureTitle">Figure 14.3. Modular hash functions for encoded characters</h5>
<h5></h5><h5></h5></center></p><p class="docText">Each line in this table shows a 3-character word, that word's ASCII encoding as a 21-bit number in octal and decimal, and standard modular hash functions for table sizes 64 and 31, respectively (right-most two columns). The table size 64 leads to undesirable results, because only the rightmost bits of the keys contribute to the hash value, and characters in natural-language words are not evenly distributed. For example, all words ending in y hash to the value 57. By contrast, the prime value 31 leads to fewer collisions in a table less than one-half the size.</p><p class="docText">
<img border="0" alt="" width="175" height="371" src="14fig03.gif" /></p>
<br />
<p class="docText">Modular hashing is completely trivial to implement except for the requirement that we make the table size prime. For some applications, we can be content with a small known prime, or we can look up a <a name="iddle1546"></a><a name="iddle1600"></a><a name="iddle1919"></a><a name="iddle2095"></a><a name="iddle2446"></a>prime number close to the table size that we want in a list of known primes. For example, numbers of the form 2<span class="docEmphasis"><sup>t</sup></span> &ndash; 1 are prime for <span class="docEmphasis">t</span> = 2, 3, 5, 7, 13, 17, 19, and 31 (and no other <span class="docEmphasis">t</span> &lt; 31): these are the famous <span class="docEmphasis">Mersenne primes</span>. To allocate a table of a certain size dynamically, we would need to compute a prime number close to a certain value. This calculation is not a trivial one (although there is a clever algorithm for the task, which we shall examine in Part 5), so, in practice, a common solution is to use a precomputed table (see <a class="docLink" href="#ch14fig04">Figure 14.4</a>). Use of modular hashing is not the only reason to make a table size prime; we shall consider another reason in <a class="docLink" href="ch14lev1sec4.html#ch14lev1sec4">Section 14.4</a>.</p>
<a name="ch14fig04"></a><p><center>
<h5 class="docFigureTitle">Figure 14.4. Prime numbers for hash tables</h5>
<h5></h5><h5></h5></center></p><p class="docText">This table of the largest prime less than 2<span class="docEmphasis"><sup>n</sup></span> for 8 <img src="U2264.GIF" border="0" /> <span class="docEmphasis">n</span> <img src="U2264.GIF" border="0" /> 32 can be used to dynamically allocate a hash table, when it is required that the table size be prime. For any given positive value in the range covered, we can use this table to get a prime number within a factor of 2 of that value.</p><p class="docText">
<img border="0" alt="" width="145" height="371" src="14fig04.gif" /></p>
<br />
<p class="docText">Another alternative for integer keys is to combine the multiplicative and modular methods: Multiply the key by a constant between 0 and 1, then reduce it modulo <span class="docEmphasis">M</span>. That is, use the function <span class="docEmphasis">h(k) = <img src="U230A.GIF" border="0" />k&#945;<img src="U230B.GIF" border="0" /></span> mod <span class="docEmphasis">M</span>. There is interplay among the values of <span class="docEmphasis">&#945;</span>, <span class="docEmphasis">M</span>, and the effective radix of the key that could possibly result in anomalous behavior, but if we use an arbitrary value of <span class="docEmphasis">&#945;</span>, we are not likely to encounter trouble in a practical application. A popular choice for <span class="docEmphasis">&#945;</span> is <span class="docEmphasis">&#248;</span> = 0.618033 ... (the <span class="docEmphasis">golden ratio</span>). Many other variations on this theme have been studied, particularly hash functions that can be implemented with efficient machine instructions such as shifting and masking (<span class="docEmphasis">see reference section</span>).</p>
<p class="docText">In many applications where symbol tables are used, the keys are not numbers and are not necessarily short, but rather are alphanumeric strings and possibly are long. How do we compute the hash function for a word such as</p>
<pre><tt>averylongkey?</tt></pre><br />
<p class="docText">In 7-bit ASCII, this word corresponds to the 84-bit number</p>
<div class="docText"><pre>97&#183;128<sup>11</sup> + 118&#183;128<sup>10</sup> + 101&#183;128<sup>9</sup> + 114&#183;128<sup>8</sup> + 121.128<sup>7</sup>
         + 108&#183;128<sup>6</sup> + 111&#183;128<sup>5</sup> + 110&#183;128<sup>4</sup> + 103&#183;128<sup>3</sup>
         + 107&#183;128<sup>2</sup> + 101&#183;128<sup>1</sup> + 121&#183;128<sup>0</sup>,</pre></div><br />
<p class="docText">which is too large to be represented for normal arithmetic functions in most computers. Moreover, we should be able to handle keys that are much longer.</p>
<p class="docText">To compute a modular hash function for long keys, we transform the keys piece by piece. We can take advantage of arithmetic properties of the <tt>mod</tt> function and use Horner's algorithm (see <a class="docLink" href="ch04lev1sec9.html#ch04lev1sec9">Section 4.9</a>).</p>
<p class="docText"></p><a name="ch14ex01"></a><h5 id="title-IDAOK00B" class="docExampleTitle">Program 14.1. Hash function for string keys</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1726"></a><a name="iddle2452"></a>This implementation of a hash function for string keys involves one multiplication and one addition per character in the key. If we were to replace the constant 127 by 128, the program would simply compute the remainder when the number corresponding to the 7-bit ASCII representation of the key was divided by the table size, using Horner's method. The prime base 127 helps us to avoid anomalies if the table size is a power of 2 or a multiple of 2.</p>
<div class="docText"><pre>  int hash(char *v, int M)
    { int h = 0, a = 127;
      for (; *v != 0; v++)
        h = (a*h + *v) % M;
      return h;
    }</pre></div><br />
</td></tr></table></p>
<p class="docText">This method is based on yet another way of writing the number corresponding to keys. For our example, we write the following expression:</p>
<div class="docText"><pre>((((((((((97&#183;128 + 118)&#183;128 + 101)&#183;128 + 114)&#183;128 + 121)&#183;128
                 + 108)&#183;128 + 111)&#183;128 + 110)&#183;128 + 103)&#183;128
                 + 107)&#183;128 + 101)&#183;128 + 121.</pre></div><br />
<p class="docText">That is, we can compute the decimal number corresponding to the character encoding of a string by proceeding left to right, multiplying the accumulated value by 128, then adding the encoded value of the next character. This computation would eventually produce a number larger than we can represent in our machine for a long string, but we are not interested in computing the number; we want just its remainder when divided by <span class="docEmphasis">M</span>, which is small. We can get our result without ever carrying a large accumulated value, because we can cast out multiples of <span class="docEmphasis">M</span> at any point during this computation&mdash;we need to keep only the remainder modulo <span class="docEmphasis">M</span> each time that we do a multiply and add&mdash;and we get the same result as we would if we had the capability to compute the long number, then to do the division (see <a class="docLink" href="#ch14qa1q10">Exercise 14.10</a>). This observation leads to a direct arithmetic way to compute modular hash functions for long strings; see <a class="docLink" href="#ch14ex01">Program 14.1</a>. The program uses one final twist: It uses the prime 127 instead of the base 128. The reason for this change is discussed in the next paragraph.</p>
<p class="docText"></p><a name="ch14ex02"></a><h5 id="title-IDAXM00B" class="docExampleTitle">Program 14.2. Universal hash function (for string keys)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1602"></a><a name="iddle2226"></a><a name="iddle2605"></a>This program does the same computations as <a class="docLink" href="#ch14ex01">Program 14.1</a>, but using pseudorandom coefficient values instead of a fixed radix, to approximate the ideal of having a collision between two given nonequal keys occur with probability 1/<span class="docEmphasis">M</span>. We use a crude random-number generator to avoid spending excessive time on computing the hash function.</p>
<div class="docText"><pre> int hashU(char *v, int M)
   { int h, a = 31415, b = 27183;
     for (h = 0; *v != 0; v++, a = a*b % (M-1))
         h = (a*h + *v) % M;
     return (h &lt; 0) ? (h + M) : h;
   }</pre></div><br />
</td></tr></table></p>
<p class="docText">There are many ways to compute hash functions at approximately the same cost as doing modular hashing using Horner's method (one or two arithmetic operations for each character in the key). For random keys, the methods hardly differ, but real keys are hardly random. The opportunity to economically make real keys appear to be random leads us to consider <span class="docEmphasis">randomized</span> algorithms for hashing&mdash;we want hash functions that produce random table indices, no matter what the keys are. Randomization is not difficult to arrange, because there is no requirement that we stick to the letter of the definition of modular hashing&mdash;we merely want to involve all the bits of the key in a computation that produces an integer less than <span class="docEmphasis">M</span>. <a class="docLink" href="#ch14ex01">Program 14.1</a> shows one way to do that: Use a prime base, instead of the power of 2 called for in the definition of the integer corresponding to the ASCII representation of the string. <a class="docLink" href="#ch14fig05">Figure 14.5</a> illustrates how this change avoids poor dispersion for typical string keys. The hash values produced by <a class="docLink" href="#ch14ex01">Program 14.1</a> could theoretically be bad for table sizes that are a multiple of 127 (although these effects are likely to be minimal in practice); we could choose the multiplier value at random to produce a randomized algorithm. An even more effective approach is to use <span class="docEmphasis">random</span> values for the coefficients in the computation, and a <span class="docEmphasis">different</span> random value for each digit in the key. This approach gives a randomized algorithm called <span class="docEmphasis">universal hashing</span>.</p>
<a name="ch14fig05"></a><p><center>
<h5 class="docFigureTitle">Figure 14.5. Hash functions for character strings</h5>
<h5></h5><h5></h5></center></p><p class="docText">These diagrams show the dispersion for a set of English words (the first 1000 distinct words of Melville's <span class="docEmphStrong">Moby Dick</span>) using <a class="docLink" href="#ch14ex01">Program 14.1</a> with <span class="docEmphBoldItalic">M = 96</span> and <span class="docEmphBoldItalic">a = 128</span> <span class="docEmphasis">(top)</span> <span class="docEmphBoldItalic">M = 97</span> and <span class="docEmphBoldItalic">a = 128</span> <span class="docEmphasis">(center)</span> and <span class="docEmphBoldItalic">M = 96</span> and <span class="docEmphBoldItalic">a = 127</span> <span class="docEmphasis">(bottom)</span> Poor dispersion in the first instance results from the combination of uneven usage of the letters and the common factor 32 in the table size and multiplier, which preserves the unevenness. The other two instances appear random because the table size and the multiplier are relatively prime.</p><p class="docText">
<img border="0" alt="" width="145" height="167" src="14fig05.gif" /></p>
<br />
<p class="docText">A theoretically ideal universal hash function is one for which the chance of a collision between two distinct keys in a table of size <span class="docEmphasis">M</span> is precisely 1/<span class="docEmphasis">M</span>. It is possible to prove that using a sequence of different random values, instead of a fixed arbitrary value, for the coefficient a in <a class="docLink" href="#ch14ex01">Program 14.1</a> turns modular hashing into a universal hash function. However, the cost of generating a new random number for each character in the key is likely to be prohibitive. <a class="docLink" href="#ch14ex02">Program 14.2</a> demonstrates a practical compromise: We vary the coefficients by generating a simple pseudorandom sequence.</p>
<p class="docText">In summary, to use hashing for an abstract symbol-table implementation, the first step is to extend the abstract type interface to include a <tt>hash</tt> operation that maps keys into nonnegative integers less than <tt>M</tt>, the table size. The direct implementation</p>
<div class="docText"><pre>inline int hash(Key v, int M)
  { return (int) M*(v-s)[/](t-s); }</pre></div><br />
<p class="docText">does the job for floating-point keys between the values s and t; for integer keys, we can simply return <tt>v % M</tt>. If <span class="docEmphasis">M</span> is not prime, the hash function might return</p>
<div class="docText"><pre>(int) (.616161 * (float) v) % M</pre></div><br />
<p class="docText">or the result of a similar integer computation such as</p>
<div class="docText"><pre>(16161 * (unsigned) v) % M.</pre></div><br />
<p class="docText">All of these functions, including <a class="docLink" href="#ch14ex01">Program 14.1</a> for string keys, are venerable ones that usually spread out the keys and have served programmers well for years. The universal method of <a class="docLink" href="#ch14ex02">Program 14.2</a> is a distinct improvement for string keys that provides random hash values at little extra cost, and we can craft similar randomized methods for integer keys (see <a class="docLink" href="#ch14qa1q1">Exercise 14.1</a>).</p>
<p class="docText">Universal hashing could prove to be much slower than simpler methods in a given application, because doing two arithmetic operations for each character of the key could be overly time-consuming for long keys. To respond to this objection, we can process the key in bigger pieces. Indeed, we may as well use the largest pieces that can fit into a machine word, as in elementary modular hashing. As we discussed in detail previously, an operation of this kind can be difficult or can require special loopholes in some strongly typed high-level languages, but it can be inexpensive or require absolutely no work in C++ if we use casting among appropriate data-representation formats. These factors are important to consider in many situations because the computation <a name="iddle1572"></a><a name="iddle1587"></a><a name="iddle2227"></a>of the hash function might be in the inner loop, so, by speeding up the hash function, we might speed up the whole computation.</p>
<p class="docText">Despite the evidence in favor of these methods, care is required in implementing them, for two reasons. First, we have to be vigilant to avoid bugs when converting among types and using arithmetic functions on various different machine representations of keys. Such operations are notorious sources of error, particularly when a program is converted from an old machine to a new one with a different number of bits per word or with other precision differences. Second, the hash-function computation is likely to fall in the inner loop in many applications, and its running time may well dominate the total running time. In such cases, it is important to be sure that it reduces to efficient machine code. Such operations are notorious sources of inefficiency&mdash;for example, the difference in running time between the simple modular method and the version where we multiply by 0.61616 first can be startling on a machine with slow hardware or software for floating-point operations. The fastest method of all, for many machines, is to make <span class="docEmphasis">M</span> a power of 2, and to use the hash function</p>
<div class="docText"><pre>inline int hash(Key v, int M)
  { return v &amp; (M-1); }</pre></div><br />
<p class="docText">This function uses only the least-significant bits of the keys, but the bitwise <span class="docEmphasis">and</span> operation may be sufficiently faster than integer division to offset any ill effects from poor key dispersion.</p>
<p class="docText">A bug that typically arises in hashing implementations is for the hash function always to return the same value, perhaps because an intended type conversion did not take place properly. Such a bug is called a <span class="docEmphasis">performance</span> bug because a program using such a hash function is likely to run correctly, but to be extremely slow (because it was designed to be efficient only when the hash values are well dispersed). The one-line implementations of these functions are so easy to test that we are well-advised to check how well they perform for the types of keys that are to be encountered for any particular symbol-table implementation.</p>
<p class="docText">We can use a <span class="docEmphasis">x<sup>2</sup></span> statistic to test the hypothesis that a hash function produces random values (see <a class="docLink" href="#ch14qa1q5">Exercise 14.5</a>), but this requirement is perhaps too stringent. Indeed, we might be happy if the hash function produces each value the same number of times, which corresponds to a <span class="docEmphasis">x<sup>2</sup></span> statistic that is equal to 0, and is decidedly not random. Still, we should be suspicious of huge <span class="docEmphasis">x<sup>2</sup></span> statistics. In practice, it probably suffices to use a test that the values are sufficiently well-spread that no value dominates (see <a class="docLink" href="#ch14qa1q15">Exercise 14.15</a>). In the same spirit, a well-engineered implementation of a symbol-table implementation based on universal hashing might occasionally check that hash values are not poorly dispersed. The client might be informed that <span class="docEmphasis">either</span> a low-probability event has happened <span class="docEmphasis">or</span> there is a bug in the hash function. This kind of check would be a wise addition to any practical randomized algorithm.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa1q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">14.1</span> Using the <tt>digit</tt> abstraction from <a class="docLink" href="ch10.html#ch10">Chapter 10</a> to treat a machine word as a sequence of bytes, implement a randomized hash function for keys represented as bits in machine words.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa1q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.2</span> Check whether there is any execution-time overhead in converting from a 4-byte key to a 32-bit integer in your programming environment.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa1q3"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">14.3</span> Develop a hash function for string keys based on the idea of loading 4 bytes at a time, then performing arithmetic operations on 32 bits at a time. Compare the time required for this function with the times for <a class="docLink" href="#ch14ex01">Program 14.1</a> for 4-, 8-, 16-, and 32-byte keys.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa1q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.4</span> Write a program to find values of a and <span class="docEmphasis">M</span>, with <span class="docEmphasis">M</span> as small as possible, such that the hash function <tt>a*x % M</tt> produces distinct values (no collisions) for the keys in <a class="docLink" href="#ch14fig02">Figure 14.2</a>. The result is an example of a<span class="docEmphasis">perfect hash function</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa1q5"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">14.5</span> Write a program to compute the <span class="docEmphasis">x<sup>2</sup></span> statistic for the hash values of <span class="docEmphasis">N</span> keys with table size <span class="docEmphasis">M</span>. This number is defined by the equation 
<img border="0" alt="" width="180" height="43" src="596equ01.jpg" />
where <span class="docEmphasis">fi</span> is the number of keys with hash value <span class="docEmphasis">i</span>. If the hash values are random, this statistic, for <span class="docEmphasis">N</span> &gt; c<span class="docEmphasis">M</span>, should be <span class="docEmphasis">M</span>
<img border="0" alt="" width="50" height="12" src="596inlineequ01.jpg" /> with probability 1&ndash;1/<span class="docEmphasis">c</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa1q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.6</span> Use your program from <a class="docLink" href="#ch14qa1q5">Exercise 14.5</a> to evaluate the hash function 618033*x % 10000 for keys that are random positive integers less than 10<sup>6</sup>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa1q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.7</span> Use your program from <a class="docLink" href="#ch14qa1q5">Exercise 14.5</a> to evaluate the hash function in <a class="docLink" href="#ch14ex01">Program 14.1</a> for distinct string keys taken from some large file on your system, such as a dictionary.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa1q8"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">14.8</span> Suppose that keys are <span class="docEmphasis">t</span>-bit integers. For a modular hash function with prime <span class="docEmphasis">M</span>, prove that each key bit has the property that there exist two keys differing only in that bit with different hash values.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa1q9"></a><b></b></td><td><p class="docText"><a name="iddle1597"></a><a name="iddle1795"></a><span class="docEmphStrong">14.9</span> Consider the idea of implementing modular hashing for integer keys with the code <tt>(a*x) % M</tt>, where a is an arbitrary fixed prime. Does this change mix up the bits sufficiently well that you can use nonprime <span class="docEmphasis">M</span>?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa1q10"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.10</span> Prove that (((<span class="docEmphasis">ax</span>) mod <span class="docEmphasis">M</span>) + <span class="docEmphasis">b</span>) mod <span class="docEmphasis">M</span> = (<span class="docEmphasis">ax</span> + <span class="docEmphasis">b</span>) mod <span class="docEmphasis">M</span>, assuming that <span class="docEmphasis">a</span>, <span class="docEmphasis">b</span>, <span class="docEmphasis">x</span>, and <span class="docEmphasis">M</span> are all nonnegative integers.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa1q11"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">14.11</span> If you use the words from a text file, such as a book, in <a class="docLink" href="#ch14qa1q7">Exercise 14.7</a>, you are unlikely to get a good <span class="docEmphasis">x</span><sup>2</sup> statistic. Explain why this assertion is true.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa1q12"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.12</span> Use your program from <a class="docLink" href="#ch14qa1q5">Exercise 14.5</a> to evaluate the hash function <tt>97*x % M</tt>, for all table sizes between 100 and 200, using 10<sup>3</sup> random positive integers less than 10<sup>6</sup> as keys.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa1q13"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.13</span> Use your program from <a class="docLink" href="#ch14qa1q5">Exercise 14.5</a> to evaluate the hash function <tt>97*x % M</tt>, for all table sizes between 100 and 200, using the integers between 10<sup>2</sup> and 10<sup>3</sup> as keys.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa1q14"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.14</span> Use your program from <a class="docLink" href="#ch14qa1q5">Exercise 14.5</a> to evaluate the hash function <tt>100*x % M</tt>, for all table sizes between 100 and 200, using 10<sup>3</sup> random positive integers less than 10<sup>6</sup> as keys.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa1q15"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.15</span> Do <a class="docLink" href="#ch14qa1q12">Exercises 14.12</a> and <a class="docLink" href="#ch14qa1q14">14.14</a>, but use the simpler criterion of rejecting hash functions that produce any value more than 3<span class="docEmphasis">N/M</span> times.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch14.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch14lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>