<html><head><title>7.6. Duplicate Keys</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch07lev1sec5.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch07lev1sec7.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch07lev1sec6"></a>
<h3 id="title-IDAKUMWD" class="docSection1Title">7.6. Duplicate Keys</h3>
<p class="docText"><a name="iddle1136"></a><a name="iddle1357"></a><a name="iddle1394"></a><a name="iddle1403"></a><a name="iddle1662"></a><a name="iddle1846"></a><a name="iddle2037"></a><a name="iddle2065"></a><a name="iddle2168"></a>Files with large numbers of duplicate sort keys arise frequently in applications. For example, we might wish to sort a large personnel file by year of birth, or even to use a sort to separate females from males.</p>
<p class="docText">When there are many duplicate keys present in the file to be sorted, the quicksort implementations that we have considered do not have unacceptably poor performance, but they can be substantially improved. For example, a file that consists solely of keys that are equal (just one value) does not need to be processed further, but our implementations so far keep partitioning down to small subfiles, no matter how big the file is (see <a class="docLink" href="ch07lev1sec2.html#ch07qa2q3">Exercise 7.8</a>). In a situation where there are large numbers of duplicate keys in the input file, the recursive nature of quicksort ensures that subfiles consisting solely of items with a single key value will occur often, so there is potential for significant improvement.</p>
<p class="docText">One straightforward idea is to partition the file into <span class="docEmphasis">three</span> parts, one each for keys smaller than, equal to, and larger than the partitioning element:</p>
<p class="docText"><img border="0" alt="" width="450" height="54" src="336fig01.gif" /></p>
<p class="docText">Accomplishing this partitioning is more complicated than the two-way partitioning that we have been using, and various different methods have been suggested for the task. It was a classical programming exercise popularized by Dijkstra as the <span class="docEmphasis">Dutch National Flag problem</span>, because the three possible key categories might correspond to the three colors on the flag (<span class="docEmphasis">see reference section</span>). For quicksort, we add the constraint that a single pass through the file must do the job&mdash;an algorithm that involves two passes through the data would slow down quicksort by a factor of two, even if there are no duplicate keys at all.</p>
<p class="docText">A clever method invented by Bentley and McIlroy in 1993 for three-way partitioning works by modifying the standard partitioning scheme as follows: Keep keys equal to the partitioning element that are encountered in the left subfile at the left end of the file, and keep keys equal to the partitioning element that are encountered in the right subfile at the right end of the file. During the partitioning process, we maintain the following situation:
</p><p class="docText"><img border="0" alt="" width="495" height="60" src="337fig01.gif" /></p>
<p class="docText">Then, when the pointers cross and the precise location for the equal keys is known, we swap into position all the items with keys equal to the partitioning element. This scheme does not quite meet the requirement that three-way partitioning be accomplished in one pass through the file, but the extra overhead for duplicate keys is proportional to only the number of duplicate keys found. This fact has two implications: First, the method works well even if there are no duplicate keys, since there is no extra overhead. Second, the method is linear time when there is only a constant number of key values: Each partitioning phase removes from the sort all the keys with the same value as the partitioning element, so each key can be involved in at most a constant number of partitions.</p>
<p class="docText"><a class="docLink" href="#ch07fig12">Figure 7.12</a> illustrates the three-way partitioning algorithm on a sample file, and <a class="docLink" href="#ch07ex08">Program 7.5</a> is a quicksort implementation based on the method. The implementation requires the addition of just two <tt>if</tt> statements in the exchange loop, and just two <tt>for</tt> loops to complete partitioning by putting the keys equal to the partitioning element into position. It seems to require less code than other alternatives for maintaining three partitions. More important, it not only handles duplicate keys in as efficient a manner as possible, but also incurs a minimal amount of extra overhead in the case that there are no duplicate keys.</p>
<a name="ch07fig12"></a><p><center>
<h5 class="docFigureTitle">Figure 7.12. Three-way partitioning</h5>
<h5></h5><h5></h5></center></p><p class="docText">This diagram depicts the process of putting all keys equal to the partitioning element into position. As in <a class="docLink" href="ch07lev1sec1.html#ch07fig02">Figure 7.2</a>, we scan from the left to find an element that is not smaller than the partitioning element and from the right to find an element that is not larger than the partitioning element, then exchange them. If the element on the left after the exchange is equal to the partitioning element, we exchange it to the left end of the array; we proceed similarly on the right. When the pointers cross, we put the partitioning element into position as before <span class="docEmphasis">(next-to-bottom line)</span>, then exchange all the keys equal to it into position on either side of it <span class="docEmphasis">(bottom line)</span>.</p>
<p class="docText">
<img border="0" alt="" width="175" height="198" src="07fig12.gif" /></p>
<br />
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa8q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">7.34</span> Explain what happens when <a class="docLink" href="#ch07ex08">Program 7.5</a> is run on a randomly ordered file with (<span class="docEmphasis">i</span>) two distinct key values, and (<span class="docEmphasis">ii</span>) three distinct key values.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa8q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">7.35</span> Modify <a class="docLink" href="ch07lev1sec1.html#ch07ex01">Program 7.1</a> to <tt>return</tt> if all keys in the subfile are equal. Compare the performance of your program to <a class="docLink" href="ch07lev1sec1.html#ch07ex01">Program 7.1</a> for large random files with keys having <tt>t</tt> distinct values for <span class="docEmphasis">t</span> = 2, 5, and 10.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa8q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">7.36</span> Suppose that we scan over keys equal to the partitioning element in <a class="docLink" href="ch07lev1sec1.html#ch07ex02">Program 7.2</a> instead of stopping the scans when we encounter them. Show that the running time of <a class="docLink" href="ch07lev1sec1.html#ch07ex01">Program 7.1</a> would be quadratic in this case.</p></td></tr></table></p>
<p class="docText"></p><a name="ch07ex08"></a><h5 id="title-IDAD3MWD" class="docExampleTitle">Program 7.5. Quicksort with three-way partitioning</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This program is based on partitioning the array into three parts: elements smaller than the partitioning element (in <tt>a[l]</tt>, <tt>...</tt>, <tt>a[j])</tt>; elements equal to the partitioning element (in <tt>a[j+1]</tt>, <tt>...</tt>, <tt>a[i-1])</tt>; and elements larger than the partitioning element (in <tt>a[i], ..., a[r])</tt>. Then the sort can be completed with two recursive calls.</p>
<p class="docText">To accomplish the objective, the program keeps keys equal to the partitioning element on the left between <tt>l</tt> and <tt>p</tt> and on the right between <tt>q</tt> and <tt>r</tt>. In the partitioning loop, after the scan pointers stop and the items at <tt>i</tt> and <tt>j</tt> are exchanged, it checks each of those items to see whether it is equal to the partitioning element. If the one now on the left is equal to the partitioning element, it is exchanged into the left part of the array; if one now on the right is equal to the partitioning element, it is exchanged into the right part of the array.</p>
<p class="docText">After the pointers cross, the elements equal to the partitioning element are exchanged from the ends of the array into position. Then those keys can be excluded from the subfiles for the recursive calls.</p>
<div class="docText"><pre>    template &lt;class Item&gt;
    int operator==(const Item &amp;A, const Item &amp;B)
      { return !less(A, B) &amp;&amp; !less(B, A); }
    template &lt;class Item&gt;
    void quicksort(Item a[], int l, int r)
      { int k; Item v = a[r];
        if (r &lt;= l) return;
        int i = l-1, j = r, p = l-1, q = r;
        for (;;)
          {
           while (a[++i] &lt; v) ;
           while (v &lt; a[--j]) if (j == l) break;
           if (i &gt;= j) break;
           exch(a[i],a[j]);
           if (a[i] == v) { p++; exch(a[p],a[i]); }
           if (v == a[j]) { q--; exch(a[q],a[j]); }
       }
     exch(a[i], a[r]); j = i-1; i = i+1;
     for (k = l ; k &lt;= p; k++, j--) exch(a[k],a[j]);
     for (k = r-1; k &gt;= q; k--, i++) exch(a[k],a[i]);
     quicksort(a, l, j);
     quicksort(a, i, r);
   }</pre></div><br />
</td></tr></table></p>
<p><table border="0" cellspacing="16" cellpadding="0"><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa9q1"></a><b></b></td><td><p class="docText"><a name="iddle1526"></a><a name="iddle1723"></a><a name="iddle1774"></a><a name="iddle2441"></a><a name="iddle2449"></a><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">7.37</span> Prove that the running time of the program in <a class="docLink" href="#ch07qa8q3">Exercise 7.36</a> is quadratic for all files with <span class="docEmphasis">O</span>(1) distinct key values.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa9q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">7.38</span> Write a program to determine the number of distinct keys that occur in a file. Use your program to count the distinct keys in random files of <span class="docEmphasis">N</span> integers in the range 0 to <span class="docEmphasis">M</span> - 1, for <span class="docEmphasis">M</span> = 10, 100, and 1000, and for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch07lev1sec5.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch07lev1sec7.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>