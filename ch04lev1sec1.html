<html><head><title>4.1. Abstract Objects and Collections of Objects</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch04.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch04lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch04lev1sec1"></a>
<h3 id="title-IDATMHJD" class="docSection1Title">4.1. Abstract Objects and Collections of Objects</h3>
<p class="docText">The data structures that we use in applications often contain a great deal of information of various types, and certain pieces of information may belong to multiple independent data structures. For example, a file of personnel data may contain records with names, addresses, and various other pieces of information about employees; and each record may need to belong to one data structure for searching for particular employees, to another data structure for answering statistical queries, and so forth.</p>
<p class="docText">Despite this diversity and complexity, a large class of computing applications involve generic manipulation of data objects, and need access to the information associated with them for a limited number of specific reasons. Many of the manipulations that are required are a natural outgrowth of basic computational procedures, so they are needed in a broad variety of applications. Many of the fundamental algorithms that we consider in this book can be applied effectively to the task of building a layer of abstraction that can provide client programs with the ability to perform such manipulations efficiently. Thus, we shall consider in detail numerous ADTs that are associated with such manipulations. They define various operations on collections of abstract objects, independent of the type of the object.</p>
<p class="docText">We have discussed the use of simple data types in order to write code that does not depend on object types, in <a class="docLink" href="ch03lev1sec1.html#ch03lev1sec1">Section 3.1</a>, where we used <tt>typedef</tt> to specify the type of our data items. This approach allows us to use the same code for, say, integers and floating-point numbers, just by changing the <tt>typedef</tt>. With pointers, the object types can be arbitrarily complex. When we use this approach, we often find ourselves making implicit assumptions about the operations that we perform on the objects (for example, in <a class="docLink" href="ch03lev1sec1.html#ch03ex03">Program 3.2</a> we assume that addition, multiplication, and conversion to <tt>float</tt> are defined for objects of type <tt>Number</tt>), and we are not hiding the data representation from our client programs. ADTs provide a way for us to make explicit any assumptions about the operations that we perform on data objects.</p>
<p class="docText">We will consider several examples of the use of C++ classes for building ADTs for generic data objects through the remainder of this chapter. We shall see how to build an ADT for objects of a generic type <tt>Item</tt> so that we can write client programs where we use <tt>Item</tt> in the same way that we use built-in types. When appropriate, we explicitly define in the <tt>Item</tt> class the operations that our algorithms need to perform on generic objects. We specify all of these characteristics of our objects without providing any information about the data representation to client programs.</p>
<p class="docText"><a name="iddle1302"></a><a name="iddle1307"></a><a name="iddle1352"></a><a name="iddle1540"></a><a name="iddle2155"></a><a name="iddle2509"></a>Once we have implemented an <tt>Item</tt> class for our generic objects (or chosen to use a built-in class), we will use the C++ <span class="docEmphasis">template</span> mechanism to write code that is generic with respect to types. For example, we can define an exchange operation for generic items, as follows:</p>
<div class="docText"><pre>template &lt;class Item&gt;
  void exch(Item &amp;x, Item &amp;y)
    { Item t = x; x = y; y = t; }</pre></div><br />
<p class="docText">We can implement other simple operations on items in a similar manner. With templates, we can specify families of classes, one for each type of item.</p>
<p class="docText">Having settled on a generic-object class, we can move on to consider <span class="docEmphasis">collections</span> of objects. Many of the data structures and algorithms that we consider in this book are used to implement fundamental ADTs comprising collections of abstract objects, built up from the following two operations:</p>
<ul><li><p class="docList"><span class="docEmphasis">insert</span> a new object into the collection.</p></li><li><p class="docList"><span class="docEmphasis">remove</span> an object from the collection.</p></li></ul>
<p class="docText">We refer to such ADTs as <span class="docEmphasis">generalized queues</span>. For convenience, we also typically include explicit operations to <span class="docEmphasis">construct</span> the data structure (constructors) and to <span class="docEmphasis">count</span> the number of objects in the data structure (or just to test whether it is empty). We also might need operations to <span class="docEmphasis">destroy</span> the data structure (destructors) or to <span class="docEmphasis">copy</span> it (copy constructors); we shall discuss such operations in <a class="docLink" href="ch04lev1sec8.html#ch04lev1sec8">Section 4.8</a>.</p>
<p class="docText">When we <span class="docEmphasis">insert</span> an object, our intent is clear, but which object do we get when we <span class="docEmphasis">remove</span> an object from the collection? Different ADTs for collections of objects are characterized by different criteria for deciding which object to remove for the <span class="docEmphasis">remove</span> operation and by different conventions associated with the various criteria. Moreover, we shall encounter a number of other natural operations beyond <span class="docEmphasis">insert</span> and <span class="docEmphasis">remove</span>. Many of the algorithms and data structures that we consider in this book were designed to support efficient implementation of various subsets of these operations, for various different <span class="docEmphasis">remove</span> criteria and other conventions. These ADTs are conceptually simple, used widely, and lie at the core of a great many computational tasks, so they deserve the careful attention that we pay them.</p>
<p class="docText">We consider several of these fundamental data structures, their properties, and examples of their application while at the same time using them as examples to illustrate the basic mechanisms that we use to <a name="iddle1264"></a><a name="iddle1306"></a><a name="iddle1479"></a><a name="iddle2129"></a><a name="iddle2153"></a><a name="iddle2432"></a>develop ADTs. In <a class="docLink" href="ch04lev1sec2.html#ch04lev1sec2">Section 4.2</a>, we consider the <span class="docEmphasis">pushdown stack</span>, where the rule for removing an object is to remove the one that was most recently inserted. We consider applications of stacks in <a class="docLink" href="ch04lev1sec3.html#ch04lev1sec3">Section 4.3</a>, and implementations in <a class="docLink" href="ch04lev1sec4.html#ch04lev1sec4">Section 4.4</a>, including a specific approach to keeping the applications and implementations separate. Following our discussion of stacks, we step back to consider the process of creating a new ADT, in the context of the union&ndash;find abstraction for the connectivity problem that we considered in <a class="docLink" href="ch01.html#ch01">Chapter 1</a>. Following that, we return to collections of abstract objects, to consider FIFO queues and generalized queues (which differ from stacks on the abstract level only in that they involve using a different rule to remove items) and generalized queues where we disallow duplicate items.</p>
<p class="docText">As we saw in <a class="docLink" href="ch03.html#ch03">Chapter 3</a>, arrays and linked lists provide basic mechanisms that allow us to <span class="docEmphasis">insert</span> and <span class="docEmphasis">remove</span> specified items. Indeed, linked lists and arrays are the underlying data structures for several of the implementations of generalized queues that we consider. As we know, the cost of insertion and deletion is dependent on the specific structure that we use and the specific item being inserted or removed. For a given ADT, our challenge is to choose a data structure that allows us to perform the required operations efficiently. In this chapter, we examine in detail several examples of ADTs for which linked lists and arrays provide appropriate solutions. ADTs that support more powerful operations require more sophisticated implementations, which are the prime impetus for many of the algorithms that we consider in this book.</p>
<p class="docText">Data types comprising collections of abstract objects (generalized queues) are a central object of study in computer science because they directly support a fundamental paradigm of computation. For a great many computations, we find ourselves in the position of having many objects with which to work, but being able to process only one object at a time. Therefore, we need to save the others while processing that one. This processing might involve examining some of the objects already saved away or adding more to the collection, but operations of saving the objects away and retrieving them according to some criterion are the basis of the computation. Many classical data structures and algorithms fit this mold, as we shall see.</p>
<p class="docText">In C++, classes that implement collections of abstract objects are called <span class="docEmphasis">container classes</span>. Some of the data structures that we shall <a name="iddle1018"></a><a name="iddle2130"></a><a name="iddle2142"></a>discuss are implemented in the C++ library or its template-based extension (the Standard Template Library), but, to avoid confusion, we refer to these classes rarely, and develop the material in this book from first principles.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa2q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">4.6</span> Give a class definition for <tt>Item</tt> that overloads the <tt>==</tt> operator to support equality testing among floating-point numbers. Consider two floating-point numbers to be equal if the absolute value of their difference divided by the larger (in absolute value) of the two numbers is less than <tt>10<sup>&ndash;6</sup></tt></p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa2q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">4.7</span> Give a class definition for <tt>Item</tt>, and overload the <tt>==</tt> and <tt>&lt;&lt;</tt> operators, so that they might be used in programs that process playing cards.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa2q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.8</span> Rewrite <a class="docLink" href="ch03lev1sec1.html#ch03ex02">Program 3.1</a> to use a generic object class <tt>Item</tt>. Your program should work for any type of <tt>Item</tt> that can be output via <tt>&lt;&lt;</tt>, generated randomly via a static member function <tt>rand()</tt>, and for which <tt>+</tt> and <tt>/</tt> are defined.</p>
</td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch04.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch04lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>