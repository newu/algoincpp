<html><head><title>10.3. MSD Radix Sort</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch10lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch10lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch10lev1sec3"></a>
<h3 id="643999-958" class="docSection1Title">10.3. MSD Radix Sort</h3>
<p class="docText">Using just 1 bit in radix quicksort amounts to treating keys as radix-2 (binary) numbers and considering the most significant digits first. Generalizing, suppose that we wish to sort radix-<span class="docEmphasis">R</span> numbers by considering the most significant bytes first. Doing so requires partitioning the array into <span class="docEmphasis">R</span>, rather than just two, different parts. Traditionally we refer to the partitions as <span class="docEmphasis">bins</span> or <span class="docEmphasis">buckets</span> and think of the algorithm as using a group of <span class="docEmphasis">R</span> bins, one for each possible value of the first digit, as indicated in the following diagram:</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="500" height="71" src="427equ01.jpg" /></p>
<p class="docText">We pass through the keys, distributing them among the bins, then recursively sort the bin contents on keys with 1 fewer byte.</p>
<p class="docText"><a name="iddle2036"></a><a class="docLink" href="#ch10fig06">Figure 10.6</a> shows an example of MSD radix sorting on a random permutation of integers. By contrast with binary quicksort, this algorithm can bring a file nearly into order rather quickly, even on the first partition, if the radix is sufficiently large.</p>
<a name="ch10fig06"></a><p><center>
<h5 class="docFigureTitle">Figure 10.6. Dynamic characteristics of MSD radix sort</h5>
<h5></h5><h5></h5></center></p><p class="docText">Just one stage of MSD radix sort can nearly complete a sort task, as shown in this example with random 8-bit integers. The first stage of an MSD sort, on the leading 2 bits (left), divides the file into four subfiles. The next stage divides each of those into four subfiles. An MSD sort on the leading 3 bits (right) divides the file into eight subfiles, in just one distribution-counting pass. At the next level, each of those subfiles is divided into eight parts, leaving just a few elements in each.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="150" height="109" src="10fig06.gif" /></p>
<br />
<p class="docText">As mentioned in <a class="docLink" href="ch10lev1sec2.html#ch10lev1sec2">Section 10.2</a>, one of the most attractive features of radix sorting is the intuitive and direct manner in which it adapts to sorting applications where keys are strings of characters. This observation is especially true in C++ and other programming environments that provide direct support for processing strings. For MSD radix sorting, we simply use a radix corresponding to the byte size. To extract a digit, we load a byte; to move to the next digit, we increment a string pointer. For the moment, we consider fixed-length keys; we shall see shortly that variable-length string keys are easy to handle with the same basic mechanisms.</p>
<p class="docText"><a class="docLink" href="#ch10fig07">Figure 10.7</a> shows an example of MSD radix sorting on three-letter words. For simplicity, this figure assumes that the radix is 26, although in most applications we would use a larger radix corresponding to the character encodings. First, the words are partitioned so all those that start with a appear before those that start with b, and so forth. Then, the words that start with a are sorted recursively, then the words that start with b are sorted, and so forth. As is obvious from the example, most of the work in the sort lies in partitioning on the first letter; the subfiles that result from the first partition are small.</p>
<a name="ch10fig07"></a><p><center>
<h5 class="docFigureTitle">Figure 10.7. MSD radix sort example</h5>
<h5></h5><h5></h5></center></p><p class="docText">We divide the words into 26 bins according to the first letter. Then, we sort all the bins by the same method, starting at the second letter.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="125" height="654" src="10fig07.gif" /></p>
<br />
<p class="docText">As we saw for quicksort in <a class="docLink" href="ch07.html#ch07">Chapter 7</a> and <a class="docLink" href="ch10lev1sec2.html#ch10lev1sec2">Section 10.2</a> and for mergesort in <a class="docLink" href="ch08.html#ch08">Chapter 8</a>, we can improve the performance of most recursive programs by using a simple algorithm for small cases. Using a different method for small subfiles (bins containing a small number of elements) is essential for radix sorting, because there are so many of them! Moreover, we can tune the algorithm by adjusting the value of <span class="docEmphasis">R</span> because there is a clear tradeoff: If <span class="docEmphasis">R</span> is too large, the cost of initializing and checking the bins dominates; if it is too small, the method does not take advantage of the potential gain available by subdividing into as many pieces as possible. We return to these issues at the end of this section and in <a class="docLink" href="ch10lev1sec6.html#ch10lev1sec6">Section 10.6</a>.</p>
<p class="docText">To implement MSD radix sort, we need to generalize the methods for partitioning an array that we studied in relation to quicksort implementations in <a class="docLink" href="ch07.html#ch07">Chapter 7</a>. These methods, which are based on pointers that start from the two ends of the array and meet in the middle, <a name="iddle1739"></a><a name="iddle1872"></a><a name="iddle2196"></a><a name="iddle2204"></a>work well when there are just two or three partitions, but do not immediately generalize. Fortunately, the <span class="docEmphasis">key-indexed counting</span> method from <a class="docLink" href="ch06.html#ch06">Chapter 6</a> for sorting files with key values in a small range suits our needs perfectly. We use a table of counts and an auxiliary array; on a first pass through the array, we count the number of occurrences of each leading digit value. These counts tell us where the partitions will fall. Then, on a second pass through the array, we use the counts to move items to the appropriate position in the auxiliary array.</p>
<p class="docText"><a class="docLink" href="#ch10ex04">Program 10.2</a> implements this process. Its recursive structure generalizes quicksort's, so the same issues that we considered in <a class="docLink" href="ch07lev1sec3.html#ch07lev1sec3">Section 7.3</a> need to be addressed. Should we do the largest of the subfiles last to avoid excessive recursion depth? Probably not, because the recursion depth is limited by the length of the keys. Should we sort small subfiles with a simple method such as insertion sort? Certainly, because there are huge numbers of them.</p>
<p class="docText">To do the partitioning, <a class="docLink" href="#ch10ex04">Program 10.2</a> uses an auxiliary array of size equal to the size of the array to be sorted. Alternatively, we could choose to use in-place key-indexed counting (see <a class="docLink" href="#ch10qa3q4">Exercise 10.17</a> and <a class="docLink" href="#ch10qa3q5">10.18</a>). We need to pay particular attention to space, because the recursive calls might use excessive space for local variables. In <a class="docLink" href="#ch10ex04">Program 10.2</a>, the temporary buffer for moving keys (<tt>aux</tt>) can be global, but the array that holds the counts and the partition positions (<tt>count</tt>) must be local.</p>
<p class="docText">Extra space for the auxiliary array is not a major concern in many practical applications of radix sorting that involve long keys and records, because a pointer sort should be used for such data. Therefore, the extra space is for rearranging pointers, and is small compared to the space for the keys and records themselves (although still not insignificant). If space is available and speed is of the essence (a common situation when we use radix sorts), we can also eliminate the time required for the array copy by recursive argument switchery, in the same manner as we did for mergesort in <a class="docLink" href="ch10lev1sec4.html#ch10lev1sec4">Section 10.4</a>.</p>
<p class="docText">For random keys, the number of keys in each bin (the size of the subfiles) after the first pass will be <span class="docEmphasis">N/R</span> on the average. In practice, the keys may not be random (for example, when the keys are strings representing English-language words, we know that few start with <tt>x</tt> and none start with <tt>xx</tt>), so many bins will be empty and some of the nonempty ones will have many more keys than others do (see <a name="iddle1811"></a><a class="docLink" href="#ch10fig08">Figure 10.8</a>). Despite this effect, the multiway partitioning process will generally be effective in dividing a large file to be sorted into many smaller ones.</p>
<a name="ch10fig08"></a><p><center>
<h5 class="docFigureTitle">Figure 10.8. MSD radix sort example (with empty bins)</h5>
<h5></h5><h5></h5></center></p><p class="docText">Excessive numbers of empty bins are encountered, even in the second stage, for small files.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="65" height="622" src="10fig08.gif" /></p>
<br />
<a name="ch10ex04"></a><h5 id="title-IDAUAT5H" class="docExampleTitle">Program 10.2. MSD radix sort</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We derive this program from Program 8.17 (key-indexed-counting sort) by changing key references to key-digit references, and adding a loop at the end that does recursive calls for each subfile of keys starting with the same digit. For variable-length keys terminated by 0 digits (such as C-style strings), omit the first <tt>if</tt> statement and the first recursive call. This implementation uses an auxiliary array (<tt>aux</tt>) that is big enough to hold a copy of the input.</p>
<div class="docText"><pre>#define bin(A) l+count[A]
 template &lt;class Item&gt;
 void radixMSD(Item a[], int l, int r, int d)
   { int i, j, count[R+1];
     static Item aux[maxN];
     if (d &gt; bytesword) return;
     if (r-l &lt;= M) { insertion(a, l, r); return; }
     for (j = 0; j &lt; R; j++) count[j] = 0;
     for (i = l; i &lt;= r; i++)
       count[digit(a[i], d) + 1]++;
     for (j = 1; j &lt; R; j++)
       count[j] += count[j-1];
     for (i = l; i &lt;= r; i++)
       aux[l+count[digit(a[i], d)]++] = a[i];
     for (i = l; i &lt;= r; i++) a[i] = aux[i];
     radixMSD(a, l, bin(0)-1, d+1);
     for (j = 0; j &lt; R-1; j++)
       radixMSD(a, bin(j), bin(j+1)-1, d+1);
 }</pre></div><br />
</td></tr></table></p>
<p class="docText">Another natural way to implement MSD radix sorting is to use linked lists. We keep one linked list for each bin: On a first pass through the items to be sorted, we insert each item into the appropriate linked list, according to its leading digit value. Then, we sort the sublists, and stitch together all the linked lists to make a sorted whole. This approach presents a challenging programming exercise <a name="iddle2208"></a><a name="iddle2461"></a>(see <a class="docLink" href="ch10lev1sec5.html#ch10qa5q5">Exercise 10.36</a>). Stitching together the lists requires keeping track of the beginning and the end of all the lists, and, of course, many of the lists are likely to be empty.</p>
<p class="docText">To achieve good performance using radix sort for a particular application, we need to limit the number of empty bins encountered by choosing appropriate values both for the radix size and for the cutoff for small subfiles. As a concrete example, suppose that 2<sup>24</sup> (about sixteen million) 64-bit integers are to be sorted. To keep the table of counts small by comparison with the file size, we might choose a radix of <span class="docEmphasis">R</span> = 2<sup>16</sup>, corresponding to checking 16 bits of the keys. But after the first partition, the average file size is only 2<sup>8</sup>, and a radix of 2<sup>16</sup> for such small files is overkill. To make matters worse, there can be huge numbers of such files: about 2<sup>16</sup> of them in this case. For each of those 2<sup>16</sup> files, the sort sets 2<sup>16</sup> counters to zero, then checks that all but about 2<sup>8</sup> of them are nonzero, and so forth, for a cost of <span class="docEmphasis">at least</span> 2<sup>32</sup> arithmetic operations. <a class="docLink" href="#ch10ex04">Program 10.2</a>, which is implemented on the assumption that most bins are nonempty, does more than a few arithmetic operations for each empty bin (for example, it does recursive calls for all the empty bins), so its running time would be huge for this example. A more appropriate radix for the second level might be 2<sup>8</sup> or 2<sup>4</sup>. In short, we should be certain not to use large radices for small files in a MSD radix sort. We shall consider this point in detail in <a class="docLink" href="ch10lev1sec6.html#ch10lev1sec6">Section 10.6</a>, when we look carefully at the performance of the various methods.</p>
<p class="docText">If we set <span class="docEmphasis">R</span> = 256 and eliminate the recursive call for bin 0, then <a class="docLink" href="#ch10ex04">Program 10.2</a> is an effective way to sort C-style strings. If we know that the lengths of all the strings are less than a certain fixed length, we can set the variable <tt>bytesword</tt> to that length, or we can eliminate the test on <tt>bytesword</tt> to sort standard variable-length character strings. For sorting strings, we normally would implement the <tt>digit</tt> abstract operation as a single array reference, as we discussed in <a class="docLink" href="ch10lev1sec1.html#ch10lev1sec1">Section 10.1</a>. By adjusting <span class="docEmphasis">R</span> and <tt>bytesword</tt> (and testing their values), we can easily modify <a class="docLink" href="#ch10ex04">Program 10.2</a> to handle strings from nonstandard alphabets or in nonstandard formats involving length restrictions or other conventions.</p>
<p class="docText">String sorting again illustrates the importance of managing empty bins properly. <a class="docLink" href="#ch10fig08">Figure 10.8</a> shows the partitioning process for an example like <a class="docLink" href="#ch10fig07">Figure 10.7</a>, but with two-letter words and with the empty <a name="iddle1928"></a><a name="iddle2251"></a><a name="iddle2579"></a>bins shown explicitly. In this example, we radix sort two-letter words using radix 26, so there are 26 bins at every stage. In the first stage, there are not many empty bins; in the second stage, however, most bins are empty.</p>
<p class="docText">An MSD radix-sorting function divides the file on the first digit of the keys, then recursively calls itself for subfiles corresponding to each value. <a class="docLink" href="#ch10fig09">Figure 10.9</a> shows this recursive-call structure for MSD radix sorting for the example in <a class="docLink" href="#ch10fig08">Figure 10.8</a>. The call structure corresponds to a <span class="docEmphasis">multiway trie</span>, a direct generalization of the trie structure for binary quicksort in <a class="docLink" href="ch10lev1sec2.html#ch10fig04">Figure 10.4</a>. Each node corresponds to a recursive call on the MSD sort for some subfile. For example, the subtree of the root with root labeled o corresponds to sorting the subfile consisting of the three keys <tt>of</tt>, <tt>on</tt>, and <tt>or</tt>.</p>
<a name="ch10fig09"></a><p><center>
<h5 class="docFigureTitle">Figure 10.9. Recursive structure of MSD radix sort</h5>
<h5></h5><h5></h5></center></p><p class="docText">This tree corresponds to the operation of the recursive MSD radix sort in <a class="docLink" href="#ch10ex04">Program 10.2</a> on the two-letter MSD sorting example in <a class="docLink" href="#ch10fig08">Figure 10.8</a>. If the file size is 1 or 0, there are no recursive calls. Otherwise, there are 26 calls: one for each possible value of the current byte.</p><p class="docText"><div class="v1"><a target="_blank" href="10fig09_alt.gif">[View full size image]</a></div><img border="0" alt="" id="118095012104" width="500" height="60" src="10fig09.gif" /></p>
<br />
<p class="docText">These figures make obvious the presence of significant numbers of empty bins in MSD sorting with strings. In <a class="docLink" href="ch10lev1sec4.html#ch10lev1sec4">Section 10.4</a>, we study one way to cope with this problem; in <a class="docLink" href="ch15.html#ch15">Chapter 15</a>, we examine explicit uses of trie structures in string-processing applications. Generally, we work with compact representations of the trie structures that do not include the nodes corresponding to the empty bins and that have the labels moved from the edges to the nodes below, as illustrated in <a class="docLink" href="#ch10fig10">Figure 10.10</a>, the structure that corresponds to the recursive call structure (ignoring empty bins) for the three-letter MSD radix-sorting example of <a class="docLink" href="#ch10fig07">Figure 10.7</a>. For example, the subtree of the root with root labeled <span class="docEmphasis">j</span> corresponds to sorting the bin containing the four keys <tt>jam</tt>, <tt>jay</tt>, <tt>jot</tt>, and <tt>joy</tt>. We examine properties of such tries in detail in <a class="docLink" href="ch15.html#ch15">Chapter 15</a>.</p>
<a name="ch10fig10"></a><p><center>
<h5 class="docFigureTitle">Figure 10.10. Recursive structure of MSD radix sort (null subfiles ignored)</h5>
<h5></h5><h5></h5></center></p><p class="docText">This representation of the recursive structure of MSD radix sort is more compact than the one in <a class="docLink" href="#ch10fig09">Figure 10.9</a>. Each node in this tree is labeled with the value of the (i - <span class="docEmphasis">1</span>)st digit of certain keys, where i is the distance from the node to the root. Each path from the root to the bottom of the tree corresponds to a key; putting the node labels together gives the key. This tree corresponds to the three-letter MSD sorting example in <a class="docLink" href="#ch10fig07">Figure 10.7</a>.</p><p class="docText"><div class="v1"><a target="_blank" href="10fig10_alt.gif">[View full size image]</a></div><img border="0" alt="" id="118095012104" width="500" height="79" src="10fig10.gif" /></p>
<br />
<p class="docText">The main challenge in getting maximum efficiency in a practical MSD radix sort for keys that are long strings is to deal with lack of randomness in the data. Typically, keys may have long stretches of equal or unnecessary data, or parts of them might fall in only a narrow range. For example, an information-processing application for student data records might have keys with fields corresponding to graduation year (4 bytes, but one of four different values), state names <a name="iddle1227"></a><a name="iddle2194"></a>(perhaps 10 bytes, but one of 50 different values), and gender (1 byte with one of two given values), as well as to a person's name (more similar to random strings, but probably not short, with nonuniform letter distributions, and with trailing blanks in a fixed-length field). All these various restrictions lead to large numbers of empty bins during the MSD radix sort (see <a class="docLink" href="#ch10qa3q10">Exercise 10.23</a>).</p>
<p class="docText">One practical way to cope with this problem is to develop a more complex implementation of the abstract operation of accessing bytes that takes into account any specialized knowledge that we might have about the strings being sorted. Another method that is easy to implement, which is called the <span class="docEmphasis">bin-span heuristic</span>, is to keep track of the high and low ends of the range of nonempty bins during the counting phase, then to use only bins in that range (perhaps also including special cases for a few special key values, such as 0 or blank). This arrangement is attractive for the kind of situation described in the previous paragraph. For example, with radix-256 alphanumeric data, we might be working with numbers in one section of the keys and thus have only 10 nonempty bins corresponding to the digits, while we might be working with uppercase letters in another section of the keys and thus have only 26 nonempty bins corresponding to them.</p>
<p class="docText">There are various alternatives that we might try for extending the bin-span heuristic (<span class="docEmphasis">see reference section</span>). For example, we could consider keeping track of the nonempty bins in an auxiliary data structure, and only keep counters and do the recursive calls for those. Doing so (and even the bin-span heuristic itself) is probably overkill for this situation, however, because the cost savings is negligible unless the radix is huge or the file size is tiny, in which case we should be using a smaller radix or sorting the file with some other method. We might achieve some of the same cost savings that we could achieve by adjusting the radix or switching to a different method for small files by using an ad hoc method, but we could not do so as easily. In <a class="docLink" href="ch10lev1sec4.html#ch10lev1sec4">Section 10.4</a>, we shall consider yet another version of quicksort that does handle the empty-bin problem gracefully.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa3q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">10.14</span> Draw the compact trie strucure (with no empty bins and with keys in nodes, as in <a class="docLink" href="#ch10fig10">Figure 10.10</a>) corresponding to <a class="docLink" href="#ch10fig09">Figure 10.9</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa3q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">10.15</span> How many nodes are there in the full trie corresponding to <a class="docLink" href="#ch10fig10">Figure 10.10</a>?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa3q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">10.16</span> Show how the set of keys <tt>now is the time for all good people to come the aid of their party</tt> is partitioned with MSD radix sort.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa3q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">10.17</span> Write a program that does four-way partitioning in place, by counting the frequency of occurrence of each key as in key-indexed counting, then using a method like <a class="docLink" href="ch06lev1sec8.html#ch06ex27">Program 6.14</a> to move the keys.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa3q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">10.18</span> Write a program to solve the general <span class="docEmphasis">R</span>-way partitioning problem, using the method sketched in <a class="docLink" href="#ch10qa3q4">Exercise 10.17</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa3q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.19</span> Write a program that generates random 80-byte keys. Use this key generator to generate <span class="docEmphasis">N</span> random keys, then sort them with MSD radix sort, for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>. Instrument your program to print out the total number of key bytes examined for each sort.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa3q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">10.20</span> What is the rightmost key byte position that you would expect the program in <a class="docLink" href="#ch10qa3q6">Exercise 10.19</a> to access for each of the given values of <span class="docEmphasis">N</span>? If you have done that exercise, instrument your program to keep track of this quantity, and compare your theoretical result with empirical results.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa3q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.21</span> Write a key generator that generates keys by shuffling a random 80-byte sequence. Use your key generator to generate <span class="docEmphasis">N</span> random keys, then sort them with MSD radix sort, for <tt>N = 10</tt><sup>3</sup>, <tt>10</tt><sup>4</sup>, <tt>10</tt><sup>5</sup>, and <tt>10</tt><sup>6</sup>. Compare your performance results with those for the random case (see <a class="docLink" href="#ch10qa3q6">Exercise 10.19</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa3q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.22</span> What is the rightmost key byte position that you would expect the program in <a class="docLink" href="#ch10qa3q8">Exercise 10.21</a> to access for each value of <span class="docEmphasis">N</span>? If you have done that exercise, compare your theoretical result with empirical results from your program.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa3q10"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.23</span> Write a key generator that generates 30-byte random strings made up of three fields: a four-byte field with one of a set of 10 given strings; a 10-byte field with one of a set of 50 given strings; a 1-byte field with one of two given values; and a 15-byte field with random left-justified strings of letters equally likely to be four through 15 characters long. Use your key generator to generate <span class="docEmphasis">N</span> random keys, then sort them with MSD radix sort, for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>. Instrument your program to print out the total number of key bytes examined. Compare your performance results with those for the random case (see <a class="docLink" href="#ch10qa3q6">Exercise 10.19</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa3q11"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.24</span> Modify <a class="docLink" href="#ch10ex04">Program 10.2</a> to implement the bin-span heuristic. Test your program on the data of <a class="docLink" href="#ch10qa3q10">Exercise 10.23</a>.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch10lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch10lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>