<html><head><title>12.1. Symbol-Table Abstract Data Type</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch12lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch12lev1sec1"></a>
<h3 id="title-IDAKWBSE" class="docSection1Title">12.1. Symbol-Table Abstract Data Type</h3>
<p class="docText"><a name="iddle1020"></a><a name="iddle1859"></a><a name="iddle2478"></a><a name="iddle2486"></a>As with priority queues, we think of search algorithms as belonging to interfaces declaring a variety of generic operations that can be separated from particular implementations, so that we can easily substitute alternative implementations. The operations of interest include</p>
<ul><li><p class="docList"><span class="docEmphasis">Insert</span> a new item.</p></li><li><p class="docList"><span class="docEmphasis">Search</span> for an item (or items) having a given key.</p></li><li><p class="docList"><span class="docEmphasis">Remove</span> a specified item.</p></li><li><p class="docList"><span class="docEmphasis">Select</span> the <span class="docEmphasis">k</span>th largest item in a symbol table.</p></li><li><p class="docList"><span class="docEmphasis">Sort</span> the symbol table (show all the items in order of their keys).</p></li><li><p class="docList"><span class="docEmphasis">Join</span> two symbol tables.</p></li></ul>
<p class="docText">As we do with many data structures, we might also need to add standard <span class="docEmphasis">construct</span>, <span class="docEmphasis">test if empty</span>, and perhaps <span class="docEmphasis">destroy</span> and <span class="docEmphasis">copy</span> operations to this set. In addition, we might wish to consider various other practical modifications of the basic interface. For example, a <span class="docEmphasis">search-and-insert</span> operation is often attractive because, for many implementations, <a name="iddle1011"></a><a name="iddle1059"></a><a name="iddle1101"></a><a name="iddle1241"></a><a name="iddle1338"></a><a name="iddle1431"></a><a name="iddle1527"></a><a name="iddle1689"></a><a name="iddle1694"></a><a name="iddle1759"></a><a name="iddle1767"></a><a name="iddle1975"></a><a name="iddle1997"></a><a name="iddle2002"></a>the search for a key, even if unsuccessful, nevertheless gives precisely the information needed to insert a new item with that key.</p>
<p class="docText">We commonly use the term &quot;search algorithm&quot; to mean &quot;symbol-table ADT implementation,&quot; although the latter more properly implies defining and building an underlying data structure for the symbol table and implementing ADT operations in addition to search. Symbol tables are so important to so many computer applications that they are available as high-level abstractions in many programming environments. The C standard library has <tt>bsearch</tt>, an implementation of the binary search algorithm in <a class="docLink" href="ch12lev1sec4.html#ch12lev1sec4">Section 12.4</a>, and the C++ Standard Template Library offers a large variety of symbol tables, called &quot;associative containers.&quot; As usual, it is difficult for a general-purpose implementation to meet the demanding performance needs of diverse applications. Our study of many of the ingenious methods that have been developed to implement the symbol-table abstraction will set a context to help us understand the characteristics of prepackaged implementations and to help us decide when to develop an implementation that is tailored to a particular application.</p>
<p class="docText">As we did with sorting, we will consider the methods without specifying the types of the items being processed. In the same manner that we discussed in detail in <a class="docLink" href="ch06lev1sec8.html#ch06lev1sec8">Section 6.8</a>, we consider implementations that use an interface that defines <tt>Item</tt> and the basic abstract operations on the data. We consider both comparison-based methods and radix-based methods that use keys or pieces of keys as indices. To emphasize the separate roles played by items and keys in search, we extend the <tt>Item</tt> concept that we used in <a class="docLink" href="ch06.html#ch06">Chapters 6</a> through <a class="docLink" href="ch11.html#ch11">11</a> such that items contain keys of type <tt>Key</tt>. Since we are asking (slightly) more of items than we did for sorting algorithms, we shall assume that they are packaged as ADTs implemented with C++ classes, as illustrated in <a class="docLink" href="#ch12ex02">Program 12.1</a>. We use a member function <tt>key()</tt> to extract keys from items and overload <tt>operator==</tt> to test whether two keys are equal. In this chapter and in <a class="docLink" href="ch13.html#ch13">Chapter 13</a>, we also overload <tt>operator&lt;</tt> to compare two key values, to guide us in the search; in <a class="docLink" href="ch14.html#ch14">Chapters 14</a> and <a class="docLink" href="ch15.html#ch15">15</a>, our search algorithms are based on extracting pieces of keys using the basic radix operations that we used in <a class="docLink" href="ch10.html#ch10">Chapter 10</a>. We also assume that items are initialized to be <span class="docEmphasis">null</span>, and that clients have access to a function <tt>null()</tt> that can test whether an item is null. We use null items for the purpose of providing a return value for the case when no <a name="iddle1012"></a><a name="iddle1339"></a><a name="iddle1690"></a><a name="iddle2017"></a><a name="iddle2019"></a>item in the symbol table has the search key. In some implementations, we assume that null items have a sentinel key.</p>
<a name="ch12ex02"></a><h5 id="title-IDAHRCSE" class="docExampleTitle">Program 12.1. Sample implementation for item ADT</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This class definition for items that are small records consisting of integer keys and associated floating-point information illustrates our basic conventions for symbol-table items. Our symbol-table implementations are client programs that use the operators <tt>==</tt> and <tt>&lt;</tt> to compare keys, and the member functions <tt>key()</tt> and <tt>null()</tt> to access keys and test whether items are null, respectively.</p>
<p class="docText">We also include the functions <tt>scan</tt> (read an <tt>Item</tt>), <tt>rand</tt> (generate a random <tt>Item</tt>), and <tt>show</tt> (print an <tt>Item</tt>) in item type definitions for use by drivers. This arrangement gives us the flexibility to implement and test various symbol-table implementations on various types of items.</p>
<div class="docText"><pre>#include &lt;stdlib.h&gt;
#include &lt;iostream.h&gt;
static int maxKey = 1000;
typedef int Key;
class Item
  {
    private:
      Key keyval;
      float info;
    public:
      Item()
        { keyval = maxKey; }
      Key key()
        { return keyval; }
      int null()
        { return keyval == maxKey; }
      void rand()
        { keyval = 1000*::rand()[/]RAND_MAX;
          info = 1.0*::rand()[/]RAND_MAX; }
      int scan(istream&amp; is = cin)
        { return (is &gt;&gt; keyval &gt;&gt; info) != 0; }
      void show(ostream&amp; os = cout)
        { os &lt;&lt; keyval &lt;&lt; ["] ["] &lt;&lt; info &lt;&lt; endl; }
  };
ostream&amp; operator&lt;&lt;(ostream&amp; os, Item&amp; x)
 { x.show(os); return os; }</pre></div><br />
</td></tr></table></p>
<a name="ch12ex03"></a><h5 id="title-IDAWSCSE" class="docExampleTitle">Program 12.2. Symbol-table abstract data type</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This interface defines operations for a simple symbol table: initialize, return the item count, find an item with a given key, add a new item, remove an item, select the <span class="docEmphasis">k</span>th smallest item, and show the items in order of their keys (on a designated output stream).</p>
<div class="docText"><pre>template &lt;class Item, class Key&gt;
class ST
  {
    private:
      // Implementation-dependent code
    public:
      ST(int);
      int count();
      Item search(Key) ;
      void insert(Item);
      void remove(Item);
      Item select(int);
      void show(ostream&amp;);
  };</pre></div><br />
</td></tr></table></p>
<p class="docText">To use the interfaces and implementations for floating-point numbers, strings, and more complicated items from <a class="docLink" href="ch06lev1sec8.html#ch06lev1sec8">Sections 6.8</a> and <a class="docLink" href="ch06lev1sec9.html#ch06lev1sec9">6.9</a> for search, we need only to be sure that appropriate definitions are available for <tt>Key</tt>, <tt>key()</tt>, <tt>null()</tt>, <tt>operator==</tt>, and <tt>operator&lt;</tt>, and to modify <tt>rand</tt>, <tt>scan</tt>, and <tt>show</tt> to be class member functions and to refer to keys as appropriate.</p>
<p class="docText"><a class="docLink" href="#ch12ex03">Program 12.2</a> is an interface that defines the basic symbol-table operations (except <span class="docEmphasis">join</span>). We shall use this interface between client programs and all the search implementations in this and the next several chapters. We are not using a first-class ADT in the sense of <a class="docLink" href="ch04lev1sec8.html#ch04lev1sec8">Section 4.8</a> (see <a class="docLink" href="#ch12qa1q6">Exercise 12.6</a>) because most programs use only one table and because the addition of copy constructors, overloaded assignment operators, and destructors, though a straightforward task for most implementations, would distract us from the essential characteristics of the algorithms. We also can define a version of the interface in <a name="iddle1401"></a><a name="iddle1432"></a><a name="iddle1760"></a><a name="iddle1998"></a><a name="iddle2003"></a><a name="iddle2495"></a><a class="docLink" href="#ch12ex03">Program 12.2</a> to manipulate handles to items in a manner similar to <a class="docLink" href="ch09lev1sec5.html#ch09ex17">Program 9.8</a> (see <a class="docLink" href="#ch12qa1q7">Exercise 12.7</a>), but this arrangement unnecessarily complicates the programs in the typical situation where it suffices to manipulate an item by the key. The interface does not specify how we determine which item to <span class="docEmphasis">remove</span>. Most implementations use the interpretation &quot;remove an item with key equal to the given item&quot;, with an implied <span class="docEmphasis">search</span>. Other implementations that provide handles and can test for item identity obviate the need to <span class="docEmphasis">search</span> before removing, and so can admit faster algorithms. Also, when we consider algorithms for the <span class="docEmphasis">join</span> operation, implying that we have applications that process multiple symbol tables, we may wish to use first-class symbol-table ADT implementations, carefully implemented so as to avoid wasting time or space (see <a class="docLink" href="ch12lev1sec9.html#ch12lev1sec9">Section 12.9</a>).</p>
<p class="docText">Some algorithms do not assume any implied ordering among the keys and therefore use only <tt>operator==</tt> (and not <tt>operator&lt;</tt>) to compare keys, but many of the symbol-table implementations use the ordering relationship among keys implied by <tt>operator&lt;</tt> to structure the data and to guide the search. Also, the <span class="docEmphasis">select</span> and <span class="docEmphasis">sort</span> abstract operations explicitly refer to key order. The <span class="docEmphasis">sort</span> function is packaged as a function that sends all the items in order to the output stream, without necessarily rearranging them. We can easily generalize <span class="docEmphasis">sort</span> implementations to make a function that visits the items in order of their keys, perhaps applying a procedure passed as an argument to each. We name our symbol-table <span class="docEmphasis">sort</span> functions <tt>show</tt> because the implementations that we provide show the contents of the symbol table, in sorted order. Algorithms that do not use <tt>operator&lt;</tt> do not require that keys be comparable to one another, and do not necessarily support <span class="docEmphasis">select</span> and <span class="docEmphasis">sort</span>.</p>
<p class="docText">The possibility of items with duplicate keys should receive special consideration in a symbol-table implementation. Some applications disallow duplicate keys, so keys can be used as handles. An example of this situation is the use of social-security numbers as keys in personnel files. Other applications may involve numerous items with duplicate keys: for example, keyword search in document databases typically will result in multiple search hits.</p>
<p class="docText">We can handle items with duplicate keys in one of several ways. One approach is to insist that the primary search data structure contain only items with distinct keys, and to maintain, for each key, a link to <a name="iddle2489"></a>a list of application items with duplicate keys. That is, we use items that contain a key and a link in our primary data structures, and do not have items with duplicate keys. This arrangement is convenient in some applications, since all the items with a given search key are returned with one <span class="docEmphasis">search</span> or can be removed with one <span class="docEmphasis">remove</span>. From the point of view of the implementation, this arrangement is equivalent to leaving duplicate-key management to the client. A second possibility is to leave items with equal keys in the primary search data structure, and to return <span class="docEmphasis">any</span> item with the given key for a <span class="docEmphasis">search</span>. This convention is simpler for applications that process one item at a time, where the order in which items with duplicate keys are processed is not important. It may be inconvenient in terms of the algorithm design, because the interface might have to be extended to include a mechanism to retrieve all items with a given key or to call a specified function for each item with the given key. A third possibility is to assume that each item has a unique identifier (apart from the key), and to require that a <span class="docEmphasis">search</span> find the item with a given identifier, given the key. Or some more complicated mechanism might be necessary. These considerations apply to all the symbol-table operations in the presence of duplicate keys. Do we want to <span class="docEmphasis">remove</span> all items with the given key, or any item with the key, or a specific item (which requires an implementation that provides handles to items)? When describing symbol-table implementations, we indicate informally how items with duplicate keys might be handled most conveniently, without necessarily considering each mechanism for each implementation.</p>
<p class="docText"><a class="docLink" href="#ch12ex04">Program 12.3</a> is a sample client program that illustrates these conventions for symbol-table implementations. It uses a symbol table to find the distinct values in a sequence of keys (randomly generated or read from standard input), then prints them out in sorted order.</p>
<p class="docText">As usual, we have to be aware that differing implementations of the symbol-table operations have differing performance characteristics, which may depend on the mix of operations. One application might use <span class="docEmphasis">insert</span> relatively infrequently (perhaps to build a table), then follow up with a huge number of <span class="docEmphasis">search</span> operations; another application might use <span class="docEmphasis">insert</span> and <span class="docEmphasis">remove</span> a huge number of times on relatively small tables, intermixed with <span class="docEmphasis">search</span> operations. Not all implementations will support all operations, and some implementations might provide efficient support of certain functions at the expense of others, with an implicit assumption that the expensive functions are performed rarely. Each of the fundamental operations in the symbol table interface has important applications, and many basic organizations have been suggested to support efficient use of various combinations of the operations. In this and the next few chapters, we shall concentrate on implementations of the fundamental functions <span class="docEmphasis">construct</span>, <span class="docEmphasis">insert</span>, and <span class="docEmphasis">search</span>, with some comment on <span class="docEmphasis">remove</span>, <span class="docEmphasis">select</span>, <span class="docEmphasis">sort</span>, and <span class="docEmphasis">join</span> when appropriate. The wide variety of algorithms to consider stems from differing performance characteristics for various combinations of the basic operations, and perhaps also from constraints on key values, or item size, or other considerations.</p>
<a name="ch12ex04"></a><h5 id="title-IDA20CSE" class="docExampleTitle">Program 12.3. Example of a symbol-table client</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This program uses a symbol table to find the distinct keys in a sequence generated randomly or read from standard input. For each key, it uses  <tt>search</tt> to check whether the key has been seen before. If the key has not been seen before, it inserts an item with that key into the symbol table. The types of keys and items, and the abstract operations on them, are specified in <tt>Item.cxx</tt> (see, for example, <a class="docLink" href="#ch12ex02">Program 12.1</a>).</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
#include "Item.cxx"
#include "ST.cxx"
int main(int argc, char *argv[])
  { int N, maxN = atoi(argv[1]), sw = atoi(argv[2]);
    ST&lt;Item, Key&gt; st(maxN);
    for (N = 0; N &lt; maxN; N++)
      { Item v;
        if (sw) v.rand(); else if (!v.scan()) break;
        if (!(st.search(v.key())).null()) continue;
        st.insert(v);
      }
    st.show(cout); cout &lt;&lt; endl;
    cout &lt;&lt; N &lt;&lt; " keys" &lt;&lt; endl;
    cout &lt;&lt; st.count() &lt;&lt; " distinct keys" &lt;&lt; endl;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a name="iddle2487"></a>In this chapter, we shall see implementations where <span class="docEmphasis">search</span>, <span class="docEmphasis">insert</span>, <span class="docEmphasis">remove</span>, and <span class="docEmphasis">select</span> take time proportional to the logarithm of the number of items in the dictionary, on the average, for random keys, and <span class="docEmphasis">sort</span> runs in linear time. In <a class="docLink" href="ch13.html#ch13">Chapter 13</a>, we shall examine ways to guarantee this level of performance, and we shall see one implementation in <a class="docLink" href="ch12lev1sec2.html#ch12lev1sec2">Section 12.2</a> and several in <a class="docLink" href="ch14.html#ch14">Chapters 14</a> and <a class="docLink" href="ch15.html#ch15">15</a> with constant-time performance under certain circumstances.</p>
<p class="docText">Many other operations on symbol tables have been studied. Examples include <span class="docEmphasis">finger search</span>, where a search can begin from the point where a previous search ended; <span class="docEmphasis">range search</span>, where we want to count or show all the nodes falling within a specified interval; and, when we have a concept of <span class="docEmphasis">distance</span> between keys, <span class="docEmphasis">near-neighbor</span> search, where we want to find items with keys closest to a given key. We consider such operations in the context of geometric algorithms, in Part 6.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa1q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">12.1</span> Write an <tt>Item</tt> class implementation (similar to <a class="docLink" href="#ch12ex02">Program 12.1</a>) to support having the symbol-table implementations process items consisting solely of integer keys.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa1q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.2</span> Write an <tt>Item</tt> class implementation (similar to <a class="docLink" href="#ch12ex02">Program 12.1</a>) to support having the symbol-table implementations process items consisting solely of C-style string keys, maintaining a buffer for the strings, as in <a class="docLink" href="ch06lev1sec8.html#ch06ex24">Program 6.11</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa1q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">12.3</span> Use the symbol-table ADT <a class="docLink" href="#ch12ex03">Program 12.2</a> to implement stack and queue ADTs.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa1q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">12.4</span> Use the symbol-table ADT defined by the interface <a class="docLink" href="#ch12ex03">Program 12.2</a> to implement a priority-queue ADT that supports <span class="docEmphasis">both</span> remove-the-maximum <span class="docEmphasis">and</span> remove-the-minimum operations.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa1q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.5</span> Use the symbol-table ADT defined by the interface <a class="docLink" href="#ch12ex03">Program 12.2</a> to implement an array sort compatible with those in <a class="docLink" href="ch06.html#ch06">Chapters 6</a> through <a class="docLink" href="ch10.html#ch10">10</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa1q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">12.6</span> Add declarations for a destructor, a copy constructor, and an overloaded assignment operator to <a class="docLink" href="#ch12ex03">Program 12.2</a> to convert it into a first-class ADT (see <a class="docLink" href="ch04lev1sec8.html#ch04lev1sec8">Sections 4.8</a> and <a class="docLink" href="ch09lev1sec5.html#ch09lev1sec5">9.5</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa1q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.7</span> Define an interface for a symbol-table ADT that allows client programs to remove specific items via handles and to change keys (see <a class="docLink" href="ch04lev1sec8.html#ch04lev1sec8">Sections 4.8</a> and <a class="docLink" href="ch09lev1sec5.html#ch09lev1sec5">9.5</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa1q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">12.8</span> Give an item-type interface and implementation for items with two fields: a 16-bit integer key and a C string that contains information associated with the key.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa1q9"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">12.9</span> Give the average number of distinct keys that our example driver program (<a class="docLink" href="#ch12ex04">Program 12.3</a>) will find among <span class="docEmphasis">N</span> random positive integers less than <a name="iddle1446"></a><a name="iddle1640"></a><a name="iddle1742"></a><a name="iddle2313"></a><a name="iddle2326"></a><a name="iddle2483"></a><a name="iddle2485"></a><a name="iddle2491"></a>1000, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10, 10<sup>2</sup>, 10<sup>3</sup>, 10<sup>4</sup></tt>, and <tt>10<sup>5</sup></tt>. Determine your answer empirically, or analytically, or both.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch12lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>