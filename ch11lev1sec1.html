<html><head><title>11.1. Batcher's Odd&ndash;Even Mergesort</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch11.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch11lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch11lev1sec1"></a>
<h3 id="title-IDAVIOXE" class="docSection1Title">11.1. Batcher's Odd&ndash;Even Mergesort</h3>
<p class="docText">To begin, we shall consider a sorting method that is based on just two abstract operations, the <span class="docEmphasis">compare&ndash;exchange</span> operation and the <span class="docEmphasis">perfect shuffle</span> operation (along with its inverse, the <span class="docEmphasis">perfect unshuffle</span>). The algorithm, developed by Batcher in 1968, is known as <span class="docEmphasis">Batcher's odd&ndash;even mergesort</span>. It is a simple task to implement the algorithm using shuffles, compare&ndash;exchanges, and double recursion, but it is more challenging to understand why the algorithm works, and to untangle the shuffles and recursion to see how it operates at a low level.</p>
<p class="docText">We encountered the compare&ndash;exchange operation briefly in <a class="docLink" href="ch06.html#ch06">Chapter 6</a>, where we noted that some of the elementary sort methods discussed there could be expressed more concisely in terms of this abstract operation. Now, we are interested in methods that examine the data <span class="docEmphasis">exclusively</span> with compare&ndash;exchange operations. Standard comparisons are ruled out: The compare&ndash;exchange operation does not return a result, so there is no way for a program to take action that depends on data values.</p>
<a name="ch11ex01"></a><h5 id="title-IDA1JOXE" class="docExampleTitle">Definition 11.1. A <span class="docEmphasis">nonadaptive</span> sorting algorithm is one where the sequence of operations performed depends on only the number of the inputs, rather than on the values of the keys</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">In this section, we do allow operations that unilaterally rearrange the data, such as exchanges and perfect shuffles, but they are not essential, as we shall see in <a class="docLink" href="ch11lev1sec2.html#ch11lev1sec2">Section 11.2</a>. Nonadaptive methods are equivalent to <span class="docEmphasis">straight-line programs</span> for sorting: They can be expressed simply as a list of the compare&ndash;exchange operations to be performed. For example, the sequence</p>
<div class="docText"><pre>compexch(a[0], a[1])
compexch(a[1], a[2])
compexch(a[0], a[1])</pre></div><br />
<p class="docText">is a straight-line program for sorting three elements. We use loops, shuffles, and other high-level operations for convenience and economy in expressing algorithms, but our goal in developing an algorithm is to define, for each <span class="docEmphasis">N</span>, a fixed sequence of <tt>compexch</tt> operations that can sort any set of <span class="docEmphasis">N</span> keys. We can assume without loss of generality that the key values are the integers 1 through <span class="docEmphasis">N</span> (see <a class="docLink" href="#ch11qa1q4">Exercise 11.4</a>); to know that a straight-line program is correct, we have to prove that it sorts each possible permutation of these values (see, for example, <a class="docLink" href="#ch11qa1q5">Exercise 11.5</a>).</p>
<a name="ch11ex02"></a><h5 id="title-IDAWLOXE" class="docExampleTitle">Program 11.1. Perfect shuffle and perfect unshuffle</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The <tt>shuffle</tt> function rearranges a subarray <tt>a[l]</tt>, <tt>...</tt>, <tt>a[r]</tt> by splitting that subarray in half, then alternating elements from each half: Elements in the first half go in the even-numbered positions in the result, and elements in the second half go in the odd-numbered positions in the result. The <tt>unshuffle</tt> function does the opposite: Elements in the even-numbered positions go in the first half of the result, and elements in the odd-numbered positions go in the second half of the result. We use these functions only for subarrays with an even number of elements.</p>
<div class="docText"><pre>template &lt;class Item&gt;
void shuffle(Item a[], int l, int r)
  { int i, j, m = (l+r)/2;
    static Item aux[maxN];
    for (i = l, j = 0; i &lt;= r; i+=2, j++)
      { aux[i] = a[l+j]; aux[i+1] = a[m+1+j]; }
    for (i = l; i &lt;= r; i++) a[i] = aux[i];
  }
template &lt;class Item&gt;
void unshuffle(Item a[], int l, int r)
  { int i, j, m = (l+r)/2;
    static Item aux[maxN];
    for (i = l, j = 0; i &lt;= r; i+=2, j++)
      { aux[l+j] = a[i]; aux[m+1+j] = a[i+1]; }
    for (i = l; i &lt;= r; i++) a[i] = aux[i];
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">Few of the sorting algorithms that we considered in <a class="docLink" href="ch06.html#ch06">Chapters 6</a> through <a class="docLink" href="ch10.html#ch10">10</a> are nonadaptive&mdash;they all use <tt>operator&lt;</tt> or examine the keys in other ways, then take differing actions depending on key values. One exception is bubble sort (see <a class="docLink" href="ch06lev1sec4.html#ch06lev1sec4">Section 6.4</a>), which uses only compare&ndash;exchanges. Pratt's version of shellsort (see <a class="docLink" href="ch06lev1sec6.html#ch06lev1sec6">Section 6.6</a>) is another nonadaptive method.</p>
<p class="docText"><a class="docLink" href="#ch11ex02">Program 11.1</a> gives an implementation of the other abstract operations that we shall be using&mdash;the perfect shuffle and the perfect unshuffle&mdash;and <a class="docLink" href="#ch11fig01">Figure 11.1</a> gives an example of each. The perfect shuffle rearranges an array in a manner corresponding to the way that a deck of cards might be rearranged when shuffled by an expert: It is split precisely in half, then the cards are taken alternately from each half to make the shuffled deck. We always take the first card from the top half of the deck. If the number of cards is even, the two halves have the same number of cards; if the number of cards is odd, the extra card ends up in the top half. The perfect unshuffle does the opposite: We make the unshuffled deck by putting cards alternately in the top half and the bottom half.</p>
<a name="ch11fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 11.1. Perfect shuffle and perfect unshuffle</h5>
<h5></h5><h5></h5></center></p><p class="docText">To perform a perfect shuffle <span class="docEmphasis">(left)</span>, we take the first element in the file, then the first element in the second half, then the second element in the file, then the second element in the second half, and so forth. Consider the elements to be numbered starting at 0, top to bottom. Then, elements in the first half go to even-numbered positions, and elements in the second half go to odd-numbered positions. To perform a perfect unshuffle <span class="docEmphasis">(right)</span>, we do the opposite: Elements in even-numbered positions go to the first half, and elements in odd-numbered positions go to the second half.</p>
<p class="docText">
<img border="0" alt="" width="175" height="198" src="11fig01.gif" /></p>
</td></tr></table></p><br />
<p class="docText">Batcher's sort is exactly the top-down mergesort of <a class="docLink" href="ch08lev1sec3.html#ch08lev1sec3">Section 8.3</a>; the difference is that instead of one of the adaptive merge implementations from <a class="docLink" href="ch08.html#ch08">Chapter 8</a>, it uses Batcher's odd-even merge, a nonadaptive top-down recursive merge. <a class="docLink" href="ch08lev1sec3.html#ch08ex03">Program 8.3</a> itself does not access the data at all, so our use of a nonadaptive merge implies that the whole sort is nonadaptive.</p>
<p class="docText">We shall implicitly assume in the text throughout this section and <a class="docLink" href="ch11lev1sec2.html#ch11lev1sec2">Section 11.2</a> that the number of items to be sorted is a power of 2. Then, we can always refer to &quot;<span class="docEmphasis">N/2</span>&quot; without a caveat about <span class="docEmphasis">N</span> being odd, and so forth. This assumption is impractical, of course&mdash;our programs and examples involve other file sizes&mdash;but it simplifies the discussion considerably. We shall return to this issue at the end of <a class="docLink" href="ch11lev1sec2.html#ch11lev1sec2">Section 11.2</a>.</p>
<p class="docText">Batcher's merge is itself a divide-and-conquer recursive method. To do a 1-by-1 merge, we use a single compare&ndash;exchange operation. Otherwise, to do an <span class="docEmphasis">N</span>-by-<span class="docEmphasis">N</span> merge, we unshuffle to get two <span class="docEmphasis">N/</span>2-by-<span class="docEmphasis">N/</span>2 merging problems, and then solve them recursively to get two sorted files. Shuffling these files, we get a file that is nearly sorted&ndash;all that is needed is a single pass of <span class="docEmphasis">N/2</span>- 1 independent compare&ndash;exchange operations: between elements 2<span class="docEmphasis">i</span> and 2<span class="docEmphasis">i</span> + 1 for <span class="docEmphasis">i</span> from 1 to <span class="docEmphasis">N/</span>2-1. An example is depicted in <a class="docLink" href="#ch11fig02">Figure 11.2</a>. From this description, the implementation in <a class="docLink" href="#ch11ex03">Program 11.2</a> is immediate.</p>
<a name="ch11fig02"></a><p><center>
<h5 class="docFigureTitle">Figure 11.2. Top-down Batcher's odd-even merge example</h5>
<h5></h5><h5></h5></center></p><p class="docText">To merge <span class="docEmphasis"><tt>A G I N O R S T</tt></span> with <span class="docEmphasis"><tt>A E E L M P X Y</tt></span>, we begin with an unshuffle operation, which creates two independent merging problems of about one-half the size (shown in the second line): we have to merge <span class="docEmphasis"><tt>A I O S</tt></span> with <span class="docEmphasis"><tt>A E M X</tt></span> (in the first half of the array) and <span class="docEmphasis"><tt>G N R T</tt></span> with <span class="docEmphasis"><tt>E L P Y</tt></span> (in the second half of the array). After solving these subproblems recursively, we shuffle the solutions to these problems (shown in the next-to-last line) and complete the sort by compare&ndash;exchanging <span class="docEmphasis"><tt>E</tt></span> with <span class="docEmphasis"><tt>A, G</tt></span> with <span class="docEmphasis"><tt>E, L</tt></span> with <span class="docEmphasis"><tt>I, N</tt></span> with <span class="docEmphasis"><tt>M, P</tt></span> with <span class="docEmphasis"><tt>O, R</tt></span> with <span class="docEmphasis"><tt>S</tt></span>, and <span class="docEmphasis"><tt>T</tt></span> with <span class="docEmphasis"><tt>X</tt></span>.</p>
<p class="docText">
<img border="0" alt="" width="185" height="339" src="11fig02.gif" /></p>
<br />
<p class="docText">Why does this method sort all possible input permutations? The answer to this question is not at all obvious&mdash;the classical proof is an indirect one that depends on a general characteristic of nonadaptive sorting programs.</p>
<p class="docText"></p><a name="ch11ex03"></a><h5 id="title-IDAIUOXE" class="docExampleTitle">Program 11.2. Batcher's odd&ndash;even merge (recursive version)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This recursive program implements an abstract inplace merge, using the <tt>shuffle</tt> and <tt>unshuffle</tt> operations from <a class="docLink" href="#ch11ex02">Program 11.1</a>, although they are not essential&mdash;<a class="docLink" href="ch11lev1sec2.html#ch11ex06">Program 11.3</a> is a bottom-up nonrecursive version of this program with shuffling removed. Our primary interest here is that this implementation provides a compact description of Batcher's algorithm, when the file size is a power of 2.</p>
<div class="docText"><pre>template &lt;class Item&gt;
void merge(Item a[], int l, int m, int r)
  {
    if (r == l+1) compexch(a[l], a[r]);
    if (r &lt; l+2) return;
    unshuffle(a, l, r);
    merge(a, l, (l+m)/2, m);
    merge(a, m+1, (m+1+r)/2, r);
    shuffle(a, l, r);
    for (int i = l+1; i &lt; r; i+=2)
      compexch(a[i], a[i+1]);
  }</pre></div><br />
</td></tr></table></p>
<a name="ch11ex04"></a><h5 id="title-IDARVOXE" class="docExampleTitle">Property 11.1. (0&ndash;1 principle) If a nonadaptive program produces sorted output when the inputs are all either 0 or 1, then it does so when the inputs are arbitrary keys</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">See <a class="docLink" href="#ch11qa1q7">Exercise 11.7</a>.</p>
</td></tr></table></p>
<a name="ch11ex05"></a><h5 id="title-IDAJWOXE" class="docExampleTitle">Property 11.2. Batcher's odd&ndash;even merge (<a class="docLink" href="#ch11ex03">Program 11.2</a>) is a valid merging method</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Using the 0&mdash;1 principle, we check only that the method properly merges when the inputs are all either 0 or 1. Suppose that there are <span class="docEmphasis">i</span> 0s in the first subfile and <span class="docEmphasis">j</span> 0s in the second subfile. The proof of this property involves checking four cases, depending on whether <span class="docEmphasis">i</span> and <span class="docEmphasis">j</span> are odd or even. If they are both even, then the two merging subproblems each involve one file with <span class="docEmphasis">i</span>/2 0s and one file with <span class="docEmphasis">j</span>/2 0s, so both results have (<span class="docEmphasis">i + j</span>)/2 0s. Shuffling, we get a sorted 0&ndash;1 file. The 0&ndash;1 file is also sorted after shuffling in the case that <span class="docEmphasis">i</span> is even and <span class="docEmphasis">j</span> is odd and the case that <span class="docEmphasis">i</span> is odd and <span class="docEmphasis">j</span> is even. But if both <span class="docEmphasis">i</span> and <span class="docEmphasis">j</span> are odd, then we end up shuffling a file with (<span class="docEmphasis">i + j</span>)/2 + 1 0s with a file with (<span class="docEmphasis">i</span> + <span class="docEmphasis">j</span>)/2 - 1 0s, so the 0&ndash;1 file after shuffling has <span class="docEmphasis">i</span> + <span class="docEmphasis">j</span> - 1 0s, a 1, a 0, then <span class="docEmphasis">N-i-j-1</span> 1s (see <a class="docLink" href="#ch11fig03">Figure 11.3</a>), and one of the comparators in the final stage completes the sort.</p>
</td></tr></table></p>
<a name="ch11fig03"></a><p><center>
<h5 class="docFigureTitle">Figure 11.3. Four cases for 0-1 merging</h5>
<h5></h5><h5></h5></center></p><p class="docText">These four examples consist of five lines each: a 0-1 merging problem; the result of an unshuffle operation, which gives two merging problems; the result of recursively completing the merges; the result of a shuffle; and the result of the final odd&ndash;even compares. The last stage performs an exchange only when the number of 0s in both input files is odd.</p>
<p class="docText">
<img border="0" alt="" width="175" height="258" src="11fig03.gif" /></p>
<br />
<p class="docText">We do not need actually to shuffle the data. Indeed, we can use <a class="docLink" href="#ch11ex03">Programs 11.2</a> and <a class="docLink" href="ch08lev1sec3.html#ch08ex03">8.3</a> to output a straight-line sorting program for any <span class="docEmphasis">N</span>, by changing the implementations of <tt>compexch</tt> and <tt>shuffle</tt> to maintain indices and to refer to the data indirectly (see <a class="docLink" href="#ch11qa1q12">Exercise 11.12</a>). Or, we can have the program output the compare&ndash;exchange instructions to use on the original input (see <a class="docLink" href="#ch11qa1q13">Exercise 11.13</a>). We could apply these techniques to any nonadaptive sorting method that rearranges the data with exchanges, shuffles, or similar operations. For Batcher's merge, the structure of the algorithm is so simple that we can develop a bottom-up implementation directly, as we shall see in <a class="docLink" href="ch11lev1sec2.html#ch11lev1sec2">Section 11.2</a>.</p>
</td></tr></table>
<p class="docText">&nbsp;<a name="iddle2049"></a><a name="iddle2351"></a><a name="iddle2400"></a><a name="iddle1368"></a><a name="iddle1906"></a><a name="iddle2233"></a></p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa1q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">11.1</span> Give the result of shuffling and unshuffling the keys <tt>E A S Y Q U E S T I O N</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa1q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">11.2</span> Generalize <a class="docLink" href="#ch11ex02">Program 11.1</a> to implement <span class="docEmphasis">h</span>-way shuffle and unshuffle. Defend your strategy for the case that the file size is not a multiple of <span class="docEmphasis">h</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa1q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">11.3</span> Implement the shuffle and unshuffle operations without using an auxiliary array.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa1q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">11.4</span> Show that a straight-line program that sorts <span class="docEmphasis">N</span> distinct keys will sort <span class="docEmphasis">N</span> keys that are not necessarily distinct.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa1q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">11.5</span> Show how the straight-line program given in the text sorts each of the six permutations of the integers 1, 2, and 3.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa1q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">11.6</span> Give a straight-line program that sorts four elements.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa1q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">11.7</span> Prove <a class="docLink" href="#ch11ex04">Property 11.1</a>. <span class="docEmphasis">Hint</span>: Show that if the program does not sort some input array with arbitrary keys, then there is some 0&ndash;1 sequence that it does not sort.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa1q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">11.8</span> Show how the keys A E Q S U Y E I N O S T are merged using <a class="docLink" href="#ch11ex03">Program 11.2</a>, in the style of the example diagrammed in <a class="docLink" href="#ch11fig02">Figure 11.2</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa1q9"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">11.9</span> Answer <a class="docLink" href="#ch11qa1q8">Exercise 11.8</a> for the keys A E S Y E I N O Q S T U.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa1q10"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">11.10</span> Answer <a class="docLink" href="#ch11qa1q8">Exercise 11.8</a> for the keys 1 0 0 1 1 1 0 0 0 0 0 1 0 1 0 0.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa1q11"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">11.11</span> Empirically compare the running time of Batcher's mergesort with that of standard top-down mergesort (<a class="docLink" href="ch08lev1sec3.html#ch08ex03">Programs 8.3</a> and <a class="docLink" href="ch08lev1sec2.html#ch08ex02">8.2</a>) for <span class="docEmphasis">N = 10<sup>3</sup></span>, <span class="docEmphasis">10<sup>4</sup></span>, <span class="docEmphasis">10<sup>5</sup></span>,and <span class="docEmphasis">10<sup>6</sup></span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa1q12"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">11.12</span> Give implementations of <tt>compexch</tt>, <tt>shuffle</tt>, and <tt>unshuffle</tt> that cause <a class="docLink" href="#ch11ex03">Programs 11.2</a> and <a class="docLink" href="ch08lev1sec3.html#ch08ex03">8.3</a> to operate as an indirect sort (see <a class="docLink" href="ch06lev1sec8.html#ch06lev1sec8">Section 6.8</a>).</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa1q13"></a><b></b></td><td><p class="docText"><a name="iddle1286"></a><a name="iddle1935"></a><a name="iddle1941"></a><a name="iddle2399"></a><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">11.13</span> Give implementations of <tt>compexch</tt>, <tt>shuffle</tt>, and <tt>unshuffle</tt> that cause <a class="docLink" href="#ch11ex03">Programs 11.2</a> and <a class="docLink" href="ch08lev1sec3.html#ch08ex03">8.3</a> to print out, given <span class="docEmphasis">N</span>, a straight-line program for sorting <span class="docEmphasis">N</span> elements. You may use an auxiliary global array to keep track of indices.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa1q14"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">11.14</span> If we put the second file for the merge in reverse order, we have a <span class="docEmphasis">bitonic</span> sequence, as defined in <a class="docLink" href="ch08lev1sec2.html#ch08lev1sec2">Section 8.2</a>. Changing the final loop in <a class="docLink" href="#ch11ex03">Program 11.2</a> to start at <tt>l</tt> instead of <tt>l</tt>+1 turns the program into one that sorts bitonic sequences. Show how the keys <tt>A E S Q U Y T S O N I E</tt> are merged using this method, in the style of the example diagrammed in <a class="docLink" href="#ch11fig02">Figure 11.2</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa1q15"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">1.15</span> Prove that the modified <a class="docLink" href="#ch11ex03">Program 11.2</a> described in <a class="docLink" href="#ch11qa1q14">Exercise 11.14</a> sorts any bitonic sequence.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></div></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch11.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch11lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table><!--IP User 2--></td></body></head></html>