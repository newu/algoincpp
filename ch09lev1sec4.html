<html><head><title>9.4. Heapsort</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch09lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch09lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch09lev1sec4"></a>
<h3 id="title-IDA52FYE" class="docSection1Title">9.4. Heapsort</h3>
<p class="docText">We can adapt the basic idea in <a class="docLink" href="ch09lev1sec3.html#ch09ex12">Program 9.6</a> to sort an array without needing any extra space, by maintaining the heap within the array to be sorted. That is, focusing on the task of sorting, we abandon the <a name="iddle1613"></a><a name="iddle1617"></a><a name="iddle2366"></a>notion of hiding the representation of the priority queue, and rather than being constrained by the interface to the priority-queue ADT, we use <tt>fixUp</tt> and <tt>fixDown</tt> directly.</p>
<p class="docText">Using <a class="docLink" href="ch09lev1sec3.html#ch09ex09">Program 9.5</a> directly in <a class="docLink" href="ch09lev1sec3.html#ch09ex12">Program 9.6</a> corresponds to proceeding from left to right through the array, using <tt>fixUp</tt> to ensure that the elements to the left of the scanning pointer make up a heap-ordered complete tree. Then, during the sortdown process, we put the largest element into the place vacated as the heap shrinks. That is, the sortdown process is like selection sort, but it uses a more efficient way to find the largest element in the unsorted part of the array.</p>
<p class="docText">Rather than constructing the heap via successive insertions as shown in <a class="docLink" href="ch09lev1sec3.html#ch09fig05">Figures 9.5</a> and <a class="docLink" href="ch09lev1sec3.html#ch09fig06">9.6</a>, it is more efficient to build the heap by going backward through it, making little subheaps from the bottom up, as shown in <a class="docLink" href="#ch09fig09">Figure 9.9</a>. That is, we view every position in the array as the root of a small subheap, and take advantage of the fact that <tt>fixDown</tt> works as well for such subheaps as it does for the big heap. If the two children of a node are heaps, then calling <tt>fixDown</tt> on that node makes the subtree rooted there a heap. By working backward through the heap, calling <tt>fixDown</tt> on each node, we can establish the heap property inductively. The scan starts halfway back through the array because we can skip the subheaps of size 1.</p>
<a name="ch09fig09"></a><p><center>
<h5 class="docFigureTitle">Figure 9.9. Bottom-up heap construction</h5>
<h5></h5><h5></h5></center></p><p class="docText">Working from right to left and bottom to top, we construct a heap by ensuring that the subtree below the current node is heap ordered. The total cost is linear in the worst case, because most nodes are near the bottom.</p>
<p class="docText">
<img border="0" alt="" width="175" height="604" src="09fig09.gif" /></p>
<br />
<p class="docText">A full implementation is given in <a class="docLink" href="#ch09ex14">Program 9.7</a>, the classical <span class="docEmphasis">heap-sort</span> algorithm. Although the loops in this program seem to do different tasks (the first constructs the heap, and the second destroys the heap for the sortdown), they are built around the same fundamental procedure, which restores order in a tree that is heap-ordered except possibly at the root, using the array representation of a complete tree. <a class="docLink" href="#ch09fig10">Figure 9.10</a> illustrates the contents of the array for the example corresponding to <a class="docLink" href="ch09lev1sec3.html#ch09fig07">Figures 9.7</a> through <a class="docLink" href="#ch09fig09">9.9</a>.</p>
<a name="ch09fig10"></a><p><center>
<h5 class="docFigureTitle">Figure 9.10. Heapsort example</h5>
<h5></h5><h5></h5></center></p><p class="docText">Heapsort is an efficient selection-based algorithm. First, we build a heap from the bottom up, in-place. The top eight lines in this figure correspond to <a class="docLink" href="#ch09fig09">Figure 9.9</a>. Next, we repeatedly remove the largest element in the heap. The unshaded parts of the bottom lines correspond to <a class="docLink" href="ch09lev1sec3.html#ch09fig07">Figures 9.7</a> and <a class="docLink" href="ch09lev1sec3.html#ch09fig08">9.8</a>; the shaded parts contain the growing sorted file.</p>
<p class="docText">
<img border="0" alt="" width="175" height="270" src="09fig10.gif" /></p>
<br />
<a name="ch09ex13"></a><h5 id="title-IDASTL3E" class="docExampleTitle">Property 9.4. Bottom-up heap construction takes linear time</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This fact follows from the observation that most of the heaps processed are small. For example, to build a heap of 127 elements, we process 32 heaps of size 3, 16 heaps of size 7, 8 heaps of size 15, 4 heaps of size 31, 2 heaps of size 63, and 1 heap of size 127, so 32 . 1 + 16 . 2 + 8 . 3 + 4 . 4 + 2 . 5 + 1 . 6 = 120 promotions (twice as many comparisons) are required in the worst case. For <span class="docEmphasis">N = 2<sup>n</sup>&mdash;1</span>, an upper bound on the number of promotions is </p><p class="docText"><img border="0" alt="" width="250" height="40" src="391equ01.jpg" /></p></td></tr></table></p>
<p class="docText">A similar proof holds when <span class="docEmphasis">N + 1</span> is not a power of 2.</p>
</td></tr></table>
<p class="docText"></p><a name="ch09ex14"></a><h5 id="title-IDAXUL3E" class="docExampleTitle">Program 9.7. Heapsort</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1618"></a><a name="iddle2302"></a>Using <tt>fixDown</tt> directly gives the classical heapsort algorithm. The <tt>for</tt> loop constructs the heap; then, the <tt>while</tt> loop exchanges the largest element with the final element in the array and repairs the heap, continuing until the heap is empty. The pointer <tt>pq</tt> to <tt>a[l-1]</tt> allows the code to treat the subarray passed to it as an array with the first element at index 1, for the array representation of the complete tree (see <a class="docLink" href="ch09lev1sec2.html#ch09fig02">Figure 9.2</a>). Some programming environments may disallow this usage.</p>
<div class="docText"><pre>    template &lt;class Item&gt;
    void heapsort(Item a[], int l, int r)
      { int k, N = r-l+1;
        Item *pq = a+l-1;
        for (k = N/2; k &gt;= 1; k--)
          fixDown(pq, k, N);
        while (N &gt; 1)
          { exch(pq[1], pq[N]);
            fixDown(pq, 1, --N); }
      }</pre></div><br />
</td></tr></table></p>
<p class="docText">This property is not of particular importance for heapsort, because its time is still dominated by the <span class="docEmphasis">N</span> <span class="docEmphRoman">log</span> <span class="docEmphasis">N</span> time for the sortdown, but it is important for other priority-queue applications, where a linear-time <span class="docEmphasis">construct</span> operation can lead to a linear-time algorithm. As noted in <a class="docLink" href="ch09lev1sec3.html#ch09fig06">Figure 9.6</a>, constructing a heap with <span class="docEmphasis">N</span> successive <span class="docEmphasis">insert</span> operations requires a total of <span class="docEmphasis">N</span> <span class="docEmphRoman">log</span> <span class="docEmphasis">N</span> steps in the worst case (even though the total turns out to be linear on the average for random files).</p>
<a name="ch09ex15"></a><h5 id="title-IDAQXL3E" class="docExampleTitle">Property 9.5. Heapsort uses fewer than <span class="docEmphasis">2 N lg N</span> comparisons to sort <span class="docEmphasis">N</span> elements</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The slightly higher bound <span class="docEmphasis">3 N lg N</span> follows immediately from <a class="docLink" href="ch09lev1sec3.html#ch09ex10">Property 9.2</a>. The bound given here follows from a more careful count based on <a class="docLink" href="#ch09ex13">Property 9.4</a>.</p>
</td></tr></table></p>
<p class="docText"><a name="iddle1503"></a><a name="iddle1890"></a><a name="iddle2169"></a><a class="docLink" href="#ch09ex15">Property 9.5</a> and the in-place property are the two primary reasons that heapsort is of practical interest: It is <span class="docEmphasis">guaranteed</span> to sort <span class="docEmphasis">N</span> elements in place in time proportional to <span class="docEmphasis">N</span> <span class="docEmphRoman">log</span> <span class="docEmphasis">N</span>, no matter what the input. There is no worst-case input that makes heapsort run significantly slower (unlike quicksort), and heapsort does not use any extra space (unlike mergesort). This guaranteed worst-case performance does come at a price: for example, the algorithm's inner loop (cost per comparison) has more basic operations than quicksort's, and it uses more comparisons than quicksort for random files, so heapsort is likely to be slower than quicksort for typical or random files.</p>
<p class="docText">Heaps are also useful for solving the <span class="docEmphasis">selection</span> problem of finding the <span class="docEmphasis">k</span> largest of <span class="docEmphasis">N</span> items (see <a class="docLink" href="ch07.html#ch07">Chapter 7</a>), particularly if <span class="docEmphasis">k</span> is small. We simply stop the heapsort algorithm after <span class="docEmphasis">k</span> items have been taken from the top of the heap.</p>
<a name="ch09ex16"></a><h5 id="title-IDAZ0Y2H" class="docExampleTitle">Property 9.6. Heap-based selection allows the <span class="docEmphasis">k</span>th largest of <span class="docEmphasis">N</span> items to be found in time proportional to <span class="docEmphasis">N</span> when <span class="docEmphasis">k</span> is small or close to <span class="docEmphasis">N</span>, and in time proportional to <span class="docEmphasis">N</span> <span class="docEmphRoman">log</span> <span class="docEmphasis">N</span> otherwise</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">One option is to build a heap, using fewer than <tt>2</tt><span class="docEmphasis">N</span> comparisons (by <a class="docLink" href="#ch09ex13">Property 9.4</a>), then to remove the <span class="docEmphasis">k</span> largest elements, using <span class="docEmphasis">2k lg N</span> or fewer comparisons (by <a class="docLink" href="ch09lev1sec3.html#ch09ex10">Property 9.2</a>), for a total of <span class="docEmphasis">2N + 2k lg N</span>. Another method is to build a minimum-oriented heap of size <span class="docEmphasis">k</span>, then to perform <span class="docEmphasis">k</span> <span class="docEmphasis">replace the minimum</span> (<span class="docEmphasis">insert</span> followed by <span class="docEmphasis">remove the minimum</span>) operations with the remaining elements for a total of at most <span class="docEmphasis">2k + 2(N &ndash; k)lg k</span> comparisons (see <a class="docLink" href="#ch09qa5q8">Exercise 9.35</a>). This method uses space proportional to <span class="docEmphasis">k</span>, so is attractive for finding the <span class="docEmphasis">k</span> largest of <span class="docEmphasis">N</span> elements when <span class="docEmphasis">k</span> is small and <span class="docEmphasis">N</span> is large (or is not known in advance). For random keys and other typical situations, the lg<span class="docEmphasis">k</span> upper bound for heap operations in the second method is likely to be <span class="docEmphasis">O(1)</span> when <span class="docEmphasis">k</span> is small relative to <span class="docEmphasis">N</span> (see <a class="docLink" href="#ch09qa5q9">Exercise 9.36</a>).</p>
</td></tr></table></p>
<p class="docText">Various ways to improve heapsort further have been investigated. One idea, developed by Floyd, is to note that an element reinserted into the heap during the sortdown process usually goes all the way to the bottom, so we can save time by avoiding the check for whether the element has reached its position, simply promoting the larger of the two children until the bottom is reached, then moving back up the heap to the proper position. This idea cuts the number of comparisons by a factor of 2 asymptotically&mdash;close to the <span class="docEmphasis">lg N! <img src="U2248.GIF" border="0" /> N lg N &ndash; N/ln 2</span> that is <a name="iddle1207"></a><a name="iddle2170"></a>the absolute minimum number of comparisons needed by any sorting algorithm (see Part 8). The method requires extra bookkeeping, and it is useful in practice only when the cost of comparisons is relatively high (for example, when we are sorting records with strings or other types of long keys).</p>
<p class="docText">Another idea is to build heaps based on an array representation of complete heap-ordered <span class="docEmphasis">ternary</span> trees, with a node at position <span class="docEmphasis">k</span> larger than or equal to nodes at positions <span class="docEmphasis">3k &ndash; 1</span>, <span class="docEmphasis">3k</span>,and <span class="docEmphasis">3k + 1</span> and smaller than or equal to nodes at position <span class="docEmphasis"><img src="U230A.GIF" border="0" />(k + 1)=/3<img src="U230B.GIF" border="0" /></span>, for positions between 1 and <span class="docEmphasis">N</span> in an array of <span class="docEmphasis">N</span> elements. There is a tradeoff between the lower cost from the reduced tree height and the higher cost of finding the largest of the three children at each node. This tradeoff is dependent on details of the implementation (see <a class="docLink" href="#ch09qa5q3">Exercise 9.30</a>). Further increasing the number of children per node is not likely to be productive.</p>
<p class="docText"><a class="docLink" href="#ch09fig11">Figure 9.11</a> shows heapsort in operation on a randomly ordered file. At first, the process seems to do anything but sorting, because large elements are moving to the beginning of the file as the heap is being constructed. But then the method looks more like a mirror image of selection sort, as expected. <a class="docLink" href="#ch09fig12">Figure 9.12</a> shows that different types of input files can yield heaps with peculiar characteristics, but they look more like random heaps as the sort progresses.</p>
<a name="ch09fig11"></a><p><center>
<h5 class="docFigureTitle">Figure 9.11. Dynamic characteristics of heapsort</h5>
<h5></h5><h5></h5></center></p><p class="docText">The construction process <span class="docEmphasis">(left)</span> seems to unsort the file, putting large elements near the beginning. Then, the sortdown process <span class="docEmphasis">(right)</span> works like selection sort, keeping a heap at the beginning and building up the sorted array at the end of the file.</p>
<p class="docText">
<img border="0" alt="" width="175" height="504" src="09fig11.gif" /></p>
<br />
<a name="ch09fig12"></a><p><center>
<h5 class="docFigureTitle">Figure 9.12. Dynamic characteristics of heapsort on various types of files</h5>
<h5></h5><h5></h5></center></p><p class="docText">The running time for heapsort is not particularly sensitive to the input. No matter what the input values are, the largest element is always found in less than <span class="docEmphasis">lg</span> N steps. These diagrams show files that are random, Gaussian, nearly ordered, nearly reverse-ordered, and randomly ordered with 10 distinct key values (at the top, left to right). The second diagrams from the top show the heap constructed by the bottom-up algorithm, and the remaining diagrams show the sortdown process for each file. The heaps somewhat mirror the initial file at the beginning, but all become more like the heaps for a random file as the process continues.</p>
<p class="docText">
<img border="0" alt="" width="300" height="496" src="09fig12.gif" /></p>
<br />
<p class="docText">Naturally, we are interested in the issue of how to choose among heapsort, quicksort, and mergesort for a particular application. The choice between heapsort and mergesort essentially reduces to a choice between a sort that is not stable (see <a class="docLink" href="#ch09qa5q1">Exercise 9.28</a>) and one that uses extra memory; the choice between heapsort and quicksort reduces to a choice between average-case speed and worst-case speed. Having dealt extensively with improving the inner loops of quicksort and mergesort, we leave this activity for heapsort as exercises in this chapter. Making heapsort faster than quicksort is typically not in the cards&mdash;as indicated by the empirical studies in <a class="docLink" href="#ch09table02">Table 9.2</a>&mdash;but people interested in fast sorts on their machines will find the exercise instructive. As usual, various specific properties of machines and programming environments can play an important role. For example, quicksort and mergesort have a locality property that gives them a further advantage on certain machines. When comparisons are extremely expensive, Floyd's version is the method of choice, as it is nearly optimal in terms of time and space costs in such situations.</p>
<p class="docText"></p><a name="ch09table02"></a><p><table cellspacing="0" frame="hsides" rules="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 9.2. Empirical study of heapsort algorithms</h5></caption><colgroup align="left" span="9"><col width="70"></col><col width="55"></col><col width="55"></col><col width="55"></col><col width="55"></col><col width="55"></col><col width="55"></col><col width="55"></col><col width="55"></col></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top" colspan="9"><p class="docText"><a name="iddle1420"></a>The relative timings for various sorts on files of random integers in the left part of the table confirm our expectations from the lengths of the inner loops that heapsort is slower than quicksort but competitive with mergesort. The timings for the first <span class="docEmphasis">N</span> words of <span class="docEmphasis">Moby Dick</span> in the right part of the table show that Floyd's method is an effective improvement to heapsort when comparisons are expensive.</p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="bottomBorder" align="center" valign="top" colspan="5"><p class="docText">32-bit integer keys</p></td><td class="bottomBorder" align="center" valign="top" colspan="3"><p class="docText">string keys</p></td></tr><tr><td class="bottomBorder" align="right" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">Q</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">M</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">PQ</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">H</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">F</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">Q</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">H</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">F</p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">12500</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">2</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">5</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">4</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">3</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">4</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">8</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">11</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">8</p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">25000</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">7</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">11</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">9</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">8</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">8</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">16</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">25</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">20</p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">50000</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">13</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">24</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">22</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">18</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">19</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">36</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">60</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">49</p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">100000</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">27</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">52</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">47</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">42</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">46</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">88</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">143</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">116</p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">200000</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">58</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">111</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">106</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">100</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">107</p></td><td class="docTableCell" align="right" valign="top"><p class="docText"></p></td><td class="docTableCell" align="right" valign="top"><p class="docText"></p></td><td class="docTableCell" align="right" valign="top"><p class="docText"></p></td></tr><tr><td class="docTableCell" align="right" valign="top"><p class="docText">400000</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">122</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">238</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">245</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">232</p></td><td class="docTableCell" align="right" valign="top"><p class="docText">246</p></td><td class="docTableCell" align="right" valign="top"><p class="docText"></p></td><td class="docTableCell" align="right" valign="top"><p class="docText"></p></td><td class="docTableCell" align="right" valign="top"><p class="docText"></p></td></tr><tr><td class="bottomBorder" align="right" valign="top"><p class="docText">800000</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">261</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">520</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">643</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">542</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText">566</p></td><td class="bottomBorder" align="right" valign="top"><p class="docText"></p></td><td class="bottomBorder" align="right" valign="top"><p class="docText"></p></td><td class="bottomBorder" align="right" valign="top"><p class="docText"></p></td></tr><tr><td class="docTableCell" align="left" valign="top" colspan="9"><p class="docText"><span class="docEmphasis">Key</span>:</p>
<blockquote><p></p><p class="docList">Q Quicksort, standard implementation (<a class="docLink" href="ch07lev1sec1.html#ch07ex01">Program 7.1</a>)</p></blockquote></td></tr></table></p><p></p><p class="docList">M Mergesort, standard implementation (<a class="docLink" href="ch08lev1sec1.html#ch08ex01">Program 8.1</a>)</p><p></p><p class="docList">PQ Priority-queue based heapsort (<a class="docLink" href="ch09lev1sec3.html#ch09ex09">Program 9.5</a>)</p><p></p><p class="docList">H Heapsort, standard implementation (<a class="docLink" href="ch09lev1sec3.html#ch09ex12">Program 9.6</a>)</p><p></p><p class="docList">F Heapsort with Floyd's improvement</p></div></td></tr></table><br />
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa5q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.28</span> Show that heapsort is not stable.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa5q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">9.29</span> Empirically determine the percentage of time heapsort spends in the construction phase for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa5q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">9.30</span> Implement a version of heapsort based on complete heap-ordered ternary trees, as described in the text. Compare the number of comparisons used by your program empirically with the standard implementation, for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa5q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">9.31</span> Continuing <a class="docLink" href="#ch09qa5q3">Exercise 9.30</a>, determine empirically whether or not Floyd's method is effective for ternary heaps.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa5q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">9.32</span> Considering the cost of comparisons only, and assuming that it takes <span class="docEmphasis">t</span> comparisons to find the largest of <span class="docEmphasis">t</span> elements, find the value of <span class="docEmphasis">t</span> that minimizes <a name="iddle2099"></a>the coefficient of <span class="docEmphasis">N</span> <span class="docEmphRoman">log</span> <span class="docEmphasis">N</span> in the comparison count when a <span class="docEmphasis">t</span>-ary heap is used in heapsort. First, assume a straightforward generalization of <a class="docLink" href="#ch09ex14">Program 9.7</a>; then, assume that Floyd's method can save one comparison in the inner loop.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa5q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">9.33</span> For <span class="docEmphasis">N</span> = 32, give an arrangement of keys that makes heapsort use as many comparisons as possible.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa5q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">9.34</span> For <span class="docEmphasis">N</span> = 32, give an arrangement of keys that makes heapsort use as few comparisons as possible.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa5q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.35</span> Prove that building a priority queue of size <span class="docEmphasis">k</span> then doing <span class="docEmphasis">N &ndash; k</span> <span class="docEmphasis">replace the minimum</span> (<span class="docEmphasis">insert</span> followed by <span class="docEmphasis">remove the minimum</span>) operations leaves the <span class="docEmphasis">k</span> largest of the <span class="docEmphasis">N</span> elements in the heap.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa5q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.36</span> Implement both of the versions of heapsort-based selection referred to in the discussion of <a class="docLink" href="#ch09ex16">Property 9.6</a>, using the method described in <a class="docLink" href="ch09lev1sec3.html#ch09qa4q5">Exercise 9.25</a>. Compare the number of comparisons they use empirically with the quicksort-based method from <a class="docLink" href="ch07.html#ch07">Chapter 7</a>, for <span class="docEmphasis">N</span> = 10<sup>6</sup> and <span class="docEmphasis">k =</span> 10, 100, 1000, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa5q10"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">9.37</span> Implement a version of heapsort based on the idea of representing the heap-ordered tree in preorder rather than in level order. Empirically compare the number of comparisons used by this version with the number used by the standard implementation, for randomly ordered keys with <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></body></head></html>