<html><head><title>14.5. Dynamic Hash Tables</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch14lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch14lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch14lev1sec5"></a>
<h3 id="title-IDAHMK4B" class="docSection1Title">14.5. Dynamic Hash Tables</h3>
<p class="docText">As the number of keys in a hash table increases, search performance degrades. With separate chaining, the search time increases gradually&mdash;when the number of keys in the table doubles, the search time doubles. The same is true of open-addressing methods such as linear probing and double hashing for sparse tables, but the cost increases dramatically as the table fills up, and, worse, we reach a point where no more keys can be inserted at all. This situation is in contrast to search trees, which accommodate growth naturally. For example, in a red-black tree, the search cost increases only slightly (by one comparison) whenever the number of nodes in the tree doubles.</p>
<p class="docText">One way to accomplish growth in a hash table is to double the table's size when it begins to fill up. Doubling the table is an expensive operation because everything in the table has to be reinserted, but it is an operation that is performed infrequently. <a class="docLink" href="#ch14ex12">Program 14.7</a> is an implementation of growth by doubling for linear probing. An example is depicted in <a class="docLink" href="#ch14fig12">Figure 14.12</a>. The same solution also works for double hashing, and the basic idea applies to separate chaining as well (see <a class="docLink" href="#ch14qa5q7">Exercise 14.46</a>). Each time that the table gets more than half full, we expand the table by doubling it in size. After the first expansion, the table is always between one-quarter and one-half full, so the search cost is less than three probes, on the average. Furthermore, although the operation of rebuilding the table is expensive, it happens <a name="iddle1062"></a><a name="iddle1577"></a><a name="iddle1595"></a><a name="iddle1779"></a>so infrequently that its cost represents only a constant fraction of the total cost of building the table.</p>
<a name="ch14fig12"></a><p><center>
<h5 class="docFigureTitle">Figure 14.12. Dynamic hash-table expansion</h5>
<h5></h5><h5></h5></center></p><p class="docText">This diagram shows the process of inserting the keys <span class="docEmphasis">A S E R C H I N G X M P L</span> into a dynamic hash table that expands by doubling, using the hash values given at the top and resolving collisions with linear probing. The four rows beneath the keys give the hash values when the table size is 4, 8, 16, and 32. The table size starts at 4, doubles to 8 for the <span class="docEmphasis">E</span>, to 16 for the <span class="docEmphasis">C</span> and to 32 for the <span class="docEmphasis">G</span>. All keys are rehashed and reinserted when the table size doubles. All insertions are into sparse tables (less than one-quarter full for reinsertion, between one-quarter and one-half full otherwise), so there are few collisions.</p>
<p class="docText">
<img border="0" alt="" width="475" height="297" src="14fig12.gif" /></p>
<br />
<a name="ch14ex12"></a><h5 id="title-IDAPPK4B" class="docExampleTitle">Program 14.7. Dynamic hash insertion (for linear probing)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This implementation of insert for linear probing (see <a class="docLink" href="ch14lev1sec3.html#ch14ex06">Program 14.4</a>) handles an arbitrary number of keys by doubling the size of the table each time that the table becomes half full (this same approach can be used for double hashing or separate chaining). Doubling requires that we allocate memory for the new table, rehash all the keys into the new table, then free the memory for the old table. Member function init is used to construct or to reconstruct a table filled with null items of a specified size: it is implemented in the same way as the ST constructor in <a class="docLink" href="ch14lev1sec3.html#ch14ex06">Program 14.4</a>, so the code is omitted.</p>
<div class="docText"><pre>   private:
     void expand()
       { Item *t = st;
         init(M+M);
         for (int i = 0; i &lt; M/2; i++)
           if (!t[i].null()) insert(t[i]);
         delete t;
       }
   public:
     ST(int maxN)
       { init(4); }
     void insert(Item item)
       { int i = hash(item.key(), M);
         while (!st[i].null()) i = (i+1) % M;
         st[i] = item;
         if (N++ &gt;= M/2) expand();
       }</pre></div><br />
</td></tr></table></p>
<p class="docText">Another way to express this concept is to say that the average cost <span class="docEmphasis">per insertion</span> is less than four probes. This assertion is not the same as saying that each insertion requires less than four probes on the average; indeed, we know that those insertions that cause the table to double will require a large number of probes. This argument is a simple example of <span class="docEmphasis">amortized analysis</span>: We cannot guarantee that each and every operation will be fast for this algorithm, but we can guarantee that the average cost per operation will be low.</p>
<p class="docText"><a name="iddle1593"></a>Although the total cost is low, the performance profile for insertions is erratic: Most operations are extremely fast, but certain rare operations require about as much time as the whole previous cost of building the table. As a table grows from 1 thousand to 1 million keys, this slowdown will happen about 10 times. This kind of behavior is acceptable in many applications, but it might not be appropriate when absolute performance guarantees are desirable or required. For example, while a bank or an airline might be willing to suffer the consequences of keeping a customer waiting for so long on 10 out of every 1 million transactions, long waits might be catastrophic in other applications, such as an online system implementing a large financial transaction-processing system or in an air-traffic control system.</p>
<p class="docText">If we support the <span class="docEmphasis">remove</span> ADT operation, then it may be worthwhile to contract the table by halving it as it shrinks (see <a class="docLink" href="#ch14qa5q5">Exercise 14.44</a>), with one proviso: The thresholds for shrinking have to be separated from those for growing, because otherwise a small number of <span class="docEmphasis">insert</span> and <span class="docEmphasis">remove</span> operations could cause a sequence of doubling and halving operations even for huge tables.</p>
<a name="ch14ex13"></a><h5 id="title-IDA4RK4B" class="docExampleTitle">Property 14.6. A sequence of <span class="docEmphasis">t</span> search, insert, and delete symbol-table operations can be executed in time proportional to <span class="docEmphasis">t</span> and with memory usage always within a constant factor of the number of keys in the table</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We use linear probing with growth by doubling whenever an <span class="docEmphasis">insert</span> causes the number of keys in the table to be half the table size, and we use shrinkage by halving whenever a <span class="docEmphasis">remove</span> causes the number of keys in the table to be one-eighth the table size. In both cases, after the table is rebuilt to size <span class="docEmphasis">N</span>, it has <span class="docEmphasis">N</span>/4 keys. Then, <span class="docEmphasis">N</span>/4 <span class="docEmphasis">insert</span> operations must be executed before the table doubles again (by reinsertion of <span class="docEmphasis">N</span>/2 keys into a table of size 2<span class="docEmphasis">N</span>), and <span class="docEmphasis">N</span>/8 <span class="docEmphasis">remove</span> operations must be executed before the table halves again (by reinsertion of <span class="docEmphasis">N</span>/8 keys into a table of size <span class="docEmphasis">N</span>/2). In both cases, the number of keys reinserted is within a factor of 2 of the number of operations that we performed to bring the table to the point of being rebuilt, so the total cost is linear. Furthermore, the table is always between one-eighth and one-fourth full (see <a class="docLink" href="#ch14fig13">Figure 14.13</a>), so the average number of probes for each operation is less than 3, by <a class="docLink" href="ch14lev1sec4.html#ch14ex10">Property 14.4</a>.</p>
</td></tr></table></p>
<a name="ch14fig13"></a><p><center>
<h5 class="docFigureTitle">Figure 14.13. Dynamic hashing</h5>
<h5></h5><h5></h5></center></p><p class="docText">This diagram shows the number of keys in the table <span class="docEmphasis">(bottom)</span> and the table size <span class="docEmphasis">(top)</span> when we insert keys into and remove them from a dynamic hash table using an algorithm that doubles the table when an insert makes it half full and halves the table when a removal makes it one-eighth full. The table size is initialized at 4 and is always a power of 2 (dotted lines in the figure are at powers of 2). The table size changes when the curve tracing the number of keys in the table crosses a dotted line for the first time after having crossed a different dotted line. The table is always between one-eighth and one-half full.</p>
<p class="docText">
<img border="0" alt="" width="300" height="97" src="14fig13.gif" /></p>
<br />
<p class="docText">This method is appropriate for use in a symbol-table implementation for a general library where usage patterns are unpredictable, because it can handle tables of all sizes in a reasonable way. The primary drawback is the cost of rehashing and allocating memory when the table expands and shrinks; in the typical case, when searches predominate, the guarantee that the table is sparse leads to excellent performance. In <a class="docLink" href="ch16.html#ch16">Chapter 16</a>, we shall consider another approach that avoids rehashing and is suitable for huge external search tables.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa5q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">14.40</span> Give the contents of the hash table that results when you insert items with the keys E A S Y Q U T I O N in that order into an initially empty table of initial size <span class="docEmphasis">M</span> = 4 that is expanded with doubling whenever half full, with collisions resolved using linear probing. Use the hash function 11<span class="docEmphasis">k</span> mod <span class="docEmphasis">M</span> to transform the <span class="docEmphasis">k</span>th letter of the alphabet into a table index.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa5q2"></a><b></b></td><td><p class="docText"><a name="iddle1588"></a><span class="docEmphStrong">14.41</span> Would it be more economical to expand a hash table by tripling (rather than doubling) the table in size when the table is half full?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa5q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.42</span> Would it be more economical to expand a hash table by tripling the table in size when the table is one-third full (rather than doubling the table in size when the table is half full)?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa5q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.43</span> Would it be more economical to expand a hash table by doubling the table in size when the table is three-quarters (rather than half) full?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa5q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.44</span> Add to <a class="docLink" href="#ch14ex12">Program 14.7</a> a <span class="docEmphasis">remove</span> function that deletes an item as in <a class="docLink" href="ch14lev1sec3.html#ch14ex06">Program 14.4</a> but then contracts the table by halving it if the deletion leaves it seven-eighths empty.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa5q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">14.45</span> Implement a version of <a class="docLink" href="#ch14ex12">Program 14.7</a> for separate chaining that increases the table size by a factor of 10 each time the average list length is equal to 10.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa5q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.46</span> Modify <a class="docLink" href="#ch14ex12">Program 14.7</a> and your implementation from <a class="docLink" href="#ch14qa5q5">Exercise 14.44</a> to use double hashing with lazy deletion (see <a class="docLink" href="ch14lev1sec4.html#ch14qa4q3">Exercise 14.33</a>). Make sure that your program takes into account the number of dummy items, as well as the number of empty positions, in making the decisions whether to expand or contract the table.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch14qa5q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">14.47</span> Develop a symbol-table implementation using linear probing with dynamic tables that includes a destructor, a copy constructor, and an overloaded assignment operator, and supports the <span class="docEmphasis">construct</span>, <span class="docEmphasis">count</span>, <span class="docEmphasis">search</span>, <span class="docEmphasis">insert</span>, <span class="docEmphasis">remove</span>, and <span class="docEmphasis">join</span> operations for a first-class symbol-table ADT, with support for client handles (see <a class="docLink" href="ch12lev1sec1.html#ch12qa1q6">Exercises 12.6</a> and <a class="docLink" href="ch12lev1sec1.html#ch12qa1q7">12.7</a>).</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch14lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch14lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>