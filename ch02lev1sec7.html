<html><head><title>2.7. Guarantees, Predictions, and Limitations</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch02lev1sec6.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch02lev2sec1.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch02lev1sec7"></a>
<h3 id="title-IDAKPKYJ" class="docSection1Title">2.7. Guarantees, Predictions, and Limitations</h3>
<p class="docText"><a name="iddle1425"></a>The running time of most algorithms depends on their input data. Typically, our goal in the analysis of algorithms is somehow to eliminate that dependence: We want to be able to say something about the performance of our programs that depends on the input data to as little an extent as possible, because we generally do not know what the input data will be each time the program is invoked. The examples in <a class="docLink" href="ch02lev1sec6.html#ch02lev1sec6">Section 2.6</a> illustrate the two major approaches that we use toward this end: worst-case analysis and average-case analysis.</p>
<p class="docText"><a name="iddle1038"></a><a name="iddle1104"></a><a name="iddle1668"></a><a name="iddle2303"></a><a name="iddle2626"></a>Studying the <span class="docEmphasis">worst-case</span> performance of algorithms is attractive because it allows us to make <span class="docEmphasis">guarantees</span> about the running time of programs. We say that the number of times certain abstract operations are executed is less than a certain function of the number of inputs, no matter what the input values are. For example, <a class="docLink" href="ch02lev1sec6.html#ch02ex06">Property 2.3</a> is an example of such a guarantee for binary search, as is <a class="docLink" href="ch01lev1sec3.html#ch01ex06">Property 1.3</a> for weighted quick union. If the guarantees are low, as is the case with binary search, then we are in a favorable situation, because we have eliminated cases for which our program might run slowly. Programs with good worst-case performance characteristics are a basic goal in algorithm design.</p>
<p class="docText">There are several difficulties with worst-case analysis, however. For a given algorithm, there might be a significant gap between the time required for it to solve a worst-case instance of the input and the time required for it to solve the data that it might encounter in practice. For example, quick union requires time proportional to <span class="docEmphasis">N</span> in the worst case, but only <span class="docEmphRoman">log</span> <span class="docEmphasis">N</span> for typical data. More important, we cannot always prove that there is an input for which the running time of an algorithm achieves a certain bound; we can prove only that it is guaranteed to be lower than the bound. Moreover, for some problems, algorithms with good worst-case performance are significantly more complicated than are other algorithms. We often find ourselves in the position of having an algorithm with good worst-case performance that is slower than simpler algorithms for the data that occur in practice, or that is not sufficiently faster that the extra effort required to achieve good worst-case performance is justified. For many applications, other considerations&mdash;such as portability or reliability&mdash;are more important than improved worst-case performance guarantees. For example, as we saw in <a class="docLink" href="ch01.html#ch01">Chapter 1</a>, weighted quick union with path compression provides provably better performance guarantees than weighted quick union, but the algorithms have about the same running time for typical practical data.</p>
<p class="docText">Studying the <span class="docEmphasis">average-case</span> performance of algorithms is attractive because it allows us to make <span class="docEmphasis">predictions</span> about the running time of programs. In the simplest situation, we can characterize precisely the inputs to the algorithm; for example, a sorting algorithm might operate on an array of <tt>N</tt> random integers, or a geometric algorithm might process a set of <tt>N</tt> random points in the plane with coordinates <a name="iddle1052"></a><a name="iddle2221"></a>between 0 and 1. Then, we calculate the average number of times that each instruction is executed, and calculate the average running time of the program by multiplying each instruction frequency by the time required for the instruction and adding them all together.</p>
<p class="docText">There are also several difficulties with average-case analysis, however. First, the input model may not accurately characterize the inputs encountered in practice, or there may be no natural input model at all. Few people would argue against the use of input models such as &quot;randomly ordered file&quot; for a sorting algorithm, or &quot;random point set&quot; for a geometric algorithm, and for such models it is possible to derive mathematical results that can predict accurately the performance of programs running on actual applications. But how should one characterize the input to a program that processes English-language text? Even for sorting algorithms, models other than randomly ordered inputs are of interest in certain applications. Second, the analysis might require deep mathematical reasoning. For example, the average-case analysis of union-find algorithms is difficult. Although the derivation of such results is normally beyond the scope of this book, we will illustrate their nature with a number of classical examples, and we will cite relevant results when appropriate (fortunately, many of our best algorithms have been analyzed in the research literature). Third, knowing the average value of the running time might not be sufficient: we may need to know the standard deviation or other facts about the distribution of the running time, which may be even more difficult to derive. In particular, we are often interested in knowing the chance that the algorithm could be dramatically slower than expected.</p>
<p class="docText">In many cases, we can answer the first objection listed in the previous paragraph by turning randomness to our advantage. For example, if we randomly scramble an array before attempting to sort it, then the assumption that the elements in the array are in random order is accurate. For such algorithms, which are called <span class="docEmphasis">randomized algorithms</span>, the average-case analysis leads to predictions of the expected running time in a strict probabilistic sense. Moreover, we are often able to prove that the probability that such an algorithm will be slow is negligibly small. Examples of such algorithms include quicksort (see <a class="docLink" href="ch09.html#ch09">Chapter 9</a>), randomized BSTs (see <a class="docLink" href="ch13.html#ch13">Chapter 13</a>), and hashing (see <a class="docLink" href="ch14.html#ch14">Chapter 14</a>).</p>
<p class="docText"><a name="iddle1040"></a><a name="iddle1237"></a><a name="iddle1290"></a><a name="iddle1515"></a><a name="iddle1842"></a><a name="iddle1992"></a><a name="iddle2607"></a><a name="iddle2627"></a>The field of <span class="docEmphasis">computational complexity</span> is the branch of analysis of algorithms that helps us to understand the fundamental <span class="docEmphasis">limitations</span>that we can expect to encounter when designing algorithms. The overall goal is to determine the worst-case running time of the <span class="docEmphasis">best</span>algorithm to solve a given problem, to within a constant factor. This function is called the <span class="docEmphasis">complexity</span> of the problem.</p>
<p class="docText">Worst-case analysis using the <span class="docEmphasis">O</span>-notation frees the analyst from considering the details of particular machine characteristics. The statement that the running time of an algorithm is <span class="docEmphasis">O</span>(<span class="docEmphasis">f</span>(<span class="docEmphasis">N</span>)) is independent of the input and is a useful way to categorize algorithms in a way that is independent of both inputs and implementation details, separating the analysis of an algorithm from any particular implementation. We ignore constant factors in the analysis; in most cases, if we want to know whether the running time of an algorithm is proportional to <span class="docEmphasis">N</span> or proportional to <span class="docEmphRoman">log</span> <span class="docEmphasis">N</span>, it does not matter whether the algorithm is to be run on a nanocomputer or on a supercomputer, and it does not matter whether the inner loop has been implemented carefully with only a few instructions or badly implemented with many instructions.</p>
<p class="docText">When we can prove that the worst-case running time of an algorithm to solve a certain problem is <span class="docEmphasis">O</span>(<span class="docEmphasis">f</span>(<span class="docEmphasis">N</span>)), we say that <span class="docEmphasis">f</span>(<span class="docEmphasis">N</span>) is an <span class="docEmphasis">upper bound</span> on the complexity of the problem. In other words, the running time of the best algorithm to solve a problem is no higher than the running time of any particular algorithm to solve the problem.</p>
<p class="docText">We constantly strive to improve our algorithms, but we eventually reach a point where no change seems to improve the running time. For every given problem, we are interested in knowing when to stop trying to find improved algorithms, so we seek <span class="docEmphasis">lower bounds</span> on the complexity. For many problems, we can prove that <span class="docEmphasis">any</span> algorithm to solve the problem must use a certain number of fundamental operations. Proving lower bounds is a difficult matter of carefully constructing a machine model and then developing intricate theoretical constructions of inputs that are difficult for any algorithm to solve. We rarely touch on the subject of proving lower bounds, but they represent computational barriers that guide us in the design of algorithms, so we maintain awareness of them when they are relevant.</p>
<p class="docText">When complexity studies show that the upper bound of an algorithm matches the lower bound, then we have some confidence that it is fruitless to try to design an algorithm that is fundamentally faster <a name="iddle2046"></a><a name="iddle2507"></a><a name="iddle2621"></a>than the best known, and we can start to concentrate on the implementation. For example, binary search is optimal, in the sense that no algorithm that uses comparisons exclusively can use fewer comparisons in the worst case than binary search.</p>
<p class="docText">We also have matching upper and lower bounds for pointer-based union-find algorithms. <a class="docLink" href="ch02lev2sec1.html#biblio02_010">Tarjan</a> showed in 1975 that weighted quick union with path compression requires following less than <span class="docEmphasis">O</span>(<tt>lg<sup>*</sup></tt> <span class="docEmphasis">V</span>) pointers in the worst case, and that any pointer-based algorithm must follow more than a constant number of pointers in the worst case for some input. In other words, there is no point looking for some new improvement that will guarantee to solve the problem with a linear number of <tt>i = a[i]</tt> operations. In practical terms, this difference is hardly significant, because <tt>lg<sup>*</sup></tt> <span class="docEmphasis">V</span> is so small; still, finding a simple linear algorithm for this problem was a research goal for many years, and Tarjan's lower bound has allowed researchers to move on to other problems. Moreover, the story shows that there is no avoiding functions like the rather complicated <tt>log<sup>*</sup></tt> function, because such functions are intrinsic to this problem.</p>
<p class="docText">Many of the algorithms in this book have been subjected to detailed mathematical analyses and performance studies far too complex to be discussed here. Indeed, it is on the basis of such studies that we are able to recommend many of the algorithms that we discuss.</p>
<p class="docText">Not all algorithms are worthy of such intense scrutiny; indeed, during the design process, it is preferable to work with approximate performance indicators to guide the design process without extraneous detail. As the design becomes more refined, so must the analysis, and more sophisticated mathematical tools need to be applied. Often, the design process leads to detailed complexity studies that lead to theoretical algorithms that are rather far from any particular application. It is a common mistake to assume that rough analyses from complexity studies will translate immediately into efficient practical algorithms; such assumptions can lead to unpleasant surprises. On the other hand, computational complexity is a powerful tool that tells us when we have reached performance limits in our design work and that can suggest departures in design in pursuit of closing the gap between upper and lower bounds.</p>
<p class="docText">In this book, we take the view that algorithm design, careful implementation, mathematical analysis, theoretical studies, and empirical analysis all contribute in important ways to the development of elegant and efficient programs. We want to gain information about the properties of our programs using any tools at our disposal, then to modify or develop new programs on the basis of that information. We will not be able to do exhaustive testing and analysis of every algorithm that we run in every programming environment on every machine, but we can use careful implementations of algorithms that we know to be efficient, then refine and compare them when peak performance is necessary. Throughout the book, when appropriate, we shall consider the most important methods in sufficient detail to appreciate why they perform well.</p>
<p class="docQandasetTitle">Exercise</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa7q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">2.51</span> You are given the information that the time complexity of one problem is <span class="docEmphasis">N</span> <tt>log</tt> <span class="docEmphasis">N</span> and that the time complexity of another problem is <span class="docEmphasis">N</span><sup>3</sup>. What does this statement imply about the relative performance of specific algorithms that solve the problems?</p></td></tr></table></p>
<a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch02lev1sec6.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch02lev2sec1.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>