<html><head><title>6.9. Sorting of Linked Lists</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch06lev1sec8.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch06lev1sec10.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch06lev1sec9"></a>
<h3 id="title-IDA52EWD" class="docSection1Title">6.9. Sorting of Linked Lists</h3>
<p class="docText">As we know from <a class="docLink" href="ch03.html#ch03">Chapter 3</a>, arrays and linked lists provide two of the most basic ways to structure data, and we considered an implementation of insertion sort for linked lists as a list-processing example in <a class="docLink" href="ch03lev1sec4.html#ch03lev1sec4">Section 3.4</a> (<a class="docLink" href="ch03lev1sec4.html#ch03ex14">Program 3.11</a>). The sort implementations that we have considered to this point all assume that the data to be sorted is in an array, and are not directly applicable if we are working within a system that uses linked lists to organize data. In some cases, the <span class="docEmphasis">algorithms</span> may be useful, but only if they process data in the essentially sequential manner that we can support efficiently for linked lists.</p>
<p class="docText"></p><a name="ch06ex28"></a><h5 id="title-IDAH4EWD" class="docExampleTitle">Program 6.15. Linked-list&ndash;type interface definition</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This interface for linked lists can be contrasted with the one for arrays in <a class="docLink" href="ch06lev1sec7.html#ch06ex20">Program 6.7</a>. The <tt>randlist</tt> function builds a list of random items, including storage allocation. The <tt>showlist</tt> function prints out the keys in the list. Sorting programs use overloaded <tt>operator&lt;</tt> to compare items and manipulate pointers to rearrange the items. The data representation for nodes is specified in the usual way (see <a class="docLink" href="ch03.html#ch03">Chapter 3</a>), and includes a constructor for nodes that fills in each new node with the given value and a null link.</p>
<div class="docText"><pre>struct node
  { Item item; node* next;
    node(Item x)
      { item = x; next = 0; }
  };
typedef node *link;
link randlist(int);
link scanlist(int&amp;);
void showlist(link);
link sortlist(link);</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch06ex28">Program 6.15</a> gives an interface, which is similar to <a class="docLink" href="ch06lev1sec7.html#ch06ex20">Program 6.7</a>, for a <span class="docEmphasis">linked-list</span> data type. With <a class="docLink" href="#ch06ex28">Program 6.15</a>, the driver program corresponding to <a class="docLink" href="ch06lev1sec7.html#ch06ex19">Program 6.6</a> is a one-liner:</p>
<div class="docText"><pre>main(int argc, char *argv[])
  { showlist(sortlist(scanlist(atoi(argv[1])))); }</pre></div><br />
<p class="docText">Most of the work (including allocation of memory) is left to the linked-list and <tt>sort</tt> implementations. As we did with with our array driver, we want to initialize the list (either from standard input or with random values), to show the contents of the list, and, of course, to sort it. As usual, we use an <tt>Item</tt> for the data type of the items being sorted, just as we did in <a class="docLink" href="ch06lev1sec7.html#ch06lev1sec7">Section 6.7</a>. The code to implement the routines for this interface is standard for linked lists of the kind that we examined in detail in <a class="docLink" href="ch03.html#ch03">Chapter 3</a>, and left as an exercise.</p>
<p class="docText">This interface is a low-level one that does not make a distinction between a link (a pointer to a node) and a linked list (a pointer that is either <tt>0</tt> or a pointer to a node containing a pointer to a list). Alternatively, we might choose to use a first-class ADT for lists and <a name="iddle1963"></a><a name="iddle2334"></a>implementations that precisely specify dummy-node conventions, and so forth. The low-level approach that we are using makes it easier to concentrate on the link manipulations that characterize the algorithms and data structures themselves, our prime focus in this book.</p>
<p class="docText">There is a ground rule for manipulating linked structures that is critical in many applications, but is not always evident from our code. In a more complex environment, it could be the case that pointers to the list nodes that we are manipulating are maintained by other parts of the applications system (i.e., they are in multilists). The possibility that nodes could be referenced through pointers that are maintained outside the sort means that our programs should <span class="docEmphasis">change only links in nodes, and should not alter keys or other information</span>. For example, when we want to do an exchange, it would seem simplest just to exchange items (as we did when sorting arrays). But then any reference to either node through some other link would find the value changed, and probably will not have the desired effect. We need to change the links themselves such that the nodes appear in sorted order when the list is traversed via the links we have access to, without affecting their order when accessed via any other links. Doing so makes the implementations more difficult, but usually is necessary.</p>
<p class="docText">We can adapt insertion, selection, and bubble sort to linked-list implementations, although each one presents amusing challenges.</p>
<p class="docText"></p><a name="ch06ex29"></a><h5 id="title-IDARCFWD" class="docExampleTitle">Program 6.16. Linked-list selection sort</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Selection sort of a linked list is straightforward, but differs slightly from the array version because it is easier to insert at the front of a list. We maintain an input list (pointed to by <tt>h-&gt;next</tt>), and an output list (pointed to by <tt>out</tt>). While it is nonempty, we scan the input list to find the maximum remaining element, then remove that element from the input list and insert it at the front of the output list. This implementation uses an auxiliary routine <tt>findmax</tt>, which returns a link to the node whose link points to the maximum element on a list (see <a class="docLink" href="ch03lev1sec4.html#ch03qa4q2">Exercise 3.34</a>).</p>
<div class="docText"><pre>link listselection(link h)
  { node dummy(0); link head = &amp;dummy, out = 0;
    head-&gt;next = h;
    while (head-&gt;next != 0)
      { link max = findmax(head), t = max-&gt;next;
        max-&gt;next = t-&gt;next;
        t-&gt;next = out; out = t;
      }
    return out;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">Selection sort is straightforward: We maintain an input list (which initially has the data) and an output list (which collects the sorted result), and simply scan through the list to find the maximum element in the input list, remove it from the list, and add it to the front of the output list (see <a class="docLink" href="#ch06fig16">Figure 6.16</a>). Implementing this operation is a simple exercise in linked-list manipulation, and is a useful method for sorting short lists. An implementation is given in <a class="docLink" href="#ch06ex29">Program 6.16</a>. We leave the other methods for exercises.</p>
<a name="ch06fig16"></a><p><center>
<h5 class="docFigureTitle">Figure 6.16. Linked-list selection sort</h5>
<h5></h5><h5></h5></center></p><p class="docText">This diagram depicts one step of selection sort for linked lists. We maintain an input list, pointed to by <tt>h-&gt;next</tt>, and an output list, pointed to by <tt>out</tt> (top). We scan through the input list to make <tt>max</tt> point to the node before (and <tt>t</tt> point to) the node containing the maximum item. These are the pointers we need to remove <tt>t</tt> from the input list (reducing its length by 1) and put it at the front of the output list (increasing its length by 1), keeping the output list in order (bottom). Iterating, we eventually exhaust the input list and have the nodes in order in the output list.</p>
<p class="docText">
<img border="0" alt="" width="400" height="322" src="06fig16.gif" /></p>
<br />
<p class="docText">In some list-processing situations, we may not need to explicitly implement a sort at all. For example, we could choose to keep the list in order at all times, inserting new nodes into the list as in insertion sort. This approach comes at little extra cost if insertions are relatively rare or the list is small, and in certain other situations. For example, we might need to scan the whole list for some reason before inserting new nodes (perhaps to check for duplicates). We shall discuss an algorithm that uses ordered linked lists in <a class="docLink" href="ch14.html#ch14">Chapter 14</a>, and we shall see numerous data structures that gain efficiency from order in the data in <a class="docLink" href="ch12.html#ch12">Chapters 12</a> and <a class="docLink" href="ch14.html#ch14">14</a>.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa9q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">6.64</span> Give the contents of the input list and output list as <a class="docLink" href="#ch06ex29">Program 6.16</a> is used for the keys <tt>A S O R T I N G E X A M P L E</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa9q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.65</span> Provide an implementation for the linked-list interface given in <a class="docLink" href="#ch06ex28">Program 6.15</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa9q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.66</span> Implement a performance-driver client program for linked-list sorts (see <a class="docLink" href="ch06lev1sec1.html#ch06qa1q9">Exercise 6.9</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa9q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">6.67</span> Develop a first-class ADT for linked lists (see <a class="docLink" href="ch04lev1sec8.html#ch04lev1sec8">Section 4.8</a>) that includes a constructor for random initialization, a constructor for initialization via overloaded <tt>operator&lt;&lt;</tt>, output via overloaded <tt>operator&gt;&gt;</tt>, a destructor, a copy constructor, and a <tt>sort</tt> member function. Use selection sort to implement <tt>sort</tt>, with <tt>findmax</tt> as a private member function.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa9q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.68</span> Implement bubble sort for a linked list. <span class="docEmphasis">Caution</span>: exchanging two adjacent elements on a linked list is more difficult than it seems at first.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa9q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">6.69</span> Package the insertion-sort code in <a class="docLink" href="ch03lev1sec4.html#ch03ex14">Program 3.11</a> such that it has the same functionality as <a class="docLink" href="#ch06ex29">Program 6.16</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa9q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.70</span> The insertion-sort method used in <a class="docLink" href="ch03lev1sec4.html#ch03ex14">Program 3.11</a> makes the linked-list insertion sort run significantly slower than the array version for some input files. Describe one such file, and explain the problem.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa9q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">6.71</span> Implement a linked-list version of shellsort that does not use significantly more time or space than the array version for large random files. <span class="docEmphasis">Hint</span>: Use bubble sort.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa9q9"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">6.72</span> Implement an ADT for <span class="docEmphasis">sequences</span>, which allows us to use a single client program to debug both linked-list and array sort implementations. That is, client programs can create a sequence with N items (either generated randomly or filled from standard input), sort the sequence, or show its contents. For example, your ADT, in the file <tt>SEQ.cxx</tt>, should work with the following code:</p>
<div class="docText"><pre>#include "Item.h"
#include "SEQ.cxx"
main(int argc, char *argv[])
  { int N = atoi(argv[1]), sw = atoi(argv[2]);
    if (sw) SEQrand(N); else SEQscan();
    SEQsort();
    SEQshow();
  }</pre></div><br />
<p class="docText">Provide one implementation that uses an array representation and another that uses a linked-list representation. Use selection sort.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa9q10"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">6.73</span> Extend your implementation from <a class="docLink" href="#ch06qa9q9">Exercise 6.72</a> such that it is a first-class ADT. <span class="docEmphasis">Hint</span>: Look for a solution in the Standard Template Library.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch06lev1sec8.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch06lev1sec10.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>