<html><head><title>4.4. Stack ADT Implementations</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch04lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch04lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch04lev1sec4"></a>
<h3 id="title-IDA5GQZM" class="docSection1Title">4.4. Stack ADT Implementations</h3>
<p class="docText">In this section, we consider two implementations of the stack ADT: one using arrays and one using linked lists. The implementations are both straightforward applications of the basic tools that we covered <a name="iddle1095"></a><a name="iddle2131"></a>in <a class="docLink" href="ch03.html#ch03">Chapter 3</a>. They differ only, we expect, in their performance characteristics.</p>
<a name="ch04ex09"></a><h5 id="title-IDAKIQZM" class="docExampleTitle">Program 4.7. Array implementation of a pushdown stack</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">When there are <span class="docEmphasis">N</span> items in the stack, this implementation keeps them in <tt>s[0],. . .,s[N-1]</tt>, in order from least recently inserted to most recently inserted. The top of the stack (the position where the next item to be pushed will go) is <tt>s[N]</tt>. The client program passes the maximum number of items expected on the stack as the argument to the constructor for <tt>STACK</tt>, which allocates an array of that size, but this code does not check for errors such as pushing onto a full stack (or popping an empty one).</p>
<div class="docText"><pre>template &lt;class Item&gt;
class STACK
  {
    private:
      Item *s; int N;
    public:
      STACK(int maxN)
        { s = new Item[maxN]; N = 0; }
      int empty() const
        { return N == 0; }
      void push(Item item)
        { s[N++] = item; }
      Item pop()
        { return s[--N]; }
  };</pre></div><br />
</td></tr></table></p>
<p class="docText">If we use an array to represent the stack, each of the functions declared in <a class="docLink" href="ch04lev1sec2.html#ch04ex06">Program 4.4</a> is trivial to implement, as shown in <a class="docLink" href="#ch04ex09">Program 4.7</a>. We put the items in the array precisely as diagrammed in <a class="docLink" href="ch04lev1sec2.html#ch04fig01">Figure 4.1</a>, keeping track of the index of the top of the stack. Doing the <span class="docEmphasis">push</span> operation amounts to storing the item in the array position indicated by the top-of-stack index, then incrementing the index; doing the <span class="docEmphasis">pop</span> operation amounts to decrementing the index, then returning the item that it designates. The <span class="docEmphasis">construct</span> operation (constructor) involves allocating an array of the indicated size, and the <span class="docEmphasis">test if empty</span> operation involves checking whether the index is 0. Compiled together with a <a name="iddle1441"></a><a name="iddle1815"></a><a name="iddle2139"></a>client program such as <a class="docLink" href="ch04lev1sec3.html#ch04ex07">Program 4.5</a> or <a class="docLink" href="ch04lev1sec3.html#ch04ex08">Program 4.6</a>, this implementation provides an efficient and effective pushdown stack.</p>
<p class="docText">We know one potential drawback to using an array representation: As is usual with data structures based on arrays, we need to know the maximum size of the array before using it, so that we can allocate memory for it. In this implementation, we make that information an argument to the constructor. This constraint is an artifact of our choice to use an array implementation; it is not an essential part of the stack ADT. We may have no easy way to estimate the maximum number of elements that our program will be putting on the stack: If we choose an arbitrarily high value, this implementation will make inefficient use of space, and that may be undesirable in an application where space is a precious resource. If we choose too small a value, our program might not work at all. By using an ADT, we make it possible to consider other alternatives, in other implementations, without changing any client program.</p>
<p class="docText">For example, to allow the stack to grow and shrink gracefully, we may wish to consider using a linked list, as in the implementation in <a class="docLink" href="#ch04ex10">Program 4.8</a>. We keep the stack in reverse order from the array implementation, from most recently inserted element to least recently inserted element, to make the basic stack operations easier to implement, as illustrated in <a class="docLink" href="#ch04fig05">Figure 4.5</a>. To <span class="docEmphasis">pop</span>, we remove the node from the front of the list and return its item; to <span class="docEmphasis">push</span>, we create a new node and add it to the front of the list. Because all linked-list operations are at the beginning of the list, we do not need to use a head node.</p>
<a name="ch04fig05"></a><p><center>
<h5 class="docFigureTitle">Figure 4.5. Linked-list pushdown stack</h5>
<h5></h5><h5></h5></center></p><p class="docText">The stack is represented by a pointer <span class="docEmphasis">head</span>, which points to the first (most recently inserted) item. To pop the stack <span class="docEmphasis">(top)</span>, we remove the item at the front of the list, by setting <span class="docEmphasis">head</span> from its link. To push a new item onto the stack <span class="docEmphasis">(bottom)</span>, we link it in at the beginning by setting its link field to <span class="docEmphasis">head</span>, then setting <span class="docEmphasis">head</span> to point to it.</p>
<p class="docText">
<img border="0" alt="" width="240" height="646" src="04fig05.gif" /></p>
<br />
<p class="docText">The code in <a class="docLink" href="#ch04ex10">Program 4.8</a> does not check for errors such as popping an empty stack, pushing onto a full stack, or running out of memory. To check for the latter two conditions, we have two options. We could treat them as separate errors, keeping track of the number of items on the list and, for each stack push, checking both that the count does not exceed the value passed as argument to the constructor and that <tt>new</tt> succeeds. Or, we might take the position that we do not need to know the maximum size of the stack ahead of time, and report a full stack only when <tt>new</tt> fails, ingoring the argument to the constructor (see <a class="docLink" href="#ch04qa5q4">Exercise 4.24</a>).</p>
<p class="docText"><a class="docLink" href="#ch04ex09">Programs 4.7</a> and <a class="docLink" href="#ch04ex10">4.8</a> are two different implementations for the same ADT. We can substitute one for the other without making <span class="docEmphasis">any</span> changes in client programs such as the ones that we examined in <a class="docLink" href="ch04lev1sec3.html#ch04lev1sec3">Section 4.3</a>. <a name="iddle1877"></a><a name="iddle2140"></a>They differ in only their performance characteristics. The array implementation uses the amount of space necessary to hold the maximum number of items expected throughout the computation; the list implementation uses space proportional to the number of items, but always uses extra space for one link per item and uses extra time, to allocate memory for each <span class="docEmphasis">push</span> and deallocate memory for each <span class="docEmphasis">pop</span>. If we need a huge stack that is usually nearly full, we might prefer the array implementation; if we have a stack whose size varies dramatically and other data structures that could make use of the space not <a name="iddle2143"></a>being used when the stack has only a few items in it, we might prefer the linked-list implementation.</p>
<a name="ch04ex10"></a><h5 id="title-IDA3PQZM" class="docExampleTitle">Program 4.8. Linked-list implementation of a pushdown stack</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This code implements the pushdown stack ADT using a linked list. The data representation for linked-list nodes is organized in the usual way (see <a class="docLink" href="ch03.html#ch03">Chapter 3</a>), and includes a constructor for nodes that fills in each new node with the given item and link.</p>
<div class="docText"><pre>template &lt;class Item&gt;
class STACK
  {
    private:
      struct node
        { Item item; node* next;
          node(Item x, node* t)
            { item = x; next = t; }
        };
      typedef node *link;
      link head;
  public:
    STACK(int)
      { head = 0; }
    int empty() const
      { return head == 0; }
    void push(Item x)
      { head = new node(x, head); }
    Item pop()
      { Item v = head-&gt;item; link t = head-&gt;next;
        delete head; head = t; return v; }
  };</pre></div><br />
</td></tr></table></p>
<p class="docText">These same considerations about space usage hold for many ADT implementations, as we shall see throughout the book. We often are in the position of choosing between the ability to access any item quickly but having to predict the maximum number of items needed ahead of time (in an array implementation) and the flexibility of always using space proportional to the number of items in use while giving up the ability to access every item quickly (in a linked-list implementation).</p>
<p class="docText">Beyond basic space-usage considerations, we normally are most interested in performance differences among ADT implementations that relate to running time. In this case, there is little difference between the two implementations that we have considered.</p>
<a name="ch04ex11"></a><h5 id="title-IDADZQZM" class="docExampleTitle">Property 4.1. <span class="docEmphasis">We can implement the</span> <span class="docEmphStrong">push</span> <span class="docEmphasis">and</span> <span class="docEmphStrong">pop</span> <span class="docEmphasis">operations for the pushdown stack ADT in constant time, using either arrays or linked lists</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This fact follows immediately from inspection of <a class="docLink" href="#ch04ex09">Programs 4.7</a> and <a class="docLink" href="#ch04ex10">4.8</a>.</p>
</td></tr></table></p>
<p class="docText">That the stack items are kept in different orders in the array and the linked-list implementations is of no concern to the client program. The implementations are free to use any data structure whatever, as long as they maintain the illusion of an abstract pushdown stack. In both cases, the implementations are able to create the illusion of an efficient abstract entity that can perform the requisite operations with just a few machine instructions. Throughout this book, our goal is to find data structures and efficient implementations for other important ADTs.</p>
<p class="docText">The linked-list implementation supports the illusion of a stack that can grow without bound. Such a stack is impossible in practical terms: at some point, <tt>new</tt> will raise an exception when the request for more memory cannot be satisfied. It is also possible to arrange for an array-based stack to grow and shrink dynamically, by doubling the size of the array when the stack becomes half full, and halving the size of the array when the stack becomes half empty. We leave the details of implementing such a strategy as an exercise in <a class="docLink" href="ch14.html#ch14">Chapter 14</a>, where we consider the process in detail for a more advanced application.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa5q1"></a><b></b></td><td><p class="docText"><a name="iddle1004"></a><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">4.21</span> Give the contents of <tt>s[0], ..., s[4]</tt> after the execution of the operations illustrated in <a class="docLink" href="ch04lev1sec2.html#ch04fig01">Figure 4.1</a>, using <a class="docLink" href="#ch04ex09">Program 4.7</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa5q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">4.22</span> Suppose that you change the pushdown-stack interface to replace <span class="docEmphasis">test if empty</span> by <span class="docEmphasis">count</span>, which should return the number of items currently in the data structure. Provide implementations for <span class="docEmphasis">count</span> for the array representation (<a class="docLink" href="#ch04ex09">Program 4.7</a>) and the linked-list representation (<a class="docLink" href="#ch04ex10">Program 4.8</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa5q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.23</span> Modify the array-based pushdown-stack implementation in the text (<a class="docLink" href="#ch04ex09">Program 4.7</a>) to call a member function <tt>error()</tt> if the client attempts to <span class="docEmphasis">pop</span> when the stack is empty or to <span class="docEmphasis">push</span> when the stack is full.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa5q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.24</span> Modify the linked-list&ndash;based pushdown-stack implementation in the text (<a class="docLink" href="#ch04ex10">Program 4.8</a>) to call a member function <tt>error()</tt> if the client attempts to <span class="docEmphasis">pop</span> when the stack is empty or if there is no memory available from <tt>new</tt> for a <span class="docEmphasis">push</span>.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa5q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.25</span> Modify the linked-list&ndash;based pushdown-stack implementation in the text (<a class="docLink" href="#ch04ex10">Program 4.8</a>) to use an array of indices to implement the list (see <a class="docLink" href="ch03lev1sec3.html#ch03fig04">Figure 3.4</a>).</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa5q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.26</span> Write a linked-list&ndash;based pushdown-stack implementation that keeps items on the list in order from least recently inserted to most recently inserted. You will need to use a doubly linked list.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa5q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">4.27</span> Develop an ADT that provides clients with two different pushdown stacks. Use an array implementation. Keep one stack at the beginning of the array and the other at the end. (If the client program is such that one stack grows while the other one shrinks, this implementation uses less space than other alternatives.)</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa5q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">4.28</span> Implement an infix-expression&ndash;evaluation function for integers that includes <a class="docLink" href="ch04lev1sec3.html#ch04ex07">Programs 4.5</a> and <a class="docLink" href="ch04lev1sec3.html#ch04ex08">4.6</a>, using your ADT from <a class="docLink" href="#ch04qa5q7">Exercise 4.27</a>. <span class="docEmphasis">Note</span>: You have to cope with the fact that both stacks have to contain items of the same type.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch04lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch04lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>