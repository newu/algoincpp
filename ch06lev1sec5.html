<html><head><title>6.5. Performance Characteristics of Elementary Sorts</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch06lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch06lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch06lev1sec5"></a>
<h3 id="title-IDAYT4XE" class="docSection1Title">6.5. Performance Characteristics of Elementary Sorts</h3>
<p class="docText">Selection sort, insertion sort, and bubble sort are all quadratic-time algorithms both in the worst and in the average case, and none requires extra memory. Their running times thus differ by only a constant factor, but they operate quite differently, as illustrated in <a class="docLink" href="#ch06fig05">Figures 6.5</a> through <a class="docLink" href="#ch06fig07">6.7</a>.</p>
<a name="ch06fig05"></a><p><center>
<h5 class="docFigureTitle">Figure 6.5. Dynamic characteristics of insertion and selection sorts</h5>
<h5></h5><h5></h5></center></p><p class="docText">These snapshots of insertion sort (left) and selection sort (right) in action on a random permutation illustrate how each method progresses through the sort. We represent an array being sorted by plotting <span class="docEmphasis">i</span> vs. <tt>a[i]</tt> for each <tt>i.</tt> Before the sort, the plot is uniformly random; after the sort, it is a diagonal line from bottom left to top right. Insertion sort never looks ahead of its current position in the array; selection sort never looks back.</p>
<p class="docText">
<img border="0" alt="" width="150" height="432" src="06fig05.gif" /></p>
<br />
<a name="ch06fig06"></a><p><center>
<h5 class="docFigureTitle">Figure 6.6. Comparisons and exchanges in elementary sorts</h5>
<h5></h5><h5></h5></center></p><p class="docText">This diagram highlights the differences in the way that insertion sort, selection sort, and bubble sort bring a file into order. The file to be sorted is represented by lines that are to be sorted according to their angles. Black lines correspond to the items accessed during each pass of the sort; gray lines correspond to items not touched. For insertion sort (left), the element to be inserted goes about halfway back through the sorted part of the file on each pass. Selection sort (center) and bubble sort (right) both go through the entire unsorted part of the array to find the next smallest element there for each pass; the difference between the methods is that bubble sort exchanges any adjacent out-of-order elements that it encounters, whereas selection sort just exchanges the minimum into position. The effect of this difference is that the unsorted part of the array becomes more nearly sorted as bubble sort progresses.</p>
<p class="docText">
<img border="0" alt="" width="300" height="507" src="06fig06.gif" /></p>
<br />
<a name="ch06fig07"></a><p><center>
<h5 class="docFigureTitle">Figure 6.7. Dynamic characteristics of two bubble sorts</h5>
<h5></h5><h5></h5></center></p><p class="docText">Standard bubble sort (left) operates in a manner similar to selection sort in that each pass brings one element into position, but it also brings some order into other parts of the array, in an asymmetric manner. Changing the scan through the array to alternate between beginning to end and end to beginning gives a version of bubble sort called shaker sort (right), which finishes more quickly (see <a class="docLink" href="#ch06qa5q5">Exercise 6.30</a>).</p>
<p class="docText">
<img border="0" alt="" width="120" height="346" src="06fig07.gif" /></p>
<br />
<p class="docText">Generally, the running time of a sorting algorithm is proportional to the number of comparisons that the algorithm uses, to the number of times that items are moved or exchanged, or to both. For random input, comparing the methods involves studying constant-factor differences in the numbers of comparisons and exchanges and constant-factor differences in the lengths of the inner loops. For input with special characteristics, the running times of the methods may differ by more than a constant factor. In this section, we look closely at the analytic results in support of this conclusion.</p>
<a name="ch06ex06"></a><h5 id="title-IDAXX4XE" class="docExampleTitle">Property 6.1. Selection sort uses about <span class="docEmphasis">N</span><sup>2</sup>/2 comparisons and <span class="docEmphasis">N</span> exchanges</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We can verify this property easily by examining the sample run in <a class="docLink" href="ch06lev1sec2.html#ch06fig02">Figure 6.2</a>, which is an <span class="docEmphasis">N</span>-by-<span class="docEmphasis">N</span> table in which unshaded letters correspond to comparisons. About one-half of the elements in the table are unshaded&mdash;those above the diagonal. The <span class="docEmphasis">N</span> &ndash; 1 (not the final <a name="iddle1243"></a><a name="iddle1669"></a><a name="iddle1673"></a><a name="iddle2377"></a><a name="iddle2389"></a>one) elements on the diagonal each correspond to an exchange. More precisely, examination of the code reveals that, for each <span class="docEmphasis">i</span> from <tt>1</tt> to <span class="docEmphasis">N</span> &ndash; 1, there is one exchange and <tt>N &ndash; i</tt> comparisons, so there is a total of <span class="docEmphasis">N</span> &ndash; 1 exchanges and (<span class="docEmphasis">N</span> &ndash; 1) + (<span class="docEmphasis">N</span> &ndash; 2) <tt>+...+ 2 + 1 = N(N &ndash; 1)/2</tt> comparisons. These observations hold no matter what the input data are; the only part of selection sort that does depend on the input is the number of times that <tt>min</tt> is updated. In the worst case, this quantity could also be quadratic; in the average case, however, it is just <span class="docEmphasis">O(N</span> log <span class="docEmphasis">N)</span> (<span class="docEmphasis">see reference section</span>), so we can expect the running time of selection sort to be insensitive to the input.</p>
</td></tr></table></p>
<a name="ch06ex07"></a><h5 id="title-IDA404XE" class="docExampleTitle">Property 6.2. Insertion sort uses about <span class="docEmphasis">N</span><sup>2</sup>/4 comparisons and <span class="docEmphasis">N</span><sup>2</sup>/4 half-exchanges (moves) on the average, and twice that many at worst</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">As implemented in <a class="docLink" href="ch06lev1sec3.html#ch06ex04">Program 6.3</a>, the number of comparisons and of moves is the same. Just as for <a class="docLink" href="#ch06ex06">Property 6.1</a>, this quantity is easy to visualize in the <span class="docEmphasis">N</span>-by-<span class="docEmphasis">N</span> diagram in <a class="docLink" href="ch06lev1sec3.html#ch06fig03">Figure 6.3</a> that gives the details of the operation of the algorithm. Here, the elements below the diagonal are counted&mdash;all of them, in the worst case. For random input, we expect each element to go about halfway back, on the average, so one-half of the elements below the diagonal should be counted.</p>
</td></tr></table></p>
<a name="ch06ex08"></a><h5 id="title-IDAO24XE" class="docExampleTitle">Property 6.3. Bubble sort uses about <span class="docEmphasis">N</span><sup>2</sup>/2 comparisons and <span class="docEmphasis">N</span><sup>2</sup>/2 exchanges on the average and in the worst case</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The <span class="docEmphasis">i</span>th bubble sort pass requires <span class="docEmphasis">N</span> &ndash; <span class="docEmphasis">i</span> compare&ndash;exchange operations, so the proof goes as for selection sort. When the algorithm is modified to terminate when it discovers that the file is sorted, the running time depends on the input. Just one pass is required if the file is already in order, but the <span class="docEmphasis">i</span>th pass requires <span class="docEmphasis">N</span> &ndash; <span class="docEmphasis">i</span> comparisons <span class="docEmphasis">and</span> exchanges if the file is in reverse order. The average-case performance is not significantly better than the worst case, as stated, although the analysis that demonstrates this fact is complicated (<span class="docEmphasis">see reference section</span>).</p>
</td></tr></table></p>
<p class="docText">Although the concept of a partially sorted file is necessarily rather imprecise, insertion sort and bubble sort work well for certain types of nonrandom files that often arise in practice. General-purpose sorts are commonly misused for such applications. For example, consider the operation of insertion sort on a file that is already sorted. Each element is immediately determined to be in its proper place in the file, <a name="iddle1244"></a><a name="iddle1674"></a><a name="iddle1706"></a><a name="iddle2378"></a><a name="iddle2390"></a>and the total running time is linear. The same is true for bubble sort, but selection sort is still quadratic.</p>
<a name="ch06ex09"></a><h5 id="title-IDAA54XE" class="docExampleTitle">Definition 6.2. An <span class="docEmphasis">inversion</span> is a pair of keys that are out of order in the file</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">To count the number of inversions in a file, we can add up, for each element, the number of elements to its left that are greater (we refer to this quantity as the number of inversions corresponding to the element). But this count is precisely the distance that the elements have to move when inserted into the file during insertion sort. A file that has some order will have fewer inversions than will one that is arbitrarily scrambled.</p>
<p class="docText">In one type of partially sorted file, each item is close to its final position in the file. For example, some people sort their hand in a card game by first organizing the cards by suit, to put their cards close to their final position, then considering the cards one by one. We shall be considering a number of sorting methods that work in much the same way&mdash;they bring elements close to final positions in early stages to produce a partially sorted file with every element not far from where it ultimately must go. Insertion sort and bubble sort (but not selection sort) are efficient methods for sorting such files.</p>
</td></tr></table></p>
<a name="ch06ex10"></a><h5 id="title-IDAT54XE" class="docExampleTitle">Property 6.4. Insertion sort and bubble sort use a linear number of comparisons and exchanges for files with at most a constant number of inversions corresponding to each element</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">As just mentioned, the running time of insertion sort is directly proportional to the number of inversions in the file. For bubble sort (here, we are referring to <a class="docLink" href="ch06lev1sec4.html#ch06ex05">Program 6.4</a>, modified to terminate when the file is sorted), the proof is more subtle (see <a class="docLink" href="#ch06qa5q4">Exercise 6.29</a>). Each bubble sort pass reduces the number of smaller elements to the right of any element by precisely 1 (unless the number was already 0), so bubble sort uses at most a constant number of passes for the types of files under consideration, and therefore does at most a linear number of comparisons and exchanges.</p>
</td></tr></table></p>
<p class="docText">In another type of partially sorted file, we perhaps have appended a few elements to a sorted file or have edited a few elements in a sorted file to change their keys. This kind of file is prevalent in sorting applications. Insertion sort is an efficient method for such files; bubble sort and selection sort are not.</p>
<p class="docText"></p><a name="ch06ex11"></a><h5 id="title-IDAXA5XE" class="docExampleTitle">Property 6.5. Insertion sort uses a linear number of comparisons and exchanges for files with at most a constant number of elements having more than a constant number of corresponding inversions</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1418"></a>The running time of insertion sort depends on the total number of inversions in the file, and does not depend on the way in which the inversions are distributed.</p>
</td></tr></table></p>
<p class="docText">To draw conclusions about running time from <a class="docLink" href="#ch06ex06">Property 6.1</a> through <a class="docLink" href="#ch06ex11">Property 6.5</a>, we need to analyze the relative cost of comparisons and exchanges, a factor that in turn depends on the size of the items and keys (see <a class="docLink" href="#ch06table01">Table 6.1</a>). For example, if the items are one-word keys, then an exchange (four array accesses) should be about twice as expensive as a comparison. In such a situation, the running times of selection <a name="iddle2333"></a>and insertion sort are roughly comparable, but bubble sort is slower. But if the items are large in comparison to the keys, then selection sort will be best.</p>
<a name="ch06table01"></a><p><table cellspacing="0" frame="hsides" rules="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 6.1. Empirical study of elementary sorting algorithms</h5></caption><colgroup align="left" span="9"><col width="150"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col><col width="50"></col></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top" colspan="9"><p class="docText">Insertion sort and selection sort are about twice as fast as bubble sort for small files, but running times grow quadratically (when the file size grows by a factor of 2, the running time grows by a factor of 4). None of the methods are useful for large randomly ordered files&mdash;for example, the numbers corresponding to those in this table are less than 2 for the shellsort algorithm in <a class="docLink" href="ch06lev1sec6.html#ch06lev1sec6">Section 6.6</a>. When comparisons are expensive&mdash;for example, when the keys are strings&mdash;then insertion sort is much faster than the other two because it uses many fewer comparisons. Not included here is the case where exchanges are expensive; then selection sort is best.</p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="bottomBorder" align="center" valign="top" colspan="5"><p class="docText">32-bit integer keys</p></td><td class="bottomBorder" align="center" valign="top" colspan="3"><p class="docText">string keys</p></td></tr><tr><td class="bottomBorder" align="center" valign="top"><p class="docText">N</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">S</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">I<sup>*</sup></p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">I</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">B</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">B<sup>*</sup></p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">S</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">I</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">B</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">1000</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">5</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">7</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">4</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">11</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">8</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">13</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">8</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">19</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">2000</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">21</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">29</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">15</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">45</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">34</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">56</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">31</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">78</p></td></tr><tr><td class="bottomBorder" align="center" valign="top"><p class="docText">4000</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">85</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">119</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">62</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">182</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">138</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">228</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">126</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">321</p></td></tr><tr><td class="docTableCell" align="left" valign="top" colspan="9"><p class="docText"><span class="docEmphasis">Key</span>:</p>
<blockquote><p></p><p class="docList">S Selection sort (<a class="docLink" href="ch06lev1sec2.html#ch06ex03">Program 6.2</a>)</p></blockquote></td></tr></table></p><p></p><p class="docList">I<sup>*</sup> Insertion sort, exchange-based (<a class="docLink" href="ch06lev1sec1.html#ch06ex01">Program 6.1</a>)</p><p></p><p class="docList">I Insertion sort (<a class="docLink" href="ch06lev1sec3.html#ch06ex04">Program 6.3</a>)</p><p></p><p class="docList">B Bubble sort (<a class="docLink" href="ch06lev1sec4.html#ch06ex05">Program 6.4</a>)</p><p></p><p class="docList">B<sup>*</sup> Shaker sort (<a class="docLink" href="#ch06qa5q5">Exercise 6.30</a>)</p></td></tr></table><br />
<a name="ch06ex12"></a><h5 id="title-IDAWO5XE" class="docExampleTitle">Property 6.6. Selection sort runs in linear time for files with large items and small keys</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Let <span class="docEmphasis">M</span> be the ratio of the size of the item to the size of the key. Then we can assume the cost of a comparison to be 1 time unit and the cost of an exchange to be <span class="docEmphasis">M</span> time units. Selection sort takes about <span class="docEmphasis">N</span><sup>2</sup>/2 time units for comparisons and about <span class="docEmphasis">NM</span> time units for exchanges. If <span class="docEmphasis">M</span> is larger than a constant multiple of <span class="docEmphasis">N</span>, then the <span class="docEmphasis">NM</span> term dominates the <span class="docEmphasis">N</span><sup>2</sup> term, so the running time is proportional to <span class="docEmphasis">NM</span>, which is proportional to the amount of time that would be required to move all the data.</p>
</td></tr></table></p>
<p class="docText">For example, if we have to sort 1000 items that consist of 1-word keys and 1000 words of data each, and we actually have to rearrange the items, then we cannot do better than selection sort, since the running time will be dominated by the cost of moving all 1 million words of data. In <a class="docLink" href="ch06lev1sec8.html#ch06lev1sec8">Section 6.8</a>, we shall see alternatives to rearranging the data.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa5q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">6.26</span> Which of the three elementary methods (selection sort, insertion sort, or bubble sort) runs fastest for a file with all keys identical?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa5q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.27</span> Which of the three elementary methods runs fastest for a file in reverse order?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa5q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.28</span> Give an example of a file of 10 elements (use the keys <tt>A</tt> through <tt>J</tt>) for which bubble sort uses fewer comparisons than insertion sort, or prove that no such file exists.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa5q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">6.29</span> Show that each bubble sort pass reduces by precisely 1 the number of elements to the left of each element that are greater (unless that number was already 0).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa5q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.30</span> Implement a version of bubble sort that alternates left-to-right and right-to-left passes through the data. This (faster but more complicated) algorithm is called <span class="docEmphasis">shaker sort</span> (see <a class="docLink" href="#ch06fig07">Figure 6.7</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa5q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">6.31</span> Show that <a class="docLink" href="#ch06ex11">Property 6.5</a> does not hold for shaker sort (see <a class="docLink" href="#ch06qa5q5">Exercise 6.30</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa5q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">6.32</span> Implement selection sort in PostScript (see <a class="docLink" href="ch04lev1sec3.html#ch04lev1sec3">Section 4.3</a>), and use your implementation to draw figures like <a class="docLink" href="#ch06fig05">Figures 6.5</a> through <a class="docLink" href="#ch06fig07">6.7</a>. You may try a <a name="iddle1492"></a><a name="iddle1623"></a><a name="iddle1629"></a><a name="iddle2347"></a><a name="iddle2348"></a><a name="iddle2411"></a>recursive implementation, or read the manual to learn about loops and arrays in PostScript.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></div></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch06lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch06lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table><!--IP User 2--></td></body></head></html>