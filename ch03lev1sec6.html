<html><head><title>3.6. Strings</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03lev1sec5.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch03lev1sec7.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch03lev1sec6"></a>
<h3 id="title-IDAIA3VO" class="docSection1Title">3.6. Strings</h3>
<p class="docText">In C, we use the term <span class="docEmphasis">string</span> to refer to a variable-length array of characters, defined by a starting point and by a string-termination character marking the end. C++ inherits this data structure from C, and also includes strings as a higher-level abstraction in the standard library. In this section, we consider some examples of C-style strings. Strings are valuable as low-level data structures, for two basic reasons. First, many computing applications involve processing textual data, which can be represented directly with strings. Second, many computer systems provide direct and efficient access to <span class="docEmphasis">bytes</span> of memory, which correspond directly to characters in strings. That is, in a great many situations, the string abstraction matches needs of the application to the capabilities of the machine.</p>
<p class="docText">The abstract notion of a sequence of characters ending with a string-termination character could be implemented in many ways. For example, we could use a linked list, although that choice would exact a cost of one pointer per character. C++ inherits the concrete array-based implementation that we consider in this section from C, and also provides a more general implementation in the standard library. We shall also discuss other implementations in <a class="docLink" href="ch04.html#ch04">Chapter 4</a>.</p>
<p class="docText"><a name="iddle1080"></a><a name="iddle1764"></a><a name="iddle2445"></a><a name="iddle2456"></a><a name="iddle2467"></a>The difference between a string and an array of characters revolves around <span class="docEmphasis">length</span>. Both represent contiguous areas of memory, but the length of an array is set at the time that the array is created, whereas the length of a string may change during the execution of a program. This difference has interesting implications, which we shall explore shortly.</p>
<p class="docText">We need to reserve memory for a string, either at compile time, by declaring a fixed-length array of characters, or at execution time, by invoking <tt>new[]</tt>. Once the array is allocated, we can fill it with characters, starting at the beginning, and ending with the string-termination character. Without a string-termination character, a string is no more and no less than an array of characters; with the string-termination character, we can work at a higher level of abstraction, and consider only the portion of the array from the beginning to the string-termination character to contain meaningful information. The termination character is the one with value 0, also known as <tt>'\0'</tt>.</p>
<p class="docText">For example, to find the length of a string, we count the number of characters between the beginning and the string-termination character. <a class="docLink" href="#ch03table02">Table 3.2</a> gives simple operations that we commonly perform on strings. They all involve processing the strings by scanning through them from beginning to end. Many of these functions are available as library functions declared in <tt>&lt;string.h&gt;</tt>, although many programmers use slightly modified versions in inline code for simple applications. Robust functions implementing the same operations would have extra code to check for error conditions. We include the code here not just to highlight its simplicity, but also to expose its performance characteristics plainly.</p>
<a name="ch03table02"></a><p><table cellspacing="0" frame="hsides" rules="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 3.2. Elementary string-processing operations</h5></caption><colgroup align="left" span="1"><col width="550"></col></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top"><p class="docText">This table gives implementations of basic string-processing operations, using two different C++ language primitives. The pointer approach leads to more compact code, but the indexed-array approach is a more natural way to express the algorithms and leads to code that is easier to understand. The pointer version of the concatenate operation is the same as the indexed array version, and the pointer version of prefixed compare is obtained from the normal compare in the same way as for the indexed array version and is omitted. The implementations all take time proportional to string lengths.</p></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong">Indexed array versions</span></p>
<blockquote><p></p><p class="docList"><span class="docEmphasis">Compute string length</span> (<tt>strlen(a)</tt>)</p><blockquote><p></p><p class="docList">for (i = 0; a[i] != 0; i++) ; return i;</p></blockquote></blockquote></td></tr></table></p><p></p><p class="docList"><span class="docEmphasis">Copy</span> (<tt>strcpy(a, b)</tt>)</p><blockquote><p></p><p class="docList">for (i = 0; (a[i] = b[i]) != 0; i++) ;</p></blockquote><p></p><p class="docList"><span class="docEmphasis">Compare</span> (<tt>strcmp(a, b)</tt>)</p><blockquote><p></p><p class="docList">for (i = 0; a[i] == b[i]; i++)</p><blockquote><p></p><p class="docList">if (a[i] == 0) return 0;</p></blockquote><p></p><p class="docList">return a[i] - b[i];</p></blockquote><p></p><p class="docList"><span class="docEmphasis">Compare (prefix)</span> (<tt>strncmp(a, b, n)</tt>)</p><blockquote><p></p><p class="docList">for (i = 0; i &lt; n &amp;&amp; a[i] != 0; i++)</p><blockquote><p></p><p class="docList">if (a[i] != b[i]) return a[i] - b[i];</p></blockquote><p></p><p class="docList">return 0;</p></blockquote><p></p><p class="docList"><span class="docEmphasis">Append</span> (<tt>strcat(a, b)</tt>)</p><blockquote><p></p><p class="docList">strcpy(a+strlen(a), b)</p></blockquote></td></tr><tr><td class="docTableCell" align="left" valign="top"><p class="docText"><span class="docEmphStrong">Equivalent pointer versions</span></p>
<blockquote><p></p><p class="docList"><span class="docEmphasis">Compute string length</span> (<tt>strlen(a)</tt>)</p><blockquote><p></p><p class="docList">b = a; while (*b++) ; return b-a-1;</p></blockquote><p></p><p class="docList"><span class="docEmphasis">Copy</span> (<tt>strcpy(a, b)</tt>)</p><blockquote><p></p><p class="docList">while (*a++ = *b++) ;</p></blockquote><p></p><p class="docList"><span class="docEmphasis">Compare</span> (<tt>strcmp(a, b)</tt>)</p><blockquote><p></p><p class="docList">while (*a++ == *b++)</p><blockquote><p></p><p class="docList">if (*(a-1) == 0) return 0;</p></blockquote><p></p><p class="docList">return *(a-1) - *(b-1);</p></blockquote></blockquote>
</td></tr></table><br />
<p class="docText">One of the most important operations that we perform on strings is the <span class="docEmphasis">compare</span> operation, which tells us which of two strings would appear first in the dictionary. For purposes of discussion, we assume an idealized dictionary (since the actual rules for strings that contain punctuation, uppercase and lowercase letters, numbers, and so forth are rather complex), and compare strings character-by-character, from beginning to end. This ordering is called <span class="docEmphasis">lexicographic order</span>. We also use the compare function to tell whether strings are equal&mdash;by convention, the compare function returns a negative number if the first argument string appears before the second in the dictionary, returns 0 if they are equal, and returns a positive number if the first appears after <a name="iddle1081"></a><a name="iddle2073"></a><a name="iddle2437"></a><a name="iddle2457"></a><a name="iddle2459"></a><a name="iddle1521"></a><a name="iddle1765"></a><a name="iddle2074"></a>the second in lexicographic order. It is critical to take note that doing equality testing is <span class="docEmphasis">not</span> the same as determining whether two string <span class="docEmphasis">pointers</span> are equal&mdash;if two string pointers are equal, then so are the referenced strings (they are the <span class="docEmphasis">same</span> string), but we also could have different string pointers that point to equal strings (identical sequences of characters). Numerous applications involve storing information as strings, then processing or accessing that information by comparing the strings, so the compare operation is a particularly critical one. We shall see a specific example in <a class="docLink" href="ch03lev1sec7.html#ch03lev1sec7">Section 3.7</a> and in numerous other places throughout the book.</p>
<p class="docText"><a class="docLink" href="#ch03ex18">Program 3.15</a> is an implementation of a simple string-processing task, which prints out the places where a short pattern string appears within a long text string. Several sophisticated algorithms have been developed for this task, but this simple one illustrates several of the conventions that we use when processing strings in C++.</p>
<p class="docText">String processing provides a convincing example of the need to be knowledgeable about the performance of library functions. The problem is that a library function might take more time than we expect, intuitively. For example, <span class="docEmphasis">determining the length of a string takes time proportional to the length of the string</span>. Ignoring this fact can lead to severe performance problems. For example, after a quick look at the library, we might implement the pattern match in <a class="docLink" href="#ch03ex18">Program 3.15</a> as follows:</p>
<div class="docText"><pre>for (i = 0; i &lt; strlen(a); i++)
  if (strncmp(&amp;a[i], p, strlen(p)) == 0)
    cout &lt;&lt; i &lt;&lt; " ";</pre></div><br />
<p class="docText">Unfortunately, this code fragment takes time proportional to at least the <span class="docEmphasis">square</span> of the length of <tt>a</tt>, no matter what code is in the body of the loop, because it goes all the way through <tt>a</tt> to determine its length each time through the loop. This cost is considerable, even prohibitive: Running this program to check whether this book (which has more than 1 million characters) contains a certain word would require trillions of instructions. Problems such as this one are difficult to detect because the program might work fine when we are debugging it for small strings, but then slow down or even never finish when it goes into production. Moreover, we can avoid such problems only if we know about them!</p>
<p class="docText"></p><a name="ch03ex18"></a><h5 id="title-IDAJO3VO" class="docExampleTitle">Program 3.15. String search</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1246"></a><a name="iddle1438"></a><a name="iddle1439"></a><a name="iddle2051"></a><a name="iddle2328"></a><a name="iddle2463"></a>This program discovers all occurrences of a word from the command line in a (presumably much larger) text string. We declare the text string as a fixed-size character array (we could also use <tt>new[]</tt>, as in <a class="docLink" href="ch03lev1sec2.html#ch03ex07">Program 3.6</a>) and read it from standard input, using <tt>cin.get()</tt>. Memory for the word from the command line-argument is allocated by the system before this program is invoked, and we find the string pointer in <tt>argv[1]</tt>. For each starting position <tt>i</tt> in <tt>a</tt>, we try matching the substring starting at that position with <tt>p</tt>, testing for equality character by character. Whenever we reach the end of <tt>p</tt> successfully, we print out the starting position <tt>i</tt> of the occurrence of the word in the text.</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
#include &lt;string.h&gt;
static const int N = 10000;
int main(int argc, char *argv[])
  { int i; char t;
    char a[N], *p = argv[1];
    for (i = 0; i &lt; N-1; a[i] = t, i++)
      if (!cin.get(t)) break;
    a[i] = 0;
    for (i = 0; a[i] != 0; i++)
      { int j;
        for (j = 0; p[j] != 0; j++)
          if (a[i+j] != p[j]) break;
        if (p[j] == 0) cout &lt;&lt; i &lt;&lt; " ";
      }
    cout &lt;&lt; endl;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">This kind of error is called a <span class="docEmphasis">performance bug</span>, because the code can be verified to be correct, but it does not perform as efficiently as we (implicitly) expect. Before we can even begin the study of efficient algorithms, we must be certain to have eliminated performance bugs of this type. Although standard libraries have many virtues, we must be wary of the dangers of using them for simple functions of this kind.</p>
<p class="docText">One of the essential concepts that we return to time and again in this book is that different implementations of the same abstract notion can lead to widely different performance characteristics. For example, <a name="iddle1878"></a><a name="iddle2075"></a><a name="iddle2458"></a>the <tt>string</tt> class in the C++ standard library keeps track of the length of the string, so that it can return the length of a string in constant time, but other operations run more slowly. One implementation might be appropriate for one application; another implementation might be appropriate for another application.</p>
<p class="docText">Library functions, all too often, cannot guarantee to provide the best performance for all applications. Even if (as in the case of <tt>strlen</tt>) the performance of a library function is well documented, we have no assurance that some future implementation might not involve performance changes that will have adverse effects on our programs. This issue is critical in the design of algorithms and data structures, and thus is one that we must always bear in mind. We shall discuss other examples and further ramifications in <a class="docLink" href="ch04.html#ch04">Chapter 4</a>.</p>
<p class="docText">Strings are actually pointers to chars. In some cases, this realization can lead to compact code for string-processing functions. For example, to copy one string to another, we could write</p>
<div class="docText"><pre>while (*a++ = *b++) ;</pre></div><br />
<p class="docText">instead of</p>
<div class="docText"><pre>for (i = 0; a[i] != 0; i++) a[i] = b[i];</pre></div><br />
<p class="docText">or the third option given in <a class="docLink" href="#ch03table02">Table 3.2</a>. These two ways of referring to strings are equivalent, but may lead to code with different performance properties on different machines. We generally use the array version for clarity and the pointer version for economy of expression, reserving detailed study of which is best for particular pieces of frequently executed code in particular applications.</p>
<p class="docText">Memory allocation for strings is more difficult than for linked lists because strings vary in size. Indeed, a fully general mechanism to reserve space for strings is neither more nor less than the system-provided <tt>new[]</tt> and <tt>delete[]</tt> functions. As mentioned in <a class="docLink" href="#ch03lev1sec6">Section 3.6</a>, various algorithms have been developed for this problem, whose performance characteristics are system and machine dependent. Often, memory allocation is a less severe problem when we are working with strings than it might first appear, because we work with <span class="docEmphasis">pointers</span> to the strings, rather than with the characters themselves. Indeed, we <span class="docEmphasis">do not</span> normally assume that all strings sit in individually allocated chunks of memory. We tend to assume that each string sits in memory of indeterminate allocation, just big enough for the string and its termination <a name="iddle1084"></a><a name="iddle1325"></a><a name="iddle1850"></a><a name="iddle2590"></a>character. We must be very careful to ensure adequate allocation when we are performing operations that build or lengthen strings. As an example, we shall consider a program that reads strings and manipulates them in <a class="docLink" href="ch03lev1sec7.html#ch03lev1sec7">Section 3.7</a>.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa6q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">3.55</span> Write a program that takes a string as argument, and that prints out a table giving, for each character that occurs in the string, the character and its frequency of occurrence.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa6q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">3.56</span> Write a program that checks whether a given string is a palindrome (reads the same backward or forward), ignoring blanks. For example, your program should report success for the string <tt>if i had a hifi</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa6q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.57</span> Suppose that memory for strings is individually allocated. Write versions of <tt>strcpy</tt> and <tt>strcat</tt> that allocate memory and return a pointer to the new string for the result.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa6q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.58</span> Write a program that takes a string as argument and reads a sequence of words (sequences of characters separated by blank space) from standard input, printing out those that appear as substrings somewhere in the argument string.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa6q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.59</span> Write a program that replaces substrings of more than one blank in a given string by exactly one blank.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa6q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.60</span> Implement a pointer version of <a class="docLink" href="#ch03ex18">Program 3.15</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa6q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">3.61</span> Write an efficient program that finds the length of the longest sequence of blanks in a given string, examining as few characters in the string as possible. <span class="docEmphasis">Hint</span>: Your program should become faster as the length of the sequence of blanks increases.</p></td></tr></table></p>
<a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></div></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03lev1sec5.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch03lev1sec7.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table><!--IP User 2--></td></body></head></html>