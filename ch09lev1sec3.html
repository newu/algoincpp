<html><head><title>9.3. Algorithms on Heaps</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch09lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch09lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch09lev1sec3"></a>
<h3 id="643999-882" class="docSection1Title">9.3. Algorithms on Heaps</h3>
<p class="docText">The priority-queue algorithms on heaps all work by first making a simple modification that could violate the heap condition, then traveling through the heap, modifying the heap as required to ensure that the heap condition is satisfied everywhere. This process is sometimes called <span class="docEmphasis">heapifying,</span> or just <span class="docEmphasis">fixing</span> the heap. There are two cases. When the priority of some node is increased (or a new node is added at the bottom of a heap), we have to travel <span class="docEmphasis">up</span> the heap to restore the heap condition. When the priority of some node is decreased (for example, if we replace the node at the root with a new node), we have to travel <span class="docEmphasis">down</span> the heap to restore the heap condition. First, we consider how to implement these two basic functions; then, we see how to use them to implement the various priority-queue operations.</p>
<p class="docText">If the heap property is violated because a node's key becomes larger than that node's parent's key, then we can make progress toward fixing the violation by exchanging the node with its parent. After the exchange, the node is larger than both its children (one is the old parent, the other is smaller than the old parent because it was a child of that node) but may be still be larger than its parent. We can fix that violation in the same way, and so forth, moving up the heap until we reach a node with larger key, or the root. An example of this process is shown in <a class="docLink" href="#ch09fig03">Figure 9.3</a>. The code is straightforward, based on the notion that the parent of the node at position <tt>k</tt> in a heap is at position <tt>k/2</tt>. <a class="docLink" href="#ch09ex07">Program 9.3</a> is an implementation of a function that restores a possible <a name="iddle1615"></a>violation due to increased priority at a given node in a heap by moving up the heap.</p>
<a name="ch09fig03"></a><p><center>
<h5 class="docFigureTitle">Figure 9.3. Bottom-up heapify</h5>
<h5></h5><h5></h5></center></p><p class="docText">The tree depicted on the top is heap-ordered except for the node <span class="docEmphasis">T</span> on the bottom level. If we exchange <span class="docEmphasis">T</span> with its parent, the tree is heap-ordered, except possibly that <span class="docEmphasis">T</span> may be larger than its new parent. Continuing to exchange <span class="docEmphasis">T</span> with its parent until we encounter the root or a node on the path from <span class="docEmphasis">T</span> to the root that is larger than <span class="docEmphasis">T</span>, we can establish the heap condition for the whole tree. We can use this procedure as the basis for the insert operation on heaps, to reestablish the heap condition after adding a new element to a heap (at the rightmost position on the bottom level, starting a new level if necessary).</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="150" height="143" src="09fig03.gif" /></p>
<br />
<a name="ch09ex07"></a><h5 id="title-IDA0FNVM" class="docExampleTitle">Program 9.3. Bottom-up heapify</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">To restore the heap condition when a node's priority is increased, we move up the heap, exchanging the node at position <tt>k</tt> with its parent (at position <tt>k/2</tt>) if necessary, continuing as long as <tt>a[k/2]&lt;a[k]</tt> or until we reach the top of the heap.</p>
<div class="docText"><pre>
    template &lt;class Item&gt;
    void fixUp(Item a[], int k)
      {
        while (k &gt; 1 &amp;&amp; a[k/2] &lt; a[k])
          { exch(a[k], a[k/2]); k = k/2; }
    }</pre></div><br />
</td></tr></table></p>
<p class="docText">If the heap property is violated because a node's key becomes smaller than one or both of that node's childrens' keys, then we can make progress toward fixing the violation by exchanging the node with the larger of its two children. This switch may cause a violation at the child; we fix that violation in the same way, and so forth, moving down the heap until we reach a node with both children smaller, or the bottom. An example of this process is shown in <a class="docLink" href="#ch09fig04">Figure 9.4</a>. The code again follows directly from the fact that the children of the node at position <tt>k</tt> in a heap are at positions <tt>2k</tt> and <tt>2k + 1</tt>. <a class="docLink" href="#ch09ex08">Program 9.4</a> is an implementation of a function that restores a possible violation due to increased priority at a given node in a heap by moving down the heap. This function needs to know the size of the heap (<span class="docEmphasis">N</span>) in order to be able to test when it has reached the bottom.</p>
<a name="ch09fig04"></a><p><center>
<h5 class="docFigureTitle">Figure 9.4. Top-down heapify</h5>
<h5></h5><h5></h5></center></p><p class="docText">The tree depicted on the top is heap-ordered, except at the root. If we exchange the <span class="docEmphasis">O</span> with the larger of its two children (<span class="docEmphasis">X</span>), the tree is heap-ordered, except at the subtree rooted at <span class="docEmphasis">O</span>. Continuing to exchange <span class="docEmphasis">O</span> with the larger of its two children until we reach the bottom of the heap or a point where <span class="docEmphasis">O</span> is larger than both its children, we can establish the heap condition for the whole tree. We can use this procedure as the basis for the remove the maximum operation on heaps, to reestablish the heap condition after replacing the key at the root with the rightmost key on the bottom level.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="165" height="157" src="09fig04.gif" /></p>
<br />
<p class="docText">These two operations are independent of the way that the tree structure is represented, as long as we can access the parent (for the bottom-up method) and the children (for the top-down method) of any node. For the bottom-up method, we move up the tree, exchanging the key in the given node with the key in its parent until we reach the root or a parent with a larger (or equal) key. For the top-down method, we move down the tree, exchanging the key in the given node with the largest key among that node's children, moving down to that child, and continuing down the tree until we reach the bottom or a point where no child has a larger key. Generalized in this way, these operations apply not just to complete binary trees, but also to any tree structure. Advanced priority-queue algorithms usually use more general tree structures, but rely on these same basic operations to maintain access to the largest key in the structure, at the top.</p>
<a name="ch09ex08"></a><h5 id="title-IDA5QNVM" class="docExampleTitle">Program 9.4. Top-down heapify</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">To restore the heap condition when a node's priority is decreased, we move down the heap, exchanging the node at position <tt>k</tt> with the larger of that node's two children if necessary and stopping when the node at <tt>k</tt> is not smaller than either child or the bottom is reached. Note that if <tt>N</tt> is even and <tt>k</tt> is <span class="docEmphasis">N/2</span>, then the node at <tt>k</tt> has only one child&mdash;this case must be treated properly!</p>
<p class="docText">The inner loop in this program has two distinct exits: one for the case that the bottom of the heap is hit, and another for the case that the heap condition is satisfied somewhere in the interior of the heap. It is a prototypical example of the need for the <tt>break</tt> construct.</p>
<div class="docText"><pre>
    template &lt;class Item&gt;
    void fixDown(Item a[], int k, int N)
      {
        while (2*k &lt;= N)
          { int j = 2*k;
            if (j &lt; N &amp;&amp; a[j] &lt; a[j+1]) j++;
            if (!(a[k] &lt; a[j])) break;
            exch(a[k], a[j]); k = j;
          }
      }</pre></div><br />
</td></tr></table></p>
<p class="docText">If we imagine the heap to represent a corporate hierarchy, with each of the children of a node representing subordinates (and the parent representing the immediate superior), then these operations have amusing interpretations. The bottom-up method corresponds to a promising new manager arriving on the scene, being promoted up the chain of command (by exchanging jobs with any lower-qualified boss) until the new person encounters a higher-qualified boss. The top-down method is analogous to the situation when the president of the company is replaced by someone less qualified. If the president's most powerful subordinate is stronger than the new person, they exchange jobs, and we move down the chain of command, demoting the new person and promoting others until the level of competence of the new <a name="iddle1609"></a><a name="iddle1611"></a><a name="iddle2109"></a>person is reached, where there is no higher-qualified subordinate (this idealized scenario is rarely seen in the real world). Drawing on this analogy, we often refer to a movement up a heap as a <span class="docEmphasis">promotion</span>.</p>
<a name="ch09ex09"></a><h5 id="title-IDAITNVM" class="docExampleTitle">Program 9.5. Heap-based priority queue</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">To implement <tt>insert</tt>, we increment <span class="docEmphasis">N</span> by 1, add the new element at the end of the heap, then use <tt>fixUp</tt> to restore the heap condition. For <tt>getmax</tt>, the size of the heap has to decrease by 1, so we take the value to be returned from <tt>pq[1]</tt>, then reduce the size of the heap by moving <tt>pq[N]</tt> to <tt>pq[1]</tt> and using <tt>fixDown</tt> to restore the heap condition. The implementations of the constructor and <tt>empty</tt> are trivial. The first position in the array, <tt>pq[0]</tt>, is not used, but may be available as a sentinel for some implementations.</p>
<div class="docText"><pre>    template &lt;class Item&gt;
    class PQ
      {
        private:
          Item *pq;
          int N;
        public:
          PQ(int maxN)
            { pq = new Item[maxN+1]; N = 0; }
          int empty() const
            { return N == 0; }
          void insert(Item item)
            { pq[++N] = item; fixUp(pq, N); }
          Item getmax()
            {
              exch(pq[1], pq[N]);
              fixDown(pq, 1, N-1);
              return pq[N--];
            }
      };</pre></div><br />
</td></tr></table></p>
<p class="docText">These two basic operations allow efficient implementation of the basic priority-queue ADT, as given in <a class="docLink" href="#ch09ex09">Program 9.5</a>. With the priority queue represented as a heap-ordered array, using the <span class="docEmphasis">insert</span> operation amounts to adding the new element at the end and moving that element up through the heap to restore the heap condition; the <span class="docEmphasis">remove the maximum</span> operation amounts to taking the largest value off the top, then putting in the item from the end of the heap at the top and moving it down through the array to restore the heap condition.</p>
<a name="ch09ex10"></a><h5 id="title-IDADVNVM" class="docExampleTitle">Property 9.2. The <span class="docEmphasis">insert</span> and <span class="docEmphasis">remove the maximum</span> operations for the priority queue abstract data type can be implemented with heap-ordered trees such that <span class="docEmphasis">insert</span> requires no more than <span class="docEmphasis">lg</span> N comparisons and <span class="docEmphasis">remove the maximum</span> no more than <span class="docEmphasis">2lg</span> N comparisons, when performed on an N-item queue</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle2104"></a><a name="iddle2107"></a>Both operations involve moving along a path between the root and the bottom of the heap, and no path in a heap of size <span class="docEmphasis">N</span> includes more than lg <span class="docEmphasis">N</span> elements (see, for example, <a class="docLink" href="ch09lev1sec7.html#ch09ex27">Property 5.8</a> and <a class="docLink" href="ch05lev1sec5.html#ch05qa5q10">Exercise 5.77</a>). The <span class="docEmphasis">remove the maximum</span> operation requires two comparisons for each node: one to find the child with the larger key, the other to decide whether that child needs to be promoted.</p>
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch09fig05">Figures 9.5</a> and <a class="docLink" href="#ch09fig06">9.6</a> show an example in which we construct a heap by inserting items one by one into an initially empty heap. In the array representation that we have been using, this process corresponds to heap ordering the array by moving sequentially through the array, considering the size of the heap to grow by 1 each time that we move to a new item, and using <tt>fixUp</tt> to restore the heap order. The process takes time proportional to <span class="docEmphasis">N</span> <span class="docEmphRoman">log</span> <span class="docEmphasis">N</span> in the worst case (if each new item is the largest seen so far, it travels all the way up the heap), but it turns out to take only linear time on the average (a random new item tends to travel up only a few levels). In <a class="docLink" href="ch09lev1sec4.html#ch09lev1sec4">Section 9.4</a> we shall see a way to construct a heap (to heap order an array) in linear worst-case time.</p>
<a name="ch09fig05"></a><p><center>
<h5 class="docFigureTitle">Figure 9.5. Top-down heap construction</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts the insertion of the keys <span class="docEmphasis">A S O R T I N G</span> into an initially empty heap. New items are added to the heap at the bottom, moving from left to right on the bottom level. Each insertion affects only the nodes on the path between the insertion point and the root, so the cost is proportional to the logarithm of the size of the heap in the worst case.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="100" height="452" src="09fig05.gif" /></p>
<br />
<a name="ch09fig06"></a><p><center>
<h5 class="docFigureTitle">Figure 9.6. Top-down heap construction</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts insertion of the keys <tt>E X A M P L E</tt> into the heap started in <a class="docLink" href="#ch09fig05">Figure 9.5</a>. The total cost of constructing a heap of size <span class="docEmphasis">N</span> is less than <span class="docEmphasis">lg 1 + lg 2 + ... + lg N</span>, which is less than <span class="docEmphasis">N</span> lg <span class="docEmphasis">N</span>.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="150" height="532" src="09fig06.gif" /></p>
<br />
<p class="docText">The basic <tt>fixUp</tt> and <tt>fixDown</tt> operations in <a class="docLink" href="#ch09ex07">Programs 9.3</a> and <a class="docLink" href="#ch09ex08">9.4</a> also allow direct implementation for the <span class="docEmphasis">change priority</span> and <span class="docEmphasis">remove</span> operations. To change the priority of an item somewhere in the middle of the heap, we use <tt>fixUp</tt> to move up the heap if the priority is increased, and <tt>fixDown</tt> to go down the heap if the priority is decreased. Full implementations of such operations, which refer to specific data items, make sense only if a handle is maintained for each item to that item's place in the data structure. We shall consider implementations that do so in detail in <a class="docLink" href="ch09lev1sec5.html#ch09lev1sec5">Sections 9.5</a> through <a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7">9.7</a>.</p>
<a name="ch09ex11"></a><h5 id="title-IDA51NVM" class="docExampleTitle">Property 9.3. The <span class="docEmphasis">change priority</span>, <span class="docEmphasis">remove</span>, and <span class="docEmphasis">replace the maximum</span> operations for the priority queue abstract data type can be implemented with heap-ordered trees such that no more than <span class="docEmphasis">2 lg</span> N comparisons are required for any operation on an <span class="docEmphasis">N</span>-item queue</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Since they require handles to items, we defer considering implementations that support these operations to <a class="docLink" href="ch09lev1sec6.html#ch09lev1sec6">Section 9.6</a> (see <a class="docLink" href="ch09lev1sec6.html#ch09ex21">Program 9.12</a> and <a class="docLink" href="ch09lev1sec6.html#ch09fig14">Figure 9.14</a>). They all involve moving along one path in the heap, perhaps from top to bottom or bottom to top in the worst case.</p>
</td></tr></table></p>
<a name="ch09ex12"></a><h5 id="title-IDAS3NVM" class="docExampleTitle">Program 9.6. Sorting with a priority queue</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">To sort a subarray <tt>a[l]</tt>, <tt>...</tt>, <tt>a[r]</tt> using a priority-queue ADT, we simply use <tt>insert</tt> to put all the elements on the priority queue, and then use <tt>getmax</tt> to remove them, in decreasing order. This sorting algorithm runs in time proportional to <span class="docEmphasis">N</span> lg <span class="docEmphasis">N</span>, but uses extra space proportional to the number of items to be sorted (for the priority queue).</p>
<div class="docText"><pre>    #include "PQ.cxx"
    template &lt;class Item&gt;
    void PQsort(Item a[], int 1, int r)
      { int k;
        PQ&lt;Item&gt; pq(r-l+1);
        for (k = l; k &lt;= r; k++) pq.insert(a[k]);
        for (k = r; k &gt;= l; k--) a[k] = pq.getmax();
      }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a name="iddle1614"></a><a name="iddle2120"></a><a name="iddle2381"></a><a name="iddle2405"></a>Note carefully that the <span class="docEmphasis">join</span> operation is not included on this list. Combining two priority queues efficiently seems to require a much more sophisticated data structure. We shall consider such a data structure in detail in <a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7">Section 9.7</a>. Otherwise, the simple heap-based method given here suffices for a broad variety of applications. It uses minimal extra space and is guaranteed to run efficiently <span class="docEmphasis">except</span> in the presence of frequent and large <span class="docEmphasis">join</span> operations.</p>
<p class="docText">As we have mentioned, we can use any priority queue to develop a sorting method, as shown in <a class="docLink" href="#ch09ex12">Program 9.6</a>. We simply insert all the keys to be sorted into the priority queue, then repeatedly use <span class="docEmphasis">remove the maximum</span> to remove them all in decreasing order. Using a priority queue represented as an unordered list in this way corresponds to doing a selection sort; using an ordered list corresponds to doing an insertion sort.</p>
<p class="docText"><a name="iddle1612"></a><a name="iddle1616"></a><a name="iddle2365"></a><a class="docLink" href="#ch09fig05">Figures 9.5</a> and <a class="docLink" href="#ch09fig06">9.6</a> give an example of the first phase (the construction process) when a heap-based priority-queue implementation is used; <a class="docLink" href="#ch09fig07">Figures 9.7</a> and <a class="docLink" href="#ch09fig08">9.8</a> show the second phase (which we refer to as the <span class="docEmphasis">sortdown</span> process) for the heap-based implementation. For practical purposes, this method is comparatively inelegant, because it unnecessarily makes an extra copy of the items to be sorted (in the priority queue). Also, using <span class="docEmphasis">N</span> successive insertions is not the most efficient way to build a heap from <span class="docEmphasis">N</span> given elements. In the next section, we address these two points as we consider an implementation of the classical heapsort algorithm.</p>
<a name="ch09fig07"></a><p><center>
<h5 class="docFigureTitle">Figure 9.7. Sorting from a heap</h5>
<h5></h5><h5></h5></center></p><p class="docText">After replacing the largest element in the heap by the rightmost element on the bottom level, we can restore the heap order by sifting down along a path from the root to the bottom.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="150" height="532" src="09fig07.gif" /></p>
<br />
<a name="ch09fig08"></a><p><center>
<h5 class="docFigureTitle">Figure 9.8. Sorting from a heap</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts removal of the rest of the keys from the heap in <a class="docLink" href="#ch09fig07">Figure 9.7</a>. Even if every element goes all the way back to the bottom, the total cost of the sorting phase is less than <span class="docEmphasis">lg N + ... + lg 2 + lg 1</span>; which is less than <span class="docEmphasis">N</span> <span class="docEmphRoman">log</span> <span class="docEmphasis">N</span>.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="85" height="391" src="09fig08.gif" /></p>
<br />
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa4q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">9.21</span> Give the heap that results when the keys E A S Y Q U E S T I O N are inserted into an initially empty heap.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa4q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">9.22</span> Using the conventions of <a class="docLink" href="ch09.html#ch09qa1q1">Exercise 9.1</a> give the sequence of heaps produced when the operations</p>
<div class="docText"><pre>P R I O * R * * I * T * Y * * * Q U E * * * U * E</pre></div><br />
<p class="docText">are performed on an initially empty heap.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa4q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.23</span> Because the <tt>exch</tt> primitive is used in the heapify operations, the items are loaded and stored twice as often as necessary. Give more efficient implementations that avoid this problem, a la insertion sort.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa4q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.24</span> Why do we not use a sentinel to avoid the <span class="docEmphasis">j&lt;N</span> test in <tt>fixDown</tt>?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa4q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">9.25</span> Add the <span class="docEmphasis">replace the maximum</span> operation to the heap-based priority-queue implementation of <a class="docLink" href="#ch09ex09">Program 9.5</a>. Be sure to consider the case when the value to be added is larger than all values in the queue. <span class="docEmphasis">Note</span>: Use of <tt>pq[0]</tt> leads to an elegant solution.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa4q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.26</span> What is the minimum number of keys that must be moved during a <span class="docEmphasis">remove the maximum</span> operation in a heap? Give a heap of size 15 for which the minimum is achieved.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa4q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.27</span> What is the minimum number of keys that must be moved during three successive <span class="docEmphasis">remove the maximum</span> operations in a heap? Give a heap of size 15 for which the minimum is achieved.</p>
</td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch09lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch09lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>