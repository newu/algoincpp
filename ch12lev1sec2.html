<html><head><title>12.2. Key-Indexed Search</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch12lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch12lev1sec2"></a>
<h3 id="title-IDA4NM5H" class="docSection1Title">12.2. Key-Indexed Search</h3>
<p class="docText">Suppose that the key values are distinct small numbers. In this case, the simplest search algorithm is based on storing the items in an array, indexed by the keys, as in the implementation given in <a class="docLink" href="#ch12ex06">Program 12.4</a>. The code is straightforward: Operator <tt>new[]</tt> initializes all the entries with <tt>nullItem</tt>, then we <span class="docEmphasis">insert</span> an item with key value <span class="docEmphasis">k</span> simply by storing it in <tt>st[k]</tt>, and <span class="docEmphasis">search</span> for an item with key value <span class="docEmphasis">k</span> by looking in <tt>st[k]</tt>. To <span class="docEmphasis">remove</span> an item with key value <span class="docEmphasis">k</span>, we put <tt>nullItem</tt> in  <tt>st[k]</tt>. The <span class="docEmphasis">select</span>, <span class="docEmphasis">sort</span>, and <span class="docEmphasis">count</span> implementations in <a class="docLink" href="#ch12ex06">Program 12.4</a> use a linear scan through the array, skipping null items. The implementation leaves to the client the tasks of handling items with duplicate keys and checking for conditions such as specifying <span class="docEmphasis">remove</span> for a key not in the table.</p>
<p class="docText">This implementation is a point of departure for all the symbol-table implementations that we consider in this chapter and in <a class="docLink" href="ch13.html#ch13">Chapters 13</a> through <a class="docLink" href="ch15.html#ch15">15</a>. It can be used as an implementation for numerous different clients, and with different item types. The compiler will check that interface, implementation, and client adhere to the same defined conventions.</p>
<p class="docText">The indexing operation upon which key-indexed search is based is the same as the basic operation in the key-indexed counting sort method that we examined in <a class="docLink" href="ch06lev1sec10.html#ch06lev1sec10">Section 6.10</a>. Key-indexed search is the method of choice, when it is applicable, because <span class="docEmphasis">search</span> and <span class="docEmphasis">insert</span> could hardly be implemented more efficiently.</p>
<p class="docText">If there are no items at all (just keys), we can use a table of bits. The symbol table in this case is called an <span class="docEmphasis">existence table</span>, because we may think of the <span class="docEmphasis">k</span>th bit as signifying whether <span class="docEmphasis">k</span> exists among the set of keys in the table. For example, we could use this method to determine quickly whether a given 4-digit number in a telephone exchange has already been assigned, using a table of 313 words on a 32-bit computer (see <a class="docLink" href="#ch12qa2q5">Exercise 12.14</a>).</p>
<a name="ch12ex05"></a><h5 id="title-IDAKBO5H" class="docExampleTitle">Property 12.1. <span class="docEmphasis">If key values are positive integers less than M and items have distinct keys, then the symbol-table data type can be implemented with key-indexed arrays of items such that</span> <span class="docEmphRoman">insert, search</span>, <span class="docEmphasis">and</span> <span class="docEmphRoman">remove</span> <span class="docEmphasis">require constant time; and</span> <span class="docEmphRoman">initialize, select</span>, <span class="docEmphasis">and</span> <span class="docEmphRoman">sort</span> <span class="docEmphasis">require time proportional to M, whenever any of the operations are performed on an N-item table</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This fact is immediate from inspection of the code. Note that the conditions on the keys imply that <span class="docEmphasis">N</span> <img src="U2264.GIF" border="0" /> <span class="docEmphasis">M</span>.</p>
</td></tr></table></p>
<a name="ch12ex06"></a><h5 id="title-IDAYCO5H" class="docExampleTitle">Program 12.4. Key-indexed-array-based symbol table</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This code assumes that key values are positive integers less than a sentinel value <tt>M</tt>, and uses them as indices into an array. We use the convention that the <tt>Item</tt> constructor creates items with key values equal to the sentinel value, so that the <tt>ST</tt> constructor can find the value of <tt>M</tt> in a null item. The primary costs to watch are the amount of space required when the sentinel value is large, and the amount of time required for the <tt>ST</tt> constructor when <tt>N</tt> is small relative to <tt>M</tt>.</p>
<div class="docText"><pre>template &lt;class Item, class Key&gt;
class ST
  {
   private:
     Item nullItem, *st;
     int M;
   public:
     ST(int maxN)
       { M = nullItem.key(); st = new Item[M]; }
     int count()
       { int N = 0;
         for (int i = 0; i &lt; M; i++)
          if (!st[i].null()) N++;
         return N;
       }
     void insert(Item x)
       { st[x.key()] = x; }
     Item search(Key v)
       { return st[v]; }
     void remove(Item x)
       { st[x.key()] = nullItem; }
     Item select(int k)
       { for (int i = 0; i &lt; M; i++)
           if (!st[i].null())
             if (k-- == 0) return st[i];
         return nullItem;
       }
     void show(ostream&amp; os)
       { for (int i = 0; i &lt; M; i++)
           if (!st[i].null()) st[i].show(os); }
  };</pre></div><br />
</td></tr></table></p>
<p class="docText"><a name="iddle1097"></a><a name="iddle1563"></a><a name="iddle2481"></a><a class="docLink" href="#ch12ex06">Program 12.4</a> does not handle duplicate keys, and it assumes that the key values are between 0 and <tt>M-1</tt>. We could use linked lists or one of the other approaches mentioned in <a class="docLink" href="ch12lev1sec1.html#ch12lev1sec1">Section 12.1</a> to store any items with duplicate keys, and we could do simple transformations of the keys before using them as indices (see <a class="docLink" href="#ch12qa2q4">Exercise 12.13</a>), but we defer considering these cases in detail to <a class="docLink" href="ch14.html#ch14">Chapter 14</a>, when we consider <span class="docEmphasis">hashing</span>, which uses this same approach to implement symbol tables for general keys, by transforming keys from a potentially large range such that they fall within a small range, then taking appropriate action for items with duplicate keys. For the moment, we assume that an old item with a key value equal to the key in an item to be inserted can be silently ignored (as in <a class="docLink" href="#ch12ex06">Program 12.4</a>), or treated as an error condition (see <a class="docLink" href="#ch12qa2q1">Exercise 12.10</a>).</p>
<p class="docText">The implementation of <span class="docEmphasis">count</span> in <a class="docLink" href="#ch12ex06">Program 12.4</a> is a lazy approach where we do work only when the function <tt>count</tt> is called. An alternative (eager) approach is to maintain the count of nonempty table positions in a local variable, incrementing the variable if <tt>insert</tt> is into a table position that contains <tt>nullItem</tt>, and decrementing it if  <tt>remove</tt> is for a table position that does not contain <tt>nullItem</tt> (see <a class="docLink" href="#ch12qa2q2">Exercise 12.11</a>). The lazy approach is the better of the two if the <span class="docEmphasis">count</span> operation is used rarely (or not at all) and the number of possible key values is small; the eager approach is better if the <span class="docEmphasis">count</span> operation is used often or the number of possible key values is huge. For a general-purpose library routine, the eager approach is preferred, because it provides optimal worst-case performance at the cost of a small constant factor for <span class="docEmphasis">insert</span> and <span class="docEmphasis">remove</span>; for the inner loop in an application with a huge number of <span class="docEmphasis">insert</span> and <span class="docEmphasis">remove</span> operations but few <span class="docEmphasis">count</span> operations, the lazy approach is preferred, because it gives the fastest implementation of the common operations. This type of dilemma is common in the design of ADTs that must support a varying mix of operations, as we have seen on several occasions.</p>
<p class="docText">There are various other design decisions that we also need to make in developing a general-purpose interface. For example, should <a name="iddle1098"></a><a name="iddle2327"></a><a name="iddle2345"></a><a name="iddle2497"></a>the key range be the same for all objects, or be different for different objects? If the latter option is chosen, then it may be necessary to add arguments to the constructor and to have functions giving the client access to the key range.</p>
<p class="docText">Key-indexed arrays are useful for many applications, but they do not apply if keys do not fall into a small range. Indeed, we might think of this and the next several chapters as being concerned with designing solutions for the case where the keys are from such a large range that it is not feasible to have an indexed table with one potential place for each key.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa2q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.10</span> Implement a first-class symbol-table ADT (see <a class="docLink" href="ch12lev1sec1.html#ch12qa1q6">Exercise 12.6</a>), using dynamically allocated key-indexed arrays.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa2q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">12.11</span> Modify the implementation of <a class="docLink" href="#ch12ex06">Program 12.4</a> to provide an eager implementation of <tt>count</tt> (by keeping track of the number of nonnull entries).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa2q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">12.12</span> Modify your implementation from <a class="docLink" href="#ch12qa2q1">Exercise 12.10</a> to provide an eager implementation of <tt>count</tt> (see <a class="docLink" href="#ch12qa2q2">Exercise 12.11</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa2q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.13</span> Develop a version of <a class="docLink" href="#ch12ex06">Program 12.4</a> that uses a function <tt>h(Key)</tt>,which converts keys to nonnegative integers less than <tt>M</tt>, with no two keys mapping to the same integer. (This improvement makes the implementation useful whenever keys are in a small range (not necessarily starting at 0) and in other simple cases.)</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa2q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.14</span> Develop a version of <a class="docLink" href="#ch12ex06">Program 12.4</a> for the case when items are keys that are positive integers less than <tt>M</tt> (no associated information). In the implementation, use a dynamically allocated array of about <tt>M/bitsword</tt> words, where <tt>bitsword</tt> is the number of bits per word on your computer system.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa2q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.15</span> Use your implementation from <a class="docLink" href="#ch12qa2q5">Exercise 12.14</a> for experiments to determine empirically the average and standard deviation for the number of distinct integers in a random sequence of <span class="docEmphasis">N</span> nonnegative integers less than <span class="docEmphasis">N</span>, for <span class="docEmphasis">N</span> close to the memory available to a program on your computer, expressed as a number of bits (see <a class="docLink" href="ch12lev1sec1.html#ch12ex04">Program 12.3</a>).</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch12lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>