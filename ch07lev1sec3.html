<html><head><title>7.3. Stack Size</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch07lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch07lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch07lev1sec3"></a>
<h3 id="643999-994" class="docSection1Title">7.3. Stack Size</h3>
<p class="docText">As we did in <a class="docLink" href="ch03.html#ch03">Chapter 3</a>, we can use an explicit pushdown stack for quicksort, thinking of the stack as containing work to be done in the form of subfiles to be sorted. Any time that we need a subfile to process, we pop the stack. When we partition, we create two subfiles to be processed and push both on the stack. In the recursive implementation in <a class="docLink" href="ch07lev1sec1.html#ch07ex01">Program 7.1</a>, the stack maintained by the system holds this same information.</p>
<p class="docText">For a random file, the maximum size of the stack is proportional to <span class="docEmphRoman">log</span> <span class="docEmphasis">N</span> (<span class="docEmphasis">see reference section</span>), but the stack can grow to size proportional to <span class="docEmphasis">N</span> for a degenerate case, as illustrated in <a class="docLink" href="#ch07fig05">Figure 7.5</a>. Indeed, the very worst case is when the input file is already sorted. The potential for stack growth proportional to the size of the original file is a subtle but real difficulty with a recursive implementation of quicksort: There is always an underlying stack, and a degenerate case on a large file could cause the program to terminate abnormally because of lack of memory&mdash;behavior obviously undesirable for a library sorting routine. (Actually, we likely would run out of time before running out of space.) It is difficult to provide a <span class="docEmphasis">guarantee</span> against this behavior, but we shall see in <a class="docLink" href="ch07lev1sec5.html#ch07lev1sec5">Section 7.5</a> that it is not difficult to provide safeguards that make such degenerate cases extremely unlikely to occur.</p>
<a name="ch07fig05"></a><p><center>
<h5 class="docFigureTitle">Figure 7.5. Stack size for quicksort</h5>
<h5></h5><h5></h5></center></p><p class="docText">The recursive stack for quicksort does not grow large for random files, but can take excessive space for degenerate files. The stack sizes for two random files <span class="docEmphasis">(left, center)</span> and that for a partially ordered file <span class="docEmphasis">(right)</span> are plotted here.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="150" height="310" src="07fig05.gif" /></p>
<br />
<p class="docText"><a class="docLink" href="#ch07ex05">Program 7.3</a> is a nonrecursive implementation that addresses this problem by checking the sizes of the two subfiles and putting the larger of the two on the stack first. <a class="docLink" href="#ch07fig06">Figure 7.6</a> illustrates this policy. Comparing this example with <a class="docLink" href="ch07lev1sec1.html#ch07fig01">Figure 7.1</a>, we see that the subfiles are not changed by this policy; only the order in which they are processed is changed. Thus, we save on space costs without affecting time costs.</p>
<a name="ch07fig06"></a><p><center>
<h5 class="docFigureTitle">Figure 7.6. Quicksort example (sorting the smaller subfile first)</h5>
<h5></h5><h5></h5></center></p><p class="docText">The order in which the subfiles are processed does not affect the correct operation of the quicksort algorithm, or the time taken, but might affect the size of the pushdown stack underlying the recursive structure. Here the smaller of the two subfiles is processed first after each partition.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="200" height="220" src="07fig06.gif" /></p>
<br />
<p class="docText">The policy of putting the larger of the small subfiles on the stack ensures that each entry on the stack is no more than one-half of the size of the one below it, so that the stack needs to contain room for only about lg <span class="docEmphasis">N</span> entries. This maximum stack usage occurs when the partition always falls at the center of the file. For random files, the actual maximum stack size is much lower; for degenerate files it is likely to be small.</p>
<a name="ch07ex05"></a><h5 id="title-IDA2RYRE" class="docExampleTitle">Program 7.3. Nonrecursive quicksort</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This nonrecursive implementation (see <a class="docLink" href="ch05.html#ch05">Chapter 5</a>) of quicksort uses an explicit pushdown stack, replacing recursive calls with stack pushes (of the parameters) and the procedure call/exit with a loop that pops parameters from the stack and processes them as long as the stack is nonempty. We put the larger of the two subfiles on the stack first to ensure that the maximum stack depth for sorting <span class="docEmphasis">N</span> elements is lg <span class="docEmphasis">N</span> (see <a class="docLink" href="#ch07ex06">Property 7.3</a>).</p>
<div class="docText"><pre>    #include "STACK.cxx"
    inline void push2(STACK&lt;int&gt; &amp;s, int A, int B)
      { s.push(B); s.push(A); }
    template &lt;class Item&gt;
    void quicksort(Item a[], int l, int r)
      { STACK&lt;int&gt; s(50);
        push2(s, l, r);
        while (!s.empty())
          {
            l = s.pop(); r = s.pop();
            if (r &lt;= l) continue;
            int i = partition(a, l, r);
            if (i-l &gt; r-i)
              { push2(s, l, i-1); push2(s, i+1, r); }
            else
              { push2(s, i+1, r); push2(s, l, i-1); }
          }
      }</pre></div><br />
</td></tr></table></p>
<a name="ch07ex06"></a><h5 id="title-IDAITYRE" class="docExampleTitle">Property 7.3. <span class="docEmphasis">If the smaller of the two subfiles is sorted first, then the stack never has more than</span> <span class="docEmphRoman">lg</span> <span class="docEmphasis">N entries when quicksort is used to sort N elements</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The worst-case stack size must be less than <span class="docEmphasis">T<sub>N</sub></span>,where <span class="docEmphasis">T<sub>N</sub></span> satisfies the recurrence <span class="docEmphasis">T<sub>N</sub> = T<sub><img src="U230A.GIF" border="0" /></sub><sub>N/</sub><sub>2</sub><sub><img src="U230B.GIF" border="0" /></sub> + 1</span> with <span class="docEmphasis">T</span><sub>1</sub> = <span class="docEmphasis">T</span><sub>0</sub> = 0. This recurrence is a standard one of the type considered in <a class="docLink" href="ch05.html#ch05">Chapter 5</a> (see <a class="docLink" href="#ch07qa3q3">Exercise 7.13</a>).</p>
</td></tr></table></p>
<p class="docText"><a name="iddle2186"></a><a name="iddle2255"></a><a name="iddle2506"></a>This technique does not necessarily work in a truly recursive implementation, because it depends on <span class="docEmphasis">end-</span> or <span class="docEmphasis">tail-recursion removal</span>. If the last action of a procedure is to call another procedure, some programming environments will arrange things such that local variables are cleared from the stack <span class="docEmphasis">before</span>, rather than after, the call. Without end-recursion removal, we cannot guarantee that the stack size will be small for quicksort. For example, a call to quicksort for a file of size <span class="docEmphasis">N</span> that is already sorted will result in a recursive call to such a file of size <span class="docEmphasis">N</span> - 1, in turn resulting in a recursive call for such a file of size <span class="docEmphasis">N</span> - 2 , and so on, ultimately resulting in a stack depth proportional to <span class="docEmphasis">N</span>. This observation would seem to suggest using a nonrecursive implementation to guard against excessive stack growth. On the other hand, some C++ compilers automatically remove end recursion, and many machines have direct hardware support for function calls&mdash;the nonrecursive implementation in <a class="docLink" href="#ch07ex05">Program 7.3</a> might therefore actually be slower than the recursive implementation in <a class="docLink" href="ch07lev1sec1.html#ch07ex01">Program 7.1</a> in such environments.</p>
<p class="docText"><a class="docLink" href="#ch07fig07">Figure 7.7</a> further illustrates the point that the nonrecursive method processes the same subfiles (in a different order) as does the recursive method for any file. It shows a tree structure with the partitioning element at the root and the trees corresponding to the left and right subfiles as left and right children, respectively. Using the recursive implementation of quicksort corresponds to visiting the nodes of this tree in preorder; the nonrecursive implementation corresponds to a visit-the-smaller-subtree-first traversal rule.</p>
<a name="ch07fig07"></a><p><center>
<h5 class="docFigureTitle">Figure 7.7. Quicksort partitioning tree</h5>
<h5></h5><h5></h5></center></p><p class="docText">If we collapse the partitioning diagrams in <a class="docLink" href="ch07lev1sec1.html#ch07fig01">Figures 7.1</a> and <a class="docLink" href="#ch07fig06">7.6</a> by connecting each partitioning element to the partitioning element used in its two subfiles, we get this static representation of the partitioning process (in both cases). In this binary tree, each subfile is represented by its partitioning element (or by itself, if it is of size 1), and the subtrees of each node are the trees representing the subfiles after partitioning. For clarity, null subfiles are not shown here, although our recursive versions of the algorithm do make recursive calls with <span class="docEmphasis"><tt>r &lt; l</tt></span> when the partitioning element is the smallest or largest element in the file. The tree itself does not depend on the order in which the subfiles are partitioned. Our recursive implementation of quicksort corresponds to visiting the nodes of this tree in preorder; our nonrecursive implementation corresponds to a visit-the-smaller-subtree-first rule.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="175" height="114" src="07fig07.gif" /></p>
<br />
<p class="docText">When we use an explicit stack, as we did in <a class="docLink" href="#ch07ex05">Program 7.3</a>, we avoid some of the overhead implicit in a recursive implementation, although modern programming systems do not incur much overhead for such simple programs. <a class="docLink" href="#ch07ex05">Program 7.3</a> can be further improved. For example, it puts both subfiles on the stack, only to have the top one immediately popped off; we could change it to set the variables <tt>l</tt> and <tt>r</tt> directly. Also, the test for <tt>r &lt;= l</tt> is done as subfiles come off the stack, whereas it would be more efficient never to put such subfiles on the stack (see <a class="docLink" href="#ch07qa3q4">Exercise 7.14</a>). This case might seem insignificant, but the recursive nature of quicksort actually ensures that a large fraction of the subfiles during the course of the sort are of size 0 or 1. Next, we <a name="iddle2030"></a><a name="iddle2183"></a><a name="iddle2559"></a>examine an important improvement to quicksort that gains efficiency by expanding upon this idea, handling all small subfiles in as efficient a manner as possible.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa3q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">7.11</span> Give, in the style of <a class="docLink" href="ch05lev1sec2.html#ch05fig05">Figure 5.5</a>, the stack contents after each pair of <span class="docEmphasis">push</span> and <span class="docEmphasis">pop</span> operations, when <a class="docLink" href="#ch07ex05">Program 7.3</a> is used to sort a file with the keys E A S Y Q U E S T I O N.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa3q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">7.12</span> Answer <a class="docLink" href="#ch07qa3q1">Exercise 7.11</a> for the case where we always push the right subfile, then the left subfile (as is the case in the recursive implementation).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa3q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">7.13</span> Complete the proof of <a class="docLink" href="#ch07ex06">Property 7.3</a>, by induction.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa3q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">7.14</span> Revise <a class="docLink" href="#ch07ex05">Program 7.3</a> such that it never puts on the stack subfiles with <tt>r &lt;= l</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa3q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">7.15</span> Give the maximum stack size required by <a class="docLink" href="#ch07ex05">Program 7.3</a> when <span class="docEmphasis">N</span> = 2<sup>n</sup>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa3q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">7.16</span> Give the maximum stack sizes required by <a class="docLink" href="#ch07ex05">Program 7.3</a> when <span class="docEmphasis">N</span> = 2<sup>n</sup> - 1 and <span class="docEmphasis">N</span> = 2<sup>n</sup> + 1.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa3q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">7.17</span> Would it be reasonable to use a queue instead of a stack for a nonrecursive implementation of quicksort? Explain your answer.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa3q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">7.18</span> Determine and report whether your programming environment implements end-recursion removal.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa3q9"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">7.19</span> Run empirical studies to determine the average stack size used by the basic recursive quicksort algorithm for random files of <span class="docEmphasis">N</span> elements, for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa3q10"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">7.20</span> Find the average number of subfiles of size 0, 1, and 2 when quicksort is used to sort a random file of <span class="docEmphasis">N</span> elements.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch07lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch07lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>