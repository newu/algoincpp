<html><head><title>9.1. Elementary Implementations</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch09.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch09lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch09lev1sec1"></a>
<h3 id="title-IDA0XNJK" class="docSection1Title">9.1. Elementary Implementations</h3>
<p class="docText">The basic data structures that we discussed in <a class="docLink" href="ch03.html#ch03">Chapter 3</a> provide us with numerous options for implementing priority queues. <a class="docLink" href="#ch09ex03">Program 9.2</a> is an implementation that uses an unordered array as the underlying data structure. The <span class="docEmphasis">find the maximum</span> operation is implemented by scanning the array to find the maximum, then exchanging the maximum item with the last item and decrementing the queue size. <a class="docLink" href="#ch09fig01">Figure 9.1</a> shows the contents of the array for a sample sequence of operations. This basic implementation corresponds to similar implementations that we saw in <a class="docLink" href="ch04.html#ch04">Chapter 4</a> for stacks and queues (see <a class="docLink" href="ch04lev1sec5.html#ch04ex14">Programs 4.7</a> and <a class="docLink" href="ch04lev1sec6.html#ch04ex20">4.15</a>), and is useful for small queues. The significant difference has to do with performance. For stacks and queues, we were able to develop implementations of all the operations that take constant time; for priority queues, it is easy to find implementations where <span class="docEmphasis">either</span> the <span class="docEmphasis">insert</span> or the <span class="docEmphasis">remove the maximum</span> functions takes constant time, but finding an implementation where <span class="docEmphasis">both</span> operations will be fast is a more difficult task, and is the subject of this chapter.</p>
<a name="ch09fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 9.1. Priority-queue example (unordered array representation)</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence shows the result of the sequence of operations in the left column (top to bottom), where a letter denotes insert and an asterisk denotes remove the maximum. Each line displays the operation, the letter removed for the remove-the-maximum operations, and the contents of the array after the operation.</p>
<p class="docText">
<img border="0" alt="" width="150" height="395" src="09fig01.gif" /></p>
<br />
<p class="docText">We can use unordered or ordered sequences, implemented as linked lists or as arrays. The basic tradeoff between leaving the items unordered and keeping them in order is that maintaining an ordered sequence allows for constant-time <span class="docEmphasis">remove the maximum</span> and <span class="docEmphasis">find the maximum</span> but might mean going through the whole list for <span class="docEmphasis">insert</span>, whereas an unordered sequence allows a constant-time <span class="docEmphasis">insert</span> but might mean going through the whole sequence for <span class="docEmphasis">remove the maximum</span> and <span class="docEmphasis">find the maximum</span>. The unordered sequence is the prototypical <span class="docEmphasis">lazy</span> approach to this problem, where we defer doing work until necessary (to find the maximum); the ordered sequence is the prototypical <span class="docEmphasis">eager</span> approach to the problem, where we do as much work as we can up front (keep the list sorted on insertion) to make later operations efficient. We can use an array or linked-list representation in either case, with the basic tradeoff that the (doubly) linked list allows a constant-time <span class="docEmphasis">remove</span> (and, in the unordered case <span class="docEmphasis">join</span>), but requires more space for the links.</p>
<a name="ch09ex03"></a><h5 id="title-IDAT1DG" class="docExampleTitle">Program 9.2. Array implementation of a priority queue</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This implementation, which may be compared with the array implementations for stacks and queues that we considered in <a class="docLink" href="ch04.html#ch04">Chapter 4</a> (see <a class="docLink" href="ch04lev1sec5.html#ch04ex14">Programs 4.7</a> and <a class="docLink" href="ch04lev1sec6.html#ch04ex20">4.15</a>), keeps the items in an unordered array. Items are added to and removed from the end of the array, as in a stack.</p>
<div class="docText"><pre>
    template &lt;class Item&gt;
    class PQ
      {
        private:
          Item *pq;
          int N;
        public:
          PQ(int maxN)
            { pq = new Item[maxN]; N = 0; }
          int empty() const
            { return N == 0; }
          void insert(Item item)
            { pq[N++] = item; }
          Item getmax()
            { int max = 0;
              for (int j = 1; j &lt; N; j++)
                if (pq[max] &lt; pq[j]) max = j;
              exch(pq[max], pq[N-1]);
              return pq[--N];
          }
      };</pre></div><br />
</td></tr></table></p>
<p class="docText"><a name="iddle2121"></a><a name="iddle2307"></a>The worst-case costs of the various operations (within a constant factor) on a priority queue of size <span class="docEmphasis">N</span> for various implementations are summarized in <a class="docLink" href="#ch09table01">Table 9.1</a>.</p>
<a name="ch09table01"></a><p><table cellspacing="0" frame="hsides" rules="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 9.1. Worst-case costs of priority queue operations</h5></caption><colgroup align="left" span="7"><col width="130"></col><col width="70"></col><col width="70"></col><col width="70"></col><col width="70"></col><col width="70"></col><col width="70"></col></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top" colspan="7"><p class="docText">Implementations of the priority queue ADT have widely varying performance characteristics, as indicated in this table of the worst-case time (within a constant factor for large <span class="docEmphasis">N</span>) for various methods. Elementary methods (first four lines) require constant time for some operations and linear time for others; more advanced methods guarantee logarithmic-or constant-time performance for most or all operations.</p></td></tr><tr><td class="bottomBorder" align="left" valign="top">&nbsp;</td><td class="bottomBorder" align="center" valign="bottom"><p class="docText">insert</p></td><td class="bottomBorder" align="center" valign="bottom"><p class="docText">remove maximum</p></td><td class="bottomBorder" align="center" valign="bottom"><p class="docText">remove</p></td><td class="bottomBorder" align="center" valign="bottom"><p class="docText">find maximum</p></td><td class="bottomBorder" align="center" valign="bottom"><p class="docText">change priority</p></td><td class="bottomBorder" align="center" valign="bottom"><p class="docText">join</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">ordered array</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">ordered list</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">unordered array</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">unordered list</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">heap</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">binomial queue</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">best in theory</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText">lg <span class="docEmphasis">N</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">1</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">1</span></p></td><td class="docTableCell" align="center" valign="top"><p class="docText"><span class="docEmphasis">1</span></p></td></tr></table></p><br />
<p class="docText">Developing a full implementation requires paying careful attention to the interface&mdash;particularly to how client programs access nodes for the <span class="docEmphasis">remove</span> and <span class="docEmphasis">change priority</span> operations, and how they access priority queues themselves as data types for the <span class="docEmphasis">join</span> operation. These issues are discussed in <a class="docLink" href="ch09lev1sec4.html#ch09lev1sec4">Sections 9.4</a> and <a class="docLink" href="ch09lev1sec7.html#ch09lev1sec7">9.7</a>, where two full implementations are given: one using doubly-linked unordered lists, and another using binomial queues.</p>
<p class="docText">The running time of a client program using priority queues depends not just on the keys, but also on the mix of the various operations. It is wise to keep in mind the simple implementations because they often can outperform more complicated methods in many practical situations. For example, the unordered-list implementation might be appropriate in an application where only a few <span class="docEmphasis">remove the maximum</span> operations are performed, as opposed to a huge number of insertions, whereas an ordered list would be appropriate if a huge number of <span class="docEmphasis">find the maximum</span> operations are involved, or if the items inserted tend to be larger than those already in the priority queue.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa2q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">9.5</span> Criticize the following idea: To implement <span class="docEmphasis">find the maximum</span> in constant time, why not keep track of the maximum value inserted so far, then return that value for <span class="docEmphasis">find the maximum</span>?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa2q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">9.6</span> Give the contents of the array after the execution of the sequence of operations depicted in <a class="docLink" href="#ch09fig01">Figure 9.1</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa2q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.7</span> Provide an implementation for the basic priority queue interface that uses an ordered array for the underlying data structure.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa2q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.8</span> Provide an implementation for the basic priority queue interface that uses an unordered linked list for the underlying data structure. <span class="docEmphasis">Hint</span>: See <a class="docLink" href="ch04lev1sec8.html#ch04ex24">Programs 4.8</a> and <a class="docLink" href="ch04lev1sec6.html#ch04ex18">4.14</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa2q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.9</span> Provide an implementation for the basic priority queue interface that uses an ordered linked list for the underlying data structure. <span class="docEmphasis">Hint</span>: See <a class="docLink" href="ch03lev1sec4.html#ch03ex14">Program 3.11</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa2q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">9.10</span> Consider a lazy implementation where the list is ordered only when a <span class="docEmphasis">remove the maximum</span> or a <span class="docEmphasis">find the maximum</span> operation is performed. Insertions since the previous sort are kept on a separate list, then are sorted and merged in when necessary. Discuss advantages of such an implementation over the elementary implementations based on unordered and ordered lists.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa2q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">9.11</span> Write a performance driver client program that uses <tt>insert</tt> to fill a priority queue, then uses <tt>getmax</tt> to remove half the keys, then uses <tt>insert</tt> to fill it up again, then uses <tt>getmax</tt> to remove all the keys, doing so multiple times on random sequences of keys of various lengths ranging from small to large; measures the time taken for each run; and prints out or plots the average running times.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa2q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">9.12</span> Write a performance driver client program that uses <tt>insert</tt> to fill a priority queue, then does as many <tt>getmax</tt> and <tt>insert</tt> operations as it can do in 1 second, doing so multiple times on random sequences of keys of various lengths ranging from small to large; and prints out or plots the average number of <tt>getmax</tt> operations it was able to do.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa2q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.13</span> Use your client program from <a class="docLink" href="#ch09qa2q8">Exercise 9.12</a> to compare the unordered-array implementation in <a class="docLink" href="#ch09ex03">Program 9.2</a> with your unordered-list implementation from <a class="docLink" href="#ch09qa2q4">Exercise 9.8</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa2q10"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.14</span> Use your client program from <a class="docLink" href="#ch09qa2q8">Exercise 9.12</a> to compare your ordered-array and ordered-list implementations from <a class="docLink" href="#ch09qa2q3">Exercises 9.7</a> and <a class="docLink" href="#ch09qa2q5">9.9</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa2q11"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">9.15</span> Write an exercise driver client program that uses the functions in our priority-queue interface <a class="docLink" href="ch09.html#ch09ex02">Program 9.1</a> on difficult or pathological cases that <a name="iddle1087"></a><a name="iddle1204"></a><a name="iddle1206"></a><a name="iddle1605"></a><a name="iddle1607"></a><a name="iddle1704"></a><a name="iddle1954"></a>might turn up in practical applications. Simple examples include keys that are already in order, keys in reverse order, all keys the same, and sequences of keys having only two distinct values.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch09qa2q12"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">9.16</span> (This exercise is 24 exercises in disguise.) Justify the worst-case bounds for the four elementary implementations that are given in <a class="docLink" href="#ch09table01">Table 9.1</a>, by reference to the implementation in <a class="docLink" href="#ch09ex03">Program 9.2</a> and your implementations from <a class="docLink" href="#ch09qa2q3">Exercises 9.7</a> through <a class="docLink" href="#ch09qa2q5">9.9</a> for <span class="docEmphasis">insert</span> and <span class="docEmphasis">remove the maximum</span>; and by informally describing the methods for the other operations. For <span class="docEmphasis">remove</span>, <span class="docEmphasis">change priority</span>, and <span class="docEmphasis">join</span>, assume that you have a handle that gives you direct access to the referent.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch09.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch09lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>