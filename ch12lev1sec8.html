<html><head><title>12.8. Insertion at the Root in BSTs</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12lev1sec7.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch12lev1sec9.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch12lev1sec8"></a>
<h3 id="title-IDAW4RRE" class="docSection1Title">12.8. Insertion at the Root in BSTs</h3>
<p class="docText"><a name="iddle1178"></a><a name="iddle1427"></a><a name="iddle2276"></a>In the standard implementation of BSTs, every new node inserted goes somewhere at the bottom of the tree, replacing some external node. This state of affairs is not an absolute requirement; it is just an artifact of the natural recursive insertion algorithm. In this section, we consider an alternative insertion method, where we insist that each new item be inserted at the root, so recently inserted nodes are at the <span class="docEmphasis">top</span> of the tree.</p>
<p class="docText"><a name="iddle1180"></a><a name="iddle2285"></a>Trees built in this way have some interesting properties, but our main reason for considering this method is that it plays a crucial role in two of the improved BST algorithms that we consider in <a class="docLink" href="ch13.html#ch13">Chapter 13</a>.</p>
<p class="docText">Suppose that the key of the item to be inserted is larger than the key at the root. We might start to make a new tree by putting the new item into a new root node, with the old root as the left subtree and the right subtree of the old root as the right subtree. However, the right subtree may contain some smaller keys, so we need to do more work to complete the insertion. Similarly, if the key of the item to be inserted is smaller than the key at the root and is larger than all the keys in the left subtree of the root, we can again make a new tree with the new item at the root, but more work is needed if the left subtree contains some larger keys. To move all nodes with smaller keys to the left subtree and all nodes with larger keys to the right subtree seems a complicated transformation in general, since the nodes that have to be moved can be scattered along the search path for the node to be inserted.</p>
<p class="docText">Fortunately, there is a simple recursive solution to this problem, which is based on <span class="docEmphasis">rotation</span>, a fundamental transformation on trees. Essentially, a rotation allows us to interchange the role of the root and one of the root's children in a tree while still preserving the BST ordering among the keys in the nodes. A <span class="docEmphasis">right rotation</span> involves the root and the left child (see <a class="docLink" href="#ch12fig12">Figure 12.12</a>). The rotation puts the root on the right, essentially reversing the direction of the left link of the root: Before the rotation, it points from the root to the left child; after the rotation, it points from the old left child (the new root) to the old root (the right child of the new root). The tricky part, which makes the rotation work, is to copy the right link of the left child to be the left link of the old root. This link points to all the nodes with keys <span class="docEmphasis">between</span> the two nodes involved in the rotation. Finally, the link <span class="docEmphasis">to</span> the old root has to be changed to point to the new root. The description of a <span class="docEmphasis">left rotation</span> is identical to the description just given, with &quot;right&quot; and &quot;left&quot; interchanged everywhere (see <a class="docLink" href="#ch12fig13">Figure 12.13</a>).</p>
<a name="ch12fig12"></a><p><center>
<h5 class="docFigureTitle">Figure 12.12. Right rotation in a BST</h5>
<h5></h5><h5></h5></center></p><p class="docText">This diagram shows the result (bottom) of a right rotation at <tt>S</tt> in an example BST (top). The node containing <tt>S</tt> moves down in the tree, becoming the right child of its former left child.</p><h5></h5><p class="docText">We accomplish the rotation by getting the link to the new root <tt>E</tt> from the left link of <tt>S</tt>, setting the left link of <tt>S</tt> by copying the right link of <tt>E</tt>, setting the right link of <tt>E</tt> to <tt>S</tt>, and setting the link to <tt>S</tt> from <tt>A</tt> to point to <tt>E</tt> instead.</p><h5></h5><p class="docText">The effect of the rotation is to move <tt>E</tt> and its left subtree up one level, and to move <tt>S</tt> and its right subtree down one level. The rest of the tree is not affected at all.</p>
<p class="docText">
<img border="0" alt="" width="150" height="231" src="12fig12.gif" /></p>
<br />
<a name="ch12fig13"></a><p><center>
<h5 class="docFigureTitle">Figure 12.13. Left rotation in a BST</h5>
<h5></h5><h5></h5></center></p><p class="docText">This diagram shows the result (bottom) of a left rotation at <tt>A</tt> in an example BST (top). The node containing <tt>A</tt> moves down in the tree, becoming the left child of its former right child.</p><h5></h5><p class="docText">We accomplish the rotation by getting the link to the new root <tt>E</tt> from the right link of <tt>A</tt>, setting the right link of <tt>A</tt> by copying the left link of <tt>E</tt>, setting the left link of <tt>E</tt> to <tt>A</tt>, and setting the link to <tt>A</tt> (the head link of the tree) to point to <tt>E</tt> instead.</p>
<p class="docText">
<img border="0" alt="" width="150" height="219" src="12fig13.gif" /></p>
<br />
<p class="docText">A rotation is a local change, involving only three links and two nodes, that allows us to move nodes around in trees without changing the global ordering properties that make BSTs useful for search (see <a class="docLink" href="#ch12ex22">Program 12.12</a>). We use rotations to move specific nodes through a tree and to keep the trees from becoming unbalanced. In <a class="docLink" href="ch12lev1sec9.html#ch12lev1sec9">Section 12.9</a> we implement <span class="docEmphasis">remove</span>, <span class="docEmphasis">join</span>, and other ADT operations with rotations; in <a class="docLink" href="ch13.html#ch13">Chapter 13</a> we use them to help us build trees that afford near-optimal performance.</p>
<a name="ch12ex22"></a><h5 id="title-IDAEOQFD" class="docExampleTitle">Program 12.12. Rotations in BSTs</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">These twin routines perform the <span class="docEmphasis">rotation</span> operation on a BST. A <span class="docEmphasis">right rotation</span> makes the old root the right subtree of the new root (the old left subtree of the root); a <span class="docEmphasis">left rotation</span> makes the old root the left subtree of the new root (the old right subtree of the root). For implementations where a count field is maintained in the nodes (for example, to support <span class="docEmphasis">select</span>, as we will see in Section 14.9), we need also to exchange the count fields in the nodes involved in the rotation (see <a class="docLink" href="#ch12qa8q3">Exercise 12.75</a>).</p>
<div class="docText"><pre>void rotR(link&amp; h)
  { link x = h-&gt;l; h-&gt;l = x-&gt;r; x-&gt;r = h; h = x; }
void rotL(link&amp; h)
  { link x = h-&gt;r; h-&gt;r = x-&gt;l; x-&gt;l = h; h = x; }</pre></div><br />
</td></tr></table></p>
<p class="docText">The rotation operations provide a straightforward recursive implementation of root insertion: Recursively insert the new item into the appropriate subtree (leaving it, when the recursive operation is complete, at the root of that tree), then rotate to make it the root of the main tree. <a class="docLink" href="#ch12fig14">Figure 12.14</a> depicts an example, and <a class="docLink" href="#ch12ex23">Program 12.13</a> is a direct implementation of this method. This program is a persuasive example of the power of recursion&mdash;any reader not so persuaded is encouraged to try <a class="docLink" href="#ch12qa8q4">Exercise 12.76</a>.</p>
<a name="ch12fig14"></a><p><center>
<h5 class="docFigureTitle">Figure 12.14. BST root insertion</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts the result of inserting <tt>G</tt> into the BST at the top, with (recursive) rotation after insertion to bring the newly inserted node <tt>G</tt> to the root. The process is equivalent to inserting <tt>G</tt>, then performing a sequence of rotations to bring it to the root.</p>
<p class="docText">
<img border="0" alt="" width="110" height="544" src="12fig14.gif" /></p>
<br />
<p class="docText"><a class="docLink" href="#ch12fig15">Figures 12.15</a> and <a class="docLink" href="#ch12fig16">12.16</a> show how we construct a BST by inserting a sequence of keys into an initially empty tree, using the root insertion method. If the key sequence is random, a BST built in this way has precisely the same stochastic properties as does a BST built by the standard method. For example, <a class="docLink" href="ch12lev1sec6.html#ch12ex18">Properties 12.6</a> and <a class="docLink" href="ch12lev1sec6.html#ch12ex19">12.7</a> hold for BSTs built by root insertion.</p>
<a name="ch12fig15"></a><p><center>
<h5 class="docFigureTitle">Figure 12.15. BST construction with root insertion</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts the result of inserting the keys <tt>A S E R C H I</tt> into an initially empty BST, using the root insertion method. Each new node is inserted at the root, with links along its search path changed to make a proper BST.</p>
<p class="docText">
<img border="0" alt="" width="110" height="350" src="12fig15.gif" /></p>
<br />
<a name="ch12fig16"></a><p><center>
<h5 class="docFigureTitle">Figure 12.16. BST construction with root insertion</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts insertion of the keys <tt>N G X M P L</tt> to the BST started in <a class="docLink" href="#ch12fig15">Figure 12.15</a>.</p>
<p class="docText">
<img border="0" alt="" width="175" height="500" src="12fig16.gif" /></p>
<br />
<p class="docText">In practice, an advantage of the root insertion method is that recently inserted keys are near the top. The cost for search hits on recently inserted keys therefore is likely to be lower than that for the standard method. This property is significant, because many applications have precisely this kind of dynamic mix among their <span class="docEmphasis">search</span>and <span class="docEmphasis">insert</span> operations. A symbol table might contain a great many items, but a large fraction of the searches might refer to the items that <a name="iddle1159"></a><a name="iddle2236"></a>were most recently inserted. For example, in a commercial transaction processing system, active transactions could remain near the top and be processed quickly, without access to old transactions being lost. The root insertion method gives the data structure this and similar properties automatically.</p>
<a name="ch12ex23"></a><h5 id="title-IDABVQFD" class="docExampleTitle">Program 12.13. Root insertion in BSTs</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">With the rotation functions in <a class="docLink" href="#ch12ex22">Program 12.12</a>, a recursive function that inserts a new node at the root of a BST is immediate: Insert the new item at the root in the appropriate subtree, then perform the appropriate rotation to bring it to the root of the main tree.</p>
<div class="docText"><pre>private:
  void insertT(link&amp; h, Item x)
    { if (h == 0) { h = new node(x); return; }
      if (x.key() &lt; h-&gt;item.key())
           { insertT(h-&gt;l, x); rotR(h); }
      else { insertT(h-&gt;r, x); rotL(h); }
    }
public:
  void insert(Item item)
    { insertT(head, item); }</pre></div><br />
</td></tr></table></p>
<p class="docText">If we also change the <span class="docEmphasis">search</span> function to bring the node found to the root when we have a search hit, then we have a self-organizing search method (see <a class="docLink" href="ch12lev1sec3.html#ch12qa3q13">Exercise 12.28</a>) that keeps frequently accessed nodes near the top of the tree. In <a class="docLink" href="ch13.html#ch13">Chapter 13</a>, we shall see a systematic application of this idea to provide a symbol-table implementation that has guaranteed fast performance characteristics.</p>
<p class="docText">As is true of several other methods that we have mentioned in this chapter, it is difficult to make precise statements about the performance of the root insertion method versus the standard insertion method for practical applications, because the performance depends on the mixture of symbol-table operations in a way that is difficult to characterize analytically. Our inability to analyze the algorithm should not necessarily dissuade us from using root insertion when we know that the preponderance of searches are for recently inserted data, but we always seek precise performance guarantees&mdash;our main focus in <a class="docLink" href="ch13.html#ch13">Chapter 13</a> is methods for constructing BSTs such that these guarantees can be provided.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa8q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">12.73</span> Draw the BST that results when you insert items with the keys <tt>E A S Y Q U E S T I O N</tt> into an initially empty tree, using the root insertion method.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa8q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.74</span> Give a sequence of 10 keys (use the letters A through J) that, when inserted into an initially empty tree via the root insertion method, requires a maximal number of comparisons to build the tree. Give the number of comparisons used.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa8q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.75</span> Add the code necessary to have <a class="docLink" href="#ch12ex22">Program 12.12</a> properly modify the count fields that need to be changed after the rotation.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa8q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">12.76</span> Implement a nonrecursive BST root insertion function (see <a class="docLink" href="#ch12ex23">Program 12.13</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch12qa8q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">12.77</span> Run empirical studies to compute the average and standard deviation of the number of comparisons used for search hits and for search misses in a BST built by inserting <span class="docEmphasis">N</span> random keys into an initially empty tree, then performing a sequence of <span class="docEmphasis">N</span> random searches for the <span class="docEmphasis">N</span>/10 most recently inserted keys, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>. Run your experiment both for the standard insertion method and for the root insertion method; then, compare the results.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12lev1sec7.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch12lev1sec9.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>