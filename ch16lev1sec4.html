<html><head><title>16.4. Extendible Hashing</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch16lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch16lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch16lev1sec4"></a>
<h3 id="643999-827" class="docSection1Title">16.4. Extendible Hashing</h3>
<p class="docText">An alternative to B trees that extends digital searching algorithms to apply to external searching was developed in 1978 by <a class="docLink" href="ch16lev2sec1.html#biblio16_006">Fagin</a>, <a class="docLink" href="ch16lev2sec1.html#biblio16_006">Nievergelt</a>, <a class="docLink" href="ch16lev2sec1.html#biblio16_006">Pippenger</a>, and Strong. Their method, called <span class="docEmphasis">extendible hashing</span>, leads to a <span class="docEmphasis">search</span> implementation that requires just one or two probes for typical applications. The corresponding <span class="docEmphasis">insert</span> implementation also (almost always) requires just one or two probes.</p>
<p class="docText">Extendible hashing combines features of hashing, multiway-trie algorithms, and sequential-access methods. Like the hashing methods of <a class="docLink" href="ch14.html#ch14">Chapter 14</a>, extendible hashing is a randomized algorithm&mdash;the first step is to define a hash function that transforms keys into integers (see <a class="docLink" href="ch14lev1sec1.html#ch14lev1sec1">Section 14.1</a>). For simplicity, in this section, we simply consider keys to be random fixed-length bitstrings. Like the multiway-trie algorithms of <a class="docLink" href="ch15.html#ch15">Chapter 15</a>, extendible hashing begins a search by using the leading bits of the keys to index into a table whose size is a power of 2. Like B-tree algorithms, extendible hashing stores items on pages that are split into two pieces when they fill up. Like indexed sequential-access methods, extendible hashing maintains a directory that tells us where we can find the page containing the items that match the search key. The blending of these familiar features in one algorithm makes extendible hashing a fitting conclusion to our study of search algorithms.</p>
<p class="docText"><a name="iddle1359"></a><a name="iddle1452"></a><a name="iddle1462"></a><a name="iddle1636"></a><a name="iddle2022"></a>Suppose that the number of disk pages that we have available is a power of 2&mdash;say 2<span class="docEmphasis"><sup>d</sup></span>. Then, we can maintain a directory of the 2<span class="docEmphasis"><sup>d</sup></span> different page references, use <span class="docEmphasis">d</span> bits of the keys to index into the directory, and can keep, on the same page, all keys that match in their first <span class="docEmphasis">k</span> bits, as illustrated in <a class="docLink" href="#ch16fig10">Figure 16.10</a>. As we do with B trees, we keep the items in order on the pages, and do sequential search once we reach the page corresponding to an item with a given search key.</p>
<a name="ch16fig10"></a><p><center>
<h5 class="docFigureTitle">Figure 16.10. Directory page indices</h5>
<h5></h5><h5></h5></center></p><p class="docText">With a directory of eight entries, we can store up to 40 keys by storing all records whose first 3 bits match on the same page, which we can access via a pointer stored in the directory (left). Directory entry 0 contains a pointer to the page that contains all keys that begin with 000; table entry 1 contains a pointer to the page that contains all keys that begin with 001; table entry 2 contains a pointer to the page that contains all keys that begin with 010, and so forth. If some pages are not fully populated, we can reduce the number of pages required by having multiple directory pointers to a page. In this example (left), <tt>373</tt> is on the same page as the keys that start with <tt>2</tt>; that page is defined to be the page that contains items with keys whose first 2 bits are <tt>01</tt>.</p><h5></h5><p class="docText">If we double the size of the directory and clone each pointer, we get a structure that we can index with the first 4 bits of the search key (right). For example, the final page is still defined to be the page that contains items with keys whose first three bits are <tt>111</tt>, and it will be accessed through the directory if the first 4 bits of the search key are <tt>1110</tt> or <tt>1111</tt>. This larger directory can accommodate growth in the table.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="400" height="582" src="16fig10.gif" /></p>
<br />
<p class="docText"><a class="docLink" href="#ch16fig10">Figure 16.10</a> illustrates the two basic concepts behind extendible hashing. First, we do not necessarily need to maintain 2<span class="docEmphasis"><sup>d</sup></span> pages. That is, we can arrange to have multiple directory entries refer to the same page, without changing our ability to search the structure quickly, by <a name="iddle2066"></a>combining keys with differing values for their leading <span class="docEmphasis">d</span> bits together on the same page, while still maintaining our ability to find the page containing a given key by using the leading bits of the key to index into the directory. Second, we can double the size of the directory to increase the capacity of the table.</p>
<a name="ch16ex10"></a><h5 id="title-IDASUV1D" class="docExampleTitle">Program 16.5. Extendible hashing data structures</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">An extendible hash table is a directory of references to pages (like the external nodes in B trees) that contain up to <span class="docEmphasis">2M</span> items. Each page also contains a count <tt>(m)</tt> of the number of items on the page, and an integer (<tt>k</tt>) that specifies the number of leading bits for which we know the keys of the items to be identical. As usual, <span class="docEmphasis">N</span> specifies the number of items in the table. The variable <span class="docEmphasis">d</span> specifies the number of bits that we use to index into the directory, and <span class="docEmphasis">D</span> is the number of directory entries, so <span class="docEmphasis">D = 2<sup>d</sup></span>. The table is initially set to a directory of size 1, which points to an empty page.</p>
<div class="docText"><pre>template &lt;class Item, 
class Key&gt; class ST
  {

    private:
      struct node
        { int m; Item b[M]; int k;
        node() { m = 0; k = 0; }
        };
      typedef node *link;
      link* dir;
      Item nullItem;
      int N, d, D;
    public:
      ST(int maxN)
        { N = 0; d = 0; D = 1;
          dir = new link[D];
          dir[0] = new node;
        }
    };</pre></div><br />
</td></tr></table></p>
<p class="docText">Specifically, the data structure that we use for extendible hashing is much simpler than the one that we used for B trees. It consists of pages that contain up to <span class="docEmphasis">M</span> items, and a directory of 2<span class="docEmphasis"><sup>d</sup></span> pointers to <a name="iddle1454"></a>pages (see <a class="docLink" href="#ch16ex10">Program 16.5</a>). The pointer in directory location <span class="docEmphasis">x</span> refers to the page that contains all items whose leading <span class="docEmphasis">d</span> bits are equal to <span class="docEmphasis">x</span>. The table is constructed with <span class="docEmphasis">d</span> sufficiently large that we are guaranteed that there are less than <span class="docEmphasis">M</span> items on each page. The implementation of <span class="docEmphasis">search</span> is simple: We use the leading <span class="docEmphasis">d</span> bits of the key to index into the directory, which gives us access to the page that contains any items with matching keys, then do sequential search for such an item on that page (see <a class="docLink" href="#ch16ex11">Program 16.6</a>).</p>
<a name="ch16ex11"></a><h5 id="title-IDAHXV1D" class="docExampleTitle">Program 16.6. Extendible hashing search</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Searching in an extendible hashing table is simply a matter of using the leading bits of the key to index into the directory, then doing a sequential search on the specified page for an item with a key equal to the search key. The only requirement is that each directory entry refer to a page that is guaranteed to contain all items in the symbol table that begin with the specified bits.</p>
<div class="docText"><pre> private:
   Item search(link h, Key v)
     {
       for (int j = 0; j &lt; h-&gt;m; j++)
         if (v == h-&gt;b[j].key()) return h-&gt;b[j];
       return nullItem;
     }
 public:
    Item search(Key v)
      { return search(dir[bits(v, 0, d)], v); }</pre></div><br />
</td></tr></table></p>
<p class="docText">The data structure needs to become slightly more complicated to support <span class="docEmphasis">insert</span>, but one of its essential features is that this search algorithm works properly without any modification. To support <span class="docEmphasis">insert</span>, we need to address the following questions:</p>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa3q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> What do we do when the number of items that belong on a page exceeds that page's capacity?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa3q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> What directory size should we use?</p></td></tr></table></p>
<p class="docText">For example, we could not use <span class="docEmphasis">d</span> = 2 in the example in <a class="docLink" href="#ch16fig10">Figure 16.10</a> because some pages would overflow, and we would not use <span class="docEmphasis">d</span> = 5 because too many pages would be empty. As usual, we are most interested in supporting the <span class="docEmphasis">insert</span> operation for the symbol-table ADT, <a name="iddle1363"></a><a name="iddle1453"></a><a name="iddle1463"></a><a name="iddle2023"></a>so that, for example, the structure can grow gradually as we do a series of intermixed <span class="docEmphasis">search</span> and <span class="docEmphasis">insert</span> operations. Taking this point of view corresponds to refining our first question:</p>
<p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa4q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> What do we dowhen we need to <span class="docEmphasis">insert</span> an item into a full page? For example, we could not insert an item whose key starts with a 5 or a 7 in the example in <a class="docLink" href="#ch16fig10">Figure 16.10</a> because the corresponding pages are full.</p></td></tr></table></p>
<a name="ch16ex12"></a><h5 id="title-IDA51V1D" class="docExampleTitle">Definition 16.3. An <span class="docEmphasis">extendible hash table</span> of order d is a directory of <span class="docEmphasis">2</span><sup>d</sup> references to pages that contain up to M items with keys. The items on each page are identical in their first k bits, and the directory contains <span class="docEmphasis">2</span><sup>d-k</sup> pointers to the page, starting at the location specified by the leading k bits in the keys on the page</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Some <span class="docEmphasis">d</span>-bit patterns may not appear in any keys. We leave the corresponding directory entries unspecified in <a class="docLink" href="#ch16ex12">Definition 16.3</a>, although there is a natural way to organize pointers to null pages; we will examine it shortly.</p>
<p class="docText">To maintain these characteristics as the table grows, we use two basic operations: a <span class="docEmphasis">page split</span>, where we distribute some of the keys from a full page onto another page; and a <span class="docEmphasis">directory split</span>, where we double the size of the directory and increase d by 1. Specifically, when a page fills, we split it into two pages, using the leftmost bit position for which the keys differ to decide which items go to the new page. When a page splits, we adjust the directory pointers appropriately, doubling the size of the directory if necessary.</p>
<p class="docText">As usual, the best way to understand the algorithm is to trace through its operation as we insert a set of keys into an initially empty table. Each of the situations that the algorithm must address occurs early in the process, in a simple form, and we soon come to a realization of the algorithm's underlying principles. <a class="docLink" href="#ch16fig11">Figures 16.11</a> through <a class="docLink" href="#ch16fig13">16.13</a> show the construction of an extendible hash table for the sample set of 25 octal keys that we have been considering in this chapter. As occurs in B trees, most of the insertions are uneventful: They simply add a key to a page. Since we start with one page and end up with eight pages, we can infer that seven of the insertions caused a page split; since we start with a directory of size 1 and end up with a directory of size 16, we can infer that four of the insertions caused a directory split.</p>
<a name="ch16fig11"></a><p><center>
<h5 class="docFigureTitle">Figure 16.11. Extendible hash table construction, part 1</h5>
<h5></h5><h5></h5></center></p><p class="docText">As in B trees, the first five insertions into an extendible hash table go into a single page (left). Then, when we insert <tt>773</tt>, we split into two pages (one with all the keys beginning with a 0 bit and one with all the keys beginning with a 1 bit) and double the size of the directory to hold one pointer to each of the pages (center). We insert <tt>742</tt> into the bottom page (because it begins with a 1 bit) and <tt>373</tt> into the top page (because it begins with a 0 bit), but we then need to split the bottom page to accommodate <tt>524</tt>. For this split, we put all the items with keys that begin with <tt>10</tt> on one page and all the items with keys that begin with <tt>11</tt> on the other, and we again double the size of the directory to accommodate pointers to both of these pages (right). The directory contains two pointers to the page containing items with keys starting with a 0 bit: one for keys that begin with <tt>00</tt> and the other for keys that begin with <tt>01</tt>.</p><p class="docText"><div class="v1"><a target="_blank" href="16fig11_alt.gif">[View full size image]</a></div><img border="0" alt="" id="118095012104" width="500" height="186" src="16fig11.gif" /></p>
</td></tr></table></p><br />
<a name="ch16fig12"></a><p><center>
<h5 class="docFigureTitle">Figure 16.12. Extendible hash table construction, part 2</h5>
<h5></h5><h5></h5></center></p><p class="docText">We insert the keys <tt>766</tt> and <tt>275</tt> into the rightmost B tree in <a class="docLink" href="#ch16fig11">Figure 16.11</a> without any node splits (left). Then, when we insert <tt>737</tt>, the bottom page splits, and that, because there is only one link to the bottom page, causes a directory split (center). Then, we insert <tt>574, 434, 641</tt>, and <tt>207</tt> before <tt>001</tt> causes the top page to split (right).</p><p class="docText"><div class="v1"><a target="_blank" href="16fig12_alt.gif">[View full size image]</a></div><img border="0" alt="" id="118095012104" width="500" height="357" src="16fig12.gif" /></p>
<br />
<a name="ch16fig13"></a><p><center>
<h5 class="docFigureTitle">Figure 16.13. Extendible hash table construction, part 3</h5>
<h5></h5><h5></h5></center></p><p class="docText">Continuing the example in <a class="docLink" href="#ch16fig11">Figures 16.11</a> and <a class="docLink" href="#ch16fig12">16.12</a>, we insert the 5 keys <tt>526, 562, 017, 107</tt>, and <tt>147</tt> into the rightmost B tree in <a class="docLink" href="ch16lev1sec3.html#ch16fig06">Figure 16.6</a> Node splits occur when we insert <tt>526</tt> (left) and <tt>107</tt> (right).</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="400" height="587" src="16fig13.gif" /></p>
<br />
</td></tr></table>
<p class="docText"></p><a name="ch16ex13"></a><h5 id="title-IDALCW1D" class="docExampleTitle">Property 16.4. <span class="docEmphasis">The extendible hash table built from a set of keys depends on only the values of those keys, and does not depend on the order in which the keys are inserted</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Consider the trie corresponding to the keys (see <a class="docLink" href="ch15lev1sec2.html#ch15ex06">Property 15.2</a>), with each internal node labeled with the number of items in its subtree. An internal node corresponds to a page in the extendible hash table if and only if its label is less than <span class="docEmphasis">M</span> and its parent's label is not less than <span class="docEmphasis">M</span>. All the items below the node go on that page. If a node is at level <span class="docEmphasis">k</span>, it corresponds to a <span class="docEmphasis">k</span>-bit pattern derived from the trie path in the normal way, and all entries in the extendible hash table's directory with indices that begin with that <span class="docEmphasis">k</span>-bit pattern contain pointers to the corresponding page. The size of the directory is determined by the deepest level among all the internal nodes in the trie that correspond to pages. Thus, we can convert a trie to an extendible hash table without regard to the order in which items are inserted, and this property holds as a consequence of <a class="docLink" href="ch15lev1sec2.html#ch15ex06">Property 15.2</a></p>
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch16ex14">Program 16.7</a> is an implementation of the <span class="docEmphasis">insert</span> operation for an extendible hash table. First, we access the page that could contain the search key, with a single reference to the directory, as we did for search. Then, we insert the new item there, as we did for external nodes in B trees (see <a class="docLink" href="ch16lev1sec3.html#ch16ex05">Program 16.2</a>). If this insertion leaves <span class="docEmphasis">M</span> items in the node, then we invoke a split function, again as we did for B trees, but the split function is more complicated in this case. Each page contains the number <span class="docEmphasis">k</span> of leading bits that we know to be the same in the keys of all the items on the page, and, because we number bits from the left starting at 0, k also specifies the index of the bit that we want to test to determine how to split the items.</p>
<p class="docText">Therefore, to split a page, we make a new page, then put all the items for which that bit is 0 on the old page and all the items for which that bit is 1 on the new page, then set the bit count to <span class="docEmphasis">k</span> + 1 for both pages. Now, it could be the case that all the keys have the same value for bit <span class="docEmphasis">k</span>, which would still leave us with a full node. If so, we simply go on to the next bit, continuing until we get a least one item in each page. The process must terminate, eventually, <span class="docEmphasis">unless we have M values of the same key</span>. We discuss that case shortly.</p>
<p class="docText">As with B trees, we leave space for an extra entry in every page to allow splitting after insertion, thus simplifying the code. Again, this technique has little practical effect, and we can ignore the effect in the analysis.</p>
<p class="docText"></p><a name="ch16ex14"></a><h5 id="title-IDA1EW1D" class="docExampleTitle">Program 16.7. Extendible hashing insertion</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">To insert an item into an extendible hash table, we search; then we insert the item on the specified page; then we split the page if the insertion caused overflow. The general scheme is the same as that for B trees, but the search and split algorithms are different. The split function creates a new node, then examines the <span class="docEmphasis">k</span>th bit (counting from the left) of each item's key: if the bit is 0, the item stays in the old node; if it is 1, it goes in the new node. The value <span class="docEmphasis">k</span> + 1 is assigned to the &quot;leading bits known to be identical&quot; field of both nodes after the split. If this process does not result in at least one key in each node, we split again, until the items are so separated. At the end, we insert the pointer with the new node into the directory.</p>
<div class="docText"><pre> private:
   void split(link h)
     { link t = new node;
       while (h-&gt;m == 0 || h-&gt;m == M)
         {
           h-&gt;m = t-&gt;m = 0;
           for (int j = 0; j &lt; M; j++)
             if (bits(h-&gt;b[j].key(), h-&gt;k, 1) == 0)
                  h-&gt;b[h-&gt;m++] = h-&gt;b[j];
             else t-&gt;b[t-&gt;m++] = h-&gt;b[j];
           t-&gt;k = ++(h-&gt;k);
         }
       insertDIR(t, t-&gt;k);
     }
   void insert(link h, Item x)
     { int j; Key v = x.key();
       for (j = 0; j &lt; h-&gt;m; j++)
         if (v &lt; h-&gt;b[j].key()) break;
       for (int i = (h-&gt;m)++; i &gt; j; i--)
         h-&gt;b[i] = h-&gt;b[i-1];
       h-&gt;b[j] = x;
       if (h-&gt;m == M) split(h);
     }
 public:
   void insert(Item x)
     { insert(dir[bits(x.key(), 0, d), x); }</pre></div><br />
</td></tr></table></p>
<p class="docText"></p><a name="ch16ex15"></a><h5 id="title-IDAZFW1D" class="docExampleTitle">Program 16.8. Extendible-hashing directory insertion</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1364"></a><a name="iddle1398"></a>This deceptively simple code is at the heart of the extendible-hashing process. We are given a link <span class="docEmphasis">t</span> to a node that carries items that match in the first <span class="docEmphasis">k</span> bits, which is to be incorporated into the directory. In the simplest case, where <tt>d</tt> and <span class="docEmphasis">k</span> are equal, we just put <span class="docEmphasis">t</span> into <tt>d[x]</tt>, where <tt>x</tt> is the value of the first <tt>d</tt> bits of <tt>t-&gt;b[0]</tt> (and of all the other items on the page). If <tt>k</tt> is greater than <tt>d</tt>, we have to double the size of the directory, until reducing to the case where <tt>d</tt> and <tt>k</tt> are equal. If <tt>k</tt> is less than <tt>d</tt>, we need to set more than one pointer&mdash;the first <tt>for</tt> loop calculates the number of pointers that we need to set (2<span class="docEmphasis"><sup>d - k</sup></span>), and the second <tt>for</tt> loop does the job.</p>
<div class="docText"><pre>void insertDIR(link t, int k)
  { int i, m, x = bits(t-&gt;b[0].key(), 0, k);
    while (d &lt; k)
      { link *old = dir;
        d += 1; D += D;
        dir = new link[D];
        for (i = 0; i &lt; D; i++) dir[i] = old[i/2];
        if (d &lt; k) dir[bits(x, 0, d)^1] = new node;
      }
    for (m = 1; k &lt; d; k++) m *= 2;
    for (i = 0; i &lt; m; i++) dir[x*m+i] = t;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">When we create a new page, we have to insert a pointer to it in the directory. The code that accomplishes this insertion is given in <a class="docLink" href="#ch16ex15">Program 16.8</a>. The simplest case to consider is the one where the directory, prior to insertion, has precisely two pointers to the page that splits. In that case, we need simply to arrange to set the second pointer to reference the new page. If the number of bits <span class="docEmphasis">k</span> that we need to distinguish the keys on the new page is greater than the number of bits <span class="docEmphasis">d</span> that we have to access the directory, then we have to increase the size of the directory to accommodate the new entry. Finally, we update the directory pointers as appropriate.</p>
<p class="docText">If more than <span class="docEmphasis">M</span> items have duplicate keys, the table overflows, and the code in <a class="docLink" href="#ch16ex14">Program 16.7</a> goes into an infinite loop, looking for a way to distinguish the keys. A related problem is that the directory may get unnecessarily huge, if the keys have an excessive number of leading <a name="iddle1362"></a>bits that are equal. This situation is akin to the excessive time required for MSD radix sort, for files that have large numbers of duplicate keys or long stretches of bit positions where they are identical. We depend on the randomization provided by the hash function to stave off these problems (see <a class="docLink" href="#ch16qa5q17">Exercise 16.43</a>). Even with hashing, extraordinary steps must be taken if large numbers of duplicate keys are present, because hash functions take equal keys to equal hash values. Duplicate keys can make the directory artificially large; and the algorithm breaks down entirely if there are more equal keys than fit in one page. Therefore, we need to add tests to guard against the occurrence of these conditions before using this code (see <a class="docLink" href="#ch16qa5q9">Exercise 16.35</a>).</p>
<p class="docText">The primary performance parameters of interest are the number of pages used (as with B trees) and the size of the directory. The randomization for this algorithm is provided by the hash functions, so average-case performance results apply to any sequence of N distinct insertions.</p>
<a name="ch16ex16"></a><h5 id="title-IDAZJW1D" class="docExampleTitle">Property 16.5. <span class="docEmphasis">With pages that can hold M items, extendible hashing requires about</span> <span class="docEmphRoman">1.44</span><span class="docEmphasis">(N/M) pages for a file of N items, on the average. The expected number of entries in the directory is about</span> <span class="docEmphRoman">3.92</span><span class="docEmphasis">(N<sup>1/M</sup>)(N/M)</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This (rather deep) result extends the analysis of tries that we discussed briefly in the previous chapter (<span class="docEmphasis">see reference section</span>). The exact constants are lge = 1/ln2 for the number of pages and elge = e/ln 2 for the directory size, though the precise values of the quantities oscillate around these average values. We should not be surprised by this phenomenon because, for example, the directory size has to be a power of 2, a fact which has to be accounted for in the result.</p>
</td></tr></table></p>
<p class="docText">Note that the growth rate of the directory size is faster than linear in <span class="docEmphasis">N</span>, particularly for small <span class="docEmphasis">M</span>. However, for <span class="docEmphasis">N</span> and <span class="docEmphasis">M</span> in ranges of practical interest, <span class="docEmphasis">N<sup>1/M</sup></span> is quite close to 1, so we can expect the directory to have about <span class="docEmphasis">4(N/M)</span> entries, in practice.</p>
<p class="docText">We have considered the directory to be a single array of pointers. We can keep the directory in memory, or, if it is too big, we can keep a root node in memory that tells where the directory pages are, using the same indexing scheme. Alternatively, we can add another level, indexing the first level on the first 10 bits (say), and the second level on the rest of the bits (see <a class="docLink" href="#ch16qa5q10">Exercise 16.36</a>).</p>
<p class="docText">As we did for B trees, we leave the implementation of other symbol-table operations for exercises (see <a class="docLink" href="#ch16qa5q12">Exercises 16.38</a> and <a class="docLink" href="#ch16qa5q15">16.41</a>). Also as it is with B trees, a proper <span class="docEmphasis">remove</span> implementation is a challenge, but allowing underfull pages is an easy alternative that can be effective in many practical situations.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q1"></a><b></b></td><td><p class="docText">
<img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">16.27</span> How many pages would be empty if we were to use a directory of size 32 in <a class="docLink" href="#ch16fig10">Figure 16.10</a>?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">16.28</span> Draw figures corresponding to <a class="docLink" href="#ch16fig11">Figures 16.11</a> through <a class="docLink" href="#ch16fig13">16.13</a>, to illustrate the process of inserting the keys <tt>562, 221, 240, 771, 274, 233, 401, 273</tt>, and <tt>201</tt> in that order into an initially empty tree, with <span class="docEmphasis">M</span> = 5.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q3"></a><b></b></td><td><p class="docText">
<img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">16.29</span> Draw figures corresponding to <a class="docLink" href="#ch16fig11">Figures 16.11</a> through <a class="docLink" href="#ch16fig13">16.13</a>, to illustrate the process of inserting the keys <tt>562, 221, 240, 771, 274, 233, 401, 273</tt>, and <tt>201</tt> in that order into an initially empty tree, with <span class="docEmphasis">M</span> = 5.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q4"></a><b></b></td><td><p class="docText">
<img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">16.30</span> Assume that you are given an array of items in sorted order. Describe how you would determine the directory size of the extendible hash table corresponding to that set of items.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q5"></a><b></b></td><td><p class="docText">
<img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">16.31</span> Write a program that constructs an extendible hash table from an array of items that is in sorted order, by doing two passes through the items: one to determine the size of the directory (see <a class="docLink" href="#ch16qa5q4">Exercise 16.30</a>) and one to allocate the items to pages and fill in the directory.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q6"></a><b></b></td><td><p class="docText">
<img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">16.32</span> Give a set of keys for which the corresponding extendible hash table has directory size 16, with eight pointers to a single page.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q7"></a><b></b></td><td><p class="docText">
<img border="0" alt="" id="118095012104" width="17" height="8" src="douleblackcircle.jpg" />
<span class="docEmphStrong">16.33</span> Create a figure like <a class="docLink" href="ch16lev1sec3.html#ch16fig08">Figure 16.8</a> for extendible hashing.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q8"></a><b></b></td><td><p class="docText">
<img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">16.34</span> Write a program to compute the average number of external pages and the average directory size for an extendible hash table built from <span class="docEmphasis">N</span> random insertions into an initially empty tree, when the page capacity is <span class="docEmphasis">M</span>. Compute the percentage of empty space, for <span class="docEmphasis"><tt>M</tt></span> <tt>= 10, 100</tt>, and <tt>1000</tt> and <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">16.35</span> Add appropriate tests to <a class="docLink" href="#ch16ex14">Program 16.7</a> to guard against malfunction in case too many duplicate keys or keys with too many leading equal bits are inserted into the table.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q10"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">16.36</span> Modify the extendible-hashing implementation in <a class="docLink" href="#ch16ex10">Programs 16.5</a>through <a class="docLink" href="#ch16ex14">16.7</a> to use a two-level directory, with no more than <span class="docEmphasis">M</span> pointers per directory node. Pay particular attention to deciding what to do when the directory first grows from one level to two.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q11"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">16.37</span> Modify the extendible-hashing implementation in <a class="docLink" href="#ch16ex10">Programs 16.5</a> through <a class="docLink" href="#ch16ex14">16.7</a> to allow M items per page to exist in the data structure.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q12"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">16.38</span> Implement the <span class="docEmphasis">sort</span> operation for an extendible hash table.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q13"></a><b></b></td><td> <p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">16.39</span> Implement the <span class="docEmphasis">select</span> operation for an extendible hash table.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q14"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">16.40</span> Implement the <span class="docEmphasis">remove</span> operation for an extendible hash table.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q15"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">16.41</span> Implement the <span class="docEmphasis">remove</span> operation for an extendible hash table, using the method indicated in <a class="docLink" href="ch16lev1sec3.html#ch16qa2q21">Exercise 16.25</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q16"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">16.42</span> Develop a version of extendible hashing that splits pages when splitting the directory, so that each directory pointer points to a unique page. Develop experiments to compare the performance of your implementation to that of the standard implementation.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q17"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">16.43</span> Run empirical studies to determine the number of random numbers that we would expect to generate before finding more than <span class="docEmphasis">M</span> numbers with the same <span class="docEmphasis">d</span> initial bits, for <span class="docEmphasis"><tt>M</tt></span> <tt>= 10, 100</tt>, and <tt>1000</tt>, and for 1 <img src="U2264.GIF" border="0" /> <span class="docEmphasis">d</span> <img src="U2264.GIF" border="0" /> 20.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q18"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">16.44</span> Modify hashing with separate chaining (<a class="docLink" href="ch14lev1sec2.html#ch14ex03">Program 14.3</a>) to use a hash table of size 2<span class="docEmphasis">M</span>, and keep items in pages of size 2<span class="docEmphasis">M</span>. That is, when a page fills, link it to a new empty page, so each hash table entry points to a linked list of pages. Empirically determine the average number of probes required for a search after building a table from <span class="docEmphasis">N</span> items with random keys, for <span class="docEmphasis"><tt>M</tt></span> <tt>= 10, 100</tt>, and <tt>1000</tt> and <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch16qa5q19"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">16.45</span> Modify double hashing (<a class="docLink" href="ch14lev1sec4.html#ch14ex09">Program 14.6</a>) to use pages of size 2<span class="docEmphasis">M</span>, treating accesses to full pages as &quot;collisions.&quot; Empirically determine the average number of probes required for a search after building a table from <span class="docEmphasis">N</span> items with random keys, for <span class="docEmphasis"><tt>M</tt></span> <tt>= 10, 100</tt>, and <tt>1000</tt> and <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>, using an initial table size of 3<span class="docEmphasis">N</span>/2<span class="docEmphasis">M</span>.</p></td></tr></table></p>
<ul></ul></div></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch16lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch16lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table><!--IP User 2--></td></body></head></html>