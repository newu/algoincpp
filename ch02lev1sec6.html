<html><head><title>2.6. Examples of Algorithm Analysis</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch02lev1sec5.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch02lev1sec7.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch02lev1sec6"></a>
<h3 id="title-IDA544VF" class="docSection1Title">2.6. Examples of Algorithm Analysis</h3>
<p class="docText">Armed with the tools outlined in the previous three sections, we now consider the analysis of <span class="docEmphasis">sequential search</span> and <span class="docEmphasis">binary search</span>, two basic algorithms for determining whether or not any of a sequence of objects appears among a set of previously stored objects. Our purpose is to illustrate the manner in which we will compare algorithms, rather than to describe these particular algorithms in detail. For simplicity, we assume here that the objects in question are integers. We will consider more general applications in great detail in <a class="docLink" href="ch12.html#ch12">Chapters 12</a> through <a class="docLink" href="ch16.html#ch16">16</a>. The simple versions of the algorithms that we consider here not only expose many aspects of the algorithm design and analysis problem, but also have many direct applications.</p>
<p class="docText">For example, we might imagine a credit-card company that has <span class="docEmphasis">N</span> credit risks or stolen credit cards, and that wants to check whether any of <span class="docEmphasis">M</span> given transactions involves any one of the <span class="docEmphasis">N</span> bad numbers. To be concrete, we might think of <span class="docEmphasis">N</span> being large (say on the order of 10<sup>3</sup> to 10<sup>6</sup>) and <span class="docEmphasis">M</span> being huge (say on the order of 10<sup>6</sup> to 10<sup>9</sup>) for this application. The goal of the analysis is to be able to estimate the running times of the algorithms when the values of the parameters fall within these ranges.</p>
<p class="docText"><a class="docLink" href="#ch02ex02">Program 2.1</a> implements a straightforward solution to the search problem. It is packaged as a C++ function that operates on an array (see <a class="docLink" href="ch03.html#ch03">Chapter 3</a>) for better compatibility with other code that we will examine for the same problem in <a class="docLink" href="part04.html#part04">Part 4</a>, but it is not necessary to understand the details of the packaging to understand the algorithm: We store all the objects in an array; then, for each transaction, we look <a name="iddle2312"></a>through the array sequentially, from beginning to end, checking each to see whether it is the one that we seek.</p>
<a name="ch02ex02"></a><h5 id="title-IDAYB5VF" class="docExampleTitle">Program 2.1. Sequential search</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This function checks whether the number <tt>v</tt> is among a previously stored set of numbers in <tt>a[l], a[l+1], . . ., a[r]</tt>, by comparing against each number sequentially, starting at the beginning. If we reach the end without finding the number sought, then we return the value <tt>-1</tt>. Otherwise, we return the index of the array position containing the number.</p>
<div class="docText"><pre>int search(int a[], int v, int l, int r)
  {
    for (int i = l; i &lt;= r; i++)
      if (v == a[i]) return i;
    return -1;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">To analyze the algorithm, we note immediately that the running time depends on whether or not the object sought is in the array. We can determine that the search is unsuccessful only by examining each of the <span class="docEmphasis">N</span> objects, but a search could end successfully at the first, second, or any one of the objects.</p>
<p class="docText">Therefore, the running time depends on the data. If all the searches are for the number that happens to be in the first position in the array, then the algorithm will be fast; if they are for the number that happens to be in the last position in the array, it will be slow. We discuss in <a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7">Section 2.7</a> the distinction between being able to <span class="docEmphasis">guarantee</span> performance and being able to <span class="docEmphasis">predict</span> performance. In this case, the best guarantee that we can provide is that no more that <span class="docEmphasis">N</span> numbers will be examined.</p>
<p class="docText">To make a prediction, however, we need to make an assumption about the data. In this case, we might choose to assume that all the numbers are randomly chosen. This assumption implies, for example, that each number in the table is equally likely to be the object of a search. On reflection, we realize that it is that property of the search that is critical, because with randomly chosen numbers we would be unlikely to have a successful search at all (see <a class="docLink" href="#ch02qa6q2">Exercise 2.48</a>). For some applications, the number of transactions that involve a successful search might be high; for other applications, it might be low. To avoid confusing the model with properties of the application, we separate the two cases (successful and unsuccessful) and analyze them independently. This example illustrates that a critical part of an effective analysis is the development of a reasonable model for the application at hand. Our analytic results will depend on the proportion of searches that are successful; indeed, it will give us information that we might need if we are to choose different algorithms for different applications based on this parameter.</p>
<a name="ch02ex03"></a><h5 id="title-IDAWD5VF" class="docExampleTitle">Property 2.1. <span class="docEmphasis">Sequential search examines N numbers for each unsuccessful search and about N/2 numbers for each successful search on the average</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">If each number in the table is equally likely to be the object of a search, then</p>
<div class="docText"><pre>(1 + 2 + ... + <span class="docEmphasis">N</span>)/<span class="docEmphasis">N</span>= (<span class="docEmphasis">N</span> + 1)/2</pre></div><br />
<p class="docText">is the average cost of a search.</p>
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch02ex03">Property 2.1</a> implies that the running time of <a class="docLink" href="#ch02ex02">Program 2.1</a> is proportional to <span class="docEmphasis">N</span>, subject to the implicit assumption that the average cost of comparing two numbers is constant. Thus, for example, we can expect that, if we double the number of objects, we double the amount of time required for a search.</p>
<p class="docText">We can speed up sequential search for unsuccessful search by putting the numbers in the table in order. Sorting the numbers in the table is the subject of <a class="docLink" href="ch06.html#ch06">Chapters 6</a> through <a class="docLink" href="ch11.html#ch11">11</a>. A number of the algorithms that we will consider get that task done in time proportional to <span class="docEmphasis">N</span> <span class="docEmphRoman">log</span> <span class="docEmphasis">N</span>, which is insignificant by comparison to the search costs when <span class="docEmphasis">M</span> is huge. In an ordered table, we can terminate the search immediately on reaching a number that is larger than the one that we seek. This change reduces the cost of sequential search to about <span class="docEmphasis">N/2</span> numbers examined for unsuccessful search, the same as for successful search.</p>
<a name="ch02ex04"></a><h5 id="title-IDAIG5VF" class="docExampleTitle">Property 2.2. <span class="docEmphasis">Sequential search in an ordered table examines N numbers for each search in the worst case and about N/2 numbers for each search on the average</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We still need to specify a model for unsuccessful search. This result follows from assuming that the search is equally likely to terminate at any one of the <span class="docEmphasis">N</span> + 1 intervals defined by the <span class="docEmphasis">N</span> numbers in the table, which leads immediately to the expression</p>
<div class="docText"><pre>(1 + 2 + . . . + <span class="docEmphasis">N</span> + <span class="docEmphasis">N</span>)/<span class="docEmphasis">N</span> = (<span class="docEmphasis">N</span> + 3)/2.</pre></div><br />
<p class="docText">The cost of an unsuccessful search ending before or after the <span class="docEmphasis">N</span>th entry in the table is the same: <span class="docEmphasis">N</span>.</p>
</td></tr></table></p>
<p class="docText"></p><a name="ch02ex05"></a><h5 id="title-IDAZH5VF" class="docExampleTitle">Program 2.2. Binary search</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1039"></a><a name="iddle1143"></a><a name="iddle2316"></a>This program has the same functionality as <a class="docLink" href="#ch02ex02">Program 2.1</a>, but it is much more efficient.</p>
<div class="docText"><pre>int search(int a[], int v, int l, int r)
  {
    while (r &gt;= l)
      { int m = (l+r)/2;
        if (v == a[m]) return m;
        if (v &lt; a[m]) r = m-1; else l = m+1;
      }
    return -1;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">Another way to state the result of <a class="docLink" href="#ch02ex04">Property 2.2</a> is to say that the running time of sequential search is proportional to <span class="docEmphasis">MN</span> for <span class="docEmphasis">M</span> transactions, on the average and in the worst case. If we double either the number of transactions or the number of objects in the table, we can expect the running time to double; if we double both, we can expect the running time to go up by a factor of 4. The result also tells us that the method is not suitable for huge tables. If it takes <span class="docEmphasis">c</span> microseconds to examine a single number, then, for <span class="docEmphasis">M</span> = 10<sup>9</sup> and <span class="docEmphasis">N</span> = 10<sup>6</sup>, the running time for all the transactions would be at least (<span class="docEmphasis">c</span>/2)10<sup>9</sup> seconds, or, by <a class="docLink" href="ch02lev1sec3.html#ch02fig01">Figure 2.1</a>, about 16<span class="docEmphasis">c</span> years, which is prohibitive.</p>
<p class="docText"><a class="docLink" href="#ch02ex05">Program 2.2</a> is a classical solution to the search problem that is much more efficient than sequential search. It is based on the idea that, if the numbers in the table are in order, we can eliminate half of them from consideration by comparing the one that we seek with the one at the middle position in the table. If it is equal, we have a successful search. If it is less, we apply the same method to the left half of the table. If it is greater, we apply the same method to the right half of the <a name="iddle1055"></a><a name="iddle1067"></a><a name="iddle2290"></a>table. <a class="docLink" href="#ch02fig07">Figure 2.7</a> is an example of the operation of this method on a sample set of numbers.</p>
<a name="ch02fig07"></a><p><center>
<h5 class="docFigureTitle">Figure 2.7. Binary search</h5>
<h5></h5><h5></h5></center></p><p class="docText">To see whether or not 5025 is in the table of numbers in the left column, we first compare it with 6504; that leads us to consider the first half of the array. Then we compare against 4548 (the middle of the first half); that leads us to the second half of the first half. We continue, always working on a subarray that would contain the number being sought, if it is in the table. Eventually, we get a subarray with just 1 element, which is not equal to 5025, so 5025 is not in the table.</p>
<p class="docText">
<img border="0" alt="" width="160" height="325" src="02fig07.gif" /></p>
<br />
<a name="ch02ex06"></a><h5 id="title-IDAXM5VF" class="docExampleTitle">Property 2.3. <span class="docEmphasis">Binary search never examines more than</span> <img src="U230A.GIF" border="0" /><span class="docEmphRoman">lg</span> <span class="docEmphasis">N</span><img src="U230B.GIF" border="0" /> <span class="docEmphRoman">+ 1</span> <span class="docEmphasis">numbers</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The proof of this property illustrates the use of recurrence relations in the analysis of algorithms. If we let <span class="docEmphasis">T<sub>N</sub></span> represent the number of comparisons required for binary search in the worst case, then the way in which the algorithm reduces search in a table of size <span class="docEmphasis">N</span> to search in a table half the size immediately implies that</p>
<div class="docText"><pre>T<sub>N</sub><img src="U2264.GIF" border="0" /> T<img src="U230A.GIF" border="0" /><sub>N/2</sub><img src="U230B.GIF" border="0" /> + 1, for N <img src="U2265.GIF" border="0" /> 2 with T<sub>1</sub> = 1:</pre></div><br />
<p class="docText">To search in a table of size <span class="docEmphasis">N</span>, we examine the middle number, then search in a table of size no larger than <img src="U230A.GIF" border="0" />N/2<img src="U230B.GIF" border="0" />. The actual cost could be less than this value because the comparison might cause us to terminate a successful search, or because the table to be searched might be of size <img src="U230A.GIF" border="0" /><span class="docEmphasis">N</span>/2<img src="U230B.GIF" border="0" />&ndash;1 (if <span class="docEmphasis">N</span> is even). As we did in the solution of <a class="docLink" href="ch02lev1sec5.html#ch02ex02b">Formula 2.2</a>, we can prove immediately that <span class="docEmphasis">T<sub>N</sub></span><img src="U2264.GIF" border="0" /> <span class="docEmphasis">n</span> + 1 if <span class="docEmphasis">N</span> = 2<span class="docEmphasis"><sup>n</sup></span> and then verify the general result by induction.</p>
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch02ex06">Property 2.3</a> allows us to solve a huge search problem with up to 1 million numbers with at most 20 comparisons per transaction, and that is likely to be less than the time it takes to read or write the number on many computers. The search problem is so important that several methods have been developed that are even faster than this one, as we shall see in <a class="docLink" href="ch12.html#ch12">Chapters 12</a> through <a class="docLink" href="ch16.html#ch16">16</a>.</p>
<p class="docText">Note that we express <a class="docLink" href="#ch02ex03">Property 2.1</a> and <a class="docLink" href="#ch02ex04">Property 2.2</a> in terms of the operations that we perform most often on the data. As we noted in the commentary following <a class="docLink" href="#ch02ex03">Property 2.1</a>, we expect that each operation should take a constant amount of time, and we can conclude that the running time of binary search is proportional to lg <span class="docEmphasis">N</span> as compared to <span class="docEmphasis">N</span> for sequential search. As we double <span class="docEmphasis">N</span>, the running time of binary search hardly changes, but the running time of sequential search doubles. As <tt>N</tt> grows, the gap between the two methods becomes a chasm.</p>
<p class="docText">We can verify the analytic evidence of <a class="docLink" href="#ch02ex03">Properties 2.1</a>  and <a class="docLink" href="#ch02ex04">2.2</a> by implementing and testing the algorithms. For example, <a class="docLink" href="#ch02table04">Table 2.4</a> shows running times for binary search and sequential search for <span class="docEmphasis">M</span> searches in a table of size <span class="docEmphasis">N</span> (including, for binary search, the cost of <a name="iddle1045"></a><a name="iddle1049"></a>sorting the table) for various values of <span class="docEmphasis">M</span> and <span class="docEmphasis">N</span>. We will not consider the implementation of the program to run these experiments in detail here because it is similar to those that we consider in full detail in <a class="docLink" href="ch06.html#ch06">Chapters 6</a> and <a class="docLink" href="ch11.html#ch11">11</a>, and because we consider the use of library and external functions and other details of putting together programs from constituent pieces, including the <tt>sort</tt> function, in <a class="docLink" href="ch03.html#ch03">Chapter 3</a>. For the moment, we simply stress that doing empirical testing is an integral part of evaluating the efficiency of an algorithm.</p>
<a name="ch02table04"></a><p><table cellspacing="0" frame="hsides" rules="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 2.4. Empirical study of sequential and binary search</h5></caption><colgroup align="left" span="7"><col width="100"></col><col width="75"></col><col width="75"></col><col width="75"></col><col width="75"></col><col width="75"></col><col width="75"></col></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top" colspan="7"><p class="docText">These relative timings validate our analytic results that sequential search takes time proportional to <span class="docEmphasis">MN</span> and binary search takes time proportional to <span class="docEmphasis">M</span> lg <span class="docEmphasis">N</span> for <span class="docEmphasis">M</span> searches in a table of <span class="docEmphasis">N</span> objects. When we increase <span class="docEmphasis">N</span> by a factor of 2, the time for sequential search increases by a factor of 2 as well, but the time for binary search hardly changes. Sequential search is infeasible for huge <span class="docEmphasis">M</span> as <span class="docEmphasis">N</span> increases, but binary search is fast even for huge tables.</p></td></tr><tr><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="bottomBorder" align="center" valign="top" colspan="2"><p class="docText"><span class="docEmphasis">M</span> = 1000</p></td><td class="bottomBorder" align="center" valign="top" colspan="2"><p class="docText"><span class="docEmphasis">M</span> = 10000</p></td><td class="bottomBorder" align="center" valign="top" colspan="2"><p class="docText"><span class="docEmphasis">M</span> = 100000</p></td></tr><tr><td class="bottomBorder" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">S</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">B</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">S</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">B</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">S</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">B</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">125</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">13</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">2</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">130</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">20</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">250</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">3</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">0</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">25</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">2</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">251</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">22</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">500</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">5</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">0</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">49</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">3</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">492</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">23</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">1250</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">13</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">0</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">128</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">3</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1276</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">25</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">2500</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">26</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">267</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">3</p></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="center" valign="top"><p class="docText">28</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">5000</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">53</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">0</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">533</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">3</p></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="center" valign="top"><p class="docText">30</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">12500</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">134</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1337</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">3</p></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="center" valign="top"><p class="docText">33</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">25000</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">268</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">1</p></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="center" valign="top"><p class="docText">3</p></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="center" valign="top"><p class="docText">35</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">50000</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">537</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">0</p></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="center" valign="top"><p class="docText">4</p></td><td class="docTableCell" align="left" valign="top">&nbsp;</td><td class="docTableCell" align="center" valign="top"><p class="docText">39</p></td></tr><tr><td class="bottomBorder" align="center" valign="top"><p class="docText">100000</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">1269</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">1</p></td><td class="bottomBorder" align="left" valign="top">&nbsp;</td><td class="bottomBorder" align="center" valign="top"><p class="docText">5</p></td><td class="bottomBorder" align="left" valign="top">&nbsp;</td><td class="bottomBorder" align="center" valign="top"><p class="docText">47</p></td></tr><tr><td class="docTableCell" align="left" valign="top" colspan="7"><p class="docText"><span class="docEmphasis">Key</span>:</p>
<blockquote><p></p><p class="docList">S sequential search (<a class="docLink" href="#ch02ex02">Program 2.1</a>)</p></blockquote></td></tr></table></p><p></p><p class="docList">B binary search (<a class="docLink" href="#ch02ex05">Program 2.2</a>)</p></td></tr></table><br />
<p class="docText"><a class="docLink" href="#ch02table04">Table 2.4</a> validates our observation that the functional growth of the running time allows us to predict performance for huge cases on the basis of empirical studies for small cases. The combination of mathematical analysis and empirical studies provides persuasive evidence that binary search is the preferred algorithm, by far.</p>
<p class="docText">This example is a prototype of our general approach to comparing algorithms. We use mathematical analysis of the frequency with which algorithms perform critical abstract operations, then use those results to deduce the functional form of the running time, which allows us to verify and extend empirical studies. As we develop algorithmic solutions to computational problems that are more and more refined, and as we develop mathematical analyses to learn their performance characteristics that are more and more refined, we call on mathematical studies from the literature, so as to keep our attention on the algorithms themselves in this book. We cannot do thorough mathematical and empirical studies of every algorithm that we encounter, but we strive to identify essential performance characteristics, knowing that, in principle, we can develop a scientific basis for making informed choices among algorithms in critical applications.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa6q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">2.47</span> Give the average number of comparisons used by <a class="docLink" href="#ch02ex02">Program 2.1</a> in the case that &#945;<span class="docEmphasis">N</span> of the searches are successful, for 0<img src="U2264.GIF" border="0" />&#945; <img src="U2264.GIF" border="0" /> 1.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa6q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">2.48</span> Estimate the probability that at least one of <span class="docEmphasis">M</span> random 10-digit numbers matches one of a set of <span class="docEmphasis">N</span> given values, for <span class="docEmphasis">M</span> = 10, 100, and 1000 and <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa6q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">2.49</span> Write a driver program that generates <span class="docEmphasis">M</span> random integers and puts them in an array, then counts the number of <span class="docEmphasis">N</span> random integers that matches one of the numbers in the array, using sequential search. Run your program for <span class="docEmphasis">M</span> = 10, 100, and 1000 and <span class="docEmphasis">N</span> = 10, 100, and 1000.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa6q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">2.50</span> State and prove a property analogous to <a class="docLink" href="#ch02ex06">Property 2.3</a> for binary search.</p></td></tr></table></p>
<a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></div></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch02lev1sec5.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch02lev1sec7.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table><!--IP User 2--></td></body></head></html>