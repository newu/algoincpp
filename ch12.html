<html><head><title>Chapter Twelve. Symbol Tables and Binary Search Trees</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="part04.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch12lev1sec1.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch12"></a>
<h2 id="title-IDAHFZCP" class="docChapterTitle">Chapter Twelve. Symbol Tables and Binary Search Trees</h2>
<p class="docText"><a name="iddle1337"></a><a name="iddle1695"></a><a name="iddle1717"></a><a name="iddle2315"></a><a name="iddle2477"></a><a name="iddle2482"></a>The retrieval of a particular piece or pieces of information from large volumes of previously stored data is a fundamental operation, called <span class="docEmphasis">search</span>, that is intrinsic to a great many computational tasks. As with sorting algorithms in <a class="docLink" href="ch06.html#ch06">Chapters 6</a> through <a class="docLink" href="ch11.html#ch11">11</a>, and in particular priority queues in <a class="docLink" href="ch09.html#ch09">Chapter 9</a>, we work with data divided into records or <span class="docEmphasis">items</span>, each item having a <span class="docEmphasis">key</span> for use in searching. The goal of the search is to find the items with keys matching a given <span class="docEmphasis">search key</span>. The purpose of the search is usually to access information within the item (not merely the key) for processing.</p>
<p class="docText">Applications of search are widespread, and involve a variety of different operations. For example, consider a bank that needs to keep track of all its customers' account information and to search through these records to check account balances and to perform transactions. Another example is an airline that needs to keep track of reservations on all its flights, and to search through them to find empty seats or to cancel or otherwise modify the reservations. A third example is a search engine on a network software interface that looks for all documents in the network containing a given keyword. The demands of these applications are similar in some ways (the bank and the airline both demand accuracy and reliability) and different in others (the bank's data have a long life, compared to the data in the others); all need good search algorithms.</p>
<a name="ch12ex01"></a><h5 id="title-IDA0IZCP" class="docExampleTitle">Definition 12.1. A <span class="docEmphasis">symbol table</span> is a data structure of items with keys that supports two basic operations: insert a new item, and return an item with a given key</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Symbol tables are also sometimes called <span class="docEmphasis">dictionaries</span>, by analogy with the time-honored system of providing definitions for words by listing them alphabetically in a reference book. In an English-language dictionary, the &quot;keys&quot; are the words and the &quot;items&quot; are the entries associated with the words that contain the definition, pronunciation, and other information. People use search algorithms to find information in a dictionary, usually depending on the fact that the entries appear in alphabetical order. Telephone books, encyclopedias, and other reference books are organized in essentially the same way, and some of the search methods that we shall discuss (for example the binary search algorithm in <a class="docLink" href="ch02lev1sec6.html#ch02lev1sec6">Sections 2.6</a> and <a class="docLink" href="ch12lev1sec4.html#ch12lev1sec4">12.4</a>) also depend upon the entries being kept in order.</p>
<p class="docText">An advantage of computer-based symbol tables is that they can be much more dynamic than a dictionary or a telephone book, so most of the methods that we shall discuss build data structures that not only enable efficient search algorithms, but also support efficient implementations of operations to add new items, to remove or modify items, to combine two symbol tables into one, and so forth. In this chapter, we shall revisit many of the issues related to such operations that we considered for priority queues in <a class="docLink" href="ch09.html#ch09">Chapter 9</a>. The development of dynamic data structures to support search is one of the oldest and most widely studied problems in computer science; it will be our main focus in this chapter and in <a class="docLink" href="ch13.html#ch13">Chapters 13</a> through <a class="docLink" href="ch16.html#ch16">16</a>. As we shall see, many ingenious algorithms have been (and are still being) invented to solve the symbol-table implementation problem.</p>
<p class="docText">Beyond basic applications of the type just mentioned, symbol tables have been studied intensively by computer scientists and programmers because they are indispensable aids in organizing software on computer systems. A symbol table is the dictionary for a program: The keys are the symbolic names used in the program, and the items contain information describing the object named. From the early days of computing, when symbol tables allowed programmers to move from using numeric addresses in machine code to using symbolic names in assembly language, to modern applications of the new millennium, when symbolic names have meaning across worldwide computer networks, fast search algorithms have played and will play an essential role in computation.</p>
<p class="docText">Symbol tables are also frequently encountered in low-level abstractions, occasionally at the hardware level. The term <span class="docEmphasis">associative memory</span> is sometimes used to describe the concept. We shall focus on software implementations, but some of the methods that we consider are also appropriate for hardware implementation.</p>
<p class="docText">As with our study of sorting methods in <a class="docLink" href="ch06.html#ch06">Chapter 6</a>, we shall begin our study of search methods in this chapter by looking at some elementary methods that are useful for small tables and in other special situations and that illustrate fundamental techniques exploited by more advanced methods. Then, for much of the remainder of the chapter, we shall focus on the <span class="docEmphasis">binary search tree (BST)</span>, a fundamental and widely used data structure that admits fast search algorithms.</p>
<p class="docText">We considered two search algorithms in <a class="docLink" href="ch02lev1sec6.html#ch02lev1sec6">Section 2.6</a> as an illustration of the effectiveness of mathematical analysis in helping us to develop effective algorithms. For completeness in this chapter, we repeat some of the information that we considered in <a class="docLink" href="ch02lev1sec6.html#ch02lev1sec6">Section 2.6</a>, though we refer back to that section for some proofs. Later in the chapter, we also refer to the basic properties of binary trees that we considered in <a class="docLink" href="ch05lev1sec4.html#ch05lev1sec4">Sections 5.4</a> and <a class="docLink" href="ch05lev1sec5.html#ch05lev1sec5">5.5</a>.</p>
</td></tr></table></p>
<p class="docText">&nbsp;<a name="iddle1354"></a><a name="iddle1696"></a><a name="iddle1729"></a></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="part04.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch12lev1sec1.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>