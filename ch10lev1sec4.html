<html><head><title>10.4. Three-Way Radix Quicksort</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch10lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch10lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch10lev1sec4"></a>
<h3 id="title-IDAL5V5H" class="docSection1Title">10.4. Three-Way Radix Quicksort</h3>
<p class="docText"><a name="iddle2038"></a><a name="iddle2213"></a>Another way to adapt quicksort for MSD radix sorting is to use three-way partitioning on the leading byte of the keys, moving to the next byte on only the middle subfile (keys with leading byte equal to that of the partitioning element). This method is easy to implement (the one-sentence description plus the three-way partitioning code in <a class="docLink" href="ch07lev1sec6.html#ch07ex08">Program 7.5</a> suffices, essentially), and it adapts well to a variety of situations. <a class="docLink" href="#ch10ex05">Program 10.3</a> is a full implementation of this method.</p>
<p class="docText">In essence, doing three-way radix quicksort amounts to sorting the file on the leading characters of the keys (using quicksort), then applying the method recursively on the remainder of the keys. For sorting strings, the method compares favorably with normal quicksort and with MSD radix sort. Indeed, it might be viewed as a hybrid of these two algorithms.</p>
<p class="docText">To compare three-way radix quicksort to standard MSD radix sort, we note that it divides the file into only three parts, so it does not get the benefit of the quick multiway partition, especially in the early stages of the sort. On the other hand, for later stages, MSD radix sort involves large numbers of empty bins, whereas three-way radix quicksort adapts well to handle duplicate keys, keys that fall into a small range, small files, and other situations where MSD radix sort might run slowly. Of particular importance is that the partitioning adapts to different types of nonrandomness in different parts of the key. Furthermore, no auxiliary array is required. Balanced against all these advantages is that extra exchanges are required to get the effect of the multiway partition via a sequence of three-way partitions when the number of subfiles is large.</p>
<p class="docText"><a class="docLink" href="#ch10fig11">Figure 10.11</a> shows an example of the operation of this method on the three-letter-word sorting problem of <a class="docLink" href="ch10lev1sec3.html#ch10fig07">Figure 10.7</a>. <a class="docLink" href="#ch10fig12">Figure 10.12</a> depicts the recursive-call structure. Each node corresponds to precisely three recursive calls: for keys with a smaller first byte (left child), for keys with first byte equal (middle child), and for keys with first byte larger (right child).</p>
<a name="ch10fig11"></a><p><center>
<h5 class="docFigureTitle">Figure 10.11. Three-way radix quicksort</h5>
<h5></h5><h5></h5></center></p><p class="docText">We divide the file into three parts: words beginning with <span class="docEmphasis">a</span> through <span class="docEmphasis">i</span>, words begininning with <span class="docEmphasis">j</span>, and words beginning with <span class="docEmphasis">k</span> through <span class="docEmphasis">z</span>. Then, we sort recursively.</p>
<p class="docText">
<img border="0" alt="" width="150" height="578" src="10fig11.gif" /></p>
<br />
<a name="ch10fig12"></a><p><center>
<h5 class="docFigureTitle">Figure 10.12. Recursive structure of three-way radix quicksort</h5>
<h5></h5><h5></h5></center></p><p class="docText">This tree-trie combination corresponds to a substitution of the 26-way nodes in the trie in <a class="docLink" href="ch10lev1sec3.html#ch10fig10">Figure 10.10</a> by ternary binary search trees, as illustrated in <a class="docLink" href="#ch10fig13">Figure 10.13</a>. Any path from the root to the bottom of the tree that ends in a middle link defines a key in the file, given by the characters in the nodes left by middle links in the path. <a class="docLink" href="ch10lev1sec3.html#ch10fig10">Figure 10.10</a> has 1035 null links that are not depicted; all the 155 null links in this tree are shown here. Each null link corresponds to an empty bin, so this difference illustrates how three-way partitioning can cut dramatically the number of empty bins encountered in MSD radix sorting.</p><p class="docText"><div class="v1"><a target="_blank" href="10fig12_alt.gif">[View full size image]</a></div><img border="0" alt="" width="500" height="144" src="10fig12.gif" /></p>
<br />
<a name="ch10fig13"></a><p><center>
<h5 class="docFigureTitle">Figure 10.13. Example of trie nodes for three-way radix quicksort</h5>
<h5></h5><h5></h5></center></p><p class="docText">Three-way radix quicksort addresses the empty-bin problem for MSD radix sort by doing three-way partitioning to eliminate 1 byte value and (recursively) to work on the others. This action corresponds to replacing each M-way node in the trie that describes the recursive call structure of MSD radix sort (see <a class="docLink" href="ch10lev1sec3.html#ch10fig09">Figure 10.9</a>) by a ternary tree with an internal node for each nonempty bin. For full nodes (left), this change costs time without saving much space, but for empty nodes (right), the time cost is minimal and the space savings is considerable.</p><p class="docText"><div class="v1"><a target="_blank" href="10fig13_alt.gif">[View full size image]</a></div><img border="0" alt="" width="500" height="110" src="10fig13.gif" /></p>
<br />
<p class="docText">When the sort keys fit the abstraction of <a class="docLink" href="ch10lev1sec2.html#ch10lev1sec2">Section 10.2</a>, standard quicksort (and all the other sorts in <a class="docLink" href="ch06.html#ch06">Chapters 6</a> through <a class="docLink" href="ch09.html#ch09">9</a>) can be viewed as an MSD radix sort, because the compare function has to access the most significant part of the key first (see <a class="docLink" href="ch10lev1sec1.html#ch10qa1q3">Exercise 10.3</a>).</p>
<p class="docText"></p><a name="ch10ex05"></a><h5 id="title-IDANG2RD" class="docExampleTitle">Program 10.3. Three-way radix quicksort</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This MSD radix sort is essentially the same code as quicksort with three-way partitioning (<a class="docLink" href="ch09lev1sec3.html#ch09ex09">Program 9.5</a>), but with the following changes: (<span class="docEmphasis">i</span>) key references become key-byte references, (<span class="docEmphasis">ii</span>) the current byte is added as a parameter to the recursive routine, and (<span class="docEmphasis">iii</span>) the recursive calls for the middle subfile move to the next byte. We avoid moving past the ends of strings by checking whether the partitioning value is 0 before recursive calls that move to the next byte. When the partitioning value is 0, the left subfile is empty, the middle subfile corresponds to the keys that the program has found to be equal, and the right subfile corresponds to longer strings that need to be processed further.</p>
<div class="docText"><pre>#define ch(A) digit(A, d)
template &lt;class Item&gt;
void quicksortX(Item a[], int l, int r, int d)
  {
    int i, j, k, p, q; int v;
    if (r-l &lt;= M) { insertion(a, l, r); return; }
    v = ch(a[r]); i = l-1; j = r; p = l-1; q = r;
    while (i &lt; j)
      {
        while (ch(a[++i]) &lt; v) ;
        while (v &lt; ch(a[--j])) if (j == l) break;
        if (i &gt; j) break;
        exch(a[i], a[j]);
        if (ch(a[i])==v) { p++; exch(a[p], a[i]); }
        if (v==ch(a[j])) { q--; exch(a[j], a[q]); }
      }
    if (p == q)
      { if (v != '\0') quicksortX(a, l, r, d+1);
        return; }
    if (ch(a[i]) &lt; v) i++;
    for (k = l; k &lt;= p; k++, j--) exch(a[k], a[j]);
    for (k = r; k &gt;= q; k--, i++) exch(a[k], a[i]);
    quicksortX(a, l, j, d);
    if ((i == r) &amp;&amp; (ch(a[i]) == v)) i++;
    if (v != '\0') quicksortX(a, j+1, i-1, d+1);
    quicksortX(a, i, r, d);
  }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a name="iddle2181"></a><a name="iddle2265"></a><a name="iddle2309"></a>For example, if the keys are strings, the compare function should access only the leading bytes if they are different, the leading 2 bytes if the first bytes are the same and the second different, and so forth. The standard algorithm thus automatically realizes some of the same performance gain that we seek in MSD radix sorting (see <a class="docLink" href="ch07lev1sec7.html#ch07lev1sec7">Section 7.7</a>). The essential difference is that the standard algorithm cannot take special action when the leading bytes are equal. Indeed, one way to think of <a class="docLink" href="#ch10ex05">Program 10.3</a> is as a way for quicksort to keep track of what it knows about leading digits of items after they have been involved in multiple partitions. In the small subfiles, where most of the comparisons in the sort are done, the keys are likely to have many equal leading bytes. The standard algorithm has to scan over all those bytes for each comparison; the three-way algorithm avoids doing so.</p>
<p class="docText">Consider a case where the keys are long (and are fixed length, for simplicity), but most of the leading bytes are all equal. In such a situation, the running time of normal quicksort would be proportional to the word length <span class="docEmphasis">times</span> 2<span class="docEmphasis">N</span>ln<span class="docEmphasis">N</span>, whereas the running time of the radix version would be proportional to <span class="docEmphasis">N</span> times the word length (to discover all the leading equal bytes) <span class="docEmphasis">plus</span> 2<span class="docEmphasis">N</span>ln<span class="docEmphasis">N</span> (to do the sort on the remaining short keys). That is, this method could be up to a factor of ln <span class="docEmphasis">N</span> faster than normal quicksort, counting just the cost of comparisons. It is not unusual for keys in practical sorting applications to have characteristics similar to this artificial example (see <a class="docLink" href="#ch10qa4q1">Exercise 10.25</a>).</p>
<p class="docText">Another interesting property of three-way radix quicksort is that it has no direct dependencies on the size of the radix. For other radix <a name="iddle1736"></a><a name="iddle1926"></a><a name="iddle2174"></a><a name="iddle2417"></a><a name="iddle2611"></a>sorting methods, we have to maintain an auxiliary array indexed by radix value, and we need to ensure that the size of this array is not appreciably larger than the file size. For this method, there is no such table. Taking the radix to be extremely large (larger than the word size) reduces the method to normal quicksort, and taking the radix to be 2 reduces it to binary quicksort, but intermediate values of the radix give us an efficient way to deal with equal stretches among pieces of keys.</p>
<p class="docText">For many practical applications, we can develop a hybrid method with excellent performance by using standard MSD radix sort for large files, to get the advantage of multiway partitioning, and a three-way radix quicksort with a smaller radix for smaller files, to avoid the negative effects of large numbers of empty bins.</p>
<p class="docText">Three-way radix quicksort is also applicable when the keys to be sorted are <span class="docEmphasis">vectors</span> (either in the mathematical sense or in the sense of the C++ Standard Template Library). That is, if the keys are made up of independent components (each an abstract key), we might wish to reorder records such that they are in order according to the first components of the keys, <span class="docEmphasis">and</span> in order according to the second component of the keys if the first components are equal, and so forth. We can think of vector sorting as a generalization of radix sorting where we take <span class="docEmphasis">R</span> to be arbitrarily large. When we adapt <a class="docLink" href="#ch10ex05">Program 10.3</a> to this application, we refer to it as <span class="docEmphasis">multikey quicksort</span>.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa4q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.25</span> For <tt>d &gt; 4</tt>, suppose that keys consist of <span class="docEmphasis">d</span> bytes, with the final 4 bytes having random values and all the other bytes having value 0. Estimate the number of bytes examined when you sort the file using three-way radix quicksort (<a class="docLink" href="#ch10ex05">Program 10.3</a>) and normal quicksort (<a class="docLink" href="ch07lev1sec1.html#ch07ex01">Program 7.1</a>) for files of size <span class="docEmphasis">N</span> for large <span class="docEmphasis">N</span>, and calculate the ratio of the running times.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa4q2"></a><b></b></td><td><p class="docText"><a name="iddle1756"></a><a name="iddle2202"></a><span class="docEmphStrong">10.26</span> Empirically determine the byte size for which three-way radix quicksort runs fastest, for random 64-bit keys with <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa4q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">10.27</span> Develop an implementation of three-way radix quicksort for linked lists.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa4q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.28</span> Develop an implementation of multikey quicksort for the case where the keys are vectors of <span class="docEmphasis">t</span> floating-point numbers, using equality testing among floating point numbers as described in <a class="docLink" href="ch04lev1sec1.html#ch04qa2q1">Exercise 4.6</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa4q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.29</span> Using the key generator of <a class="docLink" href="ch10lev1sec3.html#ch10qa3q6">Exercise 10.19</a>, run three-way radix quicksort for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>. Compare its performance with that of MSD radix sort.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa4q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.30</span> Using the key generator of <a class="docLink" href="ch10lev1sec3.html#ch10qa3q8">Exercise 10.21</a>, run three-way radix quicksort for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>. Compare its performance with that of MSD radix sort.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch10qa4q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">10.31</span> Using the key generator of <a class="docLink" href="ch10lev1sec3.html#ch10qa3q10">Exercise 10.23</a>, run three-way radix quicksort for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>. Compare its performance with that of MSD radix sort.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch10lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch10lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>