<html><head><title>8.5. Bottom-Up Mergesort</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch08lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch08lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch08lev1sec5"></a>
<h3 id="643999-825" class="docSection1Title">8.5. Bottom-Up Mergesort</h3>
<p class="docText">As we discussed in <a class="docLink" href="ch05.html#ch05">Chapter 5</a>, every recursive program has a non-recursive analog that, although equivalent, may perform computations in a different order. As prototypes of the divide-and-conquer algorithm-design philosophy, nonrecursive implementations of mergesort are worth studying in detail.</p>
<p class="docText">Consider the sequence of merges done by the recursive algorithm. In the example given in <a class="docLink" href="ch08lev1sec3.html#ch08fig02">Figure 8.2</a>, we saw that a file of size 15 is sorted by the following sequence of merges:</p>
<blockquote>
<p class="docText">1-by-1 1-by-1 2-by-2 1-by-1 1-by-1 2-by-2 4-by-4</p>
<p class="docText">1-by-1 1-by-1 2-by-2 1-by-1 2-by-1 4-by-3 8-by-7.</p>
</blockquote>
<p class="docText">This order of the merges is determined by the recursive structure of the algorithm. However, the subfiles are processed independently, and merges can be done in different sequences. <a class="docLink" href="#ch08fig04">Figure 8.4</a> shows <a name="iddle1762"></a><a name="iddle2529"></a>the bottom-up strategy for the same example, where the sequence of merges is</p>
<blockquote>
<p class="docText">1-by-1 1-by-1 1-by-1 1-by-1 1-by-1 1-by-1 1-by-1</p>
<p class="docText">2-by-2 2-by-2 2-by-2 2-by-1 4-by-4 4-by-3 8-by-7.</p>
</blockquote>
<a name="ch08fig04"></a><p><center>
<h5 class="docFigureTitle">Figure 8.4. Bottom-up mergesort example</h5>
<h5></h5><h5></h5></center></p><p class="docText">Each line shows the result of a call on <span class="docEmphasis"><tt>merge</tt></span> during bottom-up mergesort. The 1-by-1 merges are done first: A and S are merged to give A S; then, O and R are merged to give O R; and so forth. Since the file size is odd, the last E is not involved in a merge. On the second pass, the 2-by-2 merges are done: We merge A S with O R to get A O R S, and so forth, finishing with a 2-by-1 merge. The sort is completed with a 4-by-4 merge, a 4-by-3 merge, and, finally, an 8-by-7 merge.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="200" height="193" src="08fig04.gif" /></p>
<br />
<a name="ch08ex09"></a><h5 id="title-IDAZOKVM" class="docExampleTitle">Program 8.5. Bottom-up mergesort</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Bottom-up mergesort consists of a sequence of passes over the whole file doing <tt>m-</tt>by-<tt>m</tt> merges, doubling <tt>m</tt> on each pass. The final subfile is of size <tt>m</tt> only if the file size is an even multiple of <tt>m</tt>, so the final merge is an <tt>m-</tt>by-<tt>x</tt> merge, for some <tt>x</tt> less than or equal to <tt>M</tt>.</p>
<div class="docText"><pre>    inline int min(int A, int B)
      { return (A &lt; B) ? A : B; }
    template &lt;class Item&gt;
    void mergesortBU(Item a[], int l, int r)
      {
        for (int m = 1; m &lt;= r-l; m = m+m)
          for (int i = l; i &lt;= r-m; i += m+m)
            merge(a, i, i+m-1, min(i+m+m-1, r));
      }</pre></div><br />
</td></tr></table></p>
<p class="docText">In both cases, there are seven 1-by-1 merges, three 2-by-2 merges, a 2-by-1 merge, a 4-by-4 merge, a 4-by-3 merge, and an 8-by-7 merge, but the merges are done in different orders. The bottom-up strategy is to merge the smallest remaining files, passing from left to right through the array.</p>
<p class="docText">The sequence of merges done by the recursive algorithm is determined by the divide-and-conquer tree shown in <a class="docLink" href="ch08lev1sec3.html#ch08fig03">Figure 8.3</a>: We simply traverse the tree in postorder. As we saw in <a class="docLink" href="ch03.html#ch03">Chapter 3</a>, a nonrecursive algorithm using an explicit stack can be developed that gives the same sequence of merges. But there is no need to restrict to postorder: <span class="docEmphasis">Any</span> tree traversal that traverses the subtrees of a node before it visits the node itself will give a proper algorithm. The only restriction is that files to be merged must have been sorted first. For mergesort, it is convenient to do all the 1-by-1 merges first, then all the 2-by-2 merges, then all the 4-by-4 merges, and so forth. This sequence corresponds to a level-order traversal, working up from the bottom of the recursion tree.</p>
<p class="docText"><a name="iddle1285"></a><a name="iddle1763"></a><a name="iddle2530"></a>We saw in several examples in <a class="docLink" href="ch05.html#ch05">Chapter 5</a> that, when we are thinking in a bottom-up fashion, it is worthwhile to reorient our thinking towards a combine-and-conquer strategy, where we take solutions to small subproblems and combine them to get a solution to a larger problem. Specifically, we get the combine-and-conquer nonrecursive version of mergesort in <a class="docLink" href="#ch08ex09">Program 8.5</a> as follows: We view all the elements in a file as ordered sublists of size 1. Then, we scan through the list performing 1-by-1 merges to produce ordered sublists of size 2; then, we scan through the list performing 2-by-2 merges to produce ordered sublists of size 4; then, we do 4-by-4 merges to get ordered sublists of size 8; and so on, until the whole list is ordered. The final sublist will not always be the same size as all of the others unless the file size is a power of 2, but we can still merge it in.</p>
<p class="docText">If the file size is a power of 2, the <span class="docEmphasis">set</span> of merges done by bottom-up mergesort is precisely the same as that done by the recursive mergesort, but the <span class="docEmphasis">sequence</span> of merges is different. Bottom-up mergesort corresponds to a <span class="docEmphasis">level-order</span> traversal of the divide-and-conquer tree, from bottom to top. By contrast, we have referred to the recursive algorithm as <span class="docEmphasis">top-down mergesort</span> because the postorder traversal works from the top of the tree down.</p>
<p class="docText">If the file size is not a power of 2, the bottom-up algorithm does a different set of merges, as shown in <a class="docLink" href="#ch08fig05">Figure 8.5</a>. The bottom-up algorithm corresponds to a combine-and-conquer tree (see <a class="docLink" href="ch05lev1sec5.html#ch05qa5q8">Exercise 5.75</a>), which is different from the divide-and-conquer tree related to the top-down algorithm. It is possible to arrange for the sequence of merges made by a recursive method to be the same as that for a nonrecursive method, but there is no particular reason to do so, because differences in cost are slight relative to total cost.</p>
<a name="ch08fig05"></a><p><center>
<h5 class="docFigureTitle">Figure 8.5. Bottom-up mergesort file sizes</h5>
<h5></h5><h5></h5></center></p><p class="docText">The merging patterns for bottom-up mergesort are completely different from those for top-down mergesort (<a class="docLink" href="ch08lev1sec3.html#ch08fig03">Figure 8.3</a>) when the file size is not a power of 2. For bottom-up mergesort, all file sizes except possibly the final one are a power of 2. These differences are of interest in understanding the basic structure of the algorithms, but have little influence on performance.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="300" height="100" src="08fig05.gif" /></p>
<br />
<p class="docText"><a class="docLink" href="ch08lev1sec3.html#ch08ex04">Properties 8.1</a> through <a class="docLink" href="ch08lev1sec3.html#ch08ex07">8.4</a> hold for bottom-up mergesort, and we have the following additional properties:</p>
<p class="docText"></p><a name="ch08ex10"></a><h5 id="title-IDASUKVM" class="docExampleTitle">Property 8.5. All the merges in each pass of a bottom-up mergesort involve file sizes that are a power of 2, except possibly the final file size</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1232"></a>This fact is easy to prove by induction.</p>
</td></tr></table></p>
<a name="ch08ex11"></a><h5 id="title-IDAKVKVM" class="docExampleTitle">Property 8.6. The number of passes in a bottom-up mergesort of <span class="docEmphasis">N</span> elements is precisely the number of bits in the binary representation of <span class="docEmphasis">N</span> (ignoring leading 0 bits)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Each pass in a bottom-up mergesort doubles the size of the ordered subfiles, so the size of the sublists after <span class="docEmphasis">k</span> passes is 2 <span class="docEmphasis"><sup>k</sup></span>. Thus, the number of passes to sort a file of <span class="docEmphasis">N</span> elements is the smallest <span class="docEmphasis">k</span> for which 2 <span class="docEmphasis"><sup>k</sup> <img src="U2265.GIF" border="0" />N</span>, which is precisely <span class="docEmphasis"><img src="U2308.GIF" border="0" />lg N<img src="U2309.GIF" border="0" /></span>, the number of bits in the binary representation of <span class="docEmphasis">N</span>. We could also prove this result by induction or by analyzing structural properties of combine-and-conquer trees.</p>
</td></tr></table></p>
<p class="docText">The operation of bottom-up mergesort on a larger file is illustrated in <a class="docLink" href="#ch08fig06">Figure 8.6</a>. We can sort 1 million elements in 20 passes through the data, 1 billion elements in 30 passes through the data, and so forth.</p>
<a name="ch08fig06"></a><p><center>
<h5 class="docFigureTitle">Figure 8.6. Bottom-up mergesort</h5>
<h5></h5><h5></h5></center></p><p class="docText">We need to do only seven passes to sort a file of 200 elements using bottom-up mergesort. Each pass halves the number of sorted subfiles and doubles the subfiles' lengths (except possibly that of the final one).</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="400" height="185" src="08fig06.gif" /></p>
<br />
<p class="docText">In summary, bottom-up and top-down mergesort are two straightforward sorting algorithms that are based upon the operation of merging two ordered subfiles into a combined ordered output file. The algorithms are closely related and indeed perform the same set of merges when the file size is a power of 2, but they are certainly not identical. <a class="docLink" href="#ch08fig07">Figure 8.7</a> is an illustration of their differing dynamic performance characteristics on a large file. Either algorithm might <a name="iddle1895"></a><a name="iddle1897"></a><a name="iddle1903"></a><a name="iddle2172"></a>be used for practical applications when space is not at premium and a guaranteed worst-case running time is desirable. Both algorithms are of interest as prototypes of the general <span class="docEmphasis">divide-and-conquer</span> and <span class="docEmphasis">combine-and-conquer</span> algorithm design paradigms.</p>
<a name="ch08fig07"></a><p><center>
<h5 class="docFigureTitle">Figure 8.7. Bottom-up versus top-down mergesort</h5>
<h5></h5><h5></h5></center></p><p class="docText">Bottom-up mergesort <span class="docEmphasis">(left)</span> consists of a series of passes through the file that merge together sorted subfiles, until just one remains. Every element in the file, except possibly a few at the end, is involved in each pass. By contrast, top-down mergesort <span class="docEmphasis">(right)</span> sorts the first half of the file before proceeding to the second half (recursively), so the pattern of its progress is decidedly different.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="150" height="433" src="08fig07.gif" /></p>
<br />
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa5q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">8.24</span> Show the merges that bottom-up mergesort (<a class="docLink" href="#ch08ex09">Program 8.5</a>) does for the keys E A S Y Q U E S T I O N.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa5q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">8.25</span> Implement a bottom-up mergesort that starts by sorting blocks of <span class="docEmphasis">M</span> elements with insertion sort. Determine empirically the value of <span class="docEmphasis">M</span> for which your program runs fastest to sort random files of <span class="docEmphasis">N</span> elements, for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa5q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">8.26</span> Draw trees that summarize the merges that <a class="docLink" href="#ch08ex09">Program 8.5</a> performs, for <span class="docEmphasis">N</span> = 16, 24, 31, 32, 33, and 39.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa5q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">8.27</span> Write a recursive mergesort that performs the same merges that bottom-up mergesort does.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa5q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">8.28</span> Write a bottom-up mergesort that performs the same merges that top-down mergesort does. (This exercise is much more difficult than is <a class="docLink" href="#ch08qa5q4">Exercises 8.27</a>.)</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa5q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">8.29</span> Suppose that the file size is a power of 2. Remove the recursion from top-down mergesort to get a nonrecursive mergesort that performs the same <span class="docEmphasis">sequence</span> of merges.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch08qa5q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">8.30</span> Prove that the number of passes taken by top-down mergesort is <span class="docEmphasis">also</span> the number of bits in the binary representation of <span class="docEmphasis">N</span> (see <a class="docLink" href="#ch08ex11">Property 8.6</a>).</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch08lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch08lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>