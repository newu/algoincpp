<html><head><title>4.8. First-Class ADTs</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch04lev1sec7.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch04lev1sec9.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch04lev1sec8"></a>
<h3 id="title-IDAEV5LK" class="docSection1Title">4.8. First-Class ADTs</h3>
<p class="docText">Our interfaces and implementations of stack and FIFO queue ADTs in <a class="docLink" href="ch04lev1sec2.html#ch04lev1sec2">Sections 4.2</a> through <a class="docLink" href="ch04lev1sec7.html#ch04lev1sec7">4.7</a> achieve the important objective of hiding from the client the particular data structure used in the implementation. Such ADTs are widely useful, and will serve as the basis for many of the implementations that we consider in this book.</p>
<p class="docText">When we use such data types in our programs in the way that we use built-in data types such as <tt>int</tt> or <tt>float</tt>, however, we can encounter pitfalls. In this section, we consider how to construct ADTs that we can manipulate in the same way that we manipulate built-in types in client programs, while still achieving the objective of hiding the implementation from the client.</p>
<a name="ch04ex22"></a><h5 id="title-IDALW5LK" class="docExampleTitle">Definition 4.4. A <span class="docEmphStrong">first-class data type</span> is one which we can use in our programs in the same way as we use built-in data types</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">For example, we can use first-class data types to declare variables and assign values to them, and we can use them as arguments and return values to functions. As with our other definitions related to data types, we cannot be precise in this definition without straying into deep issues relating to semantics of operations. As we shall see, it is one thing to insist that we be able to write <tt>a = b</tt> when <tt>a</tt> and <tt>b</tt> are objects from a user-defined class; but it is quite another thing to precisely specify what we mean by that statement.</p>
<p class="docText">In a perfect world, we might envision all data types having some universal set of well-defined operators; in practice, each data type is characterized by its own set of operators. This difference between data types in itself militates against a precise definition of the concept of first-class data types, because it implies that we should provide definitions for <span class="docEmphasis">every</span> operation that is defined for built-in types, which we rarely do. Most often, only a few crucial operations are of importance to us, and we are content to use those operations for our own data types in the same way as we do for built-in types.</p>
<p class="docText">In many programming languages, building first-class data types is difficult or impossible; in C++, the class concept and the ability to overload operators are the basic tools that we need. Indeed, as we shall see, it is easy to define classes that are first-class data types in C++; moreover, there is a well-defined path to upgrade those that are not.</p>
<p class="docText">The method that we use in C++ to implement first-class data types applies to any class: in particular, it applies to generalized queues, so it provides us with the capability to write programs that manipulate stacks and FIFO queues in much the same way that we manipulate other types of data in C++. This capability is important in the study of algorithms because it provides us with a natural way to express high-level operations involving such ADTs. For example, we can speak of operations to <span class="docEmphasis">join</span> two queues&mdash;to combine them into one. We shall consider algorithms that implement such operations for the priority queue ADT (<a class="docLink" href="ch09.html#ch09">Chapter 9</a>) and for the symbol table ADT (<a class="docLink" href="ch12.html#ch12">Chapter 12</a>).</p>
<p class="docText">If a first-class data type is accessed only through an interface, then it is a first-class ADT (see <a class="docLink" href="ch04.html#ch04ex01">Definition 4.1</a>). Being able to manipulate instances of ADTs in much the same way that we manipulate built-in data types such as <tt>int</tt> or <tt>float</tt> is an important goal in the design of many high-level programming languages, because it allows any applications program to be written such that the program manipulates the objects of central concern to the application; it allows many programmers to work simultaneously on large systems, all using a precisely defined set of abstract operations; and it provides for those abstract operations to be implemented in many different ways without any changes to the applications code&mdash;for example for new machines and programming environments.</p>
<a name="ch04ex23"></a><h5 id="title-IDASY5LK" class="docExampleTitle">Program 4.17. Complex numbers driver (roots of unity)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This client program performs a computation on complex numbers using an ADT that allows it to compute directly with the abstraction of interest by declaring variables of type <tt>Complex</tt> and using them in arithmetic expressions, via overloaded operators. This program checks the ADT implementation by computing the powers of the roots of unity. With an appropriate definition of the overloaded <tt>&lt;&lt;</tt> (see <a class="docLink" href="#ch04qa9q8">Exercise 4.70</a>), it prints the table in <a class="docLink" href="#ch04fig12">Figure 4.12</a>.</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include "COMPLEX.cxx"
int main(int argc, char *argv[])
  { int N = atoi(argv[1]);
    cout &lt;&lt; N &lt;&lt; " complex roots of unity" &lt;&lt; endl;
    for (int k = 0; k &lt; N; k++)
      { float theta = 2.0*3.14159*k/N;
        Complex t(cos(theta), sin(theta)), x = t;
        cout &lt;&lt; k &lt;&lt; ": " &lt;&lt; t &lt;&lt; " ";
        for (int j = 0; j &lt; N-1; j++) x *= t;
        cout &lt;&lt; x &lt;&lt; endl;
      }
  }</pre></div><br />
</td></tr></table></p>
<a name="ch04fig12"></a><p><center>
<h5 class="docFigureTitle">Figure 4.12. Complex roots of unity</h5>
<h5></h5><h5></h5></center></p><p class="docText">This table gives the output that would be produced by <a class="docLink" href="#ch04ex23">Program 4.17</a> when invoked with <span class="docEmphasis">a.out 8</span>, with an implementation of the overloaded <span class="docEmphasis">&lt;&lt;</span> that does appropriate output formatting (see <a class="docLink" href="#ch04qa9q8">Exercise 4.70</a>). The eight complex roots of unity are &#177; 1 , &#177; i , and <img border="0" alt="" width="100" height="40" src="183inlineequ01.jpg" /><span class="docEmphasis">(left two columns)</span>. Each of these eight numbers gives the result 1 + 0i when raised to the eighth power <span class="docEmphasis">(right two columns)</span>.</p>
<p class="docText">
<img border="0" alt="" width="175" height="116" src="04fig12.gif" /></p>
</td></tr></table></p><br />
<p class="docText">We begin by considering, as an example, a first-class ADT for the <span class="docEmphasis">complex-number</span> abstraction. Our goal is to be able to write programs like <a class="docLink" href="#ch04ex23">Program 4.17</a>, which performs algebraic operations on complex numbers using operations defined in the ADT. This program declares and initializes complex numbers and uses the operations <tt>*=</tt> and <tt>&lt;&lt;</tt>. We might wish to use several other operations, but we will consider just these two, as examples. In practice, we would consider using the class <tt>complex</tt> in the C++ library, which overloads all relevant operations, even including trigonometric functions for complex arguments.</p>
<p class="docText"><a class="docLink" href="#ch04ex23">Program 4.17</a> depends upon a few mathematical properties of complex numbers; we now digress to consider these properties briefly. In one sense, we are not digressing at all, because it is interesting to contemplate the relationship between complex numbers themselves as a mathematical abstraction and this representation of them in a computer program.</p>
<p class="docText">The number <img border="0" alt="" width="50" height="13" src="182equ02.jpg" /> is an <span class="docEmphasis">imaginary</span> number. Although <img border="0" alt="" width="28" height="14" src="rootminus1.jpg" /> is meaningless as a real number, we name it <span class="docEmphasis">i</span>, and perform algebraic manipulations with <span class="docEmphasis">i</span>, replacing <span class="docEmphasis">i</span><sup>2</sup> with <tt>&ndash;1</tt> whenever it appears. A <span class="docEmphasis">complex number</span> consists of two parts, real and imaginary&mdash;complex numbers can be written in the form <span class="docEmphasis">a</span> <tt>+</tt> <span class="docEmphasis">bi</span>, where <tt>a</tt> and <span class="docEmphasis">b</span> are reals. To multiply complex numbers, we apply the usual algebraic rules, replacing <span class="docEmphasis">i</span><sup>2</sup> with <tt>&ndash;1</tt> whenever it appears. For example,</p>
<div class="docText"><pre><span class="docEmphasis">(a + bi )(c + di ) = ac + bci + adi + bdi<sup>2</sup> = (ac &ndash; bd ) + (ad + bc )i.</span></pre></div><br />
<p class="docText">The real or imaginary parts might cancel out (have the value 0) when we perform a complex multiplication. For example,</p>
<div class="docText"><pre>(1 - <span class="docEmphasis">i</span>)(1 - <span class="docEmphasis">i</span>) = 1 - <span class="docEmphasis">i</span> - <span class="docEmphasis">i</span> + <span class="docEmphasis">i</span><sup>2</sup> = - 2i
         (1 - <span class="docEmphasis">i</span>)<sup>4</sup> = -4<span class="docEmphasis">i</span><sup>2</sup> =  -4,
            (1 -<span class="docEmphasis">i</span>)<sup>8</sup> 6 = 1.</pre></div><br />
<p class="docText">Scaling the preceding equation by dividing through by <img border="0" alt="" width="80" height="18" src="0182inlineequ01.jpg" />, we find that</p>
<p class="docText">
<img border="0" alt="" width="150" height="49" src="182equ03.jpg" /></p>
<p class="docText">In general, there are many complex numbers that evaluate to 1 when raised to a power. These are the <span class="docEmphasis">complex roots of unity</span>. Indeed, for each <span class="docEmphasis">N</span>, there are exactly <span class="docEmphasis">N</span> complex numbers z with <span class="docEmphasis">z<sup>N</sup></span> = 1. The numbers</p>
<p class="docText">
<img border="0" alt="" width="200" height="42" src="182equ04.jpg" /></p>
<p class="docText">for <span class="docEmphasis">k</span> = 0, 1, ..., <span class="docEmphasis">N</span>&ndash;1 are easily shown to have this property (see <a class="docLink" href="#ch04qa9q6">Exercise 4.68</a>). For example, taking <span class="docEmphasis">k</span> = 1 and <span class="docEmphasis">N</span> = 8 in this formula gives the particular eighth root of unity that we just discovered.</p>
<p class="docText"><a class="docLink" href="#ch04ex23">Program 4.17</a> computes each of the <span class="docEmphasis">N</span>th roots of unity for any given <span class="docEmphasis">N</span>, and raises each of them to the <span class="docEmphasis">N</span>th power, using the <tt>*=</tt> operation defined in the ADT. The output that it produces is shown in <a class="docLink" href="#ch04fig12">Figure 4.12</a>: We expect that each number raised to the <span class="docEmphasis">N</span>th power gives the same result: <tt>1</tt>, or <tt>1 + 0 i</tt>. The imaginary parts that we compute are not exactly zero because of limitations on the precision of our calculations. Our interest in this program is that it uses <tt>Complex</tt> in the same way that it uses built-in types. Next, we consider in detail why it can do so.</p>
<a name="ch04ex24"></a><h5 id="title-IDANCAMK" class="docExampleTitle">Program 4.18. First-class ADT interface for complex numbers</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This interface for complex numbers allows implementations to create objects of type <tt>Complex</tt> (initialized with two <tt>float</tt> values), to access the real and imaginary parts, and to use the <tt>*=</tt> operator. While not explicitly specified, system default mechanisms that work for all classes allow us to use <tt>Complex</tt> objects in assignment statements or as arguments or return values in functions.</p>
<div class="docText"><pre>class Complex
  {
    private:
      // Implementation-dependent code
    public:
      Complex(float, float);
      float Re() const;
      float Im() const; Complex&amp; operator*=(Complex&amp;);
  };</pre></div><br />
</td></tr></table></p>
<p class="docText">Even for this simple example, it is important that the data type be abstract because there is another standard representation that we might wish to consider using: polar coordinates (see <a class="docLink" href="#ch04qa9q5">Exercise 4.67</a>). <a class="docLink" href="#ch04ex24">Program 4.18</a> is an interface that could be used by client programs such as <a class="docLink" href="#ch04ex23">Program 4.17</a>, and <a class="docLink" href="#ch04ex25">Program 4.19</a> is an implementation that uses a standard data representation (one <tt>float</tt> for the real part and one <tt>float</tt> for the imaginary part).</p>
<p class="docText">When we say <tt>x = t</tt> in <a class="docLink" href="#ch04ex23">Program 4.17</a>, where <tt>x</tt> and <tt>t</tt> are both <tt>Complex</tt> objects, the system allocates memory for a new object and copies the values in the object associated with <tt>t</tt> to the new object. The same process would be used if we were to use a <tt>Complex</tt> object as an argument or return value for a function. Also, when an object goes out of scope, the system reclaims the storage associated with it. For example, the system reclaims the storage associated with the <tt>Complex</tt> objects <tt>t</tt> and <tt>x</tt> after the <tt>for</tt> loop in <a class="docLink" href="#ch04ex23">Program 4.17</a> in the same way that it reclaims the storage associated with the <tt>float r</tt>. In short, we use Complex in the same way that we use built-in types&mdash;it is a first-class data type.</p>
<a name="ch04ex25"></a><h5 id="title-IDATFAMK" class="docExampleTitle">Program 4.19. First-class ADT for complex numbers</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This code implements the ADT defined in <a class="docLink" href="#ch04ex24">Program 4.18</a> using <tt>float</tt>s to represent the real and imaginary parts of each complex number. It is a first-class data type because there are no pointers in the data representation. When we use a <tt>Complex</tt> object in an assignment statement or as an argument or a return value in a function, the system makes a copy by allocating a new object and copying the data, just as it does for built-in types.</p>
<p class="docText">The definition given here for the overloaded operator <tt>&lt;&lt;</tt> does not format the output (see <a class="docLink" href="#ch04qa9q8">Exercise 4.70</a>).</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
class Complex
  {
    private:
      float re, im;
    public:
      Complex(float x, float y)
        { re = x; im = y; }
      float Re() const
        { return re; }
      float Im() const
        { return im; }
      Complex&amp; operator*=(const Complex&amp; rhs)
        { float t = Re();
          re = Re()*rhs.Re() - Im()*rhs.Im();
          im = t*rhs.Im() + Im()*rhs.Re();
          return *this;
        }
  };
ostream&amp; operator&lt;&lt;(ostream&amp; t, const Complex&amp; c)
  { t &lt;&lt; c.Re() &lt;&lt; " " &lt;&lt; c.Im(); return t; }</pre></div><br />
</td></tr></table></p>
<p class="docText">Indeed, <span class="docEmphasis">any</span> class with the property that none of its data members is a pointer is a first-class data type in C++. When an object is copied, each member is copied; when something is assigned into an object, each member is overwritten; when an object goes out of scope, its storage is reclaimed. The system has default mechanisms for each of these situations: every class has a default <span class="docEmphasis">copy constructor</span>, <span class="docEmphasis">assignment operator</span> and <span class="docEmphasis">destructor</span> to perform these functions.</p>
<p class="docText">However, when a data member is a pointer, the effect of these default functions is entirely different. For an assignment operation, the default copy constructor makes a copy of the pointers, but is that really what we want? This issue of <span class="docEmphasis">copy semantics</span> is an important one to address in any ADT design. More generally, the issue of storage management is critical in the use of ADTs in software engineering. Next, we consider an example that will help us examine these issues in more detail.</p>
<p class="docText"><a class="docLink" href="#ch04ex26">Program 4.20</a> exemplifies a client program that manipulates FIFO queues as first-class data types. It simulates a certain situation involving customers arriving and being served in a set of <tt>M</tt> queues. <a class="docLink" href="#ch04fig13">Figure 4.13</a> is an example of the output produced by this program. Our interest in this program is to illustrate how the first-class data-type mechanism allows it to work with the queue ADT itself as a high-level object&mdash;we can imagine writing similar programs to test various methods of organizing queues to serve customers, and so forth.</p>
<a name="ch04fig13"></a><p><center>
<h5 class="docFigureTitle">Figure 4.13. Random-queue simulation</h5>
<h5></h5><h5></h5></center></p><p class="docText">This listing gives the tail end of the output produced when <a class="docLink" href="#ch04ex26">Program 4.20</a> is invoked with <span class="docEmphasis">80</span> as the command-line argument. It shows the contents of the queues after the indicated operations, where we choose a queue at random and <span class="docEmphasis">put</span> the next item in, then choose another queue at random and, if it is nonempty, <span class="docEmphasis">get</span> an item out.</p>
<p class="docText">
<img border="0" alt="" width="120" height="429" src="04fig13.gif" /></p>
<br />
<p class="docText">Suppose that we use the linked-list queue implementation that we considered in <a class="docLink" href="ch04lev1sec6.html#ch04ex18">Program 4.14</a>. When we say <tt>p = q</tt>, where <tt>p</tt> and <tt>q</tt> are both <tt>QUEUE</tt> objects, the system allocates memory for a new object and copies the values in the object associated with <tt>q</tt> to the new object. But those values are the <tt>head</tt> and <tt>tail</tt> pointers&mdash;the linked list itself is <span class="docEmphasis">not</span> copied. If we later modify the linked list associated with <tt>p</tt>, we also are modifying the linked list associated with <tt>q</tt>. This outcome certainly was not our intention in <a class="docLink" href="#ch04ex26">Program 4.20</a>. Again, the same process would be used if we were to use a <tt>QUEUE</tt> object as an argument for a function. For built-in types, we expect to have an object of our own for use within the function. For a pointer-based data structure, this expectation implies that we need to make a copy. The system cannot know how to do that&mdash;we have to provide the code. The same holds true for return values.</p>
<p class="docText">Worse, when a <tt>QUEUE</tt> object goes out of scope, the system reclaims the storage associated with the pointers, but <span class="docEmphasis">not</span> all the storage associated with the linked list itself. Indeed, once the pointers are gone, we have no way of accessing that storage again. This is an example of a <span class="docEmphasis">memory leak</span>, a serious problem that demands attention whenever we write programs that allocate storage.</p>
<a name="ch04ex26"></a><h5 id="title-IDACLAMK" class="docExampleTitle">Program 4.20. Queue client program (queue simulation)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This client program simulates a situation where we assign customers waiting for service at random to one of <tt>M</tt> service queues, then choose a queue at random (possibly the same one) and, if it is nonempty, perform the service (remove a customer from the queue). Each time we perform these operations, we print out the customer added, the customer served, and the contents of the queues.</p>
<p class="docText">The code implicitly assumes that <tt>QUEUE</tt> is a first-class data type. It will not function properly for the implementations given in <a class="docLink" href="ch04lev1sec6.html#ch04ex18">Programs 4.14</a> and <a class="docLink" href="ch04lev1sec6.html#ch04ex20">4.15</a> because of incorrect copy semantics in the inner <tt>for</tt> loop.</p>
<p class="docText">The queue ADT implementation in <a class="docLink" href="#ch04ex28">Program 4.22</a> has a copy constructor that corrects this defect. It makes a copy of the appropriate queue for <tt>q</tt> each time through the inner <tt>for</tt> loop, and relies on its destructor to allow the system to reclaim the memory for the copies.</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
#include "QUEUE.cxx"
static const int M = 4;
int main(int argc, char *argv[])
  { int N = atoi(argv[1]);
    QUEUE&lt;int&gt; queues[M];
    for (int i = 0; i &lt; N; i++, cout &lt;&lt; endl)
      { int in = rand() % M, out = rand() % M;
        queues[in].put(i);
        cout &lt;&lt; i &lt;&lt; " in ";
        if (!queues[out].empty())
          cout &lt;&lt; queues[out].get() &lt;&lt; " out";
        cout &lt;&lt; endl;
        for (int k = 0; k &lt; M; k++, cout &lt;&lt; endl)
           { QUEUE&lt;int&gt; q = queues[k];
             cout &lt;&lt; k &lt;&lt; ": ";
             while (!q.empty())
               cout &lt;&lt; q.get() &lt;&lt; " ";
           }
    }
  }</pre></div><br />
</td></tr></table></p>
<a name="ch04ex27"></a><h5 id="title-IDAANAMK" class="docExampleTitle">Program 4.21. First-class queue ADT interface</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">To make a user-defined class whose data members may contain pointers behave more like a built-in type, we need to include a copy constructor, an overloaded assignment operator, and a destructor in its interface, as in this extension of the basic FIFO queue interface that we considered in <a class="docLink" href="ch04lev1sec6.html#ch04ex16">Program 4.13</a>.</p>
<div class="docText"><pre>template &lt;class Item&gt;
class QUEUE
  {
    private:
      // Implementation-dependent code
    public:
      QUEUE(int);
      QUEUE(const QUEUE&amp;);
      QUEUE&amp; operator=(const QUEUE&amp;);
      ~QUEUE();
      int empty() const;
      void put(Item);
      Item get();
  };</pre></div><br />
</td></tr></table></p>
<p class="docText">C++ provides specific mechanisms to facilitate the construction of classes that have proper copy semantics and that avoid memory leaks. Specifically, we need to provide the following member functions:</p>
<ul><li><p class="docList">A <span class="docEmphasis">copy constructor</span>, to create a new object that is a copy of a given object.</p></li><li><p class="docList">An<span class="docEmphasis">overloaded assignment operator</span>, so that an object can appear on the left-hand side of an assignment operation.</p></li><li><p class="docList">A <span class="docEmphasis">destructor</span>, to reclaim any storage allocated during an object's lifetime.</p></li></ul>
<p class="docText">When the system needs to perform the indicated operations, it uses these member functions. If they are not included, it uses the default functions which operate as just described for <tt>Complex</tt>, but which lead to incorrect copy semantics and memory leaks if any data members are pointers. <a class="docLink" href="#ch04ex27">Program 4.21</a> is a FIFO queue interface that includes these three functions. Like constructors, they have distinctive signatures that involve the class name.</p>
<p class="docText">When we provide an initial value at the time that we create an object, or use an object as a parameter or return value from a function, the system automatically invokes the copy constructor <tt>QUEUE(const QUEUE&amp;)</tt>. The assignment operator <tt>QUEUE&amp; operator= (const QUEUE&amp;)</tt> is invoked whenever we use <tt>=</tt> to assign one queue to another. The destructor <tt>~QUEUE()</tt> is invoked when the storage associated with a queue is to be reclaimed. If we use a declaration such as <tt>QUEUE&lt;int&gt; q;</tt> without providing an initial value, the system uses the constructor <tt>QUEUE()</tt> to create the object <tt>q</tt>. If we do provide another queue to initialize the object with a declaration such as <tt>QUEUE&lt;int&gt; q = p</tt> (or its equivalent form <tt>QUEUE&lt;int&gt; q(p)</tt>), the system uses the copy constructor <tt>QUEUE(const QUEUE&amp;)</tt>. This function should create a new copy of <tt>p</tt>, not just another pointer to it. As usual for reference parameters, the keyword <tt>const</tt> expresses our intent not to change <tt>p</tt>, just to use it to access information.</p>
<p class="docText"><a class="docLink" href="#ch04ex28">Program 4.22</a> is an implementation of the copy constructor, overloaded assignment operator, and destructor for the linked-list queue implementation of <a class="docLink" href="ch04lev1sec6.html#ch04ex18">Program 4.14</a>. The destructor goes through the queue and reclaims the storage associated with each node using <tt>delete</tt>. The assignment operator takes no action in the event that the client program assigns an object to itself, otherwise it calls the destructor, then copies the queue on the right-hand side by using <tt>put</tt> for each item on that queue. The copy constructor sets the queue to be empty, then uses the assignment operator to effect the copy.</p>
<p class="docText">We can convert any C++ class into a first-class ADT by providing a copy constructor, overloaded assignment operator, and destructor, as in <a class="docLink" href="#ch04ex28">Program 4.22</a>. These functions are generally based on straightforward traversals of our data structures. However, we do not always take these extra steps, because</p>
<a name="ch04pro01"></a>
<table border="0" class="docText"><tr><td width="25" valign="top"><div class="docText"><b>1. </b></div></td><td><div class="docText">We often use only a single instance of an object from a class.<br /><br /></div></td></tr><tr><td width="25" valign="top"><div class="docText"><b>2. </b></div></td><td><div class="docText">If we do have multiple instances, we want to avoid inadvertently copying huge data structures.<br /><br /></div></td></tr></table>
<p class="docText">In short, while cognizant of our ability to build first-class data types, we remain aware of the tradeoff between convenience and cost when implementing them and using them, particularly when huge amounts of data are involved.</p>
<a name="ch04ex28"></a><h5 id="title-IDAVRAMK" class="docExampleTitle">Program 4.22. Linked-list implementation of a first-class queue</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We can upgrade the FIFO queue class implementation in <a class="docLink" href="ch04lev1sec6.html#ch04ex18">Program 4.14</a>, to be a first-class queue by adding these implementations of a copy constructor, overloaded assignment operator, and destructor. These functions override the defaults and are called when needed to copy and destroy objects.</p>
<p class="docText">The destructor <tt>~QUEUE()</tt> calls <tt>deletelist</tt>, a private member function that goes through the linked list and calls <tt>delete</tt> for each node, so that <span class="docEmphasis">all</span> the memory associated with the object has been reclaimed when its pointers are reclaimed.</p>
<p class="docText">The overloaded assignment operator <tt>QUEUE&amp; operator=(const QUEUE&amp; rhs)</tt> has no work to do if the invocation was a case of self-assignment such as <tt>q = q</tt>. Otherwise, it uses <tt>deletelist</tt> to clean up the memory associated with the old copy of the object (leaving the list empty), and then makes a copy of the list associated with the object on the right hand side of the assignment by calling <tt>put</tt> for each item on that list. In either case, the return value is a reference to the target of the assignment.</p>
<p class="docText">The copy constructor <tt>QUEUE(const QUEUE&amp;)</tt> initializes the list to be empty, then uses the overloaded assignment operator to make a copy of the argument.</p>
<div class="docText"><pre>private:
   void deletelist()
    {
      for (link t = head; t != 0; head = t)
        { t = head-&gt;next; delete head; }
    }
public:
  QUEUE(const QUEUE&amp; rhs)
    { head = 0; *this = rhs; }
  QUEUE&amp; operator=(const QUEUE&amp; rhs)
    {
      if (this == &amp;rhs) return *this;
      deletelist();
      link t = rhs.head;
      while (t != 0)
        { put(t-&gt;item); t = t-&gt;next; }
      return *this;
    }
  ~QUEUE()
    { deletelist(); }</pre></div><br />
</td></tr></table></p>
<p class="docText">Such considerations also explain why the C++ library includes a <tt>string</tt> class, despite the appeal of the low-level C-style string data structure. C-style strings are not first-class types, because they are little more than pointers. Indeed, many programmers' first exposure to incorrect copy semantics is when they copy a C-style string pointer expecting the string itself to be copied. By contrast, the C++ <tt>string</tt> is a first-class type, so we need to exercise caution when manipulating huge strings.</p>
<p class="docText">As another example, we might envision modifying <a class="docLink" href="#ch04ex26">Program 4.20</a> to periodically print just the first few items on each queue, so that we can track progress even when the queues become huge. But we might eventually be surprised by poor performance when the queues do become huge, because initialization of the local variable in the <tt>for</tt> loop invokes the copy constructor, which makes a copy of the entire queue, even if we only want to access a few elements. Then, at the end of each iteration of the loop, that entire queue is deallocated by the destructor, because it is the value of a local variable. For <a class="docLink" href="#ch04ex26">Program 4.20</a> as it stands, where we access every item on the copy, the extra cost of allocating and deallocating affects the running time by only a constant factor, but it would be an unreasonable price to pay if we merely wanted to access a few items. In such a situation, we would prefer to use the default pointer-assignment implementation for <span class="docEmphasis">copy</span>, and modify the ADT to add operations allowing us to access items on the queue without modifying it.</p>
<p class="docText">Memory leaks are subtle defects that plague many large systems. Though reclaiming the memory allocated by an object is usually conceptually straightforward, being certain that we have tracked down each and every piece of storage allocated is tricky business in practice. The C++ destructor mechanism is helpful, but the system cannot guarantee that we have traversed our data structures as we intended. When an object goes out of existence, its pointers are lost forever&mdash;any pointer overlooked by the destructor constitutes a potential memory leak. One common source of memory leaks is when we forget to include a destructor at all&mdash;the default destructor certainly could not be expected to properly clean up our storage. Particular attention to this issue is required when we use abstract classes such as <a class="docLink" href="ch04lev1sec5.html#ch04ex15">Program 4.12</a>.</p>
<p class="docText">Some systems have <span class="docEmphasis">automatic memory allocation</span>, where the system takes responsibility to figure out which memory is no longer being used by programs, and to reclaim it. Neither of these solutions is entirely satisfactory. Some people feel that memory allocation is too important to be left to the system; others feel that it is too important to be left to programmers.</p>
<p class="docText">The list of questions that can arise when we consider ADT implementations is long, even for simple ADTs like the ones that we have been considering in this chapter. Do we want to be able to have different types of objects on the same queue? Do we want to use different implementations for queues of the same type in a single client because we know of performance differences? Should information about the efficiency of implementations be included in the interface? What form should that information take? Such questions underscore the importance of understanding the basic characteristics of our algorithms and data structures and how client programs may use them effectively, which is, in a sense, the topic of this book. Though full implementations are often exercises in software engineering instead of algorithms design, we strive to remain cognizant of the relevant issues so that our algorithms and data structures can serve as the basis for software tools in a broad variety of applications (<span class="docEmphasis">see reference section</span>).</p>
</td></tr></table>
<p class="docText">&nbsp;<a name="iddle1288"></a><a name="iddle1289"></a><a name="iddle1390"></a><a name="iddle2282"></a><a name="iddle1625"></a><a name="iddle1864"></a><a name="iddle1980"></a><a name="iddle2078"></a><a name="iddle1303"></a><a name="iddle1308"></a><a name="iddle1808"></a><a name="iddle1882"></a><a name="iddle2064"></a><a name="iddle2154"></a><a name="iddle2160"></a><a name="iddle2220"></a><a name="iddle2161"></a><a name="iddle1100"></a><a name="iddle1353"></a><a name="iddle1995"></a><a name="iddle2016"></a><a name="iddle1305"></a><a name="iddle1809"></a><a name="iddle1271"></a><a name="iddle1860"></a><a name="iddle1883"></a><a name="iddle2069"></a><a name="iddle2444"></a></p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa9q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">4.63</span> Overload operators <tt>+</tt> and <tt>+=</tt> to work for complex numbers (<a class="docLink" href="#ch04ex24">Programs 4.18</a> and <a class="docLink" href="#ch04ex25">4.19</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa9q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.64</span> Convert the equivalence-relations ADT in <a class="docLink" href="ch04lev1sec5.html#ch04lev1sec5">Section 4.5</a> to a first-class type.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa9q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.65</span> Create a first-class ADT for use in programs that process playing cards.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa9q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">4.66</span> Write a program to determine empirically the probability that various poker hands are dealt, using your ADT from <a class="docLink" href="#ch04qa9q3">Exercise 4.65</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa9q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">4.67</span> Develop an implementation for the complex-number ADT that is based on representing complex numbers in polar coordinates (that is, in the form <span class="docEmphasis">re</span><sup>i&#952;</sup>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa9q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">4.68</span> Use the identity <span class="docEmphasis">e<sup>i&#952;</sup></span> = <span class="docEmphasis">cos&#952;</span> + <span class="docEmphasis">isin&#952;</span> to prove that <span class="docEmphasis">e<sup>2</sup>&#960;i</span> = 1 and that the <span class="docEmphasis">N</span> complex <span class="docEmphasis">N</span>th roots of unity are</p>
<p class="docText">
<img border="0" alt="" width="198" height="38" src="191equ01.jpg" /></p>
<p class="docText">for <span class="docEmphasis">k</span> = 0, 1, ..., <span class="docEmphasis">N</span> &ndash;1.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa9q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.69</span> List the <span class="docEmphasis">N</span>th roots of unity for <span class="docEmphasis">N</span> from <tt>2</tt> tHRough <tt>8</tt>.</p>
</td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa9q8"></a><b></b></td><td><p class="docText"><a name="iddle1015"></a><a name="iddle2080"></a><a name="iddle2499"></a><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">4.70</span> Use <tt>precision</tt> and <tt>setw</tt> from <tt>iostream.h</tt> to provide an implementation of the overloaded <tt>&lt;&lt;</tt> for <a class="docLink" href="#ch04ex25">Program 4.19</a> that produces the output in <a class="docLink" href="#ch04fig12">Figure 4.12</a> for <a class="docLink" href="#ch04ex23">Program 4.17</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa9q9"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">4.71</span> Describe precisely what happens when you run the queue simulation program <a class="docLink" href="#ch04ex26">Program 4.20</a> using a simple data type implementation such as <a class="docLink" href="ch04lev1sec6.html#ch04ex18">Program 4.14</a> or <a class="docLink" href="ch04lev1sec6.html#ch04ex20">Program 4.15</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa9q10"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.72</span> Develop an implementation of the FIFO queue first-class ADT given in the text (<a class="docLink" href="#ch04ex27">Program 4.21</a>) that uses an array as the underlying data structure.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa9q11"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">4.73</span> Write an interface for a first-class pushdown-stack ADT.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa9q12"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.74</span> Develop an implementation of your first-class pushdown-stack ADT from <a class="docLink" href="#ch04qa9q11">Exercise 4.73</a> that uses an array as the underlying data structure.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa9q13"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.75</span> Develop an implementation of your first-class pushdown-stack ADT from <a class="docLink" href="#ch04qa9q11">Exercise 4.73</a> that uses a linked list as the underlying data structure.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa9q14"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">4.76</span> Modify the postfix-evaluation program in <a class="docLink" href="ch04lev1sec3.html#ch04lev1sec3">Section 4.3</a> to evaluate post-fix expressions consisting of complex numbers with integer coefficients, using the first-class complex numbers ADT in the text (<a class="docLink" href="#ch04ex24">Programs 4.18</a> and <a class="docLink" href="#ch04ex25">4.19</a>). For simplicity, assume that the complex numbers all have nonnull integer coefficients for both real and imaginary parts and are written with no spaces. For example, your program should print the output <tt>8+4i</tt> when given the input</p>
<div class="docText"><pre>1+1i 0+1i + 1-2i * 3+4i + .</pre></div><br /></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa9q15"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">4.77</span> Do a mathematical analysis of the queue-simulation process in <a class="docLink" href="#ch04ex26">Program 4.20</a> to determine, as a function of <span class="docEmphasis">N</span> and <tt>M</tt>, the probability that the queue selected for the <span class="docEmphasis">N</span> th <tt>get</tt> is empty and the expected number of items in the queues after <span class="docEmphasis">N</span> iterations of the <tt>for</tt> loop.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></div></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch04lev1sec7.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch04lev1sec9.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table><!--IP User 2--></td></body></head></html>