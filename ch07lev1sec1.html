<html><head><title>7.1. The Basic Algorithm</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch07.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch07lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch07lev1sec1"></a>
<h3 id="title-IDAETCRD" class="docSection1Title">7.1. The Basic Algorithm</h3>
<p class="docText">Quicksort is a divide-and-conquer method for sorting. It works by <span class="docEmphasis">partitioning</span> an array into two parts, then sorting the parts independently. As we shall see, the precise position of the partition depends on the initial order of the elements in the input file. The crux of the method is the partitioning process, which rearranges the array to make the following three conditions hold:</p>
<ul><li><p class="docList">The element <tt>a[i]</tt> is in its final place in the array for some <tt>i</tt>.</p></li><li><p class="docList">None of the elements in <tt>a[l]</tt>,<tt>. . .</tt>, <tt>a[i-1]</tt> is greater than <tt>a[i]</tt>.</p></li><li><p class="docList">None of the elements in <tt>a[i+1]</tt>,<tt>. . .</tt>, <tt>a[r]</tt> is less than <tt>a[i]</tt>.</p></li></ul>
<p class="docText"></p><a name="ch07ex01"></a><h5 id="title-IDA2UCRD" class="docExampleTitle">Program 7.1. Quicksort</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle2254"></a>If the array has one or fewer elements, do nothing. Otherwise, the array is processed by a <tt>partition</tt> procedure (see <a class="docLink" href="#ch07ex02">Program 7.2</a>), which puts <tt>a[i]</tt> into position for some <tt>i</tt> between <tt>l</tt> and <tt>r</tt> inclusive, and rearranges the other elements such that the recursive calls properly finish the sort.</p>
<div class="docText"><pre>    template &lt;class Item&gt;
    void quicksort(Item a[], int l, int r)
      {
        if (r &lt;= l) return;
        int i = partition(a, l, r);
        quicksort(a, l, i-1);
        quicksort(a, i+1, r);
      }</pre></div><br />
</td></tr></table></p>
<p class="docText">We achieve a complete sort by partitioning, then recursively applying the method to the subfiles, as depicted in <a class="docLink" href="#ch07fig01">Figure 7.1</a>. Because the partitioning process always puts at least one element into position, a formal proof by induction that the recursive method constitutes a proper sort is not difficult to develop. <a class="docLink" href="#ch07ex01">Program 7.1</a> is a recursive program that implements this idea.</p>
<a name="ch07fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 7.1. Quicksort example</h5>
<h5></h5><h5></h5></center></p><p class="docText">Quicksort is a recursive partitioning process: We partition a file by putting some element (the partitioning element) in place, and rearranging the array such that smaller elements are to the left of the partitioning element and larger elements to its right. Then, we sort the left and right parts of the array recursively. Each line in this diagram depicts the result of partitioning the displayed subfile using the circled element. The end result is a fully sorted file.</p>
<p class="docText">
<img border="0" alt="" width="200" height="220" src="07fig01.gif" /></p>
<br />
<p class="docText">We use the following general strategy to implement partitioning. First, we arbitrarily choose <tt>a[r]</tt> to be the <span class="docEmphasis">partitioning element</span>&mdash;the one that will go into its final position. Next, we scan from the left end of the array until we find an element greater than the partitioning element, and we scan from the right end of the array until we find an element less than the partitioning element. The two elements that stopped the scans are obviously out of place in the final partitioned array, so we exchange them. Continuing in this way, we ensure that no array elements to the left of the left pointer are greater than the partitioning element, and no array elements to the right of the right pointer are less than the partitioning element, as depicted in the following diagram:</p>
<p class="docText"><img border="0" alt="" width="450" height="54" src="317fig01.gif" /></p>
<p class="docText"><a name="iddle1656"></a><a name="iddle1719"></a><a name="iddle1839"></a><a name="iddle2337"></a>Here, <tt>v</tt> refers to the value of the partitioning element, <tt>i</tt> to the left pointer, and <tt>j</tt> to the right pointer. As indicated in this diagram, it is best to stop the left scan for elements greater than <span class="docEmphasis">or equal to</span> the partitioning element and the right scan for elements less than <span class="docEmphasis">or equal to</span> the partitioning element, even though this policy might seem to create unnecessary exchanges involving elements equal to the partitioning element (we shall examine the reasons for this policy later in this section). When the scan pointers cross, all that we need to do to complete the partitioning process is to exchange <tt>a[r]</tt> with the leftmost element of the right subfile (the element pointed to by the left pointer). <a class="docLink" href="#ch07ex02">Program 7.2</a> is an implementation of this process, and <a class="docLink" href="#ch07fig02">Figures 7.2</a> and <a class="docLink" href="#ch07fig03">7.3</a> depict examples.</p>
<a name="ch07fig02"></a><p><center>
<h5 class="docFigureTitle">Figure 7.2. Quicksort partitioning</h5>
<h5></h5><h5></h5></center></p><p class="docText">Quicksort partitioning begins with the (arbitrary) choice of a partitioning element. <a class="docLink" href="#ch07ex02">Program 7.2</a> uses the rightmost element <span class="docEmphasis">E</span>. Then, it scans from the left over smaller elements and from the right over larger elements, exchanges the elements that stop the scans, continuing until the scan pointers meet. First, we scan from the left and stop at the <span class="docEmphasis">S</span>, then we scan from the right and stop at the <span class="docEmphasis">A</span>, and then we exchange the <span class="docEmphasis">S</span> and the <span class="docEmphasis">A</span>. Next, we continue the scan from the left until we stop at the <span class="docEmphasis">O</span>, and continue the scan from the right until we stop at the <span class="docEmphasis">E</span>, then exchange the <span class="docEmphasis">O</span> and the <span class="docEmphasis">E</span>. Next, our scanning pointers cross: We continue the scan from the left until we stop at the <span class="docEmphasis">R</span>, then continue the scan from the right (past the <span class="docEmphasis">R</span>) until we stop at the <span class="docEmphasis">E</span>. To finish the process, we exchange the partitioning element (the <span class="docEmphasis">E</span> at the right) with the <span class="docEmphasis">R</span>.</p>
<p class="docText">
<img border="0" alt="" width="220" height="205" src="07fig02.gif" /></p>
<br />
<a name="ch07fig03"></a><p><center>
<h5 class="docFigureTitle">Figure 7.3. Dynamic characteristics of quicksort partitioning</h5>
<h5></h5><h5></h5></center></p><p class="docText">The partitioning process divides a file into two subfiles that can be sorted independently. None of the elements to the left of the left scan pointer is larger, so there are no dots above and to its left; and none of the elements to the right of the right scan pointer is smaller, so there are no dots below and to its right. As shown in these two examples, partitioning a random array divides it into two smaller random arrays, with one element (the partitioning element) ending up on the diagonal.</p>
<p class="docText">
<img border="0" alt="" width="130" height="281" src="07fig03.gif" /></p>
<br />
<p class="docText">The inner loop of quicksort increments a pointer and compares an array element against a fixed value. This simplicity is what makes quicksort quick: It is hard to envision a shorter inner loop in a sorting algorithm.</p>
<p class="docText"><a class="docLink" href="#ch07ex02">Program 7.2</a> uses an explicit test to stop the scan if the partitioning element is the smallest element in the array. It might be worthwhile to use a sentinel to avoid this test: The inner loop of quicksort is so small that this one superfluous test could have a noticeable effect on performance. A sentinel is not needed for this implementation when the partitioning element is the largest element in the file, because the partitioning element itself is at the right end of the array to stop the scan. Other implementations of partitioning discussed later in this section and elsewhere in this chapter do not necessarily stop the scan on keys equal to the partitioning element&mdash;we might need to add a test to stop the pointer from running off the right end of the array in such an implementation. On the other hand, the improvement to quicksort that we discuss in <a class="docLink" href="ch07lev1sec5.html#ch07lev1sec5">Section 7.5</a> has the side benefit of needing neither the test nor a sentinel at either end.</p>
<p class="docText">The partitioning process is not stable, because any key might be moved past a large number of keys equal to it (which have not even been examined yet) during any exchange. No easy way to make an array-based quicksort stable is known.</p>
<p class="docText">The partitioning procedure must be implemented carefully. Specifically, the most straightforward way to guarantee that the recursive program terminates is that it (<span class="docEmphasis">i</span>) does not call itself for files of size 1 or less; and (<span class="docEmphasis">ii</span>) calls itself for <span class="docEmphasis">only</span> files that are strictly smaller <a name="iddle1442"></a><a name="iddle1711"></a>than given as input. These policies may seem obvious, but it is easy to overlook a property of the input that can lead to a spectacular failure. For instance, a common mistake in implementing quicksort is not ensuring that one element is always put into position, then falling into an infinite recursive loop when the partitioning element happens to be the largest or smallest element in the file.</p>
<a name="ch07ex02"></a><h5 id="title-IDAS4CRD" class="docExampleTitle">Program 7.2. Partitioning</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The variable <tt>v</tt> holds the value of the partitioning element <tt>a[r]</tt>, and <tt>i</tt> and <tt>j</tt> are the left and right scan pointers, respectively. The partitioning loop increments <tt>i</tt> and decrements <tt>j</tt>, while maintaining the invariant property that no elements to the left of <tt>i</tt> are greater than <tt>v</tt> and no elements to the right of <tt>j</tt> are smaller than <tt>v</tt>. Once the pointers meet, we complete the partitioning by exchanging <tt>a[i]</tt> and <tt>a[r]</tt>, which puts <tt>v</tt> into <tt>a[i]</tt>, with no larger elements to <tt>v's</tt> right and no smaller elements to its left.</p>
<p class="docText">The partitioning loop is implemented as an infinite loop, with a <tt>break</tt> when the pointers cross. The test <tt>j == l</tt> protects against the case that the partitioning element is the smallest element in the file.</p>
<div class="docText"><pre>    template &lt;class Item&gt;
    int partition(Item a[], int l, int r)
      { int i = l-1, j = r; Item v = a[r];
        for (;;)
          {
             while (a[++i] &lt; v) ;
             while (v &lt; a[--j]) if (j == l) break;
             if (i &gt;= j) break;
             exch(a[i], a[j]);
           }
          exch(a[i], a[r]);
          return i;
        }</pre></div><br />
</td></tr></table></p>
<p class="docText">When duplicate keys are present in the file, the pointer crossing is subtle. We could improve the partitioning process slightly by terminating the scans when <tt>i &lt; j</tt>, and then using <tt>j</tt>, rather than <tt>i-1</tt>, to delimit the right end of the left subfile for the first recursive call. Letting the loop iterate one more time in this case is an improvement, because, whenever the scanning loops terminate with <tt>j</tt> and <tt>i</tt> referring <a name="iddle2070"></a>to the same element, we end up with <span class="docEmphasis">two</span> elements in their final positions: the element that stopped both scans, which must therefore be equal to the partitioning element, and the partitioning element itself. This case would occur, for example, if R were E in <a class="docLink" href="#ch07fig02">Figure 7.2</a>. This change is probably worth making, because, in this particular case, the program as given leaves a record with a key equal to the partitioning key in <tt>a[r]</tt>, and that makes the first partition in the call <tt>quicksort(a, i+1, r)</tt> degenerate, because its rightmost key is its smallest. The partitioning implementation in <a class="docLink" href="#ch07ex02">Program 7.2</a> is a bit easier to understand, however, so we refer to it as the basic quicksort partitioning method. If significant numbers of duplicate keys might be present, other factors come into play. We consider them next.</p>
<p class="docText">There are three basic strategies that we could adopt with respect to keys equal to the partitioning element: have both pointers stop on such keys (as in <a class="docLink" href="#ch07ex02">Program 7.2</a>); have one pointer stop and the other scan over them; or have both pointers scan over them. The question of which of these strategies is best has been studied in detail mathematically, and results show that it is best to have both pointers stop, primarily because this strategy tends to balance the partitions in the presence of many duplicate keys, whereas the other two can lead to badly unbalanced partitions for some files. We also consider a slightly more complicated and much more effective method for dealing with duplicate keys in <a class="docLink" href="ch07lev1sec6.html#ch07lev1sec6">Section 7.6</a>.</p>
<p class="docText">Ultimately, the efficiency of the sort depends on how well the partitioning divides the file, which in turn depends on the value of the partitioning element. <a class="docLink" href="#ch07fig02">Figure 7.2</a> shows that partitioning divides a large randomly ordered file into two smaller randomly ordered files, but that the actual split could be anywhere in the file. We would prefer to choose an element that would split the file near the middle, but we do not have the necessary information to do so. If the file is randomly ordered, choosing <tt>a[r]</tt> as the partitioning element is the same as choosing any other specific element, and will give us a split near the middle <span class="docEmphasis">on the average</span>. In <a class="docLink" href="ch07lev1sec4.html#ch07lev1sec4">Section 7.4</a> we consider the analysis of the algorithm that allows us to see how this choice compares to the ideal choice. In <a class="docLink" href="ch07lev1sec5.html#ch07lev1sec5">Section 7.5</a> we see how the analysis guides us in considering choices of the partitioning element that make the algorithm more efficient.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa1q1"></a><b></b></td><td><p class="docText"><a name="iddle2179"></a><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">7.1</span> Show, in the style of the example given here, how quicksort sorts the file E A S Y Q U E S T I O N.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa1q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">7.2</span> Show how the file 1 0 0 1 1 1 0 0 0 0 0 1 0 1 0 0 is partitioned, using both <a class="docLink" href="#ch07ex02">Program 7.2</a> and the minor modifications suggested in the text.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa1q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">7.3</span> Implement partitioning without using a <tt>break</tt> statement or a <tt>goto</tt> statement.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa1q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">7.4</span> Develop a stable quicksort for linked lists.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa1q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">7.5</span> What is the maximum number of times during the execution of quicksort that the largest element can be moved, for a file of <span class="docEmphasis">N</span> elements?</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch07.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch07lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>