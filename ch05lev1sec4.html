<html><head><title>5.4. Trees</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch05lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch05lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch05lev1sec4"></a>
<h3 id="title-IDA4IFVM" class="docSection1Title">5.4. Trees</h3>
<p class="docText">Trees are a mathematical abstraction that play a central role in the design and analysis of algorithms because</p>
<ul><li><p class="docList">We use trees to describe dynamic properties of algorithms.</p></li><li><p class="docList">We build and use explicit data structures that are concrete realizations of trees.</p></li></ul>
<p class="docText">We have already seen examples of both of these uses. We designed algorithms for the connectivity problem that are based on tree structures in <a class="docLink" href="ch01.html#ch01">Chapter 1</a>, and we described the call structure of recursive algorithms with tree structures in <a class="docLink" href="ch05lev1sec2.html#ch05lev1sec2">Sections 5.2</a> and <a class="docLink" href="ch05lev1sec3.html#ch05lev1sec3">5.3</a>.</p>
<p class="docText"><a name="iddle2573"></a>We encounter trees frequently in everyday life&mdash;the basic concept is a familiar one. For example, many people keep track of ancestors or descendants with a family tree; as we shall see, much of our terminology is derived from this usage. Another example is found in the organization of sports tournaments; this usage was studied by Lewis Carroll, among others. A third example is found in the organizational chart of a large corporation; this usage is suggestive of the hierarchical decomposition that characterizes divide-and-conquer algorithms. A fourth example is a parse tree of an English sentence into its constituent parts; such trees are intimately related to the processing of computer languages, as discussed in Part 5. <a class="docLink" href="#ch05fig19">Figure 5.19</a> gives a typical example of a tree&mdash;one that describes the structure of this book. We touch on numerous other examples of applications of trees throughout the book.</p>
<a name="ch05fig19"></a><p><center>
<h5 class="docFigureTitle">Figure 5.19. A tree</h5>
<h5></h5><h5></h5></center></p><p class="docText">This tree depicts the parts, chapters, and sections in this book. There is a node for each entity. Each node is connected to its constituent parts by links down to them, and is connected to the large part to which it belongs by a link up to that part.</p><p class="docText"><div class="v1"><a target="_blank" href="05fig19_alt.gif">[View full size image]</a></div><img border="0" alt="" width="500" height="62" src="05fig19.gif" /></p><br />
<p class="docText">In computer applications, one of the most familiar uses of tree structures is to organize file systems. We keep files in <span class="docEmphasis">directories</span> (which are also sometimes called <span class="docEmphasis">folders</span>) that are defined recursively as sequences of directories and files. This recursive definition again reflects a natural recursive decomposition, and is identical to the definition of a certain type of tree.</p>
<p class="docText">There are many different types of trees, and it is important to understand the distinction between the abstraction and the concrete representation with which we are working for a given application. Accordingly, we shall consider the different types of trees and their representations in detail. We begin our discussion by defining trees as abstract objects, and by introducing most of the basic associated terminology. We shall discuss informally the different types of trees that we need to consider in decreasing order of generality:</p>
<ul><li><p class="docList">Trees</p></li><li><p class="docList">Rooted trees</p></li><li><p class="docList">Ordered trees</p></li><li><p class="docList"><span class="docEmphasis">M</span>-ary trees and binary trees</p></li></ul>
<p class="docText"></p><a name="ch05fig20"></a><p><center>
<h5 class="docFigureTitle">Figure 5.20. Types of trees</h5>
<h5></h5><h5></h5></center></p><p class="docText"><a name="iddle1504"></a><a name="iddle1509"></a><a name="iddle1967"></a><a name="iddle2043"></a><a name="iddle2283"></a><a name="iddle2473"></a><a name="iddle2543"></a><a name="iddle2562"></a><a name="iddle2565"></a><a name="iddle2567"></a><a name="iddle2613"></a>These diagrams show examples of a binary tree <span class="docEmphasis">(top left)</span>, a ternary tree <span class="docEmphasis">(top right)</span>, a rooted tree <span class="docEmphasis">(bottom left)</span>, and a free tree <span class="docEmphasis">(bottom right)</span>.</p>
<p class="docText">
<img border="0" alt="" width="500" height="274" src="05fig20.gif" /></p>
<br />
<p class="docText">After developing a context with this informal discussion, we move to formal definitions and consider representations and applications. <a class="docLink" href="#ch05fig20">Figure 5.20</a> illustrates many of the basic concepts that we discuss and then define.</p>
<p class="docText">A <span class="docEmphasis">tree</span> is a nonempty collection of vertices and edges that satisfies certain requirements. A <span class="docEmphasis">vertex</span> is a simple object (also referred to as a <span class="docEmphasis">node</span>) that can have a name and can carry other associated information; an <span class="docEmphasis">edge</span> is a connection between two vertices. A <span class="docEmphasis">path</span> in a tree is a list of distinct vertices in which successive vertices are connected by edges in the tree. The defining property of a tree is that there is precisely one path connecting any two nodes. If there is more than one path between some pair of nodes, or if there is no path between some pair of nodes, then we have a graph; we do not have a tree. A disjoint set of trees is called a <span class="docEmphasis">forest</span>.</p>
<p class="docText">A <span class="docEmphasis">rooted</span> tree is one where we designate one node as the <span class="docEmphasis">root</span> of a tree. In computer science, we normally reserve the term <span class="docEmphasis">tree</span> to refer to rooted trees, and use the term <span class="docEmphasis">free tree</span> to refer to the more general structure described in the previous paragraph. In a rooted tree, any node is the root of a <span class="docEmphasis">subtree</span> consisting of it and the nodes below it.</p>
<p class="docText">There is exactly one path between the root and each of the other nodes in the tree. The definition implies no direction on the edges; we normally think of the edges as all pointing away from the root or all pointing towards the root, depending upon the application. We usually draw rooted trees with the root at the top (even though this <a name="iddle1200"></a><a name="iddle1255"></a><a name="iddle1547"></a><a name="iddle1753"></a><a name="iddle1848"></a><a name="iddle1955"></a><a name="iddle1960"></a><a name="iddle1966"></a><a name="iddle1973"></a><a name="iddle2009"></a><a name="iddle2027"></a><a name="iddle2353"></a><a name="iddle2510"></a><a name="iddle2548"></a><a name="iddle2550"></a>convention seems unnatural at first), and we speak of node y as being <span class="docEmphasis">below</span> node <span class="docEmphasis">x</span> (and <span class="docEmphasis">x</span> as <span class="docEmphasis">above</span> <span class="docEmphasis">y</span>) if <span class="docEmphasis">x</span> is on the path from <span class="docEmphasis">y</span> to the root (that is, if <span class="docEmphasis">y</span> is below <span class="docEmphasis">x</span> as drawn on the page and is connected to <span class="docEmphasis">x</span> by a path that does not pass through the root). Each node (except the root) has exactly one node above it, which is called its <span class="docEmphasis">parent</span>; the nodes directly below a node are called its <span class="docEmphasis">children</span>. We sometimes carry the analogy to family trees further and refer to the <span class="docEmphasis">grandparent</span>or the <span class="docEmphasis">sibling</span> of a node.</p>
<p class="docText">Nodes with no children are called <span class="docEmphasis">leaves</span>, or <span class="docEmphasis">terminal</span> nodes. To correspond to the latter usage, nodes with at least one child are sometimes called <span class="docEmphasis">nonterminal</span> nodes. We have seen an example in this chapter of the utility of distinguishing these types of nodes. In trees that we use to present the call structure of recursive algorithms (see, for example, <a class="docLink" href="ch05lev1sec3.html#ch05fig14">Figure 5.14</a>) the nonterminal nodes (circles) represent function invocations with recursive calls and the terminal nodes (squares) represent function invocations with no recursive calls.</p>
<p class="docText">In certain applications, the way in which the children of each node are ordered is significant; in other applications, it is not. An <span class="docEmphasis">ordered</span> tree is a rooted tree in which the order of the children at every node is specified. Ordered trees are a natural representation: for example, we place the children in some order when we draw a tree. Indeed, many other natural concrete representations have a similar implied ordering; for example, this distinction is usually significant when we consider representing trees in a computer.</p>
<p class="docText">If each node <span class="docEmphasis">must</span> have a specific number of children appearing in a specific order, then we have an <span class="docEmphasis">M-ary tree</span>. In such a tree, it is often appropriate to define special external nodes that have no children. Then, external nodes can act as dummy nodes for reference by nodes that do not have the specified number of children. In particular, the simplest type of <span class="docEmphasis">M</span>-ary tree is the binary tree. A <span class="docEmphasis">binary tree</span> is an ordered tree consisting of two types of nodes: external nodes with no children and internal nodes with exactly two children. Since the two children of each internal node are ordered, we refer to the <span class="docEmphasis">left child</span>and the <span class="docEmphasis">right child</span> of internal nodes: every internal node must have both a left and a right child, although one or both of them might be an external node. A <span class="docEmphasis">leaf</span> in an <span class="docEmphasis">M</span>-ary tree is an internal node whose children are all external.</p>
<p class="docText"><a name="iddle1210"></a>That is the basic terminology. Next, we shall consider formal definitions, representations, and applications of, in increasing order of generality,</p>
<ul><li><p class="docList">Binary trees and <span class="docEmphasis">M</span>-ary trees</p></li><li><p class="docList">Ordered trees</p></li><li><p class="docList">Rooted trees</p></li><li><p class="docList">Free trees</p></li></ul>
<p class="docText">By starting with the most specific abstract structure, we shall be able to consider concrete representations in detail, as will become clear.</p>
<a name="ch05ex17"></a><h5 id="title-IDAYYIVM" class="docExampleTitle">Definition 5.1. A <span class="docEmphasis">binary tree</span> is either an external node or an internal node connected to a pair of binary trees, which are called the left subtree and the right subtree of that node</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This definition makes it plain that the binary tree itself is an abstract mathematical concept. When we are working with a computer representation, we are working with just one concrete realization of that abstraction. The situation is no different from representing real numbers with <tt>floats</tt>, integers with <tt>ints</tt>, and so forth. When we draw a tree with a node at the root connected by edges to the left subtree on the left and the right subtree on the right, we are choosing a convenient concrete representation. There are many different ways to represent binary trees (see, for example, <a class="docLink" href="#ch05qa4q7">Exercise 5.62</a>) that are surprising at first, but, upon reflection, that are to be expected, given the abstract nature of the definition.</p>
<p class="docText">The concrete representation that we use most often when we implement programs that use and manipulate binary trees is a structure with two links (a left link and a right link) for internal nodes (see <a class="docLink" href="#ch05fig21">Figure 5.21</a>). These structures are similar to linked lists, but they have two links per node, rather than one. Null links correspond to external nodes. Specifically, we add a link to our standard linked list representation from <a class="docLink" href="ch03lev1sec3.html#ch03lev1sec3">Section 3.3</a>, as follows:</p>
<div class="docText"><pre>struct node { Item item; node *l, *r; };
typedef node *link;</pre></div><br />
<a name="ch05fig21"></a><p><center>
<h5 class="docFigureTitle">Figure 5.21. Binary-tree representation</h5>
<h5></h5><h5></h5></center></p><p class="docText">The standard representation of a binary tree uses nodes with two links: a left link to the left subtree and a right link to the right subtree. Null links correspond to external nodes.</p>
<p class="docText">
<img border="0" alt="" width="475" height="120" src="05fig21.gif" /></p>
</td></tr></table></p><br />
<p class="docText">which is nothing more than C++ code for <a class="docLink" href="#ch05ex17">Definition 5.1</a>. Nodes consist of items and pairs of pointers to nodes, and we also refer to pointers to nodes as links. Thus, for example, we implement the abstract operation <span class="docEmphasis">move to the left subtree</span> with a pointer reference such as <tt>x = x-&gt;l</tt>.</p>
</td></tr></table>
<p class="docText"><a name="iddle1212"></a>This standard representation allows for efficient implementation of operations that call for moving <span class="docEmphasis">down</span> the tree from the root, but not for operations that call for moving <span class="docEmphasis">up</span> the tree from a child to its parent. For algorithms that require such operations, we might add a third link to each node, pointing to the parent. This alternative is analogous to a doubly linked list. As with linked lists (see <a class="docLink" href="ch03lev1sec3.html#ch03fig06">Figure 3.6</a>), we keep tree nodes in an array and use indices instead of pointers as links in certain situations. We examine a specific instance of such an implementation in <a class="docLink" href="ch12lev1sec7.html#ch12lev1sec7">Section 12.7</a>. We use other binary-tree representations for certain specific algorithms, most notably in <a class="docLink" href="ch09.html#ch09">Chapter 9</a>.</p>
<p class="docText">Because of all the different possible representations, we might develop a binary-tree ADT that encapsulates the important operations that we want to perform, and that separates the use and implementation of these operations. We do not take this approach in this book because</p>
<ul><li><p class="docList">We most often use the two-link representation.</p></li><li><p class="docList">We use trees to implement higher-level ADTs, and wish to focus on those.</p></li><li><p class="docList">We work with algorithms whose efficiency depends on a particular representation&mdash;a fact that might be lost in an ADT.</p></li></ul>
<p class="docText">These are the same reasons that we use familiar concrete representations for arrays and linked lists. The binary-tree representation depicted in <a class="docLink" href="#ch05fig21">Figure 5.21</a> is a fundamental tool that we are now adding to this short list.</p>
<p class="docText">For linked lists, we began by considering elementary operations for inserting and removing nodes (see <a class="docLink" href="ch03lev1sec3.html#ch03fig03">Figures 3.3</a> and <a class="docLink" href="ch03lev1sec3.html#ch03fig04">3.4</a>). For the standard representation of binary trees, such operations are not necessarily elementary, because of the second link. If we want to remove a <a name="iddle1505"></a><a name="iddle1849"></a><a name="iddle2010"></a><a name="iddle2549"></a><a name="iddle2551"></a>node from a binary tree, we have to reconcile the basic problem that we may have two children to handle after the node is gone, but only one parent. There are three natural operations that do not have this difficulty: insert a new node at the bottom (replace a null link with a link to a new node), remove a leaf (replace the link to it by a null link), and combine two trees by creating a new root with a left link pointing to one tree and the right link pointing to the other one. We use these operations extensively when manipulating binary trees.</p>
<a name="ch05ex18"></a><h5 id="title-IDAL5IVM" class="docExampleTitle">Definition 5.2. An <span class="docEmphasis">M-ary tree</span> is either an external node or an internal node connected to an ordered sequence of <span class="docEmphasis">M</span> trees that are also <span class="docEmphasis">M</span>-ary trees</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We normally represent nodes in <span class="docEmphasis">M</span>-ary trees either as structures with <span class="docEmphasis">M</span> named links (as in binary trees) or as arrays of <span class="docEmphasis">M</span> links. For example, in <a class="docLink" href="ch15.html#ch15">Chapter 15</a>, we consider 3-ary (or <span class="docEmphasis">ternary</span>) trees where we use structures with three named links (left, middle, and right) each of which have specific meaning for associated algorithms. Otherwise, the use of arrays to hold the links is appropriate because the value of <span class="docEmphasis">M</span> is fixed, although, as we shall see, we have to pay particular attention to excessive use of space when using such a representation.</p>
</td></tr></table></p>
<a name="ch05ex19"></a><h5 id="title-IDAYIJVM" class="docExampleTitle">Definition 5.3. A <span class="docEmphasis">tree</span> (also called an <span class="docEmphasis">ordered tree</span>) is a node (called the root) connected to a sequence of disjoint trees. Such a sequence is called a <span class="docEmphasis">forest</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The distinction between ordered trees and <span class="docEmphasis">M</span>-ary trees is that nodes in ordered trees can have any number of children, whereas nodes in <span class="docEmphasis">M</span>-ary trees must have precisely <span class="docEmphasis">M</span> children. We sometimes use the term <span class="docEmphasis">general tree</span> in contexts where we want to distinguish ordered trees from <span class="docEmphasis">M</span>-ary trees.</p>
<p class="docText">Because each node in an ordered tree can have any number of links, it is natural to consider using a linked list, rather than an array, to hold the links to the node's children. <a class="docLink" href="#ch05fig22">Figure 5.22</a> is an example of such a representation. From this example, it is clear that each node then contains two links, one for the linked list connecting it to its siblings, the other for the linked list of its children.</p>
<a name="ch05fig22"></a><p><center>
<h5 class="docFigureTitle">Figure 5.22. Tree representation</h5>
<h5></h5><h5></h5></center></p><p class="docText">Representing an ordered tree by keeping a linked list of the children of each node is equivalent to representing it as a binary tree. The diagram on the right at the top shows a linked-list-of-children representation of the tree on the left at the top, with the list implemented in the right links of nodes, and each node's left link pointing to the first node in the linked list of its children. The diagram on the right at the bottom shows a slightly rearranged version of the diagram above it, and clearly represents the binary tree at the left on the bottom. That is, we can consider the binary tree as representing the tree.</p>
<p class="docText">
<img border="0" alt="" width="500" height="244" src="05fig22.gif" /></p>
</td></tr></table></p><br />
</div></td></tr></table>
<a name="ch05ex20"></a><h5 id="title-IDA4KJVM" class="docExampleTitle">Property 5.4. <span class="docEmphasis">There is a one-to-one correspondence between binary trees and ordered forests</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle2284"></a><a name="iddle2552"></a><a name="iddle2563"></a><a name="iddle2606"></a>The correspondence is depicted in <a class="docLink" href="#ch05fig22">Figure 5.22</a>. We can represent any forest as a binary tree by making the left link of each node point to its leftmost child, and the right link of each node point to its sibling on the right.</p>
</td></tr></table></p>
<a name="ch05ex21"></a><h5 id="title-IDAXMJVM" class="docExampleTitle">Definition 5.4. A <span class="docEmphasis">rooted tree</span> (or <span class="docEmphasis">unordered tree</span>) is a node (called the root) connected to a multiset of rooted trees. (Such a multiset is called an unordered forest.)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The trees that we encountered in <a class="docLink" href="ch01.html#ch01">Chapter 1</a> for the connectivity problem are unordered trees. Such trees may be defined as ordered trees where the order in which the children of a node are considered is not significant. We could also choose to define unordered trees as comprising a set of parent&ndash;child relationships among nodes. This choice would seem to have little relation to the recursive structures that we are considering, but it is perhaps the concrete representation that is most true to the abstract notion.</p>
<p class="docText">We could choose to represent an unordered tree in a computer with an ordered tree, recognizing that many different ordered trees might represent the same unordered tree. Indeed, the converse problem of determining whether or not two different ordered trees represent the same unordered tree (the <span class="docEmphasis">tree-isomorphism</span> problem) is a difficult one to solve.</p>
<p class="docText">The most general type of tree is one where no root node is distinguished. For example, the spanning trees resulting from the connectivity algorithms in <a class="docLink" href="ch01.html#ch01">Chapter 1</a> have this property. To define properly <span class="docEmphasis">unrooted, unordered trees</span>, or <span class="docEmphasis">free trees</span>, we start with a definition for <span class="docEmphasis">graphs</span>.</p>
</td></tr></table></p>
<p class="docText"></p><a name="ch05ex22"></a><h5 id="title-IDANOJVM" class="docExampleTitle">Definition 5.5. A <span class="docEmphasis">graph</span> is a set of nodes together with a set of edges that connect pairs of distinct nodes (with at most one edge connecting any pair of nodes)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1510"></a><a name="iddle1550"></a><a name="iddle2039"></a><a name="iddle2042"></a><a name="iddle2544"></a>We can envision starting at some node and following an edge to the constituent node for the edge, then following an edge from that node to another node, and so on. A sequence of edges leading from one node to another in this way with no node appearing twice is called a <span class="docEmphasis">simple path</span>. A graph is <span class="docEmphasis">connected</span> if there is a simple path connecting any pair of nodes. A path that is simple except that the first and final nodes are the same is called a <span class="docEmphasis">cycle</span>.</p>
<p class="docText">Every tree is a graph; which graphs are trees? We consider a graph to be a tree if it satisfies any of the following four conditions:</p>
<ul><li><p class="docList"><span class="docEmphasis">G</span> has <span class="docEmphasis">N</span> &ndash; 1 edges and no cycles.</p></li><li><p class="docList"><span class="docEmphasis">G</span> has <span class="docEmphasis">N</span> &ndash; 1 edges and is connected.</p></li><li><p class="docList">Exactly one simple path connects each pair of vertices in <span class="docEmphasis">G</span>.</p></li><li><p class="docList"><span class="docEmphasis">G</span> is connected, but does not remain connected if any edge is removed.</p></li></ul>
<p class="docText">Any one of these conditions is necessary and sufficient to prove the other three. Formally, we should choose one of them to serve as a definition of a <span class="docEmphasis">free tree</span>; informally, we let them collectively serve as the definition.</p>
<p class="docText">We represent a free tree simply as a collection of edges. If we choose to represent a free tree as an unordered, ordered or even a binary tree, we need to recognize that, in general, there are many different ways to represent each free tree.</p>
<p class="docText">The tree abstraction arises frequently, and the distinctions discussed in this section are important, because knowing different tree abstractions is often an essential ingredient in finding an efficient algorithm and corresponding data structure for a given problem. We often work directly with concrete representations of trees without regard to a particular abstraction, but we also often profit from working with the proper tree abstraction, then considering various concrete representations. We shall see numerous examples of this process throughout the book.</p>
<p class="docText">Before moving back to algorithms and implementations, we consider a number of basic mathematical properties of trees; these properties will be of use to us in the design and analysis of tree algorithms.</p>
</td></tr></table></p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa4q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">5.56</span> Give representations of the free tree in <a class="docLink" href="#ch05fig20">Figure 5.20</a> as a rooted tree and as a binary tree.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa4q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">5.57</span> How many different ways are there to represent the free tree in <a class="docLink" href="#ch05fig20">Figure 5.20</a> as an ordered tree?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa4q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">5.58</span> Draw three ordered trees that are isomorphic to the ordered tree in <a class="docLink" href="#ch05fig20">Figure 5.20</a>. That is, you should be able to transform the four trees to one another by exchanging children.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa4q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.59</span> Assume that trees contain items for which <tt>operator==</tt> is defined. Write a recursive program that removes all the leaves in a binary tree with items equal to a given item (see <a class="docLink" href="ch05lev1sec1.html#ch05ex05">Program 5.5</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa4q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.60</span> Change the divide-and conquer function for finding the maximum item in an array (<a class="docLink" href="ch05lev1sec2.html#ch05ex06">Program 5.6</a>) to divide the array into <span class="docEmphasis">k</span> parts that differ by at most 1 in size, recursively find the maximum in each part, and return the maximum of the maxima.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa4q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.61</span> Draw the 3-ary and 4-ary trees corresponding to using <span class="docEmphasis">k</span> = 3 and <span class="docEmphasis">k</span> = 4 in the recursive construction suggested in <a class="docLink" href="#ch05qa4q5">Exercise 5.60</a>, for an array of 11 elements (see <a class="docLink" href="ch05lev1sec2.html#ch05fig06">Figure 5.6</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa4q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.62</span> Binary trees are equivalent to binary strings that have one more 0 bit than 1 bit, with the additional constraint that, at any position k, the number of 0 bits that appear strictly to the left of k is no larger than the number of 1 bits strictly to the left of k. A binary tree is either a 0 or two such strings concatenated together, preceded by a 1. Draw the binary tree that corresponds to the string</p>
<div class="docText"><pre>1 1 1 0 0 1 0 1 1 0 0 0 1 0 1 1 0 0 0.</pre></div><br /></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa4q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.63</span> Ordered trees are equivalent to balanced strings of parentheses: An ordered tree either is null or is a sequence of ordered trees enclosed in parentheses. Draw the ordered tree that corresponds to the string</p>
<div class="docText"><pre>( ( ( ) ( ( ) ( ) ) ( ) ) ( ( ) ( ) ( ) ) ) .</pre></div><br /></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa4q9"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">5.64</span> Write a program to determine whether or not two arrays of <span class="docEmphasis">N</span> integers between <span class="docEmphasis">0</span> and <span class="docEmphasis">N</span> &ndash; 1 represent isomorphic unordered trees, when interpreted (as in <a class="docLink" href="ch01.html#ch01">Chapter 1</a>) as parent&ndash;child links in a tree with nodes numbered between <a name="iddle1211"></a><span class="docEmphasis">0</span> and <span class="docEmphasis">N</span> &ndash; 1. That is, your program should determine whether or not there is a way to renumber the nodes in one tree such that the array representation of the one tree is identical to the array representation of the other tree.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa4q10"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">5.65</span> Write a program to determine whether or not two binary trees represent isomorphic unordered trees.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa4q11"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">5.66</span> Draw all the ordered trees that could represent the tree defined by the set of edges 0-1, 1-2, 1-3, 1-4, 4-5.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa4q12"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">5.67</span> Prove that, if a connected graph of <span class="docEmphasis">N</span> nodes has the property that removing any edge disconnects the graph, then the graph has <span class="docEmphasis">N</span> &ndash; 1 edges and no cycles.</p></td></tr></table></p>
<ul></ul></td></body></head></html>