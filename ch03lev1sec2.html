<html><head><title>3.2. Arrays</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch03lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch03lev1sec2"></a>
<h3 id="title-IDABT25F" class="docSection1Title">3.2. Arrays</h3>
<p class="docText">Perhaps the most fundamental data structure is the <span class="docEmphasis">array</span>, which is defined as a primitive in C++ and in most other programming languages. We have already seen the use of an array as the basis for the development of an efficient algorithm, in the examples in <a class="docLink" href="ch01.html#ch01">Chapter 1</a>; we shall see many more examples in this section.</p>
<p class="docText">An array is a fixed collection of same-type data that are stored contiguously and that are accessible by an index. We refer to the <tt>i</tt>th element of an array <tt>a</tt> as <tt>a[i]</tt>. It is the responsibility of the programmer to store something meaningful in an array position <tt>a[i]</tt> before referring to <tt>a[i]</tt>. In C++, it is also the responsibility of the programmer to use indices that are nonnegative and smaller than the array size. Neglecting these responsibilities are two of the more common programming mistakes.</p>
<p class="docText">Arrays are fundamental data structures in that they have a direct correspondence with memory systems on virtually all computers. To retrieve the contents of a word from memory in machine language, we provide an address. Thus, we could think of the entire computer memory as an array, with the memory addresses corresponding to array indices. Most computer-language processors translate programs that involve arrays into efficient machine-language programs that access memory directly, and we are safe in assuming that an array access such as <tt>a[i]</tt> translates to just a few machine instructions.</p>
<p class="docText"><a name="iddle1069"></a><a name="iddle1077"></a><a name="iddle1434"></a><a name="iddle1435"></a><a name="iddle1631"></a><a name="iddle1981"></a><a name="iddle2062"></a><a name="iddle2096"></a><a name="iddle2354"></a>A simple example of the use of an array is given by <a class="docLink" href="#ch03ex06">Program 3.5</a>, which prints out all prime numbers less than 10000. The method used, which dates back to the third century B.C., is called the <span class="docEmphasis">sieve of Eratosthenes</span> (see <a class="docLink" href="#ch03fig01">Figure 3.1</a>). It is typical of algorithms that exploit the fact that we can access efficiently any item of an array, given that item's index. The implementation has four loops, three of which access the items of the array sequentially, from beginning to end; the fourth skips through the array, <tt>i</tt> items at a time. In some cases, sequential processing is essential; in other cases, sequential ordering is used because it is as good as any other. For example, we could change the first loop in <a class="docLink" href="#ch03ex06">Program 3.5</a> to</p>
<div class="docText"><pre>for (i = N-1; i &gt; 1; i--) a[i] = 1;</pre></div><br />
<p class="docText">without any effect on the computation. We could also reverse the order of the inner loop in a similar manner, or we could change the final loop to print out the primes in decreasing order, but we could not change the order of the outer loop in the main computation, because it depends on all the integers less than <tt>i</tt> being processed before <tt>a[i]</tt> is tested for being prime.</p>
<a name="ch03fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 3.1. Sieve of Eratosthenes</h5>
<h5></h5><h5></h5></center></p><p class="docText">To compute the prime numbers less than 32, we initialize all the array entries to <span class="docEmphasis">1</span> (second column), to indicate that no numbers are known to be nonprime (<span class="docEmphasis"><tt>a[0]</tt></span> and <span class="docEmphasis"><tt>a[1]</tt></span> are not used and are not shown). Then, we set array entries whose indices are multiples of 2, 3, and 5 to <span class="docEmphasis">0</span>, since we know these multiples to be nonprime. Indices corresponding to array entries that remain <span class="docEmphasis">1</span> are prime (rightmost column).</p>
<p class="docText">
<img border="0" alt="" width="135" height="447" src="03fig01.gif" /></p>
<br />
<p class="docText">We will not analyze the running time of <a class="docLink" href="#ch03ex06">Program 3.5</a> in detail because that would take us astray into number theory, but it is clear that the running time is proportional to</p>
<div class="docText"><pre><span class="docEmphasis">N</span> + <span class="docEmphasis">N</span>/2 + <span class="docEmphasis">N</span>/3 + <span class="docEmphasis">N</span>/5 + <span class="docEmphasis">N</span>/7 + <span class="docEmphasis">N</span>/11 + . . .</pre></div><br />
<p class="docText">which is less than <span class="docEmphasis">N</span> + <span class="docEmphasis">N</span>/2 + <span class="docEmphasis">N</span>/3 + <span class="docEmphasis">N</span>/4 + . . . = <span class="docEmphasis">NH<sub>N</sub> ~ N</span>ln <span class="docEmphasis">N</span>.</p>
<p class="docText">One of the distinctive features of C++ is that an array name generates a pointer to the first element of the array (the one with index 0). Moreover, simple <span class="docEmphasis">pointer arithmetic</span> is allowed: if <tt>p</tt> is a pointer to an object of a certain type, then we can write code that assumes that objects of that type are arranged sequentially, and can use <tt>*p</tt> to refer to the first object, <tt>*(p+1)</tt> to refer to the second object, <tt>*(p+2)</tt> to refer to the third object, and so forth. In other words,</p>
<div class="docText"><pre>*(a+i) and a[i] <span class="docEmphasis">are equivalent</span> in C++.</pre></div><br />
<p class="docText">This equivalence provides an alternate mechanism for accessing objects in arrays that is sometimes more convenient than indexing. This mechanism is most often used for arrays of characters (strings); we discuss it again in <a class="docLink" href="ch03lev1sec6.html#ch03lev1sec6">Section 3.6</a>.</p>
<p class="docText">Like structures, pointers to arrays are significant because they allow us to manipulate the arrays efficiently as higher-level objects.</p>
<p class="docText"></p><a name="ch03ex06"></a><h5 id="title-IDA2125F" class="docExampleTitle">Program 3.5. Sieve of Eratosthenes</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1436"></a><a name="iddle2060"></a><a name="iddle2355"></a>The goal of this program is to set <tt>a[i]</tt> to 1 if <tt>i</tt> is prime, and to <tt>0</tt> if <tt>i</tt> is not prime. First, it sets to 1 all array elements, to indicate that no numbers are known to be nonprime. Then it sets to 0 array elements corresponding to indices that are known to be nonprime (multiples of known primes). If <tt>a[i]</tt> is still 1 after all multiples of smaller primes have been set to 0, then we know it to be prime.</p>
<p class="docText">Because the program uses an array consisting of the simplest type of elements, 0&ndash;1 values, it would be more space efficient if we explicitly used an array of bits, rather than one of integers. Also, some programming environments might require the array to be global if <span class="docEmphasis">N</span> is huge, or we could allocate it dynamically (see <a class="docLink" href="#ch03ex07">Program 3.6</a>).</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
static const int N = 1000;
int main()
  { int i, a[N];
    for (i = 2; i &lt; N; i++) a[i] = 1;
    for (i = 2; i &lt; N; i++)
      if (a[i])
        for (int j = i; j*i &lt; N; j++) a[i*j] = 0;
    for (i = 2; i &lt; N; i++)
      if (a[i]) cout &lt;&lt; " " &lt;&lt; i;
    cout &lt;&lt; endl;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">In particular, we can pass a pointer to an array as an argument to a function, thus enabling that function to access objects in the array without having to make a copy of the whole array. This capability is indispensable when we write programs to manipulate huge arrays. For example, the search functions that we examined in <a class="docLink" href="ch02lev1sec6.html#ch02lev1sec6">Section 2.6</a> use this feature. We shall see other examples in <a class="docLink" href="ch03lev1sec7.html#ch03lev1sec7">Section 3.7</a>.</p>
<p class="docText">The implementation in <a class="docLink" href="#ch03ex06">Program 3.5</a> assumes that the size of the array must be known beforehand: to run the program for a different value of <tt>N</tt>, we must change the constant <tt>N</tt> and recompile the program before executing it. <a class="docLink" href="#ch03ex07">Program 3.6</a> shows an alternate approach, where a user of the program can type in the value of <tt>N</tt>, and it will respond with the primes less than <tt>N</tt>. It uses two basic C++ mechanisms, both of which involve passing arrays as arguments to functions. The first is the <a name="iddle1068"></a><a name="iddle1404"></a><a name="iddle1865"></a>mechanism by which command-line arguments are passed to the main programs, in an array <tt>argv</tt> of size <tt>argc</tt>. The array <tt>argv</tt> is a compound array made up of objects that are arrays (strings) themselves, so we shall defer discussing it in further detail until <a class="docLink" href="ch03lev1sec7.html#ch03lev1sec7">Section 3.7</a>, and shall take on faith for the moment that the variable <tt>N</tt> gets the number that the user types when executing the program.</p>
<a name="ch03ex07"></a><h5 id="title-IDAPI35F" class="docExampleTitle">Program 3.6. Dynamic memory allocation for an array</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">To change the value of the maximum prime computed in <a class="docLink" href="#ch03ex06">Program 3.5</a>, we need to recompile the program. Instead, we can take the maximum desired number from the command line, and use it to allocate space for the array at execution time, using the C++ operator <tt>new[]</tt>. For example, if we compile this program and use 1000000 as a command-line argument, then we get all the primes less than 1 million (as long as our computer is big and fast enough to make the computation feasible); we can also debug with 100 (without using much time or space). We will use this idiom frequently, though, for brevity, we will omit the insufficient-memory test.</p>
<div class="docText"><pre>int main(int argc, char *argv[])
  { int i, N = atoi(argv[1]);
    int *a = new int[N];
    if (a == 0)
      { cout &lt;&lt; "out of memory" &lt;&lt; endl; return 0; }
    ...</pre></div><br />
</td></tr></table></p>
<p class="docText">The second basic mechanism that we use in <a class="docLink" href="#ch03ex07">Program 3.6</a> is <tt>new[]</tt>, an operator that <span class="docEmphasis">allocates</span> the amount of memory that we need for our array at execution time, and returns, for our exclusive use, a pointer to the array. In some programming languages, it is difficult or impossible to allocate arrays dynamically; in some other programming languages, memory allocation is an automatic mechanism. Dynamic allocation is an essential tool in programs that manipulate multiple arrays, some of which might have to be huge. In this case, without memory allocation, we would have to predeclare an array as large as any value that the user is allowed to type. In a large program where we might use many arrays, it is not feasible to do so for each array. We will generally use code like <a class="docLink" href="#ch03ex07">Program 3.6</a> in this book because of the flexibility that it provides, although in specific applications when the array size <span class="docEmphasis">is</span> known, simpler versions like <a class="docLink" href="#ch03ex06">Program 3.5</a> are perfectly suitable.</p>
<p class="docText"><a name="iddle1070"></a><a name="iddle1083"></a><a name="iddle1086"></a><a name="iddle1137"></a><a name="iddle1282"></a><a name="iddle1324"></a><a name="iddle1632"></a><a name="iddle1974"></a><a name="iddle2609"></a>Not only do arrays closely reflect the low-level mechanisms for accessing data in memory on most computers, but also they find widespread use because they correspond directly to natural methods of organizing data for applications. For example, arrays also correspond directly to <span class="docEmphasis">vectors</span>, the mathematical term for indexed lists of objects.</p>
<p class="docText">The C++ standard library provides the class <tt>Vector</tt>, an abstract object that we can index like an array (with optional automatic out-of-bounds checks), but that can also grow and shrink. We get the benefits of arrays, but can leave the problems of checking bad indices and managing the memory to the system. Since our focus in this book is so often on performance, we will tend to avoid exposure to such hidden costs by using arrays, while recognizing that our code could use or be used for <tt>Vector</tt>s, as well (see <a class="docLink" href="#ch03qa2q5">Exercise 3.14</a>).</p>
<p class="docText"><a class="docLink" href="#ch03ex08">Program 3.7</a> is an example of a simulation program that uses an array. It simulates a sequence of <span class="docEmphasis">Bernoulli trials</span>, a familiar abstract concept from probability theory. If we flip a coin <span class="docEmphasis">N</span> times, the probability that we see <span class="docEmphasis">k</span> heads is</p><p class="docText"><img border="0" alt="" width="195" height="50" src="087equ01.jpg" /></p>
<p class="docText">The approximation is known as the <span class="docEmphasis">normal approximation</span>: the familiar bell-shaped curve. <a class="docLink" href="#ch03fig02">Figure 3.2</a> illustrates the output of <a class="docLink" href="#ch03ex08">Program 3.7</a> for 1000 trials of the experiment of flipping a coin 32 times. Many more details on the Bernoulli distribution and the normal approximation can be found in any text on probability, and we shall encounter these distributions again in <a class="docLink" href="ch13.html#ch13">Chapter 13</a>. In the present context, our interest in the computation is that we use the numbers as indices into an array to count their frequency of occurrence. The ability of arrays to support this kind of operation is one of their prime virtues.</p>
<a name="ch03fig02"></a><p><center>
<h5 class="docFigureTitle">Figure 3.2. Coin-flipping simulation</h5>
<h5></h5><h5></h5></center></p><p class="docText">This table shows the result of running <a class="docLink" href="#ch03ex08">Program 3.7</a> with N = <span class="docEmphasis">32</span> and M = <span class="docEmphasis">1000</span>, simulating 1000 experiments of flipping a coin 32 times. The number of heads that we should see is approximated by the normal distribution function, which is drawn over the data.</p>
<p class="docText">
<img border="0" alt="" width="110" height="460" src="03fig02.gif" /></p>
<br />
<p class="docText"><a class="docLink" href="#ch03ex06">Programs 3.5</a> and <a class="docLink" href="#ch03ex08">3.7</a> both compute array indices from the data at hand. In a sense, when we use a computed value to access an array of size <span class="docEmphasis">N</span>, we are taking <span class="docEmphasis">N</span> possibilities into account with just a single operation. This gain in efficiency is compelling when we can realize it, and we shall be encountering algorithms throughout the book that make use of arrays in this way.</p>
<p class="docText">We use arrays to organize all different manner of types of objects, not just integers. In C++, we can declare arrays of any built-in or user-defined type (i.e., compound objects declared as structures). <a class="docLink" href="#ch03ex09">Program 3.8</a> <a name="iddle1283"></a>illustrates the use of an array of structures for points in the plane using the structure definition that we considered in <a class="docLink" href="ch03lev1sec1.html#ch03lev1sec1">Section 3.1</a>. This program also illustrates a common use of arrays: to save data away so that they can be quickly accessed in an organized manner in some computation.</p>
<a name="ch03ex08"></a><h5 id="title-IDA4Q35F" class="docExampleTitle">Program 3.7. Coin-flipping simulation</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">If we flip a coin <span class="docEmphasis">N</span> times, we expect to get <span class="docEmphasis">N/2</span> heads, but could get anywhere from 0 to <span class="docEmphasis">N</span> heads. This program runs the experiment <span class="docEmphasis">M</span> times, taking both <span class="docEmphasis">N</span> and <span class="docEmphasis">M</span> from the command line. It uses an array <span class="docEmphasis">f</span> to keep track of the frequency of occurrence of the outcome &quot;<span class="docEmphasis">i</span> heads&quot; for <span class="docEmphasis">0 <img src="U2264.GIF" border="0" />i<img src="U2264.GIF" border="0" /> N</span>, then prints out a histogram of the result of the experiments, with one asterisk for each 10 occurrences.</p>
<p class="docText">The operation on which this program is based&mdash;indexing an array with a computed value&mdash;is critical to the efficiency of many computational procedures.</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
int heads()
  { return rand() &lt; RAND_MAX/2; }
int main(int argc, char *argv[])
  { int i, j, cnt;
    int N = atoi(argv[1]), M = atoi(argv[2]);
    int *f = new int[N+1];
    for (j = 0; j &lt;= N; j++) f[j] = 0;
    for (i = 0; i &lt; M; i++, f[cnt]++)
      for (cnt = 0, j = 0; j &lt;= N; j++)
        if (heads()) cnt++;
    for (j = 0; j &lt;= N; j++)
      {
        if (f[j] == 0) cout &lt;&lt; ".";
        for (i = 0; i &lt; f[j]; i+=10) cout &lt;&lt; "*";
        cout &lt;&lt; endl;
      }
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">Incidentally, <a class="docLink" href="#ch03ex09">Program 3.8</a> is also interesting as a prototypical quadratic algorithm, which checks all pairs of a set of <span class="docEmphasis">N</span> data items, and therefore takes time proportional to <span class="docEmphasis">N<sup>2</sup></span>. In this book, we look <a name="iddle1277"></a>for improvements whenever we see such an algorithm, because its use becomes infeasible as <span class="docEmphasis">N</span> grows. In this case, we shall see how to use a compound data structure to perform this computation in linear time, in <a class="docLink" href="ch03lev1sec7.html#ch03lev1sec7">Section 3.7</a>.</p>
<a name="ch03ex09"></a><h5 id="title-IDAKT35F" class="docExampleTitle">Program 3.8. Closest-point computation</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This program illustrates the use of an array of structures, and is representative of the typical situation where we save items in an array to process them later, during some computation. It counts the number of pairs of <span class="docEmphasis">N</span> randomly generated points in the unit square that can be connected by a straight line of length less than <span class="docEmphasis">d</span>, using the data type for points described in <a class="docLink" href="ch03lev1sec1.html#ch03lev1sec1">Section 3.1</a>. The running time is <span class="docEmphasis">O(N<sup>2</sup>)</span>, so this program cannot be used for huge <span class="docEmphasis">N</span>. <a class="docLink" href="ch03lev1sec7.html#ch03ex23">Program 3.20</a> provides a faster solution.</p>
<div class="docText"><pre>#include &lt;math.h&gt;
#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
#include "Point.h"
float randFloat()
  { return 1.0*rand()/RAND_MAX; }
int main(int argc, char *argv[])
 { float d = atof(argv[2]);
   int i, cnt = 0, N = atoi(argv[1]);
   point *a = new point[N];
   for (i = 0; i &lt; N; i++)
     { a[i].x = randFloat(); a[i].y = randFloat(); }
   for (i = 0; i &lt; N; i++)
     for (int j = i+1; j &lt; N; j++)
      if (distance(a[i], a[j]) &lt; d) cnt++;
   cout &lt;&lt; cnt &lt;&lt; " pairs within " &lt;&lt; d &lt;&lt; endl;
 }</pre></div><br />
</td></tr></table></p>
<p class="docText">We can create compound types of arbitrary complexity in a similar manner: We can have not just arrays of structs, but also arrays of arrays, or structs containing arrays. We will consider these different options in detail in <a class="docLink" href="ch03lev1sec7.html#ch03lev1sec7">Section 3.7</a>. Before doing so, however, we will examine <span class="docEmphasis">linked lists</span>, which serve as the primary alternative to arrays for organizing collections of objects.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa2q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">3.10</span> Suppose that <tt>a</tt> is declared as <tt>int a[99]</tt>. Give the contents of the array after the following two statements are executed:</p>
<div class="docText"><pre>for (i = 0; i &lt; 99; i++) a[i] = 98-i;
for (i = 0; i &lt; 99; i++) a[i] = a[a[i]];</pre></div><br />
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa2q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.11</span> Modify our implementation of the sieve of Eratosthenes (<a class="docLink" href="#ch03ex06">Program 3.5</a>) to use an array of (<span class="docEmphasis">i</span>) chars; and (<span class="docEmphasis">ii</span>) bits. Determine the effects of these changes on the amount of space and time used by the program.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa2q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">3.12</span> Use the sieve of Eratosthenes to determine the number of primes less than <span class="docEmphasis">N</span>, for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa2q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">3.13</span> Use the sieve of Eratosthenes to draw a plot of <span class="docEmphasis">N</span> versus the number of primes less than <span class="docEmphasis">N</span> for <span class="docEmphasis">N</span> between 1 and 1000.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa2q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">3.14</span> The C++ standard library includes the <tt>Vector</tt> data type as an alternative to arrays. Find out how to use this data type on your system, and determine the effect on the runtime when you replace the array in <a class="docLink" href="#ch03ex06">Program 3.5</a> by a <tt>Vector</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa2q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">3.15</span> Empirically determine the effect of removing the test of <tt>a[i]</tt> from the inner loop of <a class="docLink" href="#ch03ex06">Program 3.5</a>, for <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>, and explain the effect that you observe.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa2q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">3.16</span> Write a program that counts the number of different integers less than 1000 that appear in an input stream.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa2q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">3.17</span> Write a program that determines empirically the number of random positive integers less than 1000 that you can expect to generate before getting a repeated value.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa2q9"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">3.18</span> Write a program that determines empirically the number of random positive integers less than 1000 that you can expect to generate before getting each value at least once.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa2q10"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.19</span> Modify <a class="docLink" href="#ch03ex08">Program 3.7</a> to simulate a situation where the coin turns up heads with probability <span class="docEmphasis">p</span>. Run 1000 trials for an experiment with 32 flips with <span class="docEmphasis">p</span> = 1/6 to get output that you can compare with <a class="docLink" href="#ch03fig02">Figure 3.2</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa2q11"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.20</span> Modify <a class="docLink" href="#ch03ex08">Program 3.7</a> to simulate a situation where the coin turns up heads with probability <span class="docEmphasis">&#955;/N</span>. Run 1000 trials for an experiment with 32 flips to get output that you can compare with <a class="docLink" href="#ch03fig02">Figure 3.2</a>. This distribution is the classical <span class="docEmphasis">Poisson</span> distribution.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa2q12"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">3.21</span> Modify <a class="docLink" href="#ch03ex09">Program 3.8</a> to print out the coordinates of the closest pair of points.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa2q13"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">3.22</span> Modify <a class="docLink" href="#ch03ex09">Program 3.8</a> to perform the same computation in <span class="docEmphasis">d</span> dimensions.</p></td></tr></table></p>
<a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch03lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>