<html><head><title>7.7. Strings and Vectors</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch07lev1sec6.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch07lev1sec8.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch07lev1sec7"></a>
<h3 id="title-IDA0MV1" class="docSection1Title">7.7. Strings and Vectors</h3>
<p class="docText">When the sort keys are strings, we could use a data type implementation like <a class="docLink" href="ch06lev1sec8.html#ch06ex24">Program 6.11</a> with the quicksort implementations in this chapter. Although this approach provides a correct and efficient implementation (faster than any other method we have seen so far, for large files), there is a hidden cost that is interesting to consider.</p>
<p class="docText">The problem lies in the cost of the <tt>strcmp</tt> function, which always compares two strings by proceeding from left to right, comparing strings character by character, taking time proportional to the number of leading characters that match in the two strings. For the later partitioning stages of quicksort, when keys are close together, this match might be relatively long. As usual, because of the recursive nature of quicksort, nearly all the cost of the algorithm is incurred in the later stages, so examining improvements there is worthwhile.</p>
<p class="docText">For example, consider a subfile of size 5 containing the keys <tt>discreet</tt>, <tt>discredit</tt>, <tt>discrete</tt>, <tt>discrepancy</tt>, and <tt>discretion</tt>. All the comparisons used for sorting these keys examine at least seven characters, when it would suffice to start at the seventh character, if the extra information that the first six characters are equal were available.</p>
<p class="docText">The three-way partitioning procedure that we considered in <a class="docLink" href="ch07lev1sec6.html#ch07lev1sec6">Section 7.6</a> provides an elegant way to take advantage of this observation. At each partitioning stage, we examine just one character (say the one at position <tt>d</tt>), assuming that the keys to be sorted are equal in positions <tt>0</tt> tHRough <tt>d-1</tt>. We do a three-way partition with keys whose <tt>dth</tt> character is smaller than the <tt>d</tt>th character of the partitioning element on the left, those whose <tt>dth</tt> character is equal to the <tt>d</tt>th character of the partitioning element in the middle, and those whose <tt>dth</tt> character is larger than the <tt>d</tt>th character of the partitioning element on the right. Then, we proceed as usual, <span class="docEmphasis">except</span> that we sort the middle subfile, <a name="iddle1423"></a>starting at character <tt>d+1</tt>. It is not difficult to see that this method leads to a proper sort on strings, which turns out to be very efficient (see <a class="docLink" href="#ch07table02">Table 7.2</a>). We have here a convincing example of the power of thinking (and programming) recursively.</p>
<a name="ch07table02"></a><p><table cellspacing="0" frame="hsides" rules="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 7.2. Empirical study of quicksort variants</h5></caption><colgroup align="left" span="7"><col width="60"></col><col width="60"></col><col width="60"></col><col width="60"></col><col width="60"></col><col width="60"></col><col width="60"></col></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top" colspan="7"><p class="docText">This table gives relative costs for several different versions of quicksort on the task of sorting the first <span class="docEmphasis">N</span> words of <span class="docEmphasis">Moby Dick</span>. Using insertion sort directly for small subfiles, or ignoring them and insertion sorting the same file afterward, are equally effective strategies, but the cost savings is slightly less than for integer keys (see <a class="docLink" href="ch07lev1sec5.html#ch07table01">Table 7.1</a>) because comparisons are more expensive for strings. If we do not stop on duplicate keys when partitioning, then the time to sort a file with all keys equal is quadratic; the effect of this inefficiency is noticeable on this example, because there are numerous words that appear with high frequency in the data. For the same reason, three-way partitioning is effective; it is 30 to 35 percent faster than the system sort.</p></td></tr><tr><td class="bottomBorder" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">V</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">I</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">M</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">Q</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">X</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">T</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">12500</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">8</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">7</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">6</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">10</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">7</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">6</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">25000</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">16</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">14</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">13</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">20</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">17</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">12</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">50000</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">37</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">31</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">31</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">45</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">41</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">29</p></td></tr><tr><td class="bottomBorder" align="center" valign="top"><p class="docText">100000</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">91</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">78</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">76</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">103</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">113</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">68</p></td></tr><tr><td class="docTableCell" align="left" valign="top" colspan="7"><p class="docText"><span class="docEmphasis">Key</span>:</p>
<blockquote><p></p><p class="docList">V Quicksort (<a class="docLink" href="ch07lev1sec1.html#ch07ex01">Program 7.1</a>)</p></blockquote></td></tr></table></p><p></p><p class="docList">I Insertion sort for small subfiles</p><p></p><p class="docList">M Ignore small subfiles, insertion sort afterward</p><p></p><p class="docList">Q System <tt>qsort</tt></p><p></p><p class="docList">X Scan over duplicate keys (goes quadratic when keys all equal)</p><p></p><p class="docList">T Three-way partitioning (<a class="docLink" href="ch07lev1sec6.html#ch07ex08">Program 7.5</a>)</p>
</td></tr></table><br />
<p class="docText">To implement the sort, we need a more general abstract type that allows access to characters of keys. The way in which strings are handled in C++ makes the implementation of this method particularly straightforward. However, we defer considering the implementation in detail until <a class="docLink" href="ch10.html#ch10">Chapter 10</a>, where we consider a variety of techniques for sorting that take advantage of the fact that sort keys can often be easily decomposed into smaller pieces.</p>
<p class="docText"><a name="iddle1620"></a><a name="iddle1735"></a><a name="iddle2008"></a><a name="iddle2182"></a><a name="iddle2330"></a><a name="iddle2610"></a>This approach generalizes to handle multidimensional sorts, where the sort keys are vectors and the records are to be rearranged such that the first components of the keys are in order, then those with first component equal are in order by second component, and so forth. If the components do not have duplicate keys, the problem reduces to sorting on the first component; in a typical application, however, each of the components may have only a few distinct values, and three-way partitioning (moving to the next component for the middle partition) is appropriate. This case was discussed by Hoare in his original paper, and is an important application.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa10q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">7.39</span> Discuss the possibility of improving selection, insertion, bubble, and shell sorts for strings.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch07qa10q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">7.40</span> How many characters are examined by the standard quicksort algorithm (<a class="docLink" href="ch07lev1sec1.html#ch07ex01">Program 7.1</a>, using the string type in <a class="docLink" href="ch06lev1sec8.html#ch06ex24">Program 6.11</a>) when sorting a file consisting of <span class="docEmphasis">N</span> strings of length <span class="docEmphasis">t</span>, all of which are equal? Answer the same question for the modification proposed in the text.</p></td></tr></table></p>
<ul></ul></div></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch07lev1sec6.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch07lev1sec8.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table><!--IP User 2--></td></body></head></html>