<html><head><title>3.3. Linked Lists</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch03lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch03lev1sec3"></a>
<h3 id="title-IDARU25F" class="docSection1Title">3.3. Linked Lists</h3>
<p class="docText"><a name="iddle1072"></a><a name="iddle1256"></a><a name="iddle1314"></a><a name="iddle1326"></a><a name="iddle1327"></a><a name="iddle1391"></a><a name="iddle1781"></a><a name="iddle1783"></a><a name="iddle1788"></a><a name="iddle1801"></a><a name="iddle1823"></a><a name="iddle1949"></a><a name="iddle1958"></a><a name="iddle1976"></a><a name="iddle2335"></a>When our primary interest is to go through a collection of items sequentially, one by one, we can organize the items as a <span class="docEmphasis">linked list</span>: a basic data structure where each item contains the information that we need to get to the next item. The primary advantage of linked lists over arrays is that the links provide us with the capability to rearrange the items efficiently. This flexibility is gained at the expense of quick access to any arbitrary item in the list, because the only way to get to an item in the list is to follow links from the beginning.</p>
<a name="ch03ex10"></a><h5 id="title-IDAWY25F" class="docExampleTitle">Definition 3.2. A <span class="docEmphasis">linked list</span> is a set of items where each item is part of a <span class="docEmphasis">node</span> that also contains a <span class="docEmphasis">link</span> to a node</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We define nodes by referring to nodes, so linked lists are sometimes called <span class="docEmphasis">self-referent</span> structures. Moreover, although a node's link usually refers to a different node, it could refer to the node itself, so linked lists can also be <span class="docEmphasis">cyclic</span> structures. The implications of these two facts will become apparent as we begin to consider concrete representations and applications of linked lists.</p>
<p class="docText">Normally, we think of linked lists as implementing a sequential arrangement of a set of items: Starting at a given node, we consider its item to be first in the sequence. Then, we follow its link to another node, which gives us an item that we consider to be second in the sequence, and so forth. Since the list could be cyclic, the sequence could seem infinite. We most often work with lists that correspond to a simple sequential arrangement of the items, adopting one of the following conventions for the link in the final node:</p>
<ul><li><p class="docList">It is a <span class="docEmphasis">null link</span> that points to no node.</p></li><li><p class="docList">It refers to a <span class="docEmphasis">dummy node</span> that contains no item.</p></li><li><p class="docList">It refers back to the first node, making the list a <span class="docEmphasis">circular list</span>.</p></li></ul>
<p class="docText">In each case, following links from the first node to the final one defines a sequential arrangement of items. Arrays define a sequential ordering of items as well; in an array, however, the sequential organization is provided implicitly, by the position in the array. (Arrays also support arbitrary access by index, which lists do not.)</p>
<p class="docText">We first consider nodes with precisely one link, and, in most applications, we work with one-dimensional lists where all nodes except possibly the first and the final each have precisely one link referring <span class="docEmphasis">to</span> them. This corresponds to the simplest situation, which is also the one that interests us most, where linked lists correspond to sequences of items. We will consider more complicated situations in due course.</p>
<p class="docText">Linked lists are primitive constructs in some programming environments, but not in C++. However, the basic building blocks that we discussed in <a class="docLink" href="ch03lev1sec1.html#ch03lev1sec1">Section 3.1</a> are well suited to implementing linked lists. Specifically, we use pointers for links and structures for nodes, as follows:</p>
<div class="docText"><pre>struct node { Item item; node *next; };
typedef node *link;</pre></div><br />
<p class="docText">This pair of statements is nothing more than C++ code for <a class="docLink" href="#ch03ex10">Definition 3.2</a>. Nodes consist of items (of type <tt>Item</tt>, uspecified here) and pointers to nodes, and we also refer to pointers to nodes as links. We shall see more complicated representations in <a class="docLink" href="ch04.html#ch04">Chapter 4</a> that provide more flexibility and allow more efficient implementations of certain operations, but this simple representation will suffice for us to consider the fundamentals of list processing. We use similar conventions for linked structures throughout the book.</p>
<p class="docText">Memory allocation is a central consideration in the effective use of linked lists. We have defined a single structure (<tt>struct node</tt>), but we will have many instances of this structure, one for each node that we want to use. Whenever we want to use a new node, we need to reserve memory for it. When we declare a variable of type <tt>node</tt>, we reserve memory for that variable at compile time, but we often organize computation around reserving memory at execution time, through calls on memory-management system operators. For example, the line of code
<div class="docText"><pre>link x = new node;</pre></div><br />
uses the <tt>new</tt> operator to reserve enough memory for a node and to return a pointer to it in <tt>x</tt>. In <a class="docLink" href="ch03lev1sec5.html#ch03lev1sec5">Section 3.5</a>, we shall briefly consider how the system goes about reserving memory, because it is a good application of linked lists!</p>
<p class="docText">It is standard practice in C++ to <span class="docEmphasis">initialize</span> storage, not just to <span class="docEmphasis">allocate</span> it. To this end, we typically will include a <span class="docEmphasis">constructor</span> with each <tt>struct</tt> that we define. A constructor is a function that is defined within a structure that shares the same name as the structure. We shall consider constructors in detail in <a class="docLink" href="ch04.html#ch04">Chapter 4</a>. Their purpose is to provide initial values for the data in the structure: To this end, they are automatically invoked when an instance of the structure is created. For example, if we define a list node with the code</p>
<div class="docText"><pre>struct node
  { Item item; node *next;
    node (Item x; node *t)
      { item = x; next = t; };
  };
typedef node *link;</pre></div><br />
<p class="docText">then the statement</p>
<div class="docText"><pre>link t = new node(x, t);</pre></div><br />
<p class="docText">not only reserves enough memory for a node and returns a pointer to it in <tt>t</tt>, but also sets the <tt>item</tt> field of the node to the value <tt>x</tt> and the pointer field to the value <tt>t</tt>. Constructors help us to avoid programming bugs associated with uninitialized data.</p>
<p class="docText">Now, once a list node is created, how do we refer to the information it comprises&mdash;its item and its link? We have already seen the basic operations that we need for this task: We simply dereference the pointer, then use the structure member names&mdash;the item in the node referenced by link <tt>x</tt> (which is of type <tt>Item</tt>) is <tt>(*x).item</tt> and the link (which is of type <tt>link</tt>) is <tt>(*x).link</tt>. These operations are so heavily used, however, that C++ provides the shorthand <tt>x-&gt;item</tt> and <tt>x-&gt;link</tt>, which are equivalent forms. Also, we so often need to use the phrase &quot;the node referenced by link <tt>x</tt>&quot; that we simply say &quot;node <tt>x</tt>&quot;&mdash;the link <span class="docEmphasis">does</span> name the node.</p>
<p class="docText">The correspondence between links and C++ pointers is essential, but we must bear in mind that the former is an abstraction and the latter a concrete representation. We can design algorithms that use nodes and links, and we can choose one of many possible implementations of that idea. For example, we can also represent links with array indices, as we shall see at the end of this section.</p>
<p class="docText"><a class="docLink" href="#ch03fig03">Figures 3.3</a> and <a class="docLink" href="#ch03fig04">3.4</a> show the two fundamental operations that we perform on linked lists. We can <span class="docEmphasis">remove</span> any item from a linked list, to make it shrink by 1 in length; and we can <span class="docEmphasis">insert</span> an item into a linked list at any point, to make it grow by 1 in length. For simplicity, we assume in these figures that the lists are circular and never become empty. We will consider null links, dummy nodes, and empty lists in <a class="docLink" href="ch03lev1sec4.html#ch03lev1sec4">Section 3.4</a>. As shown in the figures, insertion and deletion each require just two statements in C++. To remove the node following node <tt>x</tt>, we use the statements</p>
<div class="docText"><pre>t = x-&gt;next; x-&gt;next = t-&gt;next;</pre></div><br />
<p class="docText">or simply</p>
<div class="docText"><pre>x-&gt;next = x-&gt;next-&gt;next;</pre></div><br />
<a name="ch03fig03"></a><p><center>
<h5 class="docFigureTitle">Figure 3.3. Linked-list removal</h5>
<h5></h5><h5></h5></center></p><p class="docText">To remove the node following a given node <span class="docEmphasis">x</span> from a linked list, we set <span class="docEmphasis">t</span> to point to the node to be removed, then change <span class="docEmphasis">x</span>'s link to point to <span class="docEmphasis">t-&gt;next</span>. The pointer <span class="docEmphasis">t</span> can be used to refer to the removed node. Although its link still points into the list, we generally do not use such a link after removing the node from the list, except perhaps to inform the system, via <span class="docEmphasis">delete</span>, that its memory can be reclaimed.</p>
<p class="docText">
<img border="0" alt="" width="195" height="193" src="03fig03.gif" /></p>
</td></tr></table></p><br />
<a name="ch03fig04"></a><p><center>
<h5 class="docFigureTitle">Figure 3.4. Linked-list insertion</h5>
<h5></h5><h5></h5></center></p><p class="docText">To insert a given node <span class="docEmphasis">t</span> into a linked list at a position following another given node <span class="docEmphasis">x (top)</span>, we set <span class="docEmphasis">t-&gt;next</span> to <span class="docEmphasis">x-&gt;next (center)</span>, then set <span class="docEmphasis">x-&gt;next</span> to <span class="docEmphasis">t (bottom)</span>.</p>
<p class="docText">
<img border="0" alt="" width="185" height="387" src="03fig04.gif" /></p>
<br />
<p class="docText">To insert node <tt>t</tt> into a list at a position following node <tt>x</tt>, we use the statements</p>
<div class="docText"><pre>t-&gt;next = x-&gt;next; x-&gt;next = t;</pre></div><br />
<p class="docText">The simplicity of insertion and deletion is the <span class="docEmphasis">raison d'etre</span> of linked lists. The corresponding operations are unnatural and inconvenient in arrays, because they require moving all of the array's contents following the affected item.</p>
<p class="docText">By contrast, linked lists are <span class="docEmphasis">not</span> well suited for the <span class="docEmphasis">find the kth item</span> (find an item given its index) operation that characterizes efficient access in arrays. In an array, we find the <span class="docEmphasis">k</span>th item simply by accessing <tt>a[k]</tt>; in a list, we have to traverse <span class="docEmphasis">k</span> links. Another operation that is unnatural on singly linked lists is &quot;find the item <span class="docEmphasis">before</span> a given item.&quot;</p>
<p class="docText">When we remove a node from a linked list using <tt>x-&gt;next = x-&gt;next-&gt;next</tt>, we may never be able to access it again. For small programs such as the examples we consider at first, this is no special concern, but we generally regard it as good programming practice to use the <tt>delete</tt> operator, which is the counterpart to <tt>new</tt>, for any node that we no longer wish to use. Specifically, the sequence of instructions</p>
<div class="docText"><pre>t = x-&gt;next; x-&gt;next = t-&gt;next; delete t;</pre></div><br />
<p class="docText">not only removes <tt>t</tt> from our list but also informs the system that the memory it occupies may be used for some other purpose. We pay particular attention to <tt>delete</tt> when we have large list objects, or large numbers of them, but we will ignore it until <a class="docLink" href="ch03lev1sec5.html#ch03lev1sec5">Section 3.5</a>, so that we may focus on appreciating the benefits of linked structures.</p>
<p class="docText">We will see many examples of applications of these and other basic operations on linked lists in later chapters. Since the operations involve only a few statements, we often manipulate the lists directly rather than defining functions for inserting, deleting, and so forth. As an example, we consider next a program for solving the <span class="docEmphasis">Josephus problem</span> that provides an interesting contrast with the sieve of Eratosthenes.</p>
<a name="ch03ex11"></a><h5 id="title-IDAGN35F" class="docExampleTitle">Program 3.9. Circular list example (Josephus problem)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">To represent people arranged in a circle, we build a circular linked list, with a link from each person to the person on the left in the circle. The integer <span class="docEmphasis">i</span> represents the <span class="docEmphasis">i</span>th person in the circle. After building a one-node circular list for 1, we insert 2 through <span class="docEmphasis">N</span> after that node, resulting in a circle with 1 through <span class="docEmphasis">N</span>, leaving <span class="docEmphasis">x</span> pointing to <span class="docEmphasis">N</span>. Then, we skip <span class="docEmphasis">M</span> - 1 nodes, beginning with 1, and set the link of the (<span class="docEmphasis">M</span> - 1)st to skip the <span class="docEmphasis">M</span>th, continuing until only one node is left.</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
struct node
  { int item; node* next;
    node(int x, node* t)
      { item = x; next = t; }
  };
typedef node *link;
int main(int argc, char *argv[])
  { int i, N = atoi(argv[1]), M = atoi(argv[2]);
    link t = new node(1, 0); t-&gt;next = t;
    link x = t;
    for (i = 2; i &lt;= N; i++)
      x = (x-&gt;next = new node(i, t));
    while (x != x-&gt;next)
      {
        for (i = 1; i &lt; M; i++) x = x-&gt;next;
        x-&gt;next = x-&gt;next-&gt;next;
      }
    cout &lt;&lt; x-&gt;item &lt;&lt; endl;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">We imagine that <span class="docEmphasis">N</span> people have decided to elect a leader by arranging themselves in a circle and eliminating every <span class="docEmphasis">M</span>th person around the circle, closing ranks as each person drops out. The problem is to find out which person will be the last one remaining (a mathematically inclined potential leader will figure out ahead of time which position in the circle to take).</p>
<p class="docText">The identity of the elected leader is a function of <span class="docEmphasis">N</span> and <span class="docEmphasis">M</span> that we refer to as the <span class="docEmphasis">Josephus function</span>. More generally, we may wish to know the order in which the people are eliminated. For example, as shown in <a class="docLink" href="#ch03fig05">Figure 3.5</a>, if <span class="docEmphasis">N</span> = 9 and <span class="docEmphasis">M</span> = 5, the people are eliminated in the order 5 1 7 4 3 6 9 2, and 8 is the leader chosen. <a class="docLink" href="#ch03ex11">Program 3.9</a> reads in <span class="docEmphasis">N</span> and <span class="docEmphasis">M</span> and prints out this ordering.</p>
<a name="ch03fig05"></a><p><center>
<h5 class="docFigureTitle">Figure 3.5. Example of Josephus election</h5>
<h5></h5><h5></h5></center></p><p class="docText">This diagram shows the result of a Josephus-style election, where the group stands in a circle, then counts around the circle, eliminating every fifth person and closing the circle.</p>
<p class="docText">
<img border="0" alt="" width="85" height="552" src="03fig05.gif" /></p>
<br />
<p class="docText"><a class="docLink" href="#ch03ex11">Program 3.9</a> uses a <span class="docEmphasis">circular</span> linked list to simulate the election process directly. First, we build the list for 1 to <span class="docEmphasis">N</span>: We build a circular list consisting of a single node for person 1, then insert the nodes for people 2 through <span class="docEmphasis">N</span>, in that order, following that node in the list, using the insertion code illustrated in <a class="docLink" href="#ch03fig04">Figure 3.4</a>. Then, we proceed through the list, counting through <span class="docEmphasis">M</span> - 1 items, deleting the next one using the code illustrated in <a class="docLink" href="#ch03fig03">Figure 3.3</a>, and continuing until only one node is left (which then points to itself).</p>
<p class="docText">The sieve of Eratosthenes and the Josephus problem clearly illustrate the distinction between using arrays and using linked lists to represent a sequentially organized collection of objects. Using a linked list instead of an array for the sieve of Eratosthenes would be costly because the algorithm's efficiency depends on being able to access any array position quickly, and using an array instead of a linked list for the Josephus problem would be costly because the algorithm's efficiency depends on the ability to remove items quickly. When we choose a data structure, we <span class="docEmphasis">must</span> be aware of the effects of that choice upon the efficiency of the algorithms that will process the data. This interplay between data structures and algorithms is at the heart of the design process and is a recurring theme throughout this book.</p>
<p class="docText">In C++, pointers provide a direct and convenient concrete realization of the abstract concept of a linked list, but the essential value of the abstraction does not depend on any particular implementation. For example, <a class="docLink" href="#ch03fig06">Figure 3.6</a> shows how we could use arrays of integers to implement the linked list for the Josephus problem. That is, we can implement linked lists using array indices, instead of pointers. Linked lists were useful well before pointer constructs were available in high-level languages such as C++. Even in modern systems, array-based implementations are sometimes convenient.</p>
<a name="ch03fig06"></a><p><center>
<h5 class="docFigureTitle">Figure 3.6. Array representation of a linked list</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence shows the linked list for the Josephus problem (see <a class="docLink" href="#ch03fig05">Figure 3.5</a>), implemented with array indices instead of pointers. The index of the item following the item with index 0 in the list is <span class="docEmphasis"><tt>next[0]</tt></span>, and so forth. Initially (top three rows), the item for person <span class="docEmphasis"><tt>i</tt></span> has index <span class="docEmphasis"><tt>i-1</tt></span>, and we form a circular list by setting <span class="docEmphasis"><tt>next[i]</tt></span> to <span class="docEmphasis"><tt>i+1</tt></span> for <span class="docEmphasis"><tt>i</tt></span> from 0 to 8 and <span class="docEmphasis"><tt>next</tt></span>[8] to 0. To simulate the Josephus-election process, we change the links (<span class="docEmphasis"><tt>next</tt></span> array entries) but do not move the items. Each pair of lines shows the result of moving through the list four times with <span class="docEmphasis"><tt>x = next[x]</tt></span>, then deleting the fifth item (displayed at the left) by setting <span class="docEmphasis"><tt>next[x]</tt></span> to <span class="docEmphasis"><tt>next[next[x]]</tt></span>.</p>
<p class="docText">
<img border="0" alt="" width="200" height="379" src="03fig06.gif" /></p>
<br />
</td></tr></table>
<p class="docText">&nbsp;<a name="iddle1304"></a><a name="iddle1798"></a><a name="iddle1868"></a><a name="iddle1869"></a><a name="iddle2068"></a><a name="iddle1797"></a><a name="iddle1073"></a><a name="iddle1784"></a><a name="iddle1790"></a><a name="iddle1257"></a><a name="iddle1697"></a><a name="iddle1824"></a></p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa3q1"></a><b></b></td><td><p class="docText"><a name="iddle1071"></a><a name="iddle1074"></a><a name="iddle1437"></a><a name="iddle1520"></a><a name="iddle1633"></a><a name="iddle1785"></a><a name="iddle2356"></a><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">3.23</span> Write a function that returns the number of nodes on a circular list, given a pointer to one of the nodes on the list.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa3q2"></a><b></b></td><td><p class="docText"><a name="iddle1440"></a><a name="iddle1830"></a><a name="iddle2063"></a><span class="docEmphStrong">3.24</span> Write a code fragment that determines the number of nodes that are between the nodes referenced by two given pointers <tt>x</tt> and <tt>t</tt> to nodes on a circular list.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa3q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.25</span> Write a code fragment that, given pointers <tt>x</tt> and <tt>t</tt> to two disjoint circular lists, inserts the list pointed to by <tt>t</tt> into the list pointed to by <tt>x</tt>, at the point following <tt>x</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa3q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">3.26</span> Given pointers <tt>x</tt> and <tt>t</tt> to nodes on a circular list, write a code fragment that moves the node following <tt>t</tt> to the position following the node following <tt>x</tt> on the list.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa3q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.27</span> When building the list, <a class="docLink" href="#ch03ex11">Program 3.9</a> sets twice as many link values as it needs to because it maintains a circular list after each node is inserted. Modify the program to build the circular list without doing this extra work.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa3q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.28</span> Give the running time of <a class="docLink" href="#ch03ex11">Program 3.9</a>, within a constant factor, as a function of <span class="docEmphasis">M</span> and <span class="docEmphasis">N</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa3q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.29</span> Use <a class="docLink" href="#ch03ex11">Program 3.9</a> to determine the value of the Josephus function for <span class="docEmphasis">M</span>= 2, 3, 5, 10, and <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa3q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.30</span> Use <a class="docLink" href="#ch03ex11">Program 3.9</a> to plot the Josephus function versus <span class="docEmphasis">N</span> for <span class="docEmphasis">M</span> = 10 and <span class="docEmphasis">N</span> from 2 to 1000.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa3q9"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">3.31</span> Redo the table in <a class="docLink" href="#ch03fig06">Figure 3.6</a>, beginning with item <tt>i</tt> initially at position <tt>N-i</tt> in the array.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa3q10"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.32</span> Develop a version of <a class="docLink" href="#ch03ex11">Program 3.9</a> that uses an array of indices to implement the linked list (see <a class="docLink" href="#ch03fig06">Figure 3.6</a>).</p></td></tr></table></p>
<ul></ul></div></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch03lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table><!--IP User 2--></td></body></head></html>