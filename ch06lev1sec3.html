<html><head><title>6.3. Insertion Sort</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch06lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch06lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch06lev1sec3"></a>
<h3 id="title-IDAK1FVM" class="docSection1Title">6.3. Insertion Sort</h3>
<p class="docText">The method that people often use to sort bridge hands is to consider the elements one at a time, inserting each into its proper place among those already considered (keeping them sorted). In a computer implementation, we need to make space for the element being inserted by moving larger elements one position to the right, and then inserting the element into the vacated position. The <tt>sort</tt> function in <a class="docLink" href="ch06lev1sec1.html#ch06ex01">Program 6.1</a> is an implementation of this method, which is called <span class="docEmphasis">insertion sort</span>.</p>
<p class="docText">As in selection sort, the elements to the left of the current index are in sorted order during the sort, but they are not in their final <a name="iddle1025"></a><a name="iddle1654"></a><a name="iddle1718"></a><a name="iddle1838"></a><a name="iddle2336"></a><a name="iddle2369"></a>position, as they may have to be moved to make room for smaller elements encountered later. The array is, however, fully sorted when the index reaches the right end. <a class="docLink" href="#ch06fig03">Figure 6.3</a> shows the method in operation on a sample file.</p>
<a name="ch06fig03"></a><p><center>
<h5 class="docFigureTitle">Figure 6.3. Insertion sort example</h5>
<h5></h5><h5></h5></center></p><p class="docText">During the first pass of insertion sort, the <span class="docEmphasis">S</span> in the second position is larger than the A, so it does not have to be moved. On the second pass, when the <span class="docEmphasis">O</span> in the third position is encountered, it is exchanged with the <span class="docEmphasis">S</span> to put <span class="docEmphasis">A O S</span> in sorted order, and so forth. Unshaded elements that are not circled are those that were moved one position to the right.</p>
<p class="docText">
<img border="0" alt="" width="200" height="207" src="06fig03.gif" /></p>
<br />
<p class="docText">The implementation of insertion sort in <a class="docLink" href="ch06lev1sec1.html#ch06ex01">Program 6.1</a> is straightforward, but inefficient. We shall now consider three ways to improve it, to illustrate a recurrent theme throughout many of our implementations: We want code to be succinct, clear, and efficient, but these goals sometimes conflict, so we must often strike a balance. We do so by developing a natural implementation, then seeking to improve it by a sequence of transformations, checking the effectiveness (and correctness) of each transformation.</p>
<p class="docText">First, we can stop doing <tt>compexch</tt> operations when we encounter a key that is not larger than the key in the item being inserted, because the subarray to the left is sorted. Specifically, we can <tt>break</tt> out of the inner <tt>for</tt> loop in <tt>sort</tt> in <a class="docLink" href="ch06lev1sec1.html#ch06ex01">Program 6.1</a> when the condition <tt>a[j-1] &lt; a[j]</tt> is true. This modification changes the implementation into an adaptive sort, and speeds up the program by about a factor of 2 for randomly ordered keys (see <a class="docLink" href="ch06lev1sec5.html#ch06ex07">Property 6.2</a>).</p>
<p class="docText">With the improvement described in the previous paragraph, we have two conditions that terminate the inner loop&mdash;we could recode it as a <tt>while</tt> loop to reflect that fact explicitly. A more subtle improvement of the implementation follows from noting that the test <tt>j&gt;l</tt> is usually extraneous: indeed, it succeeds <span class="docEmphasis">only</span> when the element inserted is the smallest seen so far and reaches the beginning of the array. A commonly used alternative is to keep the keys to be sorted in <tt>a[1]</tt> to <tt>a[N]</tt>, and to put a <span class="docEmphasis">sentinel key</span> in <tt>a[0]</tt>, making it at least as small as the smallest key in the array. Then, the test whether a smaller key has been encountered simultaneously tests both conditions of interest, making the inner loop smaller and the program faster.</p>
<p class="docText">Sentinels are sometimes inconvenient to use: perhaps the smallest possible key is not easily defined, or perhaps the calling routine has no room to include an extra key. <a class="docLink" href="#ch06ex04">Program 6.3</a> illustrates one way around these two problems for insertion sort: We make an explicit first pass over the array that puts the item with the smallest key in the first position. Then, we sort the rest of the array, with that first and smallest item now serving as sentinel. We generally shall avoid sentinels in our code, because it is often easier to understand code with explicit tests, but we shall note situations where sentinels might be useful in making programs both simpler and more efficient.</p>
<a name="ch06ex04"></a><h5 id="title-IDABZFWD" class="docExampleTitle">Program 6.3. Insertion sort</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This code is an improvement over the implementation of <tt>sort</tt> in <a class="docLink" href="ch06lev1sec1.html#ch06ex01">Program 6.1</a> because (<span class="docEmphasis">i</span>) it first puts the smallest element in the array into the first position, so that that element can serve as a sentinel; (<span class="docEmphasis">ii</span>) it does a single assignment, rather than an exchange, in the inner loop; and (<span class="docEmphasis">iii</span>) it terminates the inner loop when the element being inserted is in position. For each <span class="docEmphasis">i</span>, it sorts the elements <tt>a[l]</tt>, <tt>. . .</tt>, <tt>a[i]</tt> by moving one position to the right elements in the sorted list <tt>a[l]</tt>, <tt>. . .</tt>, <tt>a[i-1]</tt> that are larger than <tt>a[i]</tt>, then putting <tt>a[i]</tt> into its proper position.</p>
<div class="docText"><pre>template &lt;class Item&gt;
void insertion(Item a[], int l, int r)
  { int i;
    for (i = r; i &gt; l; i--) compexch(a[i-1], a[i]);
    for (i = l+2; i &lt;= r; i++)
      { int j = i; Item v = a[i];
        while (v &lt; a[j-1])
          { a[j] = a[j-1]; j--; }
        a[j] = v;
      }
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">The third improvement that we shall consider also involves removing extraneous instructions from the inner loop. It follows from noting that successive exchanges involving the same element are inefficient. If there are two or more exchanges, we have</p>
<div class="docText"><pre>t = a[j]; a[j] = a[j-1]; a[j-1] = t;</pre></div><br />
<p class="docText">followed by</p>
<div class="docText"><pre>t = a[j-1]; a[j-1] = a[j-2]; a[j-2] = t;</pre></div><br />
<p class="docText">and so forth. The value of <tt>t</tt> does not change between these two sequences, and we waste time storing it, then reloading it for the next exchange. <a class="docLink" href="#ch06ex04">Program 6.3</a> moves larger elements one position to the right instead of using exchanges, and thus avoids wasting time in this way.</p>
<p class="docText"><a class="docLink" href="#ch06ex04">Program 6.3</a> is an implementation of insertion sort that is more efficient than the one given in <a class="docLink" href="ch06lev1sec1.html#ch06ex01">Program 6.1</a> (in <a class="docLink" href="ch06lev1sec5.html#ch06lev1sec5">Section 6.5</a>, we shall see that it is nearly twice as fast). In this book, we are interested <span class="docEmphasis">both</span> <a name="iddle1242"></a><a name="iddle1971"></a><a name="iddle2370"></a><a name="iddle2376"></a>in elegant and efficient algorithms <span class="docEmphasis">and</span> in elegant and efficient implementations of them. In this case, the underlying algorithms do differ slightly&mdash;we should properly refer to the <tt>sort</tt> function in <a class="docLink" href="ch06lev1sec1.html#ch06ex01">Program 6.1</a> as a <span class="docEmphasis">nonadaptive insertion sort</span>. A good understanding of the properties of an algorithm is the best guide to developing an implementation that can be used effectively in an application.</p>
<p class="docText">Unlike that of selection sort, the running time of insertion sort primarily depends on the initial order of the keys in the input. For example, if the file is large and the keys are already in order (or even are nearly in order), then insertion sort is quick and selection sort is slow. We compare the algorithms in more detail in <a class="docLink" href="ch06lev1sec5.html#ch06lev1sec5">Section 6.5</a>.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa3q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">6.15</span> Show, in the style of <a class="docLink" href="#ch06fig03">Figure 6.3</a>, how insertion sort sorts the sample file E A S Y Q U E S T I O N.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa3q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.16</span> Give an implementation of insertion sort with the inner loop coded as a <tt>while</tt> loop that terminates on one of two conditions, as described in the text.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa3q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.17</span> For each of the conditions in the <tt>while</tt> loop in <a class="docLink" href="#ch06qa3q2">Exercise 6.16</a>, describe a file of <span class="docEmphasis">N</span> elements where that condition is always false when the loop terminates.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa3q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">6.18</span> Is insertion sort stable?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa3q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.19</span> Give a nonadaptive implementation of selection sort based on finding the minimum element with code like the first <tt>for</tt> loop in <a class="docLink" href="#ch06ex04">Program 6.3</a>.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch06lev1sec2.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch06lev1sec4.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>