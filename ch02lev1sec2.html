<html><head><title>2.2. Analysis of Algorithms</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch02lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch02lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch02lev1sec2"></a>
<h3 id="title-IDAUWAG" class="docSection1Title">2.2. Analysis of Algorithms</h3>
<p class="docText">In this section, we outline the framework within which mathematical analysis can play a role in the process of comparing the performance of algorithms, to lay a foundation for us to be able to consider basic analytic results as they apply to the fundamental algorithms that we consider throughout the book. We shall consider the basic mathematical tools that are used in the analysis of algorithms, both to allow us to study classical analyses of fundamental algorithms and to make use of results from the research literature that help us understand the performance characteristics of our algorithms.</p>
<p class="docText">The following are among the reasons that we perform mathematical analysis of algorithms:</p>
<ul><li><p class="docList">To compare different algorithms for the same task</p></li><li><p class="docList">To predict performance in a new environment</p></li><li><p class="docList">To set values of algorithm parameters</p></li></ul>
<p class="docText">We shall see many examples of each of these reasons throughout the book. Empirical analysis might suffice for some of these tasks, but mathematical analysis can be more informative (and less expensive!), as we shall see.</p>
<p class="docText">The analysis of algorithms can be challenging indeed. Some of the algorithms in this book are well understood, to the point that accurate mathematical formulas are known that can be used to predict running time in practical situations. People develop such formulas by carefully studying the program, to find the running time in terms of fundamental <a name="iddle1036"></a><a name="iddle1057"></a><a name="iddle2289"></a>mathematical quantities, and then doing a mathematical analysis of the quantities involved. On the other hand, the performance properties of other algorithms in this book are not fully understood&mdash;perhaps their analysis leads to unsolved mathematical questions, or perhaps known implementations are too complex for a detailed analysis to be reasonable, or (most likely) perhaps the types of input that they encounter cannot be characterized accurately.</p>
<p class="docText">Several important factors in a precise analysis are usually outside a given programmer's domain of influence. First, C++ programs are translated into machine code for a given computer, and it can be a challenging task to figure out exactly how long even one C++ statement might take to execute (especially in an environment where resources are being shared, so even the same program can have varying performance characteristics at two different times). Second, many programs are extremely sensitive to their input data, and performance might fluctuate wildly depending on the input. Third, many programs of interest are not well understood, and specific mathematical results may not be available. Finally, two programs might not be comparable at all: one may run much more efficiently on one particular kind of input, the other runs efficiently under other circumstances.</p>
<p class="docText">All these factors notwithstanding, it is often possible to predict precisely how long a particular program will take, or to know that one program will do better than another in particular situations. Moreover, we can often acquire such knowledge by using one of a relatively small set of mathematical tools. It is the task of the algorithm analyst to discover as much information as possible about the performance of algorithms; it is the task of the programmer to apply such information in selecting algorithms for particular applications. In this and the next several sections, we concentrate on the idealized world of the analyst. To make effective use of our best algorithms, we need to be able to step into this world, on occasion.</p>
<p class="docText">The first step in the analysis of an algorithm is to identify the abstract operations on which the algorithm is based, to separate the analysis from the implementation. Thus, for example, we separate the study of how many times one of our <span class="docEmphasis">union</span>-<span class="docEmphasis">find</span> implementations executes the code fragment <tt>i = a[i]</tt> from the analysis of how many nanoseconds might be required to execute that particular code fragment on our computer. We need both these elements to determine <a name="iddle1037"></a><a name="iddle1103"></a><a name="iddle1317"></a><a name="iddle1318"></a><a name="iddle2053"></a><a name="iddle2217"></a><a name="iddle2625"></a>the actual running time of the program on a particular computer. The former is determined by properties of the algorithm; the latter by properties of the computer. This separation often allows us to compare algorithms in a way that is independent of particular implementations or of particular computers.</p>
<p class="docText">Although the number of abstract operations involved can be large, in principle, the performance of an algorithm typically depends on only a few quantities, and typically the most important quantities to analyze are easy to identify. One way to identify them is to use a profiling mechanism (a mechanism available in many C++ implementations that gives instruction-frequency counts) to determine the most frequently executed parts of the program for some sample runs. Or, like the union-find algorithms of <a class="docLink" href="ch01lev1sec3.html#ch01lev1sec3">Section 1.3</a>, our implementation might be built on a few abstract operations. In either case, the analysis amounts to determining the frequency of execution of a few fundamental operations. Our modus operandi will be to look for rough estimates of these quantities, secure in the knowledge that we can undertake a fuller analysis for important programs when necessary. Moreover, as we shall see, we can often use approximate analytic results in conjunction with empirical studies to predict performance accurately.</p>
<p class="docText">We also have to study the data, and to model the input that might be presented to the algorithm. Most often, we consider one of two approaches to the analysis: we either assume that the input is random, and study the <span class="docEmphasis">average-case</span> performance of the program, or we look for perverse input, and study the <span class="docEmphasis">worst-case</span> performance of the program. The process of characterizing random inputs is difficult for many algorithms, but for many other algorithms it is straightforward and leads to analytic results that provide useful information. The average case might be a mathematical fiction that is not representative of the data on which the program is being used, and the worst case might be a bizarre construction that would never occur in practice, but these analyses give useful information on performance in most cases. For example, we can test analytic results against empirical results (see <a class="docLink" href="ch02lev1sec1.html#ch02lev1sec1">Section 2.1</a>). If they match, we have increased confidence in both; if they do not match, we can learn about the algorithm and the model by studying the discrepancies.</p>
<p class="docText"><a name="iddle1050"></a><a name="iddle2025"></a><a name="iddle2094"></a>In the next three sections, we briefly survey the mathematical tools that we shall be using throughout the book. This material is outside our primary narrative thrust, and readers with a strong background in mathematics or readers who are not planning to check our mathematical statements on the performance of algorithms in detail may wish to skip to <a class="docLink" href="ch02lev1sec6.html#ch02lev1sec6">Section 2.6</a> and to refer back to this material when warranted later in the book. The mathematical underpinnings that we consider, however, are generally not difficult to comprehend, and they are too close to core issues of algorithm design to be ignored by anyone wishing to use a computer effectively.</p>
<p class="docText">First, in <a class="docLink" href="ch02lev1sec3.html#ch02lev1sec3">Section 2.3</a>, we consider the mathematical functions that we commonly need to describe the performance characteristics of algorithms. Next, in <a class="docLink" href="ch02lev1sec4.html#ch02lev1sec4">Section 2.4</a>, we consider the <span class="docEmphasis">O-notation</span>, and the notion of <span class="docEmphasis">is proportional to</span>, which allow us to suppress detail in our mathematical analyses. Then, in <a class="docLink" href="ch02lev1sec5.html#ch02lev1sec5">Section 2.5</a>, we consider <span class="docEmphasis">recurrence relations</span>, the basic analytic tool that we use to capture the performance characteristics of an algorithm in a mathematical equation. Following this survey, we consider examples where we use the basic tools to analyze specific algorithms, in <a class="docLink" href="ch02lev1sec6.html#ch02lev1sec6">Section 2.6</a>.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa2q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">2.3</span> Develop an expression of the form <span class="docEmphasis">c</span><sub>0</sub> <span class="docEmphasis">+ c</span><sub>1</sub><span class="docEmphasis">N + c</span><sub>2</sub><span class="docEmphasis">N</span><sup>2</sup> <span class="docEmphasis">+ c</span><sub>3</sub><span class="docEmphasis">N</span><sup>3</sup> that accurately describes the running time of your program from <a class="docLink" href="ch02lev1sec1.html#ch02qa1q2">Exercise 2.2</a>. Compare the times predicted by this expression with actual times, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10, 100</tt>, and <tt>1000</tt>.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch02qa2q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">2.4</span> Develop an expression that accurately describes the running time of <a class="docLink" href="ch01lev1sec3.html#ch01ex01">Program 1.1</a> in terms of <span class="docEmphasis">M</span> and <span class="docEmphasis">N</span>.</p></td></tr></table></p>
<a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch02lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch02lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>