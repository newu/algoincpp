<html><head><title>4.6. FIFO Queues and Generalized Queues</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch04lev1sec5.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch04lev1sec7.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch04lev1sec6"></a>
<h3 id="title-IDAAKF0D" class="docSection1Title">4.6. FIFO Queues and Generalized Queues</h3>
<p class="docText">The <span class="docEmphasis">first-in, first-out (FIFO) queue</span> is another fundamental ADT that is similar to the pushdown stack, but that uses the opposite rule to decide which element to remove for <span class="docEmphasis">remove</span>. Rather than removing the most recently inserted element, we remove the element that has been in the queue the longest.</p>
<p class="docText">Perhaps our busy professor's &quot;in&quot; box <span class="docEmphasis">should</span> operate like a FIFO queue, since the first-in, first-out order seems to be an intuitively fair way to decide what to do next. However, that professor might not ever answer the phone or get to class on time! In a stack, a memorandum can get buried at the bottom, but emergencies are handled when they arise; in a FIFO queue, we work methodically through the tasks, but each has to wait its turn.</p>
<a name="ch04ex16"></a><h5 id="title-IDA3KF0D" class="docExampleTitle">Program 4.13. FIFO queue ADT interface</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This interface is identical to the pushdown stack interface of <a class="docLink" href="ch04lev1sec2.html#ch04ex06">Program 4.4</a>, except for the names of the functions. The two ADTs differ only in the specification, which is not reflected in the interface code.</p>
<div class="docText"><pre>template &lt;class Item&gt;
class QUEUE
  {
    private:
      // Implementation-dependent code
    public:
      QUEUE(int);
      int empty();
      void put(Item);
      Item get();
  };</pre></div><br />
</td></tr></table></p>
<p class="docText">FIFO queues are abundant in everyday life. When we wait in line to see a movie or to buy groceries, we are being processed according to a FIFO discipline. Similarly, FIFO queues are frequently used within computer systems to hold tasks that are yet to be accomplished when we want to provide services on a first-come, first-served basis. Another example, which illustrates the distinction between stacks and FIFO queues, is a grocery store's inventory of a perishable product. If the grocer puts new items on the front of the shelf and customers take items from the front, then we have a stack discipline, which is a problem for the grocer because items at the back of the shelf may stay there for a very long time and therefore spoil. By putting new items at the back of the shelf, the grocer ensures that the length of time any item has to stay on the shelf is limited by the length of time it takes customers to purchase the maximum number of items that fit on the shelf. This same basic principle applies to numerous similar situations.</p>
<p class="docText"></p><a name="ch04ex17"></a><h5 id="title-IDADMF0D" class="docExampleTitle">Definition 4.3. A <span class="docEmphStrong">FIFO queue</span> is an ADT that comprises two basic operations: insert (<span class="docEmphStrong">put</span>) a new item, and remove (<span class="docEmphStrong">get</span>) the item that was least recently inserted</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1088"></a><a name="iddle1481"></a><a name="iddle1485"></a><a name="iddle1487"></a><a name="iddle1806"></a><a name="iddle2067"></a><a class="docLink" href="#ch04ex16">Program 4.13</a> is the interface for a FIFO queue ADT. This interface differs from the stack interface that we considered in <a class="docLink" href="ch04lev1sec2.html#ch04lev1sec2">Section 4.2</a> only in the nomenclature: to a compiler, say, the two interfaces are identical! This observation underscores the fact that the abstraction itself, which programmers normally do not define formally, is the essential component of an ADT. For large applications, which may involve scores of ADTs, the problem of defining them precisely is critical. In this book, we work with ADTs that capture essential concepts that we define in the text, but not in any formal language, other than via specific implementations. To discern the nature of ADTs, we need to consider examples of their use and to examine specific implementations.</p>
<p class="docText"><a class="docLink" href="#ch04fig06">Figure 4.6</a> shows how a sample FIFO queue evolves through a series of <span class="docEmphasis">get</span> and <span class="docEmphasis">put</span> operations. Each <span class="docEmphasis">get</span> decreases the size of the queue by 1 and each <span class="docEmphasis">put</span> increases the size of the queue by 1. In the figure, the items in the queue are listed in the order that they are put on the queue, so that it is clear that the first item in the list is the one that is to be returned by the <span class="docEmphasis">get</span> operation. Again, in an implementation, we are free to organize the items any way that we want, as long as we maintain the illusion that the items are organized in this way.</p>
<a name="ch04fig06"></a><p><center>
<h5 class="docFigureTitle">Figure 4.6. FIFO queue example</h5>
<h5></h5><h5></h5></center></p><p class="docText">This list shows the result of the sequence of operations in the left column (top to bottom), where a letter denotes put and an asterisk denotes get. Each line displays the operation, the letter returned for get operations, and the contents of the queue in order from least recently inserted to most recently inserted, left to right.</p>
<p class="docText">
<img border="0" alt="" width="110" height="383" src="04fig06.gif" /></p>
</td></tr></table></p><br />
<p class="docText">To implement the FIFO queue ADT using a linked list, we keep the items in the list in order from least recently inserted to most recently inserted, as diagrammed in <a class="docLink" href="#ch04fig06">Figure 4.6</a>. This order is the reverse of the order that we used for the stack implementation, but allows us to develop efficient implementations of the queue operations. We maintain two pointers into the list: one to the beginning (so that we can <span class="docEmphasis">get</span> the first element), and one to the end (so that we can <span class="docEmphasis">put</span> a new element onto the queue), as shown in <a class="docLink" href="#ch04fig07">Figure 4.7</a> and in the implementation in <a class="docLink" href="#ch04ex18">Program 4.14</a>.</p>
<a name="ch04fig07"></a><p><center>
<h5 class="docFigureTitle">Figure 4.7. Linked-list queue</h5>
<h5></h5><h5></h5></center></p><p class="docText">In this linked-list representation of a queue, we insert new items at the end, so the items in the linked list are in order from least recently inserted to most recently inserted, from beginning to end. The queue is represented by two pointers <span class="docEmphasis">head</span> and <span class="docEmphasis">tail</span> which point to the first and final item, respectively. To get an item from the queue, we remove the item at the front of the list, in the same way as we did for stacks (see <a class="docLink" href="ch04lev1sec4.html#ch04fig05">Figure 4.5</a>). To put a new item onto the queue, we set the link field of the node referenced by <span class="docEmphasis">tail</span> to point to it <span class="docEmphasis">(center)</span>, then update <span class="docEmphasis">tail</span> <span class="docEmphasis">(bottom)</span>.</p>
<p class="docText">
<img border="0" alt="" width="200" height="338" src="04fig07.gif" /></p>
<br />
<p class="docText">We can also use an array to implement a FIFO queue, although we have to exercise care to keep the running time constant for both the <span class="docEmphasis">put</span> and <span class="docEmphasis">get</span> operations. That performance goal dictates that we can not move the elements of the queue within the array, unlike what might be suggested by a literal interpretation of <a class="docLink" href="#ch04fig06">Figure 4.6</a>. Accordingly, as we did with the linked-list implementation, we maintain two indices into the array: one to the beginning of the queue and one to the end of the queue. We consider the contents of the queue to be the elements between the indices. To <span class="docEmphasis">get</span> an element, we remove it from the beginning (head) of the queue and increment the head index; to <span class="docEmphasis">put</span> an element, we add it to the end (tail) of the queue and increment the tail index. A sequence of <span class="docEmphasis">put</span> and <span class="docEmphasis">get</span> operations causes the queue to appear to move through the array, as illustrated in <a class="docLink" href="#ch04fig08">Figure 4.8</a>. When it hits the end of the array, we arrange for it to wrap around to the beginning. The details of this computation are in the code in <a class="docLink" href="#ch04ex20">Program 4.15</a>.</p>
<a name="ch04fig08"></a><p><center>
<h5 class="docFigureTitle">Figure 4.8. FIFO queue example, array implementation</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence shows the data manipulation underlying the abstract representation in <a class="docLink" href="#ch04fig06">Figure 4.6</a> when we implement the queue by storing the items in an array, keeping indices to the beginning and end of the queue, and wrapping the indices back to the beginning of the array when they reach the end of the array. In this example, the tail index wraps back to the beginning when the second <span class="docEmphasis">T</span> is inserted, and the head index wraps when the second <span class="docEmphasis">S</span> is removed.</p>
<p class="docText">
<img border="0" alt="" width="200" height="409" src="04fig08.gif" /></p>
<br />
<a name="ch04ex18"></a><h5 id="title-IDAEVF0D" class="docExampleTitle">Program 4.14. FIFO queue linked-list implementation</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The difference between a FIFO queue and a pushdown stack (<a class="docLink" href="ch04lev1sec4.html#ch04ex10">Program 4.8</a>) is that new items are inserted at the end, rather than the beginning. Accordingly, this class keeps a pointer <tt>tail</tt> to the last node of the list, so that the function <tt>put</tt> can add a new node by linking that node to the node referenced by <tt>tail</tt> and then updating <tt>tail</tt> to point to the new node. The functions <tt>QUEUE</tt>, <tt>get</tt>, and <tt>empty</tt> are all identical to their counterparts for the linked-list pushdown-stack implementation of <a class="docLink" href="ch04lev1sec4.html#ch04ex10">Program 4.8</a>. Since new nodes are always inserted at the end of the list, the node constructor can set the pointer field of each new node to be null and needs to have only one argument.</p>
<div class="docText"><pre>template &lt;class Item&gt;
class QUEUE
  {
    private:
      struct node
        { Item item; node* next;
          node(Item x)
            { item = x; next = 0; }
        };
          typedef node *link;
          link head, tail;
    public:
      QUEUE(int)
        { head = 0; }
      int empty() const
        { return head == 0; }
      void put(Item x)
        { link t = tail;
          tail = new node(x);
          if (head == 0)
               head = tail;
          else t-&gt;next = tail;
        }
      Item get()
        { Item v = head-&gt;item; link t = head-&gt;next;
          delete head; head = t; return v; }
  };</pre></div><br />
</td></tr></table></p>
</td></tr></table>
<p class="docText">&nbsp;<a name="iddle1488"></a><a name="iddle1807"></a><a name="iddle2137"></a></p>
<p class="docText"></p><a name="ch04ex19"></a><h5 id="title-IDAZXF0D" class="docExampleTitle">Property 4.2. <span class="docEmphasis">We can implement the</span> <span class="docEmphStrong">get</span> <span class="docEmphasis">and</span> <span class="docEmphStrong">put</span> <span class="docEmphasis">operations for the FIFO queue ADT in constant time, using either arrays or linked lists</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1486"></a><a name="iddle1489"></a><a name="iddle1866"></a>This fact is immediately clear when we inspect the code in <a class="docLink" href="#ch04ex18">Programs 4.14</a> and <a class="docLink" href="#ch04ex20">4.15</a>.</p>
</td></tr></table></p>
<p class="docText">The same considerations that we discussed in <a class="docLink" href="ch04lev1sec4.html#ch04lev1sec4">Section 4.4</a> apply to space resources used by FIFO queues. The array representation requires that we reserve enough space for the maximum number of items expected throughout the computation, whereas the linked-list representation uses space proportional to the number of elements in the data structure, at the cost of extra space for the links and extra time to allocate and deallocate memory for each operation.</p>
<p class="docText">Although we encounter stacks more often than we encounter FIFO queues, because of the fundamental relationship between stacks and recursive programs (see <a class="docLink" href="ch05.html#ch05">Chapter 5</a>), we shall also encounter algorithms for which the queue is the natural underlying data structure. As we have already noted, one of the most frequent uses of queues and stacks in computational applications is to postpone computation. Although many applications that involve a queue of pending work operate correctly no matter what rule is used for <span class="docEmphasis">remove</span>, the overall running time or other resource usage may be dependent on the rule. When such applications involve a large number of <span class="docEmphasis">insert</span> and <span class="docEmphasis">remove</span> operations on data structures with a large number of items on them, performance differences are paramount. Accordingly, we devote a great deal of attention in this book to such ADTs. If we ignored performance, we could formulate a single ADT that encompassed <span class="docEmphasis">insert</span> and <span class="docEmphasis">remove</span>; since we do not ignore performance, each rule, in essence, constitutes a different ADT. To evaluate the effectiveness of a particular ADT, we need to consider two costs: the implementation cost, <a name="iddle1089"></a><a name="iddle1482"></a><a name="iddle1541"></a><a name="iddle2156"></a>which depends on our choice of algorithm and data structure for the implementation; and the cost of the particular decision-making rule in terms of effect on the performance of the client. To conclude this section, we will describe a number of such ADTs, which we will be considering in detail throughout the book.</p>
<a name="ch04ex20"></a><h5 id="title-IDA11F0D" class="docExampleTitle">Program 4.15. FIFO queue array implementation</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The contents of the queue are all the elements in the array between <tt>head</tt> and <tt>tail</tt>, taking into account the wraparound back to 0 when the end of the array is encountered. If <tt>head</tt> and <tt>tail</tt> are equal, then we consider the queue to be empty; but if <tt>put</tt> would make them equal, then we consider it to be full. As usual, we do not check such error conditions, but we make the size of the array 1 greater than the maximum number of elements that the client expects to see in the queue, so that we could augment this program to make such checks.</p>
<div class="docText"><pre>template &lt;class Item&gt;
class QUEUE
  {
    private:
      Item *q; int N, head, tail;
    public:
      QUEUE(int maxN)
        { q = new Item[maxN+1];
          N = maxN+1; head = N; tail = 0; }
        int empty() const
          { return head % N == tail; }
        void put(Item item)
          { q[tail++] = item; tail = tail % N; }
        Item get()
          { head = head % N; return q[head++]; }
  };</pre></div><br />
</td></tr></table></p>
<p class="docText">Specifically, pushdown stacks and FIFO queues are special instances of a more general ADT: the <span class="docEmphasis">generalized queue</span>. Instances of generalized queues differ in only the rule used when items are removed. For stacks, the rule is &quot;remove the item that was most recently inserted&quot;; for FIFO queues, the rule is &quot;remove the item that was least recently inserted&quot;; and there are many other possibilities.</p>
<p class="docText"><a name="iddle1096"></a><a name="iddle1350"></a><a name="iddle1799"></a><a name="iddle2097"></a><a name="iddle2150"></a><a name="iddle2159"></a><a name="iddle2219"></a>A simple but powerful alternative is the <span class="docEmphasis">random queue</span>, where the rule is to &quot;remove a random item,&quot; and the client can expect to get any of the items on the queue with equal probability. We can implement the operations of a random queue in constant time using an array representation (see <a class="docLink" href="#ch04qa7q13">Exercise 4.48</a>). As do stacks and FIFO queues, the array representation requires that we reserve space ahead of time. The linked-list alternative is less attractive than it was for stacks and FIFO queues, however, because implementing both insertion and deletion efficiently is a challenging task (see <a class="docLink" href="#ch04qa7q14">Exercise 4.49</a>). We can use random queues as the basis for randomized algorithms, to avoid, with high probability, worst-case performance scenarios (see <a class="docLink" href="ch02lev1sec7.html#ch02lev1sec7">Section 2.7</a>).</p>
<p class="docText">We have described stacks and FIFO queues by identifying items according to the time that they were inserted into the queue. Alternatively, we can describe these abstract concepts in terms of a sequential listing of the items in order, and refer to the basic operations of inserting and deleting items from the beginning and the end of the list. If we insert at the end and remove at the end, we get a stack (precisely as in our array implementation); if we insert at the beginning and remove at the beginning, we also get a stack (precisely as in our linked-list implementation); if we insert at the end and remove at the beginning, we get a FIFO queue (precisely as in our linked-list implementation); and if we insert at the beginning and remove at the end, we also get a FIFO queue (this option does not correspond to any of our implementations&mdash;we could switch our array implementation to implement it precisely, but the linked-list implementation is not suitable because of the need to back up the pointer to the end when we remove the item at the end of the list). Building on this point of view, we are led to the <span class="docEmphasis">deque</span> ADT, where we allow either insertion or deletion at either end. We leave the implementations for exercises (see <a class="docLink" href="#ch04qa7q8">Exercises 4.43</a> through <a class="docLink" href="#ch04qa7q12">4.47</a>), noting that the array-based implementation is a straightforward extension of <a class="docLink" href="#ch04ex20">Program 4.15</a>, and that the linked-list implementation requires a doubly linked list, unless we restrict the deque to allow deletion at only one end.</p>
<p class="docText">In <a class="docLink" href="ch09.html#ch09">Chapter 9</a>, we consider <span class="docEmphasis">priority queues</span>, where the items have keys and the rule for deletion is &quot;remove the item with the smallest key.&quot; The priority-queue ADT is useful in a variety of applications, and the problem of finding efficient implementations for this ADT has been a research goal in computer science for many years. Identifying <a name="iddle2475"></a>and using the ADT in applications has been an important factor in this research: we can get an immediate indication whether or not a new algorithm is correct by substituting its implementation for an old implementation in a huge, complex application and checking that we get the same result. Moreover, we get an immediate indication whether a new algorithm is more efficient than an old one by noting the extent to which substituting the new implementation improves the overall running time. The data structures and algorithms that we consider in <a class="docLink" href="ch09.html#ch09">Chapter 9</a> for solving this problem are interesting, ingenious, and effective.</p>
<p class="docText">In <a class="docLink" href="ch12.html#ch12">Chapters 12</a> through <a class="docLink" href="ch16.html#ch16">16</a>, we consider <span class="docEmphasis">symbol tables</span>, which are generalized queues where the items have keys and the rule for deletion is &quot;remove an item whose key is equal to a given key, if there is one.&quot; This ADT is perhaps the most important one that we consider, and we shall examine dozens of implementations.</p>
<p class="docText">Each of these ADTs also give rise to a number of related, but different, ADTs that suggest themselves as an outgrowth of careful examination of client programs and the performance of implementations. In <a class="docLink" href="ch04lev1sec7.html#ch04lev1sec7">Sections 4.7</a> and <a class="docLink" href="ch04lev1sec8.html#ch04lev1sec8">4.8</a>, we consider numerous examples of changes in the specification of generalized queues that lead to yet more different ADTs, which we shall consider later in this book.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">4.36</span> Give the contents of <tt>q[0], ..., q[4]</tt> after the execution of the operations illustrated in <a class="docLink" href="#ch04fig06">Figure 4.6</a>, using <a class="docLink" href="#ch04ex20">Program 4.15</a>. Assume that <tt>maxN</tt> is 10, as in <a class="docLink" href="#ch04fig08">Figure 4.8</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">4.37</span> A letter means <span class="docEmphasis">put</span> and an asterisk means <span class="docEmphasis">get</span> in the sequence</p>
<div class="docText"><pre>E A S * Y * Q U E * **S T* **I O*N ***.</pre></div><br />
<p class="docText">Give the sequence of values returned by the <span class="docEmphasis">get</span> operations when this sequence of operations is performed on an initially empty FIFO queue.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.38</span> Modify the array-based FIFO queue implementation in the text (<a class="docLink" href="#ch04ex20">Program 4.15</a>) to call a function <tt>error()</tt> if the client attempts to <span class="docEmphasis">get</span> when the queue is empty or to <span class="docEmphasis">put</span> when the queue is full.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.39</span> Modify the linked-list&ndash;based FIFO queue implementation in the text (<a class="docLink" href="#ch04ex18">Program 4.14</a>) to call a function <tt>error()</tt> if the client attempts to <span class="docEmphasis">get</span> when the queue is empty or if there is no memory available from <tt>new</tt> for a <span class="docEmphasis">put</span>.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">4.40</span> An uppercase letter means <span class="docEmphasis">put</span> at the beginning, a lowercase letter means <span class="docEmphasis">put</span> at the end, a plus sign means <span class="docEmphasis">get</span> from the beginning, and an asterisk means <span class="docEmphasis">get</span> from the end in the sequence</p>
<div class="docText"><pre>E A s + Y + Q U E **+ s t + *+ I O*n ++*.</pre></div><br />
<p class="docText">Give the sequence of values returned by the <span class="docEmphasis">get</span> operations when this sequence of operations is performed on an initially empty deque.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">4.41</span> Using the conventions of <a class="docLink" href="#ch04qa7q5">Exercise 4.40</a>, give a way to insert plus signs and asterisks in the sequence <tt>E a s Y</tt> so that the sequence of values returned by the <span class="docEmphasis">get</span> operations is (<span class="docEmphasis">i</span>) <tt>E s a Y</tt> ; (<span class="docEmphasis">ii</span>) <tt>Y a s E</tt> ; (<span class="docEmphasis">iii</span>) <tt>a Y s E</tt> ; (<span class="docEmphasis">iv</span>) <tt>a s Y E</tt> ; or, in each instance, prove that no such sequence exists.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">4.42</span> Given two sequences, give an algorithm for determining whether or not it is possible to add plus signs and asterisks to make the first produce the second when interpreted as a sequence of deque operations in the sense of <a class="docLink" href="#ch04qa7q6">Exercise 4.41</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">4.43</span> Write an interface for the deque ADT.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.44</span> Provide an implementation for your deque interface (<a class="docLink" href="#ch04qa7q8">Exercise 4.43</a>) that uses an array for the underlying data structure.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q10"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.45</span> Provide an implementation for your deque interface (<a class="docLink" href="#ch04qa7q8">Exercise 4.43</a>) that uses a doubly linked list for the underlying data structure.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q11"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.46</span> Provide an implementation for the FIFO queue interface in the text (<a class="docLink" href="#ch04ex16">Program 4.13</a>) that uses a circular list for the underlying data structure.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q12"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.47</span> Write a client that tests your deque ADTs (<a class="docLink" href="#ch04qa7q8">Exercise 4.43</a>) by reading, as the first argument on the command line, a string of commands like those given in <a class="docLink" href="#ch04qa7q5">Exercise 4.40</a> then performing the indicated operations. Add a member function <tt>dump</tt> to the interface and implementations, and print out the contents of the deque after each operation, in the style of <a class="docLink" href="#ch04fig06">Figure 4.6</a>.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q13"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">4.48</span> Build a random-queue ADT by writing an interface and an implementation that uses an array as the underlying data structure. Make sure that each operation takes constant time.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q14"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">4.49</span> Build a random-queue ADT by writing an interface and an implementation that uses a linked list as the underlying data structure. Provide implementations for <span class="docEmphasis">insert</span> and <span class="docEmphasis">remove</span> that are as efficient as you can make them, and analyze their worst-case cost.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q15"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">4.50</span> Write a client that picks numbers for a lottery by putting the numbers 1 through 99 on a random queue, then prints the result of removing five of them.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q16"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.51</span> Write a client that takes an integer <span class="docEmphasis">N</span> from the first argument on the command line, then prints out <span class="docEmphasis">N</span> poker hands, by putting <span class="docEmphasis">N</span> items on a random queue (see <a class="docLink" href="ch04lev1sec1.html#ch04qa2q2">Exercise 4.7</a>), then printing out the result of picking five cards at a time from the queue.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa7q17"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">4.52</span> Write a program that solves the connectivity problem by inserting all the pairs on a random queue and then taking them from the queue, using the quick-find&ndash;weighted algorithm (<a class="docLink" href="ch01lev1sec3.html#ch01ex05">Program 1.3</a>).</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></div></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch04lev1sec5.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch04lev1sec7.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table><!--IP User 2--></td></body></head></html>