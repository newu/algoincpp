<html><head><title>4.7. Duplicate and Index Items</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch04lev1sec6.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch04lev1sec8.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch04lev1sec7"></a>
<h3 id="title-IDADQ31H" class="docSection1Title">4.7. Duplicate and Index Items</h3>
<p class="docText"><a name="iddle1006"></a><a name="iddle1393"></a><a name="iddle1691"></a><a name="iddle2134"></a>For many applications, the abstract items that we process are <span class="docEmphasis">unique</span>, a quality that leads us to consider modifying our idea of how stacks, FIFO queues, and other generalized ADTs should operate. Specifically, in this section, we consider the effect of changing the specifications of stacks, FIFO queues, and generalized queues to disallow duplicate items in the data structure.</p>
<p class="docText">For example, our company that maintains a mailing list of customers might want to try to grow the list by performing <span class="docEmphasis">insert</span> operations from other lists gathered from many sources, but would not want the list to grow for an <span class="docEmphasis">insert</span> operation that refers to a customer already on the list. We shall see that the same principle applies in a variety of applications. For another example, consider the problem of routing a message through a complex communications network. We might try going through several paths simultaneously in the network, but there is only one message, so any particular node in the network would want to have only one copy in its internal data structures.</p>
<p class="docText">One approach to handling this situation is to leave up to the clients the task of ensuring that duplicate items are not presented to the ADT, a task that clients presumably might carry out using some different ADT. But since the purpose of an ADT is to provide clients with clean solutions to applications problems, we might decide that detecting and resolving duplicates is a part of the problem that the ADT should help to solve.</p>
<p class="docText">The policy of disallowing duplicate items is a change in the <span class="docEmphasis">abstraction</span>: the interface, names of the operations, and so forth for such an ADT are the same as those for the corresponding ADT without the policy, but the behavior of the implementation changes in a fundamental way. In general, whenever we modify the specification of an ADT, we get a completely new ADT&mdash;one that has completely different properties. This situation also demonstrates the precarious nature of ADT specification: Being sure that clients and implementations adhere to the specifications in an interface is difficult enough, but enforcing a high-level policy such as this one is another matter entirely. Still, we are interested in algorithms that do so because clients can exploit such properties to solve problems in new ways, and implementations can take advantage of such restrictions to provide more efficient solutions.</p>
<p class="docText"><a name="iddle1483"></a><a name="iddle2135"></a><a class="docLink" href="#ch04fig09">Figure 4.9</a> shows how a modified no-duplicates stack ADT would operate for the example corresponding to <a class="docLink" href="ch04lev1sec2.html#ch04fig01">Figure 4.1</a> <a class="docLink" href="#ch04fig10">Figure 4.10</a> shows the effect of the change for FIFO queues.</p>
<a name="ch04fig09"></a><p><center>
<h5 class="docFigureTitle">Figure 4.9. Pushdown stack with no duplicates</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence shows the result of the same operations as those in <a class="docLink" href="ch04lev1sec2.html#ch04fig01">Figure 4.1</a>, but for a stack with no duplicate objects allowed. The gray squares mark situations where the stack is left unchanged because the item to be pushed is already on the stack. The number of items on the stack is limited by the number of possible distinct items.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="120" height="302" src="04fig09.gif" /></p>
<br />
<a name="ch04fig10"></a><p><center>
<h5 class="docFigureTitle">Figure 4.10. FIFO queue with no duplicates, ignore-the-new-item policy</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence shows the result of the same operations as those in <a class="docLink" href="ch04lev1sec6.html#ch04fig06">Figure 4.6</a>, but for a queue with no duplicate objects allowed. The gray squares mark situations where the queue is left unchanged because the item to be put onto the queue is already there.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="120" height="392" src="04fig10.gif" /></p>
<br />
<p class="docText">In general, we have a policy decision to make when a client makes an <span class="docEmphasis">insert</span> request for an item that is already in the data structure. Should we proceed as though the request never happened, or should we proceed as though the client had performed a <span class="docEmphasis">remove</span> followed by an <span class="docEmphasis">insert</span>? This decision affects the order in which items are ultimately processed for ADTs such as stacks and FIFO queues (see <a class="docLink" href="#ch04fig11">Figure 4.11</a>), and the distinction is significant for client programs. For example, the company using such an ADT for a mailing list might prefer to use the new item (perhaps assuming that it has more up-to-date information about the customer), and the switching mechanism using such an ADT might prefer to ignore the new item (perhaps it has already taken steps to send along the message). Furthermore, this policy choice affects the implementations: the forget-the-old-item policy is generally more difficult to implement than the ignore-the-new-item policy, because it requires that we modify the data structure.</p>
<a name="ch04fig11"></a><p><center>
<h5 class="docFigureTitle">Figure 4.11. FIFO queue with no duplicates, forget-the-old-item policy</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence shows the result of the same operations as in <a class="docLink" href="#ch04fig10">Figure 4.10</a>, but using the (more difficult to implement) policy by which we always add a new item at the end of the queue. If there is a duplicate, we remove it.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="120" height="390" src="04fig11.gif" /></p>
<br />
<p class="docText">To implement generalized queues with no duplicate items, we assume that we have an abstract operation for testing item equality, as discussed in <a class="docLink" href="ch04lev1sec1.html#ch04lev1sec1">Section 4.1</a>. Given such an operation, we still need to be able to determine whether a new item to be inserted is already in the data structure. This general case amounts to implementing the symbol table ADT, so we shall consider it in the context of the implementations given in <a class="docLink" href="ch12.html#ch12">Chapters 12</a> through <a class="docLink" href="ch15.html#ch15">15</a>.</p>
<p class="docText">There is an important special case for which we have a straightforward solution, which is illustrated for the pushdown stack ADT in <a class="docLink" href="#ch04ex21">Program 4.16</a>. This implementation assumes that the items are integers in the range 0 to <span class="docEmphasis">M</span>&ndash;<tt>1</tt>. Then, it uses a second array, indexed by the item itself, to determine whether that item is in the stack. When we insert item <span class="docEmphasis">i</span>, we set the <span class="docEmphasis">i</span>th entry in the second array to 1; when we remove item <span class="docEmphasis">i</span>, we set the <span class="docEmphasis">i</span>th entry in the array to 0. Otherwise, we use the same code as before to insert and remove items, with one additional test: Before inserting an item, we can test to see whether it is already in the stack. If it is, we ignore the <span class="docEmphasis">push</span>. This solution does not depend on whether we use an array or linked-list (or some other) representation for the stack. Implementing an ignore-the-old-item policy involves more work (see <a class="docLink" href="#ch04qa8q5">Exercise 4.57</a>).</p>
<p class="docText"><a name="iddle1010"></a><a name="iddle1484"></a><a name="iddle1637"></a><a name="iddle1692"></a><a name="iddle2476"></a>In summary, one way to implement a stack with no duplicates using an ignore-the-new-item policy is to maintain <span class="docEmphasis">two</span> data structures: the first contains the items in the stack, as before, to keep track of the order in which the items in the stack were inserted; the second is an array that allows us to keep track of which items are in the stack, by using the item as an index. Using an array in this way is a special case of a symbol-table implementation, which is discussed in <a class="docLink" href="ch12lev1sec2.html#ch12lev1sec2">Section 12.2</a>. We can apply the same technique to any generalized queue ADT, when we know the items to be integers in the range <tt>0</tt> to <span class="docEmphasis">M</span>&ndash;1.</p>
<p class="docText">This special case arises frequently. The most important example is when the items in the data structure are themselves array indices, so we refer to such items as <span class="docEmphasis">index items</span>. Typically, we have a set of <tt>M</tt> objects, kept in yet another array, that we need to pass through a generalized queue structure as a part of a more complex algorithm. Objects are put on the queue by index and processed when they are removed, and each object is to be processed precisely once. Using array indices in a queue with no duplicates accomplishes this goal directly.</p>
<p class="docText">Each of these choices (disallow duplicates, or do not; and use the new item, or do not) leads to a new ADT. The differences may seem minor, but they obviously affect the dynamic behavior of the ADT as seen by client programs, and affect our choice of algorithm and data structure to implement the various operations, so we have no alternative but to treat all the ADTs as different. Furthermore, we have other options to consider: For example, we might wish to modify the interface to inform the client program when it attempts to insert a duplicate item, or to give the client the option whether to ignore the new item or to forget the old one.</p>
<p class="docText">When we informally use a term such as <span class="docEmphasis">pushdown stack</span>, <span class="docEmphasis">FIFO queue</span>, <span class="docEmphasis">deque</span>, <span class="docEmphasis">priority queue</span>, or <span class="docEmphasis">symbol table</span>, we are potentially referring to a <span class="docEmphasis">family</span> of ADTs, each with different sets of defined operations and different sets of conventions about the meanings of the operations, each requiring different and, in some cases, more sophisticated implementations to be able to support those operations efficiently.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa8q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">4.53</span> Draw a figure corresponding to <a class="docLink" href="#ch04fig09">Figure 4.9</a> for the stack ADT that disallows duplicates using a forget-the-old-item policy.</p>
<p class="docText"></p><a name="ch04ex21"></a><h5 id="title-IDAO231H" class="docExampleTitle">Program 4.16. Stack with index items and no duplicates</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle2136"></a>This pushdown-stack implementation assumes that <tt>Item</tt> has an <tt>int</tt> cast that returns integers between <tt>0</tt> and <tt>maxN-1</tt>, so that it can maintain an array <tt>t</tt> that has a nonzero value corresponding to each item in the stack. The array enables <tt>push</tt> to test quickly whether its argument is already on the stack, and to take no action if the test succeeds. We use only one bit per entry in <tt>t</tt>, so we could save space by using characters or bits instead of integers, if desired (see <a class="docLink" href="ch12lev1sec2.html#ch12qa2q3">Exercise 12.12</a>).</p>
<div class="docText"><pre>template &lt;class Item&gt;
class STACK
  {
    private:
      Item *s, *t; int N;
    public:
      STACK(int maxN)
        {
         s = new Item[maxN]; N = 0;
         t = new Item[maxN];
         for (int i = 0; i &lt; maxN; i++) t[i] = 0;
        }
      int empty() const
        { return N == 0; }
      void push(Item item)
        {
          if (t[item] == 1) return;
          s[N++] = item; t[item] = 1;
        }
      Item pop()
        { t[s[--N]] = 0; return s[N]; }
  };</pre></div><br />
</td></tr></table></p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa8q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.54</span> Modify the standard array-based stack implementation in <a class="docLink" href="ch04lev1sec4.html#ch04lev1sec4">Section 4.4</a> (<a class="docLink" href="ch04lev1sec4.html#ch04ex09">Program 4.7</a>) to disallow duplicates with an ignore-the-new-item policy. Use a brute-force approach that involves scanning through the whole stack.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa8q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.55</span> Modify the standard array-based stack implementation in <a class="docLink" href="ch04lev1sec4.html#ch04lev1sec4">Section 4.4</a> (<a class="docLink" href="ch04lev1sec4.html#ch04ex09">Program 4.7</a>) to disallow duplicates with a forget-the-old-item policy. Use a brute-force approach that involves scanning through, and possibly rearranging, the whole stack.</p>
</td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa8q4"></a><b></b></td><td><p class="docText"><a name="iddle1009"></a><a name="iddle1332"></a><a name="iddle1497"></a><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">4.56</span> Do <a class="docLink" href="#ch04qa8q2">Exercises 4.54</a> and <a class="docLink" href="#ch04qa8q3">4.55</a> for the linked-list&ndash;based stack implementation in <a class="docLink" href="ch04lev1sec4.html#ch04lev1sec4">Section 4.4</a> (<a class="docLink" href="ch04lev1sec4.html#ch04ex10">Program 4.8</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa8q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">4.57</span> Develop a pushdown-stack implementation that disallows duplicates, using a forget-the-old-item policy for integer items between <tt>0</tt> and <span class="docEmphasis">M</span>&ndash;1, and that uses constant time for both <span class="docEmphasis">push</span> and <span class="docEmphasis">pop</span>. <span class="docEmphasis">Hint</span>: Use a doubly linked list representation for the stack and keep pointers to nodes, rather than 0&ndash;1 values, in an item-indexed array.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa8q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.58</span> Do <a class="docLink" href="#ch04qa8q2">Exercises 4.54</a>and <a class="docLink" href="#ch04qa8q3">4.55</a> for the FIFO queue ADT.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa8q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.59</span> Do <a class="docLink" href="#ch04qa8q4">Exercise 4.56</a> for the FIFO queue ADT.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa8q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.60</span> Do <a class="docLink" href="#ch04qa8q5">Exercise 4.57</a> for the FIFO queue ADT.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa8q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.61</span> Do <a class="docLink" href="#ch04qa8q2">Exercises 4.54</a>and <a class="docLink" href="#ch04qa8q3">4.55</a> for the randomized-queue ADT.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa8q10"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.62</span> Write a client program for your ADT from <a class="docLink" href="#ch04qa8q9">Exercise 4.61</a>, which exercises a randomized queue with no duplicates.</p>
</td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch04lev1sec6.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch04lev1sec8.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>