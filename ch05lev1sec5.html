<html><head><title>5.5. Mathematical Properties of Binary Trees</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch05lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch05lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch05lev1sec5"></a>
<h3 id="643999-839" class="docSection1Title">5.5. Mathematical Properties of Binary Trees</h3>
<p class="docText">Before beginning to consider tree-processing algorithms, we continue in a mathematical vein by considering a number of basic properties of trees. We focus on binary trees, because we use them frequently throughout this book. Understanding their basic properties will lay the groundwork for understanding the performance characteristics of various algorithms that we will encounter&mdash;not only of those that use binary trees as explicit data structures, but also of divide-and-conquer recursive algorithms and other similar applications.</p>
<a name="ch05ex23"></a><h5 id="title-IDA40FBF" class="docExampleTitle">Property 5.5. <span class="docEmphasis">A binary tree with N internal nodes has N</span><span class="docEmphRoman">+ 1</span> <span class="docEmphasis">external nodes</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We prove this property by induction: A binary tree with no internal nodes has one external node, so the property holds for <span class="docEmphasis">N</span> = 0. For <span class="docEmphasis">N</span> &gt; 0, any binary tree with <span class="docEmphasis">N</span> internal nodes has <span class="docEmphasis">k</span> internal nodes in its left subtree and <span class="docEmphasis">N</span> &ndash; 1 &ndash; <span class="docEmphasis">k</span> internal nodes in its right subtree for some <span class="docEmphasis">k</span> between 0 and <span class="docEmphasis">N</span> &ndash; 1, since the root is an internal node. By the inductive hypothesis, the left subtree has <span class="docEmphasis">k</span> + 1 external nodes and the right subtree has <span class="docEmphasis">N</span> &ndash; <span class="docEmphasis">k</span> external nodes, for a total of<span class="docEmphasis">N</span> + 1.</p>
</td></tr></table></p>
<a name="ch05ex24"></a><h5 id="title-IDAL2FBF" class="docExampleTitle">Property 5.6. A binary tree with <span class="docEmphasis">N</span> internal nodes has 2<span class="docEmphasis">N</span> links: <span class="docEmphasis">N</span> &ndash; 1 links to internal nodes and <span class="docEmphasis">N</span> + 1 links to external nodes</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">In any rooted tree, each node, except the root, has a unique parent, and every edge connects a node to its parent, so there are <span class="docEmphasis">N</span> &ndash; 1 links connecting internal nodes. Similarly, each of the <span class="docEmphasis">N</span> + 1 external nodes has one link, to its unique parent.</p>
</td></tr></table></p>
<p class="docText"><a name="iddle1213"></a><a name="iddle1957"></a><a name="iddle2040"></a><a name="iddle2546"></a><a name="iddle2554"></a>The performance characteristics of many algorithms depend not just on the number of nodes in associated trees, but on various structural properties.</p>
<a name="ch05ex25"></a><h5 id="title-IDAT4FBF" class="docExampleTitle">Definition 5.6. The <span class="docEmphasis">level</span> of a node in a tree is one higher than the level of its parent (with the root at level 0). The <span class="docEmphasis">height</span> of a tree is the maximum of the levels of the tree's nodes. The<span class="docEmphasis">path length</span> of a tree is the sum of the levels of all the tree's nodes. The<span class="docEmphasis">internal path length</span> of a binary tree is the sum of the levels of all the tree's internal nodes. The<span class="docEmphasis">external path length</span> of a binary tree is the sum of the levels of all the tree's external nodes</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">A convenient way to compute the path length of a tree is to sum, for all <span class="docEmphasis">k</span>, the product of <span class="docEmphasis">k</span> and the number of nodes at level <span class="docEmphasis">k</span>.</p>
<p class="docText">These quantities also have simple recursive definitions that follow directly from the recursive definitions of trees and binary trees. For example, the height of a tree is 1 greater than the maximum of the height of the subtrees of its root, and the path length of a tree with <span class="docEmphasis">N</span> nodes is the sum of the path lengths of the subtrees of its root plus <span class="docEmphasis">N</span> &ndash; 1. The quantities also relate directly to the analysis of recursive algorithms. For example, for many recursive computations, the height of the corresponding tree is precisely the maximum depth of the recursion, or the size of the stack needed to support the computation.</p>
</td></tr></table></p>
<a name="ch05ex26"></a><h5 id="title-IDA05FBF" class="docExampleTitle">Property 5.7. The external path length of any binary tree with <span class="docEmphasis">N</span> internal nodes is <tt>2N</tt> greater than the internal path length.</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We could prove this property by induction, but an alternate proof (which also works for <a class="docLink" href="#ch05ex24">Property 5.6</a>) is instructive. Observe that any binary tree can be constructed by the following process: Start with the binary tree consisting of one external node. Then, repeat the following <span class="docEmphasis">N</span> times: Pick an external node and replace it by a new internal node with two external nodes as children. If the external node chosen is at level <span class="docEmphasis">k</span>, the internal path length is increased by <span class="docEmphasis">k</span>, but the external path length is increased by <span class="docEmphasis">k</span> + 2 (one external node at level <span class="docEmphasis">k</span> is removed, but two at level <span class="docEmphasis">k</span> + 1 are added). The process starts with a tree with internal and external path lengths both 0 and, for each of <span class="docEmphasis">N</span> steps, increases the external path length by 2 more than the internal path length.</p>
</td></tr></table></p>
<a name="ch05ex27"></a><h5 id="title-IDAHBGBF" class="docExampleTitle">Property 5.8. The height of a binary tree with <span class="docEmphasis">N</span> internal nodes is at least lg <span class="docEmphasis">N</span> and at most <span class="docEmphasis">N</span> &ndash; 1.</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The worst case is a degenerate tree with only one leaf, with <span class="docEmphasis">N</span> &ndash; 1 links from the root to the leaf (see <a class="docLink" href="#ch05fig23">Figure 5.23</a>). The best case is a balanced tree with 2<sup><span class="docEmphasis">i</span></sup> internal nodes at every level <span class="docEmphasis">i</span> except the bottom level (see <a class="docLink" href="#ch05fig23">Figure 5.23</a>). If the height is h, then we must have</p>
<a name="ch05fig23"></a><p><center>
<h5 class="docFigureTitle">Figure 5.23. Three binary trees with 10 internal nodes</h5>
<h5></h5><h5></h5></center></p><p class="docText">The binary tree shown at the top has height 7, internal path length 31 and external path length 51. A fully balanced binary tree (center) with 10 internal nodes has height 4, internal path length 19 and external path length 39 (no binary tree with 10 nodes has smaller values for any of these quantities). A degenerate binary tree (bottom) with 10 internal nodes has height 10, internal path length 45 and external path length 65 (no binary tree with 10 nodes has larger values for any of these quantities).</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="220" height="492" src="05fig23.gif" /></p>
</td></tr></table></p><br />
<div class="docText"><pre>2<sup>h &ndash; 1</sup> &lt; N + 1 <img src="U2264.GIF" border="0" /> 2<sup>h</sup>,</pre></div><br />
<p class="docText">since there are <span class="docEmphasis">N</span> + 1 external nodes. This inequality implies the property stated: The best-case height is precisely equal to lg <span class="docEmphasis">N</span> rounded up to the nearest integer.</p>
</td></tr></table>
<p class="docText"></p><a name="ch05ex28"></a><h5 id="title-IDABEGBF" class="docExampleTitle">Property 5.9. The internal path length of a binary tree with <span class="docEmphasis">N</span> internal nodes is at least <span class="docEmphasis">N</span> lg(N/4) and at most <span class="docEmphasis">N</span>(N &ndash; 1)/2.</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1114"></a>The worst case and the best case are achieved for the same trees referred to in the discussion of <a class="docLink" href="#ch05ex27">Property 5.8</a> and depicted in <a class="docLink" href="#ch05fig23">Figure 5.23</a>. The internal path length of the worst-case tree is <tt>0+1+2+. . .+(N &ndash; 1) = N(N &ndash; 1)/2</tt>. The best case tree has (<span class="docEmphasis">N</span> + 1) external nodes at height no more than [lg <span class="docEmphasis">N</span>]. Multiplying these and applying <a class="docLink" href="#ch05ex26">Property 5.7</a>, we get the bound <tt>(N + 1)[lg N] &ndash; 2N &lt; N lg(N/4)</tt>.</p>
</td></tr></table></p>
<p class="docText">As we shall see, binary trees appear extensively in computer applications, and performance is best when the binary trees are fully balanced (or nearly so). For example, the trees that we use to describe divide-and-conquer algorithms such as binary search and mergesort are fully balanced (see <a class="docLink" href="#ch05qa5q7">Exercise 5.74</a>). In <a class="docLink" href="ch09.html#ch09">Chapters 9</a> and <a class="docLink" href="ch13.html#ch13">13</a>, we shall examine explicit data structures that are based on balanced trees.</p>
<p class="docText">These basic properties of trees provide the information that we need to develop efficient algorithms for a number of practical problems. More detailed analyses of several of the specific algorithms that we shall encounter require sophisticated mathematical analysis, although we can often get useful estimates with straightforward inductive arguments like the ones that we have used in this section. We discuss further mathematical properties of trees as needed in the chapters that follow. At this point, we are ready to move back to algorithmic matters.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa5q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">5.68</span> How many external nodes are there in an <span class="docEmphasis">M</span>-ary tree with <span class="docEmphasis">N</span> internal nodes? Use your answer to give the amount of memory required to represent such a tree, assuming that links and items require one word of memory each.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa5q2"></a><b></b></td><td><p class="docText"><a name="iddle1203"></a><a name="iddle2527"></a><a name="iddle2568"></a><span class="docEmphStrong">5.69</span> Give upper and lower bounds on the height of an <span class="docEmphasis">M</span>-ary tree with <span class="docEmphasis">N</span> internal nodes.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa5q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.70</span> Give upper and lower bounds on the internal path length of an <span class="docEmphasis">M</span>-ary tree with <span class="docEmphasis">N</span> internal nodes.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa5q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.71</span> Give upper and lower bounds on the number of leaves in a binary tree with <span class="docEmphasis">N</span> nodes.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa5q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">5.72</span> Show that if the levels of the external nodes in a binary tree differ by a constant, then the height is <tt>O(log N)</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa5q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.73</span> A <span class="docEmphasis">Fibonacci tree of height</span> <span class="docEmphasis">n</span> &gt; 2 is a binary tree with a Fibonacci tree of height <span class="docEmphasis">N</span> &ndash; 1 in one subtree and a Fibonacci tree of height <span class="docEmphasis">n</span> &ndash; 2 in the other subtree. A Fibonacci tree of height 0 is a single external node, and a Fibonacci tree of height 1 is a single internal node with two external children (see <a class="docLink" href="ch05lev1sec3.html#ch05fig14">Figure 5.14</a>). Give the height and external path length of a Fibonacci tree of height <span class="docEmphasis">N</span>, as a function of <span class="docEmphasis">N</span>, the number of nodes in the tree.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa5q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.74</span> A <span class="docEmphasis">divide-and-conquer tree</span> of <span class="docEmphasis">N</span> nodes is a binary tree with a root labeled <span class="docEmphasis">N</span>, a divide-and-conquer tree of [<span class="docEmphasis">N</span>/2] nodes in one subtree, and a divide-and-conquer tree of [<span class="docEmphasis">N</span>/2] nodes in the other subtree. (<a class="docLink" href="ch05lev1sec2.html#ch05fig06">Figure 5.6</a> depicts a divide-and-conquer tree.) Draw divide-and-conquer trees with 11, 15, 16, and 23 nodes.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa5q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">5.75</span> Prove by induction that the internal path length of a divide-and-conquer tree is between <span class="docEmphasis">N</span> lg <span class="docEmphasis">N</span> and <span class="docEmphasis">N</span> lg <span class="docEmphasis">N</span> + <span class="docEmphasis">N</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa5q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.76</span> A <span class="docEmphasis">combine-and-conquer tree</span> of <span class="docEmphasis">N</span> nodes is a binary tree with a root labeled <span class="docEmphasis">N</span>, a combine-and-conquer tree of [<span class="docEmphasis">N</span>/2] nodes in one subtree, and a combine-and-conquer tree of [<span class="docEmphasis">N</span>/2] nodes in the other subtree (see <a class="docLink" href="ch05lev1sec2.html#ch05qa2q3">Exercise 5.18</a>). Draw combine-and-conquer trees with 11, 15, 16, and 23 nodes.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa5q10"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.77</span> Prove by induction that the internal path length of a combine-and-conquer tree is between <span class="docEmphasis">N</span> lg <span class="docEmphasis">N</span> and <span class="docEmphasis">N</span> lg <span class="docEmphasis">N</span> + <span class="docEmphasis">N</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch05qa5q11"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">5.78</span> A <span class="docEmphasis">complete</span> binary tree is one with all levels filled, except possibly the final one, which is filled from left to right, as illustrated in <a class="docLink" href="#ch05fig24">Figure 5.24</a>. Prove that the internal path length of a complete tree with <span class="docEmphasis">N</span> nodes is between <span class="docEmphasis">N</span> lg <span class="docEmphasis">N</span> and <span class="docEmphasis">N</span> lg <span class="docEmphasis">N</span> + <span class="docEmphasis">N</span>.</p></td></tr></table></p>
<a name="ch05fig24"></a><p><center>
<h5 class="docFigureTitle">Figure 5.24. Complete binary trees with seven and 10 internal nodes</h5>
<h5></h5><h5></h5></center></p><p class="docText">When the number of external nodes is a power of 2 <span class="docEmphasis">(top)</span>, the external nodes in a complete binary tree are all at the same level. Otherwise <span class="docEmphasis">(bottom)</span>, the external nodes appear on two levels, with the internal nodes to the left of the external nodes on the next-to-bottom level.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="140" height="155" src="05fig24.gif" /></p>
<br />
<ul></ul></div></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch05lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch05lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table><!--IP User 2--></td></body></head></html>