<html><head><title>15.4. Multiway Tries and TSTs</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch15lev1sec3.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch15lev1sec5.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch15lev1sec4"></a>
<h3 id="title-IDAZWB4B" class="docSection1Title">15.4. Multiway Tries and TSTs</h3>
<p class="docText">For radix sorting, we found that we could get a significant improvement in speed by considering more than 1 bit at a time. The same is true for radix search: By examining <span class="docEmphasis">r</span> bits at a time, we can speed up the search by a factor of <span class="docEmphasis">r</span>. However, there is a catch that makes it necessary for us to be more careful in applying this idea than we had to be for radix sorting. The problem is that considering r bits at a time corresponds to using tree nodes with <span class="docEmphasis"><tt>R</tt></span> <tt>= 2</tt><span class="docEmphasis"><tt><sup>r</sup></tt></span> links, and that can lead to a considerable amount of wasted space for unused links.</p>
<p class="docText">In the (binary) tries of <a class="docLink" href="ch15lev1sec2.html#ch15lev1sec2">Section 15.2</a>, the nodes corresponding to key bits have two links: one for the case when the key bit is 0, and the other for the case when the key bit is 1. The appropriate generalization is to <span class="docEmphasis">R</span>-ary tries, where we have nodes with <span class="docEmphasis">R</span> links corresponding to key digits, one for each possible digit value. Keys are stored in leaves (nodes with all links null). To search in an <span class="docEmphasis">R</span>-way trie, we start at the root and at the leftmost key digit, and use the key digits to guide us down the tree. We go down the ith link (and move to the next digit) if the digit value is <span class="docEmphasis">i</span>. If we reach a leaf, it contains the only key in the trie with leading digits corresponding to the path that we have traversed, so we can compare that key with the search key to determine whether we have a search hit or a search miss. If we reach <a name="iddle1447"></a><a name="iddle2577"></a>a null link, we know that we have a search miss, because that link corresponds to a leading-digit pattern not found in any keys in the trie. <a class="docLink" href="#ch15fig14">Figure 15.14</a> shows a 10-way trie that represents a sample set of decimal numbers. As we discussed in <a class="docLink" href="ch10.html#ch10">Chapter 10</a>, numbers typically seen in practice are distinguished with relatively few trie nodes. This same effect for more general types of keys is the basis for a number of efficient search algorithms.</p>
<a name="ch15fig14"></a><p><center>
<h5 class="docFigureTitle">Figure 15.14. R-way trie for base-10 numbers</h5>
<h5></h5><h5></h5></center></p><p class="docText">This figure depicts the trie that distinguishes the set of numbers (see <a class="docLink" href="ch12lev1sec4.html#ch12fig01">Figure 12.1</a>). Each node has 10 links (one for each possible digit). At the root, link 0 points to the trie for keys with first digit 0 (there is only one); link 1 points to the trie for keys with first digit 1 (there are two), and so forth. None of these numbers has first digit 4, 7, 8, or 9, so those links are null. There is only one number for each of the first digits 0, 2, and 5, so there is a leaf containing the appropriate number for each of those digits. The rest of the structure is built recursively, moving one digit to the right.</p>
<p class="docText">
<img border="0" alt="" width="500" height="101" src="15fig14.gif" /></p>
<br />
<p class="docText">Before doing a full symbol-table implementation with multiple node types and so forth, we begin our study of multiway tries by concentrating on the <span class="docEmphasis">existence-table</span> problem, where we have only keys (no records or associated information) and want to develop algorithms to <span class="docEmphasis">insert</span> a key into a data structure and to <span class="docEmphasis">search</span> the data structure to tell us whether or not a given key has been inserted. To use the same interface that we have been using for more general symbol-table implementations, we adopt the convention that the search function returns <tt>nullItem</tt> for a search miss and a dummy item containing the search key for a search hit. This convention simplifies the code and clearly exposes the structure of the multiway tries that we shall be considering. In <a class="docLink" href="ch15lev1sec5.html#ch15lev1sec5">Section 15.5</a>, we shall discuss more general symbol-table implementations, including string indexing.</p>
<a name="ch15ex13"></a><h5 id="title-IDA40B4B" class="docExampleTitle">Definition 15.2. The <span class="docEmphasis">existence trie</span> corresponding to a set of keys is defined recursively as follows: The trie for an empty set of keys is a null link; and the trie for a nonempty set of keys is an internal node with links referring to the trie for each possible key digit, with the leading digit considered to be removed for the purpose of constructing the subtrees</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">For simplicity, we assume in this definition that no key is the prefix of another. Typically, we enforce this restriction by ensuring that the keys are distinct and either are of fixed length or have a termination character with value <tt>NULLdigit</tt>, a sentinel that is used for no other purpose. The point of this definition is that we can use existence tries to implement existence tables, without storing <span class="docEmphasis">any</span> information within the trie; the information is all implicitly defined within the trie <span class="docEmphasis">structure</span>. Each node has <span class="docEmphasis">R + 1</span> links (one for each possible character value plus one for <tt>NULLdigit</tt>), and no other information. To search, we use the digits in the key to guide us down the trie. If we reach the link to <tt>NULLdigit</tt> at the same time that we run out of key digits, we have a search hit; otherwise we have a search miss. To insert a new key, we search until we reach a null link, then add nodes for each of the remaining characters in the key. <a class="docLink" href="#ch15fig15">Figure 15.15</a> is an example of a <tt>27</tt>-way trie; <a class="docLink" href="#ch15ex15">Program 15.7</a> is an implementation of the basic (multiway) existence-trie search and insert procedures.</p>
<a name="ch15fig15"></a><p><center>
<h5 class="docFigureTitle">Figure 15.15. R-way existence trie search and insertion</h5>
<h5></h5><h5></h5></center></p><p class="docText">The 26-way trie for the words <tt>now</tt>, <tt>is</tt>, and <tt>the</tt> <span class="docEmphasis">(top)</span> has nine nodes: the root plus one for each letter. The nodes are labeled in these diagrams, but we do not use explicit node labels in the data structure, because each node label can be inferred from the position of the link to it in its parents' link array.</p><h5></h5><p class="docText">To insert the key <tt>time</tt>, we branch off the existing node for t and add new nodes for <tt>i</tt>, <tt>m</tt>, and <tt>e</tt> (center); to insert the key <tt>for</tt>, we branch off the root and add new nodes for <tt>f</tt>, <tt>o</tt>, and <tt>r</tt>.</p>
<p class="docText">
<img border="0" alt="" width="275" height="536" src="15fig15.gif" /></p>
</td></tr></table></p><br />
<p class="docText">If the keys are of fixed length and are distinct, we can dispense with the link to the terminal character and can terminate searches when we reach the key length (see <a class="docLink" href="#ch15qa4q7">Exercise 15.55</a>). We have already seen an example of this type of trie when we used tries to describe MSD sorting for fixed-length keys (<a class="docLink" href="ch10lev1sec3.html#ch10fig10">Figure 10.10</a>).</p>
<p class="docText">In one sense, this pure abstract representation of the trie structure is optimal, because it can support the <span class="docEmphasis">search</span> operation in time proportional to the length of a key and in space proportional to the total number of characters in the key in the worst case. But the total amount of space used could be as high as nearly <span class="docEmphasis">R</span> links for each character, so we seek improved implementations. As we saw with binary tries, it is worthwhile to consider the pure trie structure as a particular representation of an underlying abstract structure that is a well-defined representation of our set of keys, and then to consider other representations of the same abstract structure that might lead to better performance.</p>
</td></tr></table>
<p class="docText"></p><a name="ch15ex14"></a><h5 id="title-IDA44B4B" class="docExampleTitle">Definition 15.3. A <span class="docEmphasis">multiway trie</span> is a multiway tree that has keys associated with each of its leaves, defined recursively as follows: The trie for an empty set of keys is a null link; the trie for a single key is a leaf containing that key; and the trie for a set of keys of cardinality greater than one is an internal node with links referring to tries for keys with each possible digit value, with the leading digit considered to be removed for the purpose of constructing the subtrees</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1929"></a><a name="iddle2580"></a><a name="iddle2586"></a>We assume that keys in the data structure are distinct and that no key is the prefix of another. To search in a standard multiway trie, we use the digits of the key to guide the search down the trie, with three possible outcomes. If we reach a null link, we have a search miss; if we reach a leaf containing the search key, we have a search hit; and if we reach a leaf containing a different key, we have a search miss. All leaves have <span class="docEmphasis">R</span> null links, so different representations for leaf nodes and non-leaf nodes are appropriate, as mentioned in <a class="docLink" href="ch15lev1sec2.html#ch15lev1sec2">Section 15.2</a>. We consider such an implementation in <a class="docLink" href="ch16.html#ch16">Chapter 16</a>, and we shall consider another approach to an implementation in this chapter. In either case, the analytic results from <a class="docLink" href="ch15lev1sec3.html#ch15lev1sec3">Section 15.3</a> generalize to tell us about the performance characteristics of standard multiway tries.</p>
<a name="ch15ex15"></a><h5 id="title-IDAFZM0B" class="docExampleTitle">Program 15.7. Existence-trie search and insertion</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This implementation of <span class="docEmphasis">search</span> and <span class="docEmphasis">insert</span> for multiway tries stores the keys implicitly within the structure of the trie. Each node contains <span class="docEmphasis">R</span> pointers to the next level down the trie. We follow the <span class="docEmphasis">i</span>th link at level <span class="docEmphasis">t</span> when the <span class="docEmphasis">t</span>th digit of the key is <span class="docEmphasis">i</span>. The <span class="docEmphasis">search</span> function returns a dummy item containing the key given as the argument if it is in the table, and returns <tt>nullItem</tt> otherwise. Alternatively, we could change the interface to use only type <tt>Key</tt>, or implement a cast from <tt>Item</tt> to <tt>Key</tt> in our item class.</p>
<div class="docText"><pre>private:
  struct node
    { node **next;
     node()
       { next = new node*[R];
         for (int i = 0; i &lt; R; i++) next[i] = 0; }
    };
  typedef node *link;
  link head;
  Item searchR(link h, Key v, int d)
    { int i = digit(v, d);
      if (h == 0) return nullItem;
      if (i == NULLdigit)
        { Item dummy(v); return dummy; }
      return searchR(h-&gt;next[i], v, d+1);
    }
  void insertR(link&amp; h, Item x, int d)
    { int i = digit(x.key(), d);
      if (h == 0) h = new node;
      if (i == NULLdigit) return;
      insertR(h-&gt;next[i], x, d+1);
    }
public:
   ST(int maxN)
     { head = 0; }
   Item search(Key v)
     { return searchR(head, v, 0); }
   void insert(Item x)
     { insertR(head, x, 0); }</pre></div><br />
</td></tr></table></p>
<a name="ch15ex16"></a><h5 id="title-IDAX0M0B" class="docExampleTitle">Property 15.6. <span class="docEmphasis">Search or insertion in a standard R-ary trie requires about <span class="docEmphRoman">log</span> <span class="docEmphasis"><sub>R</sub>N byte comparisons on the average in a tree built from N random bytestrings. The number of links in an R-ary trie built from N random keys is about RN/</span> <span class="docEmphRoman">ln</span> <span class="docEmphasis">R. The number of byte comparisons for search or insertion is no more than the number of bytes in the search key</span></span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">These results generalize those in <a class="docLink" href="ch15lev1sec2.html#ch15ex06">Properties 15.3</a> and <a class="docLink" href="ch15lev1sec2.html#ch15ex07">15.4</a>. We can establish them by substituting <span class="docEmphasis">R</span> for <tt>2</tt> in the proofs of those properties. As we mentioned, however, extremely sophisticated mathematics is involved in the precise analysis of these quantities.</p>
</td></tr></table></p>
<p class="docText">The performance characteristics listed in <a class="docLink" href="#ch15ex16">Property 15.6</a> represent an extreme example of a time&ndash;space tradeoff. On the one hand, there are a large number of unused null links&mdash;only a few nodes near the top use more than a few of their links. On the other hand, the height of a tree is small. For example, suppose that we take the typical value <span class="docEmphasis"><tt>R</tt></span> <tt>= 256</tt> and that we have <span class="docEmphasis">N</span> random 64-bit keys. <a class="docLink" href="#ch15ex16">Property 15.6</a> tells us that a search will take <tt>(lg</tt> <span class="docEmphasis"><tt>N</tt></span><tt>)/8</tt> character comparisons (8 at most) and that we will use fewer than <span class="docEmphasis">47N</span> links. If plenty of space is available, this method provides an extremely efficient alternative. We could cut the search cost to 4 character comparisons for this example by taking <span class="docEmphasis"><tt>R</tt></span> <tt>= 65536</tt>, but that would require over 5900 links.</p>
<p class="docText">We shall return to standard multiway tries in <a class="docLink" href="ch15lev1sec5.html#ch15lev1sec5">Section 15.5</a>; in the remainder of this section, we shall consider an alternative representation of the tries built by <a class="docLink" href="#ch15ex15">Program 15.7</a>: the <span class="docEmphasis">ternary search trie (TST)</span>, which is illustrated in its full form in <a class="docLink" href="#ch15fig16">Figure 15.16</a>. In a TST, each node has a character and <span class="docEmphasis">three</span> links, corresponding to keys whose current digits are less than, equal to, or greater than the node's character. Using this arrangement is equivalent to implementing trie nodes as binary search trees that use as keys the characters corresponding to non-null links. In the standard existence tries of <a class="docLink" href="#ch15ex15">Program 15.7</a>, trie nodes are represented by <span class="docEmphasis">R</span> + 1 links, and we infer the character represented by each non-null link by its index. In the corresponding existence TST, all the characters corresponding to non-null links appear explicitly in nodes&mdash;we find characters corresponding to keys only when we are traversing the middle links.</p>
<a name="ch15fig16"></a><p><center>
<h5 class="docFigureTitle">Figure 15.16. Existence-trie structures</h5>
<h5></h5><h5></h5></center></p><p class="docText">These figures show three different representations of the existence trie for the 16 words <tt>call me ishmael some years ago never mind how long precisely having little or no money</tt>: The 26-way existence trie (top); the abstract trie with null links removed (center); and the TST representation (bottom). The 26-way trie has too many links, but the TST is an efficient representation of the abstract trie.</p><h5></h5><p class="docText">The top two tries assume that no key is the prefix of another. For example, adding the key <tt>not</tt> would result in the key <tt>no</tt> being lost. We can add a null character to the end of each key to correct this problem, as illustrated in the TST at the bottom.</p>
<p class="docText">
<img border="0" alt="" width="500" height="783" src="15fig16.gif" /></p>
</td></tr></table></p><br />
<p class="docText">The search algorithm for existence TSTs is so straightforward as nearly to write itself; the insertion algorithm is slightly more complicated, but mirrors directly insertion in existence tries. To search, we compare the first character in the key with the character at the root. If it is less, we take the left link; if it is greater, we take the right link; and if it is equal, we take the middle link and move to the next key character. In each case, we apply the algorithm recursively. We terminate with a search miss if we encounter a null link or if we encounter the end of the search key before encountering <tt>NULLdigit</tt> in the tree, and we terminate with a search hit if we traverse the middle link in a node whose character is <tt>NULLdigit</tt>. To insert a new key, we search, then add new nodes for the characters in the tail of the key, just as we did for tries. <a class="docLink" href="#ch15ex17">Program 15.8</a> gives the details of the implementation of these algorithms, and <a class="docLink" href="#ch15fig17">Figure 15.17</a> has TSTs that correspond to the tries in <a class="docLink" href="#ch15fig15">Figure 15.15</a>.</p>
<a name="ch15fig17"></a><p><center>
<h5 class="docFigureTitle">Figure 15.17. Existence TSTs</h5>
<h5></h5><h5></h5></center></p><p class="docText">An existence TST has one node for each letter, but only 3 children per node, rather than 26. The top three trees in this figure are the RSTs corresponding to the insertion example in <a class="docLink" href="#ch15fig15">Figure 15.15</a>, with the additional change that an end-of-key character is appended to each key. We can then remove the restriction that no key may be a prefix of another, so, for example, we can insert the key <tt>theory</tt> (bottom).</p>
<p class="docText">
<img border="0" alt="" width="300" height="728" src="15fig17.gif" /></p>
<br />
<p class="docText">Continuing the correspondence that we have been following between search trees and sorting algorithms, we see that TSTs correspond to three-way radix sorting in the same way that BSTs correspond to quicksort, tries correspond to binary quicksort, and M-way tries correspond to M-way radix sorting. <a class="docLink" href="ch10lev1sec4.html#ch10fig13">Figure 10.13</a>, which describes the recursive call structure for three-way radix sort, is a TST for that set of keys. The null-links problem for tries corresponds to the empty-bins problem for radix sorting; three-way branching provides an effective solution to both problems.</p>
<p class="docText">We can make TSTs more efficient in their use of space by putting keys in leaves at the point where they are distinguished and by eliminating one-way branching between internal nodes as we did for patricia. At the end of this section, we examine an implementation based on the former change.</p>
<p class="docText"></p><a name="ch15ex17"></a><h5 id="title-IDAHCI0B" class="docExampleTitle">Program 15.8. Existence-TST search and insertion</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This code implements the same abstract trie algorithms as <a class="docLink" href="#ch15ex15">Program 15.7</a>, but each node contains one digit and three links: one each for keys whose next digit is less than, equal to, or greater than the corresponding digit in the search key, respectively.</p>
<div class="docText"><pre>private:
  struct node
    { Item item; int d; node *l, *m, *r;
      node(int k)
        { d = k; l = 0; m = 0; r = 0; }
    };
  typedef node *link;
  link head;
  Item nullItem;
  Item searchR(link h, Key v, int d)
    { int i = digit(v, d);
      if (h == 0) return nullItem;
      if (i == NULLdigit)
        { Item dummy(v); return dummy; }
      if (i &lt; h-&gt;d) return searchR(h-&gt;l, v, d);
      if (i == h-&gt;d) return searchR(h-&gt;m, v, d+1);
      if (i &gt; h-&gt;d) return searchR(h-&gt;r, v, d);
    }
  void insertR(link&amp; h, Item x, int d)
    { int i = digit(x.key(), d);
      if (h == 0) h = new node(i);
      if (i == NULLdigit) return;
      if (i &lt; h-&gt;d) insertR(h-&gt;l, x, d);
      if (i == h-&gt;d) insertR(h-&gt;m, x, d+1);
      if (i &gt; h-&gt;d) insertR(h-&gt;r, x, d);
    }
public:
  ST(int maxN)
    { head = 0; }
  Item search(Key v)
    { return searchR(head, v, 0); }
  void insert(Item x)
    { insertR(head, x, 0); }</pre></div><br />
</td></tr></table></p>
<p class="docText"></p><a name="ch15ex18"></a><h5 id="title-IDAHDI0B" class="docExampleTitle">Property 15.7. <span class="docEmphasis">A search or insertion in a full TST requires time proportional to the key length. The number of links in a TST is at most three times the number of characters in all the keys</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">In the worst case, each key character corresponds to a full <span class="docEmphasis">R</span>-ary node that is unbalanced, stretched out like a singly linked list. This worst case is extremely unlikely to occur in a random tree. More typically, we might expect to do ln <span class="docEmphasis">R</span> or fewer byte comparisons at the first level (since the root node behaves like a BST on the <span class="docEmphasis">R</span> different byte values) and perhaps at a few other levels (if there are keys with a common prefix and up to <span class="docEmphasis">R</span> different byte values on the character following the prefix), and to do only a few byte comparisons for most characters (since most trie nodes are sparsely populated with non-null links). Search misses are likely to involve only a few byte comparisons, ending at a null link high in the trie, and search hits involve only about one byte comparison per search key character, since most of them are in nodes with one-way branching at the bottom of the trie.</p>
<p class="docText">Actual space usage is generally less than the upper bound of three links per character, because keys share nodes at high levels in the tree. We refrain from a precise average-case analysis because TSTs are most useful in practical situations where keys neither are random nor are derived from bizarre worst-case constructions.</p>
</td></tr></table></p>
<p class="docText">The prime virtue of using TSTs is that they adapt gracefully to irregularities in search keys that are likely to appear in practical applications. There are two main effects. First, keys in practical applications come from large character sets, and usage of particular characters in the character sets is far from uniform&mdash;for example, a particular set of strings is likely to use only a small fraction of the possible characters. With TSTs, we can use a 128- or 256-character encoding without having to worry about the excessive costs of nodes with 128- or 256-way branching, and without having to determine which sets of characters are relevant. Character sets for non-Roman alphabets can have thousands of characters&mdash;TSTs are especially appropriate for string keys that consist of such characters. Second, keys in practical applications often have a structured format, differing from application to application, perhaps using only letters in one part of the key, only digits in another part of the key, and special characters as delimiters (see <a class="docLink" href="#ch15qa4q24">Exercise 15.72</a>). For example, <a class="docLink" href="#ch15fig18">Figure 15.18</a> gives a list of library call numbers from an online library database. For such keys, some of the trie nodes might be represented as unary nodes in the TST (for places where all keys have delimiters); some might be represented as 10-node BSTs (for places where all keys have digits); and still others might be represented as 26-node BSTs (for places where all keys have letters). This structure develops automatically, without any need for special analysis of the keys.</p>
<a name="ch15fig18"></a><p><center>
<h5 class="docFigureTitle">Figure 15.18. Sample string keys (library call numbers)</h5>
<h5></h5><h5></h5></center></p><p class="docText">These keys from an online library database illustrate the variability of the structure found in string keys in applications. Some of the characters may appropriately be modeled as random letters, some may be modeled as random digits, and still others have fixed value or structure.</p>
<p class="docText">
<img border="0" alt="" width="150" height="229" src="15fig18.gif" /></p>
<br />
<p class="docText">A second practical advantage of TST-based search over many other algorithms is that search misses are likely to be extremely efficient, even when the keys are long. Often, the algorithm uses just a few byte comparisons (and chases a few pointers) to complete a search miss. As we discussed in <a class="docLink" href="ch15lev1sec3.html#ch15lev1sec3">Section 15.3</a>, a search miss in a hash table with <span class="docEmphasis">N</span> keys requires time proportional to the key length (to compute the hash function), and at least <tt>lg</tt> <span class="docEmphasis">N</span> key comparisons in a search tree. Even patricia requires <tt>lg</tt> <span class="docEmphasis">N</span> bit comparisons for a random search miss.</p>
<p class="docText"></p><a name="ch15ex19"></a><h5 id="title-IDAIGI0B" class="docExampleTitle">Program 15.9. Partial-match searching in TSTs</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">With judicious use of multiple recursive calls, we can find close matches in a TST structure, as shown in this program for printing all strings in the data structure that match a search string with some characters unspecified (indicated by asterisks). We are not implementing a search ADT function or using abstract items here, so we use explicit C-style string-processing primitives.</p>
<div class="docText"><pre> private:
   char wordmaxW;
   void matchR(link h, char *v, int i)
     {
       if (h == 0) return;
       if ((*v == 0) &amp;&amp; (h-&gt;d == 0))
         { wordi = 0; cout &lt;&lt; word &lt;&lt; " "; }
       if ((*v == '*') || (*v == h-&gt;d))
         { wordi = h-&gt;d; matchR(h-&gt;m, v+1, i+1); }
       if ((*v == '*') || (*v &lt; h-&gt;d))
         matchR(h-&gt;l, v, i);
       if ((*v == '*') || (*v &gt; h-&gt;d))
        matchR(h-&gt;r, v, i);
     }
 public:
   void match(char *v)
     { matchR(head, v, 0); }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="ch15lev1sec3.html#ch15table02">Table 15.2</a> gives empirical data in support of the observations in the previous two paragraphs.</p>
<p class="docText">A third reason that TSTs are attractive is that they support operations more general than the symbol-table operations that we have been considering. For example, <a class="docLink" href="#ch15ex19">Program 15.9</a> gives a program that allows particular characters in the search key to be unspecified, and prints all keys in the data structure that match the specified digits of the search key. An example is depicted in <a class="docLink" href="#ch15fig19">Figure 15.19</a>. Obviously, with a slight modification, we can adapt this program to visit all the matching keys in the way that we do for <span class="docEmphasis">sort</span>, rather than just to print them (see <a class="docLink" href="#ch15qa4q10">Exercise 15.58</a>).</p>
<a name="ch15fig19"></a><p><center>
<h5 class="docFigureTitle">Figure 15.19. TST-based partial-match search</h5>
<h5></h5><h5></h5></center></p><p class="docText">To find all keys in a TST matching the pattern <tt>i*</tt> (top), we search for <tt>i</tt> in the BST for the first character. In this example, we find <tt>is</tt> (the only word that matches the pattern) after two one-way branches. For a less restrictive pattern such as <tt>*o*</tt> (bottom), we visit all nodes in the BST for the first character, but only those corresponding to <tt>o</tt> for the second character, eventually finding <tt>for</tt> and <tt>now</tt>.</p>
<p class="docText">
<img border="0" alt="" width="300" height="340" src="15fig19.gif" /></p>
<br />
<p class="docText">Several other similar tasks are easy to handle with TSTs. For example, we can visit all keys in the data structure that differ from the search key in at most one digit position (see <a class="docLink" href="#ch15qa4q11">Exercise 15.59</a>). Operations of this type are expensive or impossible with other symbol-table implementations. We shall consider in detail these and many other problems where we do not insist on exact matches in a string search, in Part 5.</p>
<p class="docText">Patricia offers several of the same advantages; the main practical advantage of TSTs over patricia tries is that the former access key bytes rather than key bits. One reason that this difference represents an advantage is that machine operations for this purpose are found in many machines, and C++ provides direct access to bytes in C-style character strings. Another reason is that, in some applications, working with bytes in the data structure naturally reflects the byte orientation of the data itself in some applications&mdash;for example, in the partial-match search problem discussed in the previous paragraph (although, as we shall see in Chapter 18, we can speed up partial-match search with judicious use of bit access).</p>
<p class="docText">To eliminate one-way branching in TSTs, we note that most of the one-way branching occurs at the tail ends of keys, and does not occur if we evolve to a standard multiway trie implementation, where we keep records in leaves that are placed in the highest level of the trie that distinguishes the keys. We also can maintain a byte index in the same manner as in patricia tries (see <a class="docLink" href="#ch15qa4q17">Exercise 15.65</a>), but will omit this change, for simplicity. The combination of multiway branching and the TST representation by themselves is quite effective in many applications, but patricia-style collapse of one-way branching will further enhance performance when the keys are such that they are likely to match for long stretches (see <a class="docLink" href="#ch15qa4q24">Exercise 15.72</a>).</p>
<p class="docText">Another easy improvement to TST-based search is to use a large explicit multiway node at the root. The simplest way to proceed is to keep a table of <span class="docEmphasis">R</span> TSTs: one for each possible value of the first letter in the keys. If <span class="docEmphasis">R</span> is not large, we might use the first two letters of the keys (and a table of size <span class="docEmphasis">R</span><sup>2</sup>). For this method to be effective, the leading digits of the keys must be well-distributed. The resulting hybrid search algorithm corresponds to the way that a human might search for names in a telephone book. The first step is a multiway decision (&quot;Let's see, it starts with 'A' &quot;), followed perhaps by some two-way decisions (&quot;It's before 'Andrews,' but after 'Aitken&quot;') followed by sequential character matching (&quot;'Algonquin,' ...No, 'Algorithms' isn't listed, because nothing starts with 'Algor'!&quot;).</p>
<p class="docText"></p><a name="ch15ex20"></a><h5 id="title-IDAWKI0B" class="docExampleTitle">Program 15.10. Hybrid TST node-type definitions</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This code defines data structures associated with <a class="docLink" href="#ch15ex21">Programs 15.11</a>and <a class="docLink" href="#ch15ex22">15.12</a>, for a symbol-table implementation using TSTs. We use <span class="docEmphasis">R</span>-way branching at the root node: the root is an array <tt>heads</tt> of <span class="docEmphasis">R</span> links, indexed by the first digits of the keys. Each link points to a TST built from all the keys that begin with the corresponding digits. This hybrid combines the benefits of tries (fast search through indexing, at the root) and TSTs (efficient use of space with one node per character, except at the root).</p>
<div class="docText"><pre>struct node
  { Item item; int d; node *l, *m, *r;
    node(Item x, int k)
      { item = x; d = k; l = 0; m = 0; r = 0; }
    node(node* h, int k)
      { d = k; l = 0; m = h; r = 0; }
    int internal()
      { return d != NULLdigit; }
   };
typedef node *link;
link heads[R];
Item nullItem;</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch15ex20">Programs 15.10</a> through <a class="docLink" href="#ch15ex22">15.12</a> comprise a TST-based implementation of the symbol-table <span class="docEmphasis">search</span> and <span class="docEmphasis">insert</span> operations that uses <span class="docEmphasis">R</span>-way branching at the root and that keeps items in leaves (so there is no oneway branching once the keys are distinguished). These programs are likely to be among the fastest available for searching with string keys. The underlying TST structure can also support a host of other operations.</p>
<p class="docText">In a symbol table that grows to be huge, we may want to adapt the branching factor to the table size. In <a class="docLink" href="ch16.html#ch16">Chapter 16</a>, we shall see a systematic way to grow a multiway trie so that we can take advantage of multiway radix search for arbitrary file sizes.</p>
<p class="docText"></p><a name="ch15ex21"></a><h5 id="title-IDAANI0B" class="docExampleTitle">Program 15.11. Hybrid TST insertion for symbol-table ADT</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This implementation of <span class="docEmphasis">insert</span> using TSTs keeps items in leaves, generalizing <a class="docLink" href="ch15lev1sec2.html#ch15ex05">Program 15.3</a>. We use <span class="docEmphasis">R</span>-way branching for the first character and a separate TST for all words beginning with each character. If the search ends at a null link, we create a leaf to hold the item. If the search ends in a leaf, we create the internal nodes needed to distinguish the key found from the search key.</p>
<div class="docText"><pre>private:
  link split(link p, link q, int d)
    { int pd = digit(p-&gt;item.key(), d),
          qd = digit(q-&gt;item.key(), d);
      link t = new node(nullItem, qd);
      if (pd &lt; qd)
        { t-&gt;m = q; t-&gt;l = new node(p, pd); }
      if (pd == qd)
        { t-&gt;m = split(p, q, d+1); }
      if (pd &gt; qd)
        { t-&gt;m = q; t-&gt;r = new node(p, pd); }
      return t;
    }
  link newext(Item x)
    { return new node(x, NULLdigit); }
  void insertR(link&amp; h, Item x, int d)
    { int i = digit(x.key(), d);
      if (h == 0)
        { h = new node(newext(x), i); return; }
      if (!h-&gt;internal())
        { h = split(newext(x), h, d); return; }
      if (i &lt; h-&gt;d) insertR(h-&gt;l, x, d);
      if (i == h-&gt;d) insertR(h-&gt;m, x, d+1);
      if (i &gt; h-&gt;d) insertR(h-&gt;r, x, d);
    }
public:
  ST(int maxN)
    { for (int i = 0; i &lt; R; i++) headsi = 0; }
  void insert(Item x)
    { insertR(heads[digit(x.key(), 0)], x, 1); }</pre></div><br />
</td></tr></table></p>
<p class="docText"></p><a name="ch15ex22"></a><h5 id="title-IDAFOI0B" class="docExampleTitle">Program 15.12. Hybrid TST search for symbol-table ADT</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This <span class="docEmphasis">search</span> implementation for TSTs (built with <a class="docLink" href="#ch15ex21">Program 15.11</a>) is like multiway-trie search, but we use only three, rather than <span class="docEmphasis">R</span>, links per node (except at the root). We use the digits of the key to travel down the tree, ending either at a null link (search miss) or at a leaf that has a key that either is (search hit) or is not (search miss) equal to the search key.</p>
<div class="docText"><pre>private:
  Item searchR(link h, Key v, int d)
    { if (h == 0) return nullItem;
      if (h-&gt;internal())
        { int i = digit(v, d), k = h-&gt;d;
          if (i &lt; k) return searchR(h-&gt;l, v, d);
          if (i == k) return searchR(h-&gt;m, v, d+1);
          if (i &gt; k) return searchR(h-&gt;r, v, d);
        } 
      if (v == h-&gt;item.key()) return h-&gt;item;
      return nullItem;
    }
public:
  Item search(Key v)
    { return searchR(heads[digit(v, 0)], v, 1); }</pre></div><br />
</td></tr></table></p>
<a name="ch15ex23"></a><h5 id="title-IDAJPI0B" class="docExampleTitle">Property 15.8. <span class="docEmphasis">A search or insertion in a TST with items in leaves (no one-way branching at the bottom) and R<sup>t</sup>-way branching at the root requires roughly</span> <span class="docEmphRoman">ln</span> <span class="docEmphasis">N&mdash;t</span> <span class="docEmphRoman">ln</span> <span class="docEmphasis">R byte accesses for Nkeys that are random bytestrings. The number of links required is R<sup>t</sup> (for the root node) plus a small constant times N</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">These rough estimates follow immediately from <a class="docLink" href="#ch15ex16">Property 15.6</a>. For the time cost, we assume that all but a constant number of the nodes on the search path (a few at the top) act as random BSTs on <span class="docEmphasis">R</span> character values, so we simply multiply the time cost by ln <span class="docEmphasis">R</span>. For the space cost, we assume that the nodes on the first few levels are filled with <span class="docEmphasis">R</span>  character values, and that the nodes on the bottom levels have only a constant number of character values.</p>
</td></tr></table></p>
<p class="docText">For example, if we have 1 billion random bytestring keys with <span class="docEmphasis">R</span> <tt>= 256</tt>, and we use a table of size <span class="docEmphasis">R<sup>2</sup></span> <tt>= 65536</tt> at the top, then a typical search will require about ln<tt>10<sup>9</sup> &ndash; 2 ln 256<img src="U2248.GIF" border="0" /> 20.7 &ndash; 11.1 = 9.6</tt> byte comparisons. Using the table at the top cuts the search cost by a factor of 2. If we have truly random keys, we can achieve this performance with more direct algorithms that use the leading bytes in the key and an existence table, in the manner discussed in <a class="docLink" href="ch14lev1sec6.html#ch14lev1sec6">Section 14.6</a>. With TSTs, we can get the same kind of performance when keys have a less random structure.</p>
<p class="docText">It is instructive to compare TSTs without multiway branching at the root with standard BSTs, for random keys. <a class="docLink" href="#ch15ex23">Property 15.8</a> says that TST search will require about <tt>ln</tt> <span class="docEmphasis">N</span> <span class="docEmphasis">byte</span> comparisons, whereas standard BSTs require about <tt>ln</tt> <span class="docEmphasis">N key</span> comparisons. At the top of the BST, the key comparisons can be accomplished with just one byte comparison, but at the bottom of the tree multiple byte comparisons may be needed to accomplish a key comparison. This performance difference is not dramatic. The reasons that TSTs are preferable to standard BSTs for string keys are that they provide a fast search miss; they adapt directly to multiway branching at the root; and (most important) they adapt well to bytestring keys that are <span class="docEmphasis">not</span> random, so no search takes longer than the length of a key in a TST.</p>
<p class="docText">Some applications may not benefit from the <span class="docEmphasis">R</span>-way branching at the root&mdash;for example, the keys in the library-call-number example of <a class="docLink" href="#ch15fig18">Figure 15.18</a> all begin with either <tt>L</tt> or <tt>W</tt>. Other applications may call for a higher branching factor at the root&mdash;for example, as just noted, if the keys were random integers, we would use as large a table as we could afford. We can use application-specific dependencies of this sort to tune the algorithm to peak performance, but we should not lose sight of the fact that one of the most attractive features of TSTs is that TSTs free us from having to worry about such application-specific dependencies, providing good performance without any tuning.</p>
<p class="docText">Perhaps the most important property of tries or TSTs with records in leaves is that their performance characteristics are <span class="docEmphasis">independent</span> of the key length. Thus, we can use them for arbitrarily long keys. In <a class="docLink" href="ch15lev1sec5.html#ch15lev1sec5">Section 15.5</a>, we examine a particularly effective application of this kind.</p>
</div></td></tr></table>
<p class="docText">&nbsp;<a name="iddle2512"></a><a name="iddle1448"></a><a name="iddle2578"></a><a name="iddle2514"></a><a name="iddle2587"></a><a name="iddle1727"></a><a name="iddle2454"></a><a name="iddle2518"></a><a name="iddle2521"></a><a name="iddle2515"></a><a name="iddle2516"></a><a name="iddle2498"></a><a name="iddle2519"></a><a name="iddle2517"></a><a name="iddle1191"></a><a name="iddle2513"></a></p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q1"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">15.49</span> Draw the existence trie that results when you insert the words <tt>now is the time for all good people to come the aid of their party</tt> into an initially empty trie. Use 27-way branching.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q2"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">15.50</span> Draw the existence TST that results when you insert the words <tt>now is the time for all good people to come the aid of their party</tt> into an initially empty TST.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q3"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">15.51</span> Draw the 4-way trie that results when you insert items with the keys <tt>01010011 00000111 00100001 01010001 11101100 00100001 10010101 0100-1010</tt> into an initially empty trie, using 2-bit bytes.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q4"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">15.52</span> Draw the TST that results when you insert items with the keys <tt>01010011 00000111 00100001 01010001 11101100 00100001 10010101 01001010</tt> into an initially empty TST, using 2-bit bytes.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q5"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">15.53</span> Draw the TST that results when you insert items with the keys <tt>01010011 00000111 00100001 01010001 11101100 00100001 10010101 01001010</tt> into an initially empty TST, using 4-bit bytes.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q6"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">15.54</span> Draw the TST that results when you insert items with the library-call-number keys in <a class="docLink" href="#ch15fig18">Figure 15.18</a> into an initially empty TST.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q7"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">15.55</span> Modify our multiway-trie search and insertion implementation (<a class="docLink" href="#ch15ex15">Program 15.7</a>) to work under the assumption that keys are (fixed-length) <span class="docEmphasis">w</span>-byte words (so no end-of-key indication is necessary).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q8"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">15.56</span> Modify our TST search and insertion implementation (<a class="docLink" href="#ch15ex17">Program 15.8</a>) to work under the assumption that keys are (fixed-length) <span class="docEmphasis">w</span>-byte words (so no end-of-key indication is necessary).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q9"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.57</span> Run empirical studies to compare the time and space requirements of an 8-way trie built with random integers using 3-bit bytes, a 4-way trie built with random integers using 2-bit bytes, and a binary trie built from the same keys, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt> (see <a class="docLink" href="ch15lev1sec2.html#ch15qa2q4">Exercise 15.14</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q10"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.58</span> Modify <a class="docLink" href="#ch15ex19">Program 15.9</a> such that it visits, in the same manner as <span class="docEmphasis">sort</span>, all the nodes that match the search key.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q11"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">15.59</span> Write a function that prints all the keys in a TST that differ from the search key in at most <tt>k</tt> positions, for a given integer <tt>k</tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q12"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">15.60</span> Give a full characterization of the worst-case internal path length of an <span class="docEmphasis">R</span>-way trie with <span class="docEmphasis">N</span> distinct <span class="docEmphasis">w</span>-bit keys.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q13"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">15.61</span> Develop a symbol-table implementation using multiway tries that includes a destructor, a copy constructor, and an overloaded assignment operator, and supports the <span class="docEmphasis">construct</span>, <span class="docEmphasis">count</span>, <span class="docEmphasis">search</span>, <span class="docEmphasis">insert</span>, <span class="docEmphasis">remove</span>, and <span class="docEmphasis">join</span> operations for a first-class symbol-table ADT, with support for client handles (see <a class="docLink" href="ch12lev1sec1.html#ch12qa1q6">Exercises 12.6</a> and <a class="docLink" href="ch12lev1sec1.html#ch12qa1q7">12.7</a>).</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q14"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">15.62</span> Develop a symbol-table implementation using TSTs that includes a destructor, a copy constructor, and an overloaded assignment operator, and supports the <span class="docEmphasis">construct</span>, <span class="docEmphasis">count</span>, <span class="docEmphasis">search</span>, <span class="docEmphasis">insert</span>, <span class="docEmphasis">remove</span>, and <span class="docEmphasis">join</span> operations for a first-class symbol-table ADT, with support for client handles (see <a class="docLink" href="ch12lev1sec1.html#ch12qa1q6">Exercises 12.6</a> and <a class="docLink" href="ch15lev1sec1.html#ch15qa1q7">12.7</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q15"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">15.63</span> Write a program that prints out all keys in an <span class="docEmphasis">R</span>-way trie that have the same initial t bytes as a given search key.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q16"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">15.64</span> Modify our multiway-trie search and insertion implementation (<a class="docLink" href="#ch15ex15">Program 15.7</a>) to eliminate one-way branching in the way that we did for patricia tries.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q17"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">15.65</span> Modify our TST search and insertion implementation (<a class="docLink" href="#ch15ex17">Program 15.8</a>) to eliminate one-way branching in the way that we did for patricia tries.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q18"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.66</span> Write a program to balance the BSTs that represent the internal nodes of a TST (rearrange them such that all their external nodes are on one of two levels).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q19"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.67</span> Write a version of <span class="docEmphasis">insert</span> for TSTs that maintains a balanced-tree representation of all the internal nodes (see <a class="docLink" href="#ch15qa4q18">Exercise 15.66</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q20"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">15.68</span> Give a full characterization of the worst-case internal path length of a TST with <span class="docEmphasis">N</span> distinct <span class="docEmphasis">w</span>-bit keys.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q21"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.69</span> Write a program that generates random 80-byte string keys (see <a class="docLink" href="ch10lev1sec3.html#ch10qa3q6">Exercise 10.19</a>). Use this key generator to build a 256-way trie with <span class="docEmphasis">N</span> random keys, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>, using <span class="docEmphasis">search</span>, then <span class="docEmphasis">insert</span> on search miss. Instrument your program to print out the total number of nodes in each trie and the total amount of time taken to build each trie.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q22"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.70</span> Answer <a class="docLink" href="#ch15qa4q21">Exercise 15.69</a> for TSTs. Compare your performance results with those for tries.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q23"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.71</span> Write a key generator that generates keys by shuffling a random 80-byte sequence (see <a class="docLink" href="ch10lev1sec3.html#ch10qa3q8">Exercise 10.21</a>). Use this key generator to build a 256-way trie with <span class="docEmphasis">N</span> random keys, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>, using <span class="docEmphasis">search</span>, then <span class="docEmphasis">insert</span> on search miss. Compare your performance results with those for the random case (see <a class="docLink" href="#ch15qa4q21">Exercise 15.69</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q24"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">15.72</span> Write a key generator that generates 30-byte random strings made up of three fields: a 4-byte field with one of a set of 10 given strings; a 10-byte field with one of a set of 50 given strings; a 1-byte field with one of two given values; and a 15-byte field with random left-justified strings of letters equally likely to be four through 15 characters long (see <a class="docLink" href="ch10lev1sec3.html#ch10qa3q10">Exercise 10.23</a>). Use this key generator to build a 256-way trie with <span class="docEmphasis">N</span> random keys, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>, using <span class="docEmphasis">search</span>, then <span class="docEmphasis">insert</span> on search miss. Instrument your program to print out the total number of nodes in each trie and the total amount of time taken to build each trie. Compare your performance results with those for the random case (see <a class="docLink" href="#ch15qa4q21">Exercise 15.69</a>).</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q25"></a><b></b></td><td><p class="docText"><a name="iddle1644"></a><a name="iddle1728"></a><a name="iddle2455"></a><a name="iddle2474"></a><a name="iddle2522"></a><a name="iddle2566"></a><a name="iddle2588"></a><span class="docEmphStrong">15.73</span> Answer <a class="docLink" href="#ch15qa4q24">Exercise 15.72</a> for TSTs. Compare your performance results with those for tries.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q26"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.74</span> Develop an implementation of <span class="docEmphasis">search</span> and <span class="docEmphasis">insert</span> for bytestring keys using multiway <span class="docEmphasis">digital</span> search trees.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q27"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">15.75</span> Draw the 27-way DST (see <a class="docLink" href="#ch15qa4q26">Exercise 15.74</a>) that results when you insert items with the keys <tt>now is the time for all good people to come the aid of their party</tt> into an initially empty DST.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa4q28"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">15.76</span> Develop an implementation of multiway-trie search and insertion using linked lists to represent the trie nodes (as opposed to the BST representation that we use for TSTs). Run empirical studies to determine whether it is more efficient to use ordered or unordered lists, and to compare your implementation with a TST-based implementation.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></body></head></html>