<html><head><title>15.2. Tries</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch15lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch15lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch15lev1sec2"></a>
<h3 id="title-IDABJE0B" class="docSection1Title">15.2. Tries</h3>
<p class="docText">In this section, we consider a search tree that allows us to use the bits of the keys to guide the search, in the same way that DSTs do, but that keeps the keys in the tree in order, so that we can support recursive implementations of <span class="docEmphasis">sort</span> and other symbol-table functions, as we did for BSTs. The idea is to store keys only at the bottom of the tree, in leaf nodes. The resulting data structure has a number of useful properties and serves as the basis for several effective search algorithms. It was first discovered by de la Briandais in 1959, and, because it is useful for re<span class="docEmphasis">trie</span>val, it was given the name <span class="docEmphasis">trie</span> by Fredkin in 1960. Ironically, in conversation, we usually pronounce this word &quot;try-ee&quot; or just &quot;try,&quot; so as to distinguish it from &quot;tree.&quot; For consistency with the nomenclature that we have been using, we perhaps should use the name &quot;binary search trie,&quot; but the term <span class="docEmphasis">trie</span> is universally used and understood. We consider the basic binary version in this section, an important variation in <a class="docLink" href="ch15lev1sec3.html#ch15lev1sec3">Section 15.3</a>, and the basic multiway version and variations in <a class="docLink" href="ch15lev1sec4.html#ch15lev1sec4">Sections 15.4</a> and <a class="docLink" href="ch15lev1sec5.html#ch15lev1sec5">15.5</a>.</p>
<p class="docText">We can use tries for keys that are either a fixed number of bits or are variable-length bitstrings. To simplify the discussion, we start by <a name="iddle1730"></a><a name="iddle1754"></a><a name="iddle1956"></a><a name="iddle2576"></a><a name="iddle2584"></a>assuming that no search key is the prefix of another. For example, this condition is satisfied when the keys are of fixed length and are distinct.</p>
<p class="docText">In a trie, we keep the keys in the <span class="docEmphasis">leaves</span> of a binary tree. Recall from <a class="docLink" href="ch05lev1sec4.html#ch05lev1sec4">Section 5.4</a> that a leaf in a tree is a node with no children, as distinguished from an external node, which we interpret as a null child. In a binary tree, a leaf is an internal node whose left and right links are both null. Keeping keys in leaves instead of internal nodes allows us to use the bits of the keys to guide the search, as we did with DSTs in <a class="docLink" href="ch15lev1sec1.html#ch15lev1sec1">Section 15.1</a>, while still maintaining the basic invariant at each node that all keys whose current bit is 0 fall in the left subtree and all keys whose current bit is 1 fall in the right subtree.</p>
<a name="ch15ex03"></a><h5 id="title-IDAPME0B" class="docExampleTitle">Definition 15.1. A <span class="docEmphasis">trie</span> is a binary tree that has keys associated with each of its leaves, defined recursively as follows: The trie for an empty set of keys is a null link; the trie for a single key is a leaf containing that key; and the trie for a set of keys of cardinality greater than one is an internal node with left link referring to the trie for the keys whose initial bit is 0 and right link referring to the trie for the keys whose initial bit is 1, with the leading bit considered to be removed for the purpose of constructing the subtrees</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">Each key in the trie is stored in a leaf, on the path described by the leading bit pattern of the key. Conversely, each leaf contains the only key in the trie that begins with the bits defined by the path from the root to that leaf. Null links in nodes that are not leaves correspond to leading-bit patterns that do not appear in any key in the trie. Therefore, to search for a key in a trie, we just branch according to its bits, as we did with DSTs, but we do not do comparisons at internal nodes. We start at the left of the key and the top of the trie, and take the left link if the current bit is 0 and the right link if the current bit is 1, moving one bit position to the right in the key. A search that ends on a null link is a miss; a search that ends on a leaf can be completed with one key comparison, since that node contains the only key in the trie that could be equal to the search key. <a class="docLink" href="#ch15ex04">Program 15.2</a> is an implementation of this process.</p>
<p class="docText">To insert a key into a trie, we first perform a search, as usual. If the search ends on a null link, we replace that link with a link to a new leaf containing the key, as usual. But if the search ends on a leaf, we need to continue down the trie, adding an internal node for every bit where the search key and the key that was found agree, ending with both keys in leaves as children of the internal node corresponding to the first bit position where they differ. <a class="docLink" href="#ch15fig06">Figure 15.6</a> gives an example of trie search and insertion; <a class="docLink" href="#ch15fig07">Figure 15.7</a> shows the process of constructing a trie by inserting keys into an initially empty trie. <a class="docLink" href="#ch15ex05">Program 15.3</a> is a full implementation of the insertion algorithm.</p>
<a name="ch15fig06"></a><p><center>
<h5 class="docFigureTitle">Figure 15.6. Trie search and insertion</h5>
<h5></h5><h5></h5></center></p><p class="docText">Keys in a trie are stored in leaves (nodes with both links null); null links in nodes that are not leaves correspond to bit patterns not found in any keys in the trie.</p><h5></h5><p class="docText">In a successful search for the key <tt>H = 01000</tt> in this sample trie (top), we move left at the root (since the first bit in the binary representation of the key is <tt>0</tt>), then right (since the second bit is <tt>1</tt>), where we find <tt>H</tt>, which is the only key in the tree that begins with <tt>01</tt>. None of the keys in the trie begin with <tt>101</tt> or <tt>11</tt>; these bit patterns lead to the two null links in the trie that are in non-leaf nodes.</p><h5></h5><p class="docText">To insert <tt>I</tt> (bottom), we need to add three non-leaf nodes: one corresponding to <tt>01</tt>, with a null link corresponding to <tt>011</tt>; one corresponding to <tt>010</tt>, with a null link corresponding to <tt>0101</tt>; and one corresponding to <tt>0100</tt> with <tt>H = 01000</tt> in a leaf on its left and <tt>I = 01001</tt> in a leaf on its right.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="175" height="166" src="15fig06.gif" /></p>
</td></tr></table></p><br />
<a name="ch15fig07"></a><p><center>
<h5 class="docFigureTitle">Figure 15.7. Trie construction</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts the result of inserting the keys A S E R C H I N into an initially empty trie.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="175" height="558" src="15fig07.gif" /></p>
<br />
<a name="ch15ex04"></a><h5 id="title-IDA4QE0B" class="docExampleTitle">Program 15.2. Trie search</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This function uses the bits of the key to control the branching on the way down the trie, in the same way as in <a class="docLink" href="ch15lev1sec1.html#ch15ex01">Program 15.1</a> for DSTs. There are three possible outcomes: if the search reaches a leaf (with both links null), then that is the unique node in the trie that could contain the record with key v, so we test whether that node indeed contains v (search hit) or some key whose leading bits match v (search miss). If the search reaches a null link, then the parent's other link must not be null, so there is some other key in the trie that differs from the search key in the corresponding bit, and we have a search miss. This code assumes that the keys are distinct, and (if the keys may be of different lengths) that no key is a prefix of another. The <tt>item</tt> member is not used in non-leaf nodes.</p>
<div class="docText"><pre>  private:
    Item searchR(link h, Key v, int d)
      { if (h == 0) return nullItem;
        if (h-&gt;l == 0 &amp;&amp; h-&gt;r == 0)
          { Key w = h-&gt;item.key();
             return (v == w) ? h-&gt;item : nullItem; }
        if (digit(v, d) == 0)
             return searchR(h-&gt;l, v, d+1);
        else return searchR(h-&gt;r, v, d+1);
     }
  public:
    Item search(Key v)
      { return searchR(head, v, 0); }</pre></div><br />
</td></tr></table></p>
<p class="docText">We do not access null links in leaves, and we do not store items in non-leaf nodes, so we could save space by using <tt>union</tt> or a pair of derived classes to define nodes as being one of these two types (see <a class="docLink" href="#ch15qa2q10">Exercises 15.20</a> and <a class="docLink" href="#ch15qa2q11">15.21</a>). For the moment, we will take the simpler route of using the single node type that we have been using for BSTs, DSTs, and other binary tree structures, with internal nodes characterized by null keys and leaves characterized by null links, knowing that we could reclaim the space wasted because of this simplification, if desired. In <a class="docLink" href="ch15lev1sec3.html#ch15lev1sec3">Section 15.3</a>, we will see an algorithmic improvement that avoids the need for multiple node types, and in <a class="docLink" href="ch16.html#ch16">Chapter 16</a>, we will examine an implementation that uses <tt>union</tt>.</p>
<a name="ch15ex05"></a><h5 id="title-IDAFTE0B" class="docExampleTitle">Program 15.3. Trie insertion</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">To insert a new node into a trie, we search as usual, then distinguish the two cases that can occur for a search miss.</p>
<p class="docText">If the miss was not on a leaf, then we replace the null link that caused us to detect the miss with a link to a new node, as usual.</p>
<p class="docText">If the miss was on a leaf, then we use a function <tt>split</tt> to make one new internal node for each bit position where the search key and the key found agree, finishing with one internal node for the leftmost bit position where the keys differ. The <tt>switch</tt> statement in <tt>split</tt> converts the two bits that it is testing into a number to handle the four possible cases. If the bits are the same (case <tt>00<sub>2</sub></tt> = <tt>0</tt> or <tt>11<sub>2</sub></tt> = <tt>3</tt>), then we continue splitting; if the bits are different (<tt>case 01<sub>2</sub></tt> = <tt>1</tt> or <tt>10<sub>2</sub></tt> = <tt>2</tt>), then we stop splitting.</p>
<div class="docText"><pre>  private:
   link split(link p, link q, int d)
     { link t = new node(nullItem); t-&gt;N = 2;
       Key v = p-&gt;item.key(); Key w = q-&gt;item.key();
       switch(digit(v, d)*2 + digit(w, d))
         { case 0: t-&gt;l = split(p, q, d+1); break;
           case 1: t-&gt;l = p; t-&gt;r = q; break;
           case 2: t-&gt;r = p; t-&gt;l = q; break;
           case 3: t-&gt;r = split(p, q, d+1); break;
         }
       return t;
     }
   void insertR(link&amp; h, Item x, int d)
     { if (h == 0) { h = new node(x); return; }
       if (h-&gt;l == 0 &amp;&amp; h-&gt;r == 0)
         { h = split(new node(x), h, d); return; }
       if (digit(x.key(), d) == 0)
            insertR(h-&gt;l, x, d+1);
       else insertR(h-&gt;r, x, d+1);
     }
 public:
  ST(int maxN)
    { head = 0; }
  void insert(Item item)
    { insertR(head, item, 0); }</pre></div><br />
</td></tr></table></p>
<p class="docText">We now shall consider a number of basic of properties of tries, which are evident from the definition and these examples.</p>
<a name="ch15ex06"></a><h5 id="title-IDADVE0B" class="docExampleTitle">Property 15.2. <span class="docEmphasis">The structure of a trie is independent of the key insertion order: There is a unique trie for any given set of distinct keys</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This fundamental fact, which we can prove by induction on the subtrees, is a distinctive feature of tries: for all the other search tree structures that we have considered, the tree that we construct depends <span class="docEmphasis">both</span> on the set of keys <span class="docEmphasis">and</span> on the order in which we insert those keys.</p>
</td></tr></table></p>
<p class="docText">The left subtree of a trie has all the keys that have 0 for the leading bit; the right subtree has all the keys that have 1 for the leading bit. This property of tries leads to an immediate correspondence with radix sorting: binary trie search partitions the file in exactly the same way as does binary quicksort (see <a class="docLink" href="ch10lev1sec2.html#ch10lev1sec2">Section 10.2</a>). This correspondence is evident when we compare the trie in <a class="docLink" href="#ch15fig06">Figure 15.6</a> with <a class="docLink" href="ch10lev1sec2.html#ch10fig04">Figure 10.4</a>, the partitioning diagram for binary quicksort (after noting that the keys are slightly different); it is analogous to the correspondence between binary tree search and quicksort that we noted in <a class="docLink" href="ch12.html#ch12">Chapter 12</a>.</p>
<p class="docText">In particular, unlike DSTs, tries <span class="docEmphasis">do</span> have the property that keys appear in order, so we can implement the <span class="docEmphasis">sort</span> and <span class="docEmphasis">select</span> symbol-table operations in a straightforward manner (see <a class="docLink" href="#ch15qa2q7">Exercises 15.17</a> and <a class="docLink" href="#ch15qa2q8">15.18</a>). Moreover, tries are as well-balanced as DSTs.</p>
<a name="ch15ex07"></a><h5 id="title-IDAPXE0B" class="docExampleTitle">Property 15.3. <span class="docEmphasis">Insertion or search for a random key in a trie built from N random (distinct) bitstrings requires about</span> <span class="docEmphRoman">lg</span> <span class="docEmphasis">N bit comparisons on the average. The worst-case number of bit comparisons is bounded only by the number of bits in the search key</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">We need to exercise care in analyzing tries because of our insistence that the keys be distinct, or, more generally, that no key be a prefix of another. One simple model that accommodates this assumption requires the keys to be a random (infinite) sequence of bits&mdash;we take the bits that we need to build the trie.</p>
<p class="docText">The average-case result then comes from the following probabilistic argument. The probability that each of the <span class="docEmphasis">N</span> keys in a random trie differ from a random search key in at least one of the leading <span class="docEmphasis">t</span> bits is</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="65" height="30" src="633equ01.jpg" /></p>
<p class="docText">Subtracting this quantity from 1 gives the probability that one of the keys in the trie matches the search key in all of the leading t bits. In other words,</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="100" height="34" src="633equ02.jpg" /></p>
<p class="docText">is the probability that the search requires more than <span class="docEmphasis">t</span> bit comparisons. From elementary probabilistic analysis, the sum for <span class="docEmphasis">t</span> <img src="U2265.GIF" border="0" /> 0 of the probabilities that a random variable is &gt; <span class="docEmphasis">t</span> is the average value of that random variable, so the average search cost is given by</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="160" height="49" src="633equ03.jpg" /></p>
<p class="docText">Using the elementary approximation (1 &ndash; 1/<span class="docEmphasis">x</span>)<span class="docEmphasis"><sup>x</sup></span> ~ <span class="docEmphasis">e</span><sup>&ndash;1</sup>, we find the search cost to be approximately</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="140" height="48" src="633equ04.jpg" /></p>
<p class="docText">The summand is extremely close to 1 for approximately <tt>lg</tt> <span class="docEmphasis">N</span> terms with <tt>2</tt><span class="docEmphasis"><tt><sup>t</sup></tt></span> substantially smaller than <span class="docEmphasis">N</span>; it is extremely close to 0 for all the terms with <tt>2</tt><span class="docEmphasis"><tt><sup>t</sup></tt></span> substantially greater than <span class="docEmphasis">N</span>; and it is somewhere between 0 and 1 for the few terms with <tt>2</tt><span class="docEmphasis"><tt><sup>t</sup></tt></span> <img src="U2248.GIF" border="0" /> <span class="docEmphasis">N</span>. So the grand total is about <tt>lg</tt> <span class="docEmphasis">N</span>. Computing a more precise estimate of this quantity requires using extremely sophisticated mathematics (<span class="docEmphasis">see reference section</span>). This analysis assumes that <span class="docEmphasis">w</span> is sufficiently large that we never run out of bits during a search, but taking into account the true value of <span class="docEmphasis">w</span> will only reduce the cost.</p>
<p class="docText">In the worst case, we could get two keys that have a huge number of equal bits, but this event happens with vanishingly small probability. The probability that the worst-case result quoted in <a class="docLink" href="#ch15ex07">Property 15.3</a> will not hold is exponentially small (see <a class="docLink" href="#ch15qa2q19">Exercise 15.29</a>).</p>
</td></tr></table></p>
<p class="docText">Another approach to analyzing tries is to generalize the approach that we used to analyze BSTs (see <a class="docLink" href="ch12lev1sec6.html#ch12ex18">Property 12.6</a>). The probability that <span class="docEmphasis">k</span> keys start with a 0 bit and <span class="docEmphasis">N &ndash; k</span> keys start with a 1 bit is

<img border="0" alt="" width="50" height="21" src="634inlineequ01.jpg" />



so the external path length is described by the recurrence</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="275" height="42" src="634equ01.jpg" /></p>
<p class="docText">This recurrence is similar to the quicksort recurrence that we solved in <a class="docLink" href="ch07lev1sec2.html#ch07lev1sec2">Section 7.2</a>, but it is much more difficult to solve. Remarkably, the solution is precisely <span class="docEmphasis">N</span> times the expression for the average search cost that we derived for <a class="docLink" href="#ch15ex07">Property 15.3</a> (see <a class="docLink" href="#ch15qa2q16">Exercise 15.26</a>). Studying the recurrence itself gives insight into why tries have better balance than do BSTs: The probability is much higher that the split will be near the middle than that it will be anywhere else, so the recurrence is more like the mergesort recurrence (approximate solution <span class="docEmphasis"><tt>N</tt></span> <tt>lg</tt> <span class="docEmphasis"><tt>N</tt></span>) than like the quicksort recurrence (approximate solution <span class="docEmphasis"><tt>2N</tt></span> <tt>ln</tt> <span class="docEmphasis"><tt>N</tt></span>).</p>
<p class="docText">An annoying feature of tries, and another one that distinguishes them from the other types of search trees that we have seen, is the oneway branching required when keys have bits in common. For example, keys that differ in only the final bit always require a path whose length is equal to the key length, no matter how many keys there are in the tree, as illustrated in <a class="docLink" href="#ch15fig08">Figure 15.8</a>. The number of internal nodes can be somewhat larger than the number of keys.</p>
<a name="ch15fig08"></a><p><center>
<h5 class="docFigureTitle">Figure 15.8. Binary trie worst case</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sequence depicts the result of inserting the keys H = 01000 and I = 01001 into an initially empty binary trie. As it is in DSTs (see <a class="docLink" href="ch15lev1sec1.html#ch15fig04">Figure 15.4</a>), the path length is limited by the length of the binary representation of the keys; as illustrated by this example, however, paths could be that long even with only two keys in the trie.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="100" height="107" src="15fig08.gif" /></p>
<br />
<a name="ch15ex08"></a><h5 id="title-IDAGAF0B" class="docExampleTitle">Property 15.4. <span class="docEmphasis">A trie built from N random w-bit keys has about N/</span> <span class="docEmphRoman">ln 2<img src="U2248.GIF" border="0" /> 1.44</span><span class="docEmphasis">N nodes on the average</span></h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">By modifying the argument for <a class="docLink" href="#ch15ex07">Property 15.3</a>, we can write the expression</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="300" height="46" src="634equ02.jpg" /></p>
<p class="docText">for the average number of nodes in an <span class="docEmphasis">N</span>-key trie (see <a class="docLink" href="#ch15qa2q17">Exercise 15.27</a>). The mathematical analysis that yields the stated approximate value for this sum is much more difficult than the argument that we gave for <a class="docLink" href="#ch15ex07">Property 15.3</a>, because many terms contribute values that are not 0 or 1 to the value of the sum (<span class="docEmphasis">see reference section</span>).</p>
</td></tr></table></p>
<p class="docText">We can verify these results empirically. For example, <a class="docLink" href="#ch15fig09">Figure 15.9</a> shows a big trie, which has 44 percent more nodes than does the BST or the DST built with the same set of keys but nevertheless is well balanced, with a near-optimal search cost. Our first thought might be that the extra nodes would raise the average search cost substantially, but this suspicion is not valid&mdash;for example, we would increase the average search cost by only 1 even if we were to double the number of nodes in a balanced trie.</p>
<a name="ch15fig09"></a><p><center>
<h5 class="docFigureTitle">Figure 15.9. Trie example</h5>
<h5></h5><h5></h5></center></p><p class="docText">This trie, built by inserting about 200 random keys, is well-balanced, but has 44 percent more nodes than might otherwise be necessary, because of one-way branching. (Null links on leaves are not shown.)</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="450" height="85" src="15fig09.gif" /></p>
<br />
<p class="docText">For convenience in the implementations in <a class="docLink" href="#ch15ex04">Programs 15.2</a> and <a class="docLink" href="#ch15ex05">15.3</a>, we assumed that the keys are of fixed length and are distinct, so that we could be certain that the keys would eventually distinguish themselves and that the programs could process 1 bit at a time and never run out of key bits. For convenience in the analyses in <a class="docLink" href="#ch15ex06">Properties 15.215.2</a>and <a class="docLink" href="#ch15ex07">15.3</a>, we implicitly assumed that the keys have an arbitrary number of bits, so that they eventually distinguish themselves except with tiny (exponentially decaying) probability. A direct off-shoot of these assumptions is that both the programs and the analyses apply when the keys are variable-length bitstrings, with a few caveats.</p>
<p class="docText">To use the programs as they stand for variable-length keys, we need to extend our restriction that the keys be distinct to say that no key be a prefix of another. This restriction is met automatically in some applications, as we shall see in <a class="docLink" href="ch15lev1sec5.html#ch15lev1sec5">Section 15.5</a>. Alternatively, we could handle such keys by keeping information in internal nodes, because each prefix that might need to be handled corresponds to some internal node in the trie (see <a class="docLink" href="#ch15qa2q21">Exercise 15.31</a>).</p>
<p class="docText">For sufficiently long keys comprising random bits, the average-case results of <a class="docLink" href="#ch15ex06">Properties 15.215.2</a>and <a class="docLink" href="#ch15ex07">15.3</a> still hold. In the worst case, the height of a trie is still limited by the number of bits in the longest keys. This cost could be excessive if the keys are huge and perhaps have some uniformity, as might arise in encoded character data. In the next two sections, we consider methods of reducing trie costs for long keys. One way to shorten paths in tries is to collapse one-way branches into single links&mdash;we discuss an elegant and efficient way to accomplish this task in <a class="docLink" href="ch15lev1sec3.html#ch15lev1sec3">Section 15.3</a>. Another way to shorten paths in tries is to allow more than two links per node&mdash;this approach is the subject of <a class="docLink" href="ch15lev1sec4.html#ch15lev1sec4">Section 15.4</a>.</p>
</td></tr></table>
<p class="docText">&nbsp;<a name="iddle1731"></a><a name="iddle2167"></a><a name="iddle2589"></a><a name="iddle1732"></a></p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q1"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">15.11</span> Draw the trie that results when you insert items with the keys E A S Y Q U T I O N in that order into an initially empty trie.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.12</span> What happens when you use <a class="docLink" href="#ch15ex05">Program 15.3</a> to insert a record whose key is equal to some key already in the trie?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.13</span> Draw the trie that results when you insert items with the keys <tt>01010011 00000111 00100001 01010001 11101100 00100001 10010101 01001010</tt> into an initially empty trie.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.14</span> Run empirical studies to compare the height, number of nodes, and internal path length of a trie built by insertion of N random 32-bit keys into an initially empty trie with the same measures of a standard binary search tree and a red&ndash;black tree (<a class="docLink" href="ch13.html#ch13">Chapter 13</a>) built from the same keys, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt> (see <a class="docLink" href="ch15lev1sec1.html#ch15qa1q6">Exercise 15.6</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.15</span> Give a full characterization of the worst-case internal path length of a trie with <span class="docEmphasis">N</span> distinct <span class="docEmphasis">w</span>-bit keys.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q6"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">15.16</span> Implement the <span class="docEmphasis">remove</span> operation for a trie-based symbol table.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q7"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">15.17</span> Implement the <span class="docEmphasis">select</span> operation for a trie-based symbol table.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.18</span> Implement the <span class="docEmphasis">sort</span> operation for a trie-based symbol table.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q9"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="triangle.jpg" />
<span class="docEmphStrong">15.19</span> Write a program that prints out all keys in a trie that have the same initial <span class="docEmphasis">t</span> bits as a given search key.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q10"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">15.20</span> Use the C++ <tt>union</tt> construct to develop implementations of <span class="docEmphasis">search</span> and  <span class="docEmphasis">insert</span> using tries with non-leaf nodes that contain links but no items and with leaves that contain items but no links.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q11"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">15.21</span> Use a pair of derived classes to develop implementations of <span class="docEmphasis">search</span> and <span class="docEmphasis">insert</span> using tries with non-leaf nodes that contain links but no items and with leaves that contain items but no links.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q12"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.22</span> Modify <a class="docLink" href="#ch15ex05">Programs 15.3</a> and <a class="docLink" href="#ch15ex04">15.2</a> to keep the search key in a machine register and to shift one bit position to access the next bit when moving down a level in the trie.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q13"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.23</span> Modify <a class="docLink" href="#ch15ex05">Programs 15.3</a> and <a class="docLink" href="#ch15ex04">15.2</a> to maintain a table of <tt>2<sup>r</sup></tt> tries, for a fixed constant <span class="docEmphasis">r</span>, and to use the first <span class="docEmphasis">r</span> bits of the key to index into the table and the standard algorithms with the remainder of the key on the trie accessed. This change saves about <span class="docEmphasis">r</span> steps unless the table has a significant number of null entries.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q14"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.24</span> What value should we choose for <span class="docEmphasis">r</span> in <a class="docLink" href="#ch15qa2q13">Exercise 15.23</a>, if we have <span class="docEmphasis">N</span> random keys (which are sufficiently long that we can assume them to be distinct)?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q15"></a><b></b></td><td><p class="docText"><a name="iddle1921"></a><a name="iddle2047"></a><a name="iddle2581"></a><span class="docEmphStrong">15.25</span> Write a program to compute the number of nodes in the trie corresponding to a given set of distinct fixed-length keys, by sorting them and comparing adjacent keys in the sorted list.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q16"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">15.26</span> Prove by induction that
<img border="0" alt="" width="200" height="27" src="637inlineequ01.jpg" />

 is the solution to the quicksort-like recurrence that is given after <a class="docLink" href="#ch15ex07">Property 15.3</a> for the external path length in a random trie.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q17"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">15.27</span> Derive the expression given in <a class="docLink" href="#ch15ex08">Property 15.4</a> for the average number of nodes in a random trie.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q18"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">15.28</span> Write a program to compute the average number of nodes in a random trie of N nodes and print the exact value, accurate to <tt>10<sup>-3</sup></tt>, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup></tt>, and <tt>10<sup>6</sup></tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q19"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" />
<span class="docEmphStrong">15.29</span> Prove that the height of a trie built from <span class="docEmphasis">N</span> random bitstrings is about 2lg<span class="docEmphasis">N</span>. <span class="docEmphasis">Hint</span>: Consider the birthday problem (see <a class="docLink" href="ch14lev1sec2.html#ch14ex05">Property 14.2</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q20"></a><b></b></td><td><p class="docText">
<img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">15.30</span> Prove that the average cost of a search in a DST built from random keys is asymptotically <tt>lg</tt> <span class="docEmphasis">N</span> (see <a class="docLink" href="ch15lev1sec1.html#ch15ex02">Properties 15.1</a> and <a class="docLink" href="#ch15ex06">15.2</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q21"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.31</span> Modify <a class="docLink" href="#ch15ex04">Programs 15.2</a> and <a class="docLink" href="#ch15ex05">15.3</a> to handle variable-length bitstrings under the sole restriction that records with duplicate keys are not kept in the data structure. In particular, decide upon a convention for the return value of <tt>bit (v, d)</tt> for the case that <tt>d</tt> is greater than the length of v.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch15qa2q22"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">15.32</span> Use a trie to build a data structure that can support an existence table ADT for <span class="docEmphasis">w</span>-bit integers. Your program should support the <span class="docEmphasis">construct</span>, <span class="docEmphasis">insert</span>, and <span class="docEmphasis">search</span> operations, where <span class="docEmphasis">search</span> and <span class="docEmphasis">insert</span> take integer arguments, and <span class="docEmphasis">search</span> returns <tt>nullItem.key()</tt> for search miss and the argument it was given for search hit.</p></td></tr></table></p>
<ul></ul></div></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch15lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch15lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table><!--IP User 2--></td></body></head></html>