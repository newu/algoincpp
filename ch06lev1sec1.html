<html><head><title>6.1. Rules of the Game</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch06.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch06lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch06lev1sec1"></a>
<h3 id="title-IDAPQ2IF" class="docSection1Title">6.1. Rules of the Game</h3>
<p class="docText">Before considering specific algorithms, we will find it useful to discuss general terminology and basic assumptions for sorting algorithms. We shall be considering methods of sorting <span class="docEmphasis">files</span> of <span class="docEmphasis">items</span> containing <span class="docEmphasis">keys</span>. All these concepts are natural abstractions in modern programming environments. The keys, which are only part (often a small part) of the items, are used to control the sort. The objective of the sorting method is to rearrange the items such that their keys are ordered according to some well-defined ordering rule (usually numerical or alphabetical order). Specific characteristics of the keys and the items can vary widely across applications, but the abstract notion of putting keys and associated information into order is what characterizes the sorting problem.</p>
<p class="docText">If the file to be sorted will fit into memory, then the sorting method is called <span class="docEmphasis">internal</span>. Sorting files from tape or disk is called <span class="docEmphasis">external</span> sorting. The main difference between the two is that an internal sort can access any item easily whereas an external sort must access items sequentially, or at least in large blocks. We shall look at a few external sorts in <a class="docLink" href="ch11.html#ch11">Chapter 11</a>, but most of the algorithms that we consider are internal sorts.</p>
<p class="docText">We shall consider both arrays and linked lists. The problem of sorting arrays and the problem of sorting linked lists are both of interest: during the development of our algorithms, we shall also encounter some basic tasks that are best suited for sequential allocation, and other tasks that are best suited for linked allocation. Some of the classical methods are sufficiently abstract that they can be implemented efficiently for either arrays or linked lists; others are particularly well suited to one or the other. Other types of access restrictions are also sometimes of interest.</p>
<p class="docText">We begin by focusing on array sorting. <a class="docLink" href="#ch06ex01">Program 6.1</a> illustrates many of the conventions that we shall use in our implementations. It <a name="iddle1388"></a><a name="iddle2416"></a>consists of a driver program that fills an array by reading integers from standard input or generating random ones (as dictated by an integer argument); then calls a sort function to put the integers in the array in order; then prints out the sorted result.</p>
<a name="ch06ex01"></a><h5 id="title-IDASS2IF" class="docExampleTitle">Program 6.1. Example of array sort with driver program</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This program illustrates our conventions for implementing basic array sorts. The <tt>main</tt> function is a driver that initializes an array of integers (either with random values or from standard input), calls a <tt>sort</tt> function to sort that array, then prints out the ordered result.</p>
<p class="docText">Templates allow the implementation to be used to sort items of any data type for which comparison and assignment are defined. The <tt>sort</tt> function here is a version of insertion sort (see <a class="docLink" href="ch06lev1sec3.html#ch06lev1sec3">Section 6.3</a> for a detailed description, an example, and an improved implementation). It uses a template function that compares two items and exchanges them if necessary to make the second not <tt>&lt;</tt> than the first.</p>
<p class="docText">We can change the driver to sort any type of data for which <tt>operator&lt;</tt> is defined without modifying <tt>sort</tt> at all (see <a class="docLink" href="ch06lev1sec7.html#ch06lev1sec7">Section 6.7</a>).</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
template &lt;class Item&gt;
  void exch(Item &amp;A, Item &amp;B)
    { Item t = A ; A = B; B = t; }
template &lt;class Item&gt;
  void compexch(Item &amp;A, Item &amp;B)
    { if (B &lt; A) exch(A, B); }
template &lt;class Item&gt;
  void sort(Item a[], int l, int r)
    { for (int i = l+1; i &lt;= r; i++)
        for (int j = i; j &gt; l; j--)
          compexch(a[j-1], a[j]);
    }
int main(int argc, char *argv[])
  { int i, N = atoi(argv[1]), sw = atoi(argv[2]);
    int *a = new int[N];
    if (sw)
      for (i = 0; i &lt; N; i++)
        a[i] = 1000*(1.0*rand()/RAND_MAX);
    else
      { N = 0; while (cin &gt;&gt; a[N]) N++; }
    sort(a, 0, N-1);
    for (i = 0; i &lt; N; i++) cout &lt;&lt; a[i] &lt;&lt; " ";
    cout &lt;&lt; endl;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">As we know from <a class="docLink" href="ch03.html#ch03">Chapters 3</a> and <a class="docLink" href="ch04.html#ch04">4</a>, there are numerous mechanisms available to us to arrange for our sort implementations to be useful for other types of data. We shall discuss the use of such mechanisms in detail in <a class="docLink" href="ch06lev1sec7.html#ch06lev1sec7">Section 6.7</a>. The <tt>sort</tt> function in <a class="docLink" href="#ch06ex01">Program 6.1</a> is a templatized implementation, referring to the items being sorted only through its first argument and a few simple operations on the data. As usual, this approach allows us to use the same code to sort other types of items. For example, if the code for generating, storing, and printing random keys in the function <tt>main</tt> in <a class="docLink" href="#ch06ex01">Program 6.1</a> were changed to process floating-point numbers instead of integers, we would not have to change <tt>sort</tt> at all. To provide such flexibility (while at the same time explicitly identifying those variables that hold items) our sort implementations will be parameterized to operate on the data type <tt>Item</tt>. For the moment, we can think of <tt>Item</tt> as <tt>int</tt> or <tt>float</tt>; in <a class="docLink" href="ch06lev1sec7.html#ch06lev1sec7">Section 6.7</a>, we shall consider in detail data-type implementations that allow us to use our sort implementations for arbitrary items with floating-point numbers, strings, and other different types of keys, using mechanisms discussed in <a class="docLink" href="ch03.html#ch03">Chapters 3</a> and <a class="docLink" href="ch04.html#ch04">4</a>.</p>
<p class="docText">We can substitute for <tt>sort</tt> any of the array-sort implementations from this chapter, or from <a class="docLink" href="ch07.html#ch07">Chapters 7</a> through <a class="docLink" href="ch10.html#ch10">10</a>. They all assume that items of type <tt>Item</tt> are to be sorted, and they all take three arguments: the array, and the left and right bounds of the subarray to be sorted. They also all rely on <tt>operator&lt;</tt> to compare keys in items and <tt>exch</tt> or <tt>compexch</tt> to exchange items. To differentiate sorting methods, we give our various sort routines different names. It is a simple matter to rename one of them, to change the driver, or to use function pointers to switch algorithms in a client program such as <a class="docLink" href="#ch06ex01">Program 6.1</a> without having to change any code in the sort implementation.</p>
<p class="docText">These conventions will allow us to examine natural and concise implementations of many array-sorting algorithms. In <a class="docLink" href="ch06lev1sec7.html#ch06lev1sec7">Sections 6.7</a> and <a class="docLink" href="ch06lev1sec8.html#ch06lev1sec8">6.8</a>, we shall consider a driver that illustrates how to use the implementations in more general contexts, and numerous data type implementations. Although we are ever mindful of such packaging <a name="iddle1024"></a><a name="iddle1653"></a><a name="iddle1671"></a><a name="iddle1837"></a><a name="iddle1970"></a><a name="iddle2298"></a><a name="iddle2368"></a><a name="iddle2387"></a><a name="iddle2409"></a>considerations, our focus will be on algorithmic issues, to which we now turn.</p>
<p class="docText">The example sort function in <a class="docLink" href="#ch06ex01">Program 6.1</a> is a variant of <span class="docEmphasis">insertion sort</span>, which we shall consider in detail in <a class="docLink" href="ch06lev1sec3.html#ch06lev1sec3">Section 6.3</a>. Because it uses only compare&ndash;exchange operations, it is an example of a <span class="docEmphasis">nonadaptive</span> sort: The sequence of operations that it performs is independent of the order of the data. By contrast, an <span class="docEmphasis">adaptive</span> sort is one that performs different sequences of operations, depending on the outcomes of comparisons (invocations of <tt>operator&lt;</tt>). Nonadaptive sorts are interesting because they are well suited for hardware implementation (see <a class="docLink" href="ch11.html#ch11">Chapter 11</a>), but most of the general-purpose sorts that we consider are adaptive.</p>
<p class="docText">As usual, the primary performance parameter of interest is the running time of our sorting algorithms. The selection-sort, insertion-sort, and bubble-sort methods that we discuss in <a class="docLink" href="ch06lev1sec2.html#ch06lev1sec2">Sections 6.2</a> through <a class="docLink" href="ch06lev1sec4.html#ch06lev1sec4">6.4</a> all require time proportional to <span class="docEmphasis">N</span><sup>2</sup> to sort <span class="docEmphasis">N</span> items, as discussed in <a class="docLink" href="ch06lev1sec5.html#ch06lev1sec5">Section 6.5</a>. The more advanced methods that we discuss in <a class="docLink" href="ch07.html#ch07">Chapters 7</a> through <a class="docLink" href="ch10.html#ch10">10</a> can sort <span class="docEmphasis">N</span> items in time proportional to <span class="docEmphasis">N</span> log <span class="docEmphasis">N</span>, but they are not always as good as the methods considered here for small <span class="docEmphasis">N</span> and in certain other special situations. In <a class="docLink" href="ch06lev1sec6.html#ch06lev1sec6">Section 6.6</a>, we shall look at a more advanced method (shellsort) that can run in time proportional to <span class="docEmphasis">N</span><sup>3/2</sup> or less, and, in <a class="docLink" href="ch06lev1sec10.html#ch06lev1sec10">Section 6.10</a>, we shall see a specialized method (key-indexed sorting) that runs in time proportional to <span class="docEmphasis">N</span> for certain types of keys.</p>
<p class="docText">The analytic results described in the previous paragraph all follow from enumerating the basic operations (comparisons and exchanges) that the algorithms perform. As discussed in <a class="docLink" href="ch02lev1sec2.html#ch02lev1sec2">Section 2.2</a>, we also must consider the costs of the operations, and we generally find it worthwhile to focus on the most frequently executed operations (the inner loop of the algorithm). Our goal is to develop efficient and reasonable implementations of efficient algorithms. In pursuit of this goal, we will not just avoid gratuitous additions to inner loops, but also look for ways to remove instructions from inner loops when possible. Generally, the best way to reduce costs in an application is to switch to a more efficient algorithm; the second best way is to tighten the inner loop. We shall consider both options in detail for sorting algorithms.</p>
<p class="docText"><a name="iddle1648"></a><a name="iddle1707"></a><a name="iddle1873"></a><a name="iddle2384"></a><a name="iddle2396"></a><a name="iddle2412"></a><a name="iddle2431"></a>The amount of extra memory used by a sorting algorithm is the second important factor that we shall consider. Basically, the methods divide into three types: those that sort in place and use no extra memory except perhaps for a small stack or table; those that use a linked-list representation or otherwise refer to data through pointers or array indices, and so need extra memory for <span class="docEmphasis">N</span> pointers or indices; and those that need enough extra memory to hold another copy of the array to be sorted.</p>
<p class="docText">We frequently use sorting methods for items with multiple keys&mdash;we may even need to sort one set of items using different keys at different times. In such cases, it may be important for us to be aware whether or not the sorting method that we use has the following property:</p>
<a name="ch06ex02"></a><h5 id="title-IDA4H0RE" class="docExampleTitle">Definition 6.1. A sorting method is said to be <span class="docEmphasis">stable</span> if it preserves the relative order of items with duplicated keys in the file</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">For example, if an alphabetized list of students and their year of graduation is sorted by year, a stable method produces a list in which people in the same class are still in alphabetical order, but a nonstable method is likely to produce a list with no vestige of the original alphabetic order. <a class="docLink" href="#ch06fig01">Figure 6.1</a> shows an example. Often, people who are unfamiliar with stability are surprised by the way an unstable algorithm seems to scramble the data when they first encounter the situation.</p>
<a name="ch06fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 6.1. Stable-sort example</h5>
<h5></h5><h5></h5></center></p><p class="docText">A sort of these records might be appropriate on either key. Suppose that they are sorted initially by the first key (top). A nonstable sort on the second key does not preserve the order in records with duplicate keys (center), but a stable sort does preserve the order (bottom).</p>
<p class="docText">
<img border="0" alt="" width="85" height="546" src="06fig01.gif" /></p>
</td></tr></table></p><br />
<p class="docText">Several (but not all) of the simple sorting methods that we consider in this chapter are stable. On the other hand, many (but not all) of the sophisticated algorithms that we consider in the next several chapters are not. If stability is vital, we can force it by appending a small index to each key before sorting or by lengthening the sort key in some other way. Doing this extra work is tantamount to using both keys for the sort in <a class="docLink" href="#ch06fig01">Figure 6.1</a>; using a stable algorithm would be preferable. It is easy to take stability for granted; actually, few of the sophisticated methods that we see in later chapters achieve stability without using significant extra time or space.</p>
<p class="docText">As we have mentioned, sorting programs normally access items in one of two ways: either keys are accessed for comparison, or entire items are accessed to be moved. If the items to be sorted are large, it is wise to avoid shuffling them around by doing an <span class="docEmphasis">indirect sort</span>: we rearrange not the items themselves, but rather an array of pointers (or indices) such that the first pointer points to the smallest item, the second pointer points to the next smallest item, and so forth. We can keep keys either with the items (if the keys are large) or with the pointers (if the keys are small). We could rearrange the items after the sort, but that is often unnecessary, because we do have the capability to refer to them in sorted order (indirectly). We shall consider indirect sorting in <a class="docLink" href="ch06lev1sec8.html#ch06lev1sec8">Section 6.8</a>.</p>
</td></tr></table>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa1q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">6.1</span> A child's sorting toy has <span class="docEmphasis">i</span> cards that fit on a peg in position <span class="docEmphasis">i</span> for <span class="docEmphasis">i</span> from 1 to 5. Write down the method that you use to put the cards on the pegs, assuming that you cannot tell from the card whether it fits on a peg (you have to try fitting it on).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa1q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.2</span> A card trick requires that you put a deck of cards in order by suit (in the order spades, hearts, clubs, diamonds) and by rank within each suit. Ask a few friends to do this task (shuffling in between!) and write down the method(s) that they use.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa1q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.3</span> Explain how you would sort a deck of cards with the restriction that the cards must be laid out face down in a row, and the only allowed operations are to check the values of two cards and (optionally) to exchange them.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa1q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">6.4</span> Explain how you would sort a deck of cards with the restriction that the cards must be kept stacked in the deck, and the only allowed operations are to look at the value of the top two cards, to exchange the top two cards, and to move the top card to the bottom of the deck.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa1q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.5</span> Give all sequences of three compare&ndash;exchange operations that will sort three elements (see <a class="docLink" href="#ch06ex01">Program 6.1</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa1q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">6.6</span> Give a sequence of five compare&ndash;exchange operations that will sort four elements.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa1q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">6.7</span> Write a client program that checks whether the sort routine being used is stable.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa1q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.8</span> Checking that the array is sorted after <tt>sort</tt> provides no guarantee that the sort works. Why not?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa1q9"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">6.9</span> Write a performance driver client program that runs <tt>sort</tt> multiple times on files of various sizes, measures the time taken for each run, and prints out or plots the average running times.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa1q10"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">6.10</span> Write an exercise driver client program that runs <tt>sort</tt> on difficult or pathological cases that might turn up in practical applications. Examples include files that are already in order, files in reverse order, files where all keys are the same, files consisting of only two distinct values, and files of size 0 or 1.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></div></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch06.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch06lev1sec2.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table><!--IP User 2--></td></body></head></html>