<html><head><title>3.7. Compound Data Structures</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="16051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03lev1sec6.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch04.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch03lev1sec7"></a>
<h3 id="643999-941" class="docSection1Title">3.7. Compound Data Structures</h3>
<p class="docText">Arrays, linked lists, and strings all provide simple ways to structure data sequentially. They provide a first level of abstraction that we can use to group objects in ways amenable to processing the objects efficiently. Having settled on these abstractions, we can use them in a hierarchical fashion to build up more complex structures. We can contemplate arrays of arrays, arrays of lists, arrays of strings, and so forth. In this section, we consider examples of such structures.</p>
<p class="docText">In the same way that one-dimensional arrays correspond to vectors, <span class="docEmphasis">two-dimensional</span> arrays, with two indices, correspond to <span class="docEmphasis">matrices</span>, and are widely used in mathematical computations. For example, <a name="iddle1076"></a><a name="iddle1406"></a><a name="iddle1879"></a><a name="iddle1925"></a><a name="iddle2288"></a><a name="iddle2592"></a>we might use the following code to multiply two matrices <tt>a</tt> and <tt>b</tt>, leaving the result in a third matrix <tt>c</tt>.</p>
<div class="docText"><pre>for (i = 0; i &lt; N; i++)
  for (j = 0; j &lt; N; j++)
    c[i][j] = 0.0;
for (i = 0; i &lt; N; i++)
  for (j = 0; j &lt; N; j++)
    for (k = 0; k &lt; N; k++)
      c[i][j] += a[i][k]*b[k][j];</pre></div><br />
<p class="docText">We frequently encounter mathematical computations that are naturally expressed in terms of multidimensional arrays.</p>
<p class="docText">Beyond mathematical applications, a familiar way to structure information is to use a table of numbers organized into rows and columns. A table of students' grades in a course might have one row for each student, and one column for each assignment. Such a table would be represented as a two-dimensional array with one index for the row and one for the column. If we were to have 100 students and 10 assignments, we would write <tt>grades[100][10]</tt> to declare the array, and then refer to the <span class="docEmphasis">i</span>th student's grade on the <span class="docEmphasis">j</span>th assignment as <tt>grade[i][j]</tt>. To compute the average grade on an assignment, we sum together the elements in a column and divide by the number of rows; to compute a particular student's average grade in the course, we sum together the elements in a row and divide by the number of columns, and so forth. Two-dimensional arrays are widely used in applications of this type. On a computer, it is often convenient and straightforward to use more than two dimensions. For example, an instructor might use a third index to keep student-grade tables for a sequence of years.</p>
<p class="docText">Two-dimensional arrays are a notational convenience, as the numbers are ultimately stored in the computer memory, which is essentially a one-dimensional array. In many programming environments, two-dimensional arrays are stored in <span class="docEmphasis">row-major order</span> in a one-dimensional array: In an array <tt>a[M][N]</tt>, the first <span class="docEmphasis">N</span> positions would be occupied by the first row (elements <tt>a[0][0]</tt> through <tt>a[0][N-1]</tt>), the second <span class="docEmphasis">N</span> positions by the second row (elements <tt>a[1][0]</tt> through <tt>a[1][N-1]</tt>), and so forth. With row-major order, the final line in <a name="iddle1066"></a>the matrix-multiplication code in the previous paragraph is precisely equivalent to</p>
<a name="ch03ex19"></a><h5 id="title-IDAGODGL" class="docExampleTitle">Program 3.16. Two-dimensional array allocation</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This function dynamically allocates the memory for a two-dimensional array, as an array of arrays. We first allocate an array of pointers, then allocate memory for each row. With this function, the statement</p>
<div class="docText"><pre>int **a = malloc2d(M, N);</pre></div><br />
<p class="docText">allocates an <span class="docEmphasis">M</span>-by-<span class="docEmphasis">N</span> array of integers.</p>
<div class="docText"><pre>int **malloc2d(int r, int c)
  { int **t = new int*[r];
    for (int i = 0; i &lt; r; i++)
      t[i] = new int[c];
    return t;
  }</pre></div><br />
</td></tr></table></p>
<div class="docText"><pre>c[N*i+j] = a[N*i+k]*b[N*k+j]</pre></div><br />
<p class="docText">The same scheme generalizes to provide a facility for arrays with more dimensions. In C++, multidimensional arrays may be implemented in a more general manner: we can define them to be compound data structures (arrays of arrays). This provides the flexibility, for example, to have an array of arrays that differ in size.</p>
<p class="docText">We saw a method in <a class="docLink" href="ch03lev1sec2.html#ch03ex07">Program 3.6</a> for dynamic allocation of arrays that allows us to use our programs for varying problem sizes without recompiling them, and would like to have a similar method for multidimensional arrays. How do we allocate memory for multidimensional arrays whose size we do not know at compile time? That is, we want to be able to refer to an array element such as <tt>a[i][j]</tt> in a program, but cannot declare it as <tt>int a[M][N]</tt> (for example) because we do not know the values of <tt>M</tt> and <tt>N</tt>. For row-major order, a statement like</p>
<div class="docText"><pre>int* a = malloc(M*N*sizeof(int));</pre></div><br />
<p class="docText">will allocate an <span class="docEmphasis">M</span>-by-<span class="docEmphasis">N</span> array of integers, but this solution will not work in all situations. For example, when an array is passed to a function, only its first dimension can be unspecified at compile time. <a class="docLink" href="#ch03ex19">Program 3.16</a> gives a more effective solution for two-dimensional arrays, based on their definition as arrays of arrays.</p>
<p class="docText"><a name="iddle1082"></a><a name="iddle2076"></a><a name="iddle2413"></a><a name="iddle2443"></a><a name="iddle2464"></a><a class="docLink" href="#ch03ex20">Program 3.17</a> illustrates the use of a similar compound structure: an array of strings. At first blush, since our abstract notion of a string is an array of characters, we might represent arrays of strings as arrays of arrays. However, the concrete representation that we use for a string is a <span class="docEmphasis">pointer</span> to the beginning of an array of characters, so an array of strings can also be an array of pointers. As illustrated in <a class="docLink" href="#ch03fig12">Figure 3.12</a>, we then can get the effect of rearranging strings simply by rearranging the pointers in the array. <a class="docLink" href="#ch03ex20">Program 3.17</a> uses the <tt>qsort</tt> library function&mdash;implementing such functions is the subject of <a class="docLink" href="ch06.html#ch06">Chapters 6</a> through <a class="docLink" href="ch09.html#ch09">9</a> in general and of <a class="docLink" href="ch07.html#ch07">Chapter 7</a> in particular. This example illustrates a typical scenario for processing strings: we read the characters themselves into a huge one-dimensional array, save pointers to individual strings (delimiting them with string-termination characters), then manipulate the pointers.</p>
<a name="ch03fig12"></a><p><center>
<h5 class="docFigureTitle">Figure 3.12. String sort</h5>
<h5></h5><h5></h5></center></p><p class="docText">When processing strings, we normally work with pointers into a buffer that contains the strings <span class="docEmphasis">(top)</span>, because the pointers are easier to manipulate than the strings themselves, which vary in length. For example, the result of a sort is to rearrange the pointers such that accessing them in order gives the strings in alphabetical (lexico-graphic) order.</p>
<p class="docText">
<img border="0" alt="" id="118095009249" width="475" height="331" src="03fig12.gif" /></p>
<br />
<p class="docText">We have already encountered another use of arrays of strings: the <tt>argv</tt> array that is used to pass argument strings to <tt>main</tt> in C++ programs. The system stores in a string buffer the command line typed by the user and passes to <tt>main</tt> a pointer to an array of pointers to strings in that buffer. We use conversion functions to calculate <a name="iddle1522"></a><a name="iddle1768"></a><a name="iddle1771"></a><a name="iddle2146"></a><a name="iddle2414"></a><a name="iddle2438"></a><a name="iddle2465"></a><a name="iddle1415"></a><a name="iddle1549"></a><a name="iddle1828"></a><a name="iddle1852"></a><a name="iddle1927"></a><a name="iddle2426"></a><a name="iddle2612"></a>numbers corresponding to some arguments; we use other arguments as strings, directly.</p>
<a name="ch03ex20"></a><h5 id="title-IDAPYDGL" class="docExampleTitle">Program 3.17. Sorting an array of strings</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This program illustrates an important string-processing function: rearranging a set of strings into sorted order. We read strings into a buffer large enough to hold them all, maintaining a pointer to each string in an array, then rearrange the pointers to put the pointer to the smallest string in the first position in the array, the pointer to the second smallest string in the second position in the array, and so forth.</p>
<p class="docText">The <tt>qsort</tt> library function that actually does the sort takes four arguments: a pointer to the beginning of the array, the number of objects, the size of each object, and a comparison function. It achieves independence from the type of object being sorted by blindly rearranging the blocks of data that represent objects (in this case string pointers) and by using a comparison function that takes pointers to <tt>void</tt> as argument. This code casts these back to type pointer to pointer to char for <tt>strcmp</tt>. To actually access the first character in a string for a comparison, we dereference three pointers: one to get the index (which is a pointer) into our array, one to get the pointer to the string (using the index), and one to get the character (using the pointer).</p>
<p class="docText">We use a different method to achieve type independence for our sorting and searching functions (see <a class="docLink" href="ch04.html#ch04">Chapters 4</a> and <a class="docLink" href="ch06.html#ch06">6</a>).</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
int compare(const void *i, const void *j)
  { return strcmp(*(char **)i, *(char **)j); }
int main()
  { const int Nmax = 1000;
    const int Mmax = 10000;
    char* a[Nmax]; int N;
    char buf[Mmax]; int M = 0;
    for (N = 0; N &lt; Nmax; N++)
      {
        a[N] = &amp;buf[M];
        if (!(cin &gt;&gt; a[N])) break;
        M += strlen(a[N])+1;
      }
    qsort(a, N, sizeof(char*), compare);
    for (int i = 0; i &lt; N; i++)
      cout &lt;&lt; a[i] &lt;&lt; endl;
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">We can build compound data structures exclusively with links, as well. <a class="docLink" href="#ch03fig13">Figure 3.13</a> shows an example of a <span class="docEmphasis">multilist</span>, where nodes have multiple link fields and belong to independently maintained linked lists. In algorithm design, we often use more than one link to build up complex data structures, but in such a way that they are used to allow us to process them efficiently. For example, a doubly linked list is a multilist that satisfies the constraint that <tt>x-&gt;l-&gt;r</tt> and <tt>x-&gt;r-&gt;l</tt> are both equal to <tt>x</tt>. We shall examine a much more important data structure with two links per node in <a class="docLink" href="ch05.html#ch05">Chapter 5</a>.</p>
<a name="ch03fig13"></a><p><center>
<h5 class="docFigureTitle">Figure 3.13. A multilist</h5>
<h5></h5><h5></h5></center></p><p class="docText">We can link together nodes with two link fields in two independent lists, one using one link field, the other using the other link field. Here, the right link field links together nodes in one order (for example, this order could be the order in which the nodes were created) and the left link field links together nodes in a different order (for example, in this case, sorted order, perhaps the result of insertion sort using the left link field only). Following right links from <span class="docEmphasis">a</span>, we visit the nodes in the order created; following left links from <span class="docEmphasis">b</span>, we visit the nodes in sorted order.</p>
<p class="docText">
<img border="0" alt="" id="118095009249" width="500" height="192" src="03fig13.gif" /></p>
<br />
<p class="docText">If a multidimensional matrix is <span class="docEmphasis">sparse</span> (relatively few of the entries are nonzero), then we might use a multilist rather than a multidimensional array to represent it. We could use one node for each value in the matrix and one link for each dimension, with the link pointing to the next item in that dimension. This arrangement reduces the storage required from the product of the maximum indices in the dimensions to be proportional to the number of nonzero entries, but increases the time required for many algorithms, because they have to traverse links to access individual elements.</p>
<p class="docText">To see more examples of compound data structures and to highlight the distinction between indexed and linked data structures, we next consider data structures for representing graphs. A <span class="docEmphasis">graph</span> is a fundamental combinatorial object that is defined simply as a set of objects (called <span class="docEmphasis">vertices</span>) and a set of connections among the vertices (called <span class="docEmphasis">edges</span>). We have already encountered graphs, in the connectivity problem of <a class="docLink" href="ch01.html#ch01">Chapter 1</a>.</p>
<p class="docText"></p><a name="ch03ex21"></a><h5 id="title-IDAP2DGL" class="docExampleTitle">Program 3.18. Adjacency-matrix graph representation</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1030"></a><a name="iddle1085"></a><a name="iddle1553"></a><a name="iddle1851"></a><a name="iddle2591"></a><a name="iddle2600"></a>This program reads a set of edges that define an undirected graph and builds an adjacency-matrix representation for the graph, setting <tt>a[i][j]</tt> and <tt>a[j][i]</tt> to 1 if there is an edge from <tt>i</tt> to <tt>j</tt> or <tt>j</tt> to <tt>i</tt> in the graph, or to 0 if there is no such edge. The program assumes that the number of vertices <tt>V</tt> is a compile-time constant. Otherwise, it would need to dynamically allocate the array that represents the adjacency matrix (see <a class="docLink" href="#ch03qa7q10">Exercise 3.71</a>).</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
int main()
  { int i, j, adj[V][V];
    for (i = 0; i &lt; V; i++)
      for (j = 0; j &lt; V; j++)
        adj[i][j] = 0;
    for (i = 0; i &lt; V; i++) adj[i][i] = 1;
    while (cin &gt;&gt; i &gt;&gt; j)
      { adj[i][j] = 1; adj[j][i] = 1; }
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">We assume that a graph with <tt>V</tt> vertices and <tt>E</tt> edges is defined by a set of <tt>E</tt> pairs of integers between <tt>0</tt> and <tt>V-1</tt>. That is, we assume that the vertices are labeled with the integers <tt>0</tt>, <tt>1</tt>, <tt>. . .</tt>, <tt>V-1</tt>, and that the edges are specified as pairs of vertices. As in <a class="docLink" href="ch01.html#ch01">Chapter 1</a> we take the pair <tt>i-j</tt> as defining a connection between <tt>i</tt> and <tt>j</tt> and thus having the same meaning as the pair <tt>j-i</tt>. Graphs that comprise such edges are called <span class="docEmphasis">undirected</span> graphs. We shall consider other types of graphs in Part 7.</p>
<p class="docText">One straightforward method for representing a graph is to use a two-dimensional array, called an <span class="docEmphasis">adjacency matrix</span>. With an adjacency matrix, we can determine immediately whether or not there is an edge from vertex <span class="docEmphasis">i</span> to vertex <span class="docEmphasis">j</span>, just by checking whether row <span class="docEmphasis">i</span> and column <span class="docEmphasis">j</span> of the matrix is nonzero. For the undirected graphs that we are considering, if there is an entry in row <span class="docEmphasis">i</span> and column <span class="docEmphasis">j</span>, then there also must be an entry in row <span class="docEmphasis">j</span> and column <span class="docEmphasis">i</span>, so the matrix is symmetric. <a class="docLink" href="#ch03fig14">Figure 3.14</a> shows an example of an adjacency matrix for an undirected graph; <a class="docLink" href="#ch03ex21">Program 3.18</a> shows how we can create an adjacency matrix, given a sequence of edges as input.</p>
<a name="ch03fig14"></a><p><center>
<h5 class="docFigureTitle">Figure 3.14. Graph with adjacency matrix representation</h5>
<h5></h5><h5></h5></center></p><p class="docText">A graph is a set of vertices and a set of edges connecting the vertices. For simplicity, we assign indices (nonnegative integers, consecutively, starting at 0) to the vertices. An adjacency matrix is a two-dimensional array where we represent a graph by putting a 1 bit in row <span class="docEmphasis">i</span> and column <span class="docEmphasis">j</span> if and only if there is an edge from vertex <span class="docEmphasis">i</span> to vertex <span class="docEmphasis">j</span>. The array is symmetric about the diagonal. By convention, we assign 1 bits on the diagonal (each vertex is connected to itself). For example, the sixth row (and the sixth column) says that vertex 6 is connected to vertices 0, 4, and 6.</p>
<p class="docText">
<img border="0" alt="" id="118095009249" width="165" height="367" src="03fig14.gif" /></p>
<br />
<p class="docText"><a name="iddle1027"></a><a name="iddle1551"></a><a name="iddle1782"></a><a name="iddle1821"></a>Another straightforward method for representing a graph is to use an array of linked lists, called <span class="docEmphasis">adjacency lists</span>. We keep a linked list for each vertex, with a node for each vertex connected to that vertex. For the undirected graphs that we are considering, if there is a node for <span class="docEmphasis">j</span> in <span class="docEmphasis">i</span>'s list, then there must be a node for <span class="docEmphasis">i</span> in <span class="docEmphasis">j</span>'s list. <a class="docLink" href="#ch03fig15">Figure 3.15</a> shows an example of the adjacency-lists representation of an undirected graph; <a class="docLink" href="#ch03ex22">Program 3.19</a> shows how we can create an adjacency-lists representation of a graph, given a sequence of edges as input.</p>
<a name="ch03fig15"></a><p><center>
<h5 class="docFigureTitle">Figure 3.15. Adjacency-lists representation of a graph</h5>
<h5></h5><h5></h5></center></p><p class="docText">This representation of the graph in <a class="docLink" href="#ch03fig14">Figure 3.14</a> uses an array of lists. The space required is proportional to the number of nodes plus the number of edges. To find the indices of the vertices connected to a given vertex <span class="docEmphasis">i</span>, we look at the <span class="docEmphasis">i</span>th position in an array, which contains a pointer to a linked list containing one node for each vertex connected to <span class="docEmphasis">i</span>.</p>
<p class="docText">
<img border="0" alt="" id="118095009249" width="300" height="162" src="03fig15.gif" /></p>
<br />
<p class="docText">Both graph representations are arrays of simpler data structures&mdash;one for each vertex describing the edges incident on that vertex. For an adjacency matrix, the simpler data structure is implemented as an indexed array; for an adjacency list, it is implemented as a linked list.</p>
<p class="docText">Thus, we face straightforward space tradeoffs when we represent a graph. The adjacency matrix uses space proportional to <span class="docEmphasis">V<sup>2</sup></span>; the adjacency lists use space proportional to <span class="docEmphasis">V + E</span>. If there are few edges (such a graph is said to be <span class="docEmphasis">sparse</span>), then the adjacency-lists representation uses far less space; if most pairs of vertices are connected by edges (such a graph is said to be <span class="docEmphasis">dense</span>), the adjacency-matrix representation might be preferable, because it involves no links. Some algorithms will be more efficient with the adjacency-matrix representation, because it allows the question &quot;is there an edge between vertex <span class="docEmphasis">i</span> and vertex <span class="docEmphasis">j</span>?&quot; to be answered in constant time; other algorithms will be more efficient with the adjacency-lists representation, because it allows us to <a name="iddle1787"></a><a name="iddle2593"></a>process all the edges in a graph in time proportional to <span class="docEmphasis">V + E</span>, rather than to <span class="docEmphasis">V<sup>2</sup></span>. We see a specific example of this tradeoff in <a class="docLink" href="ch05lev1sec8.html#ch05lev1sec8">Section 5.8</a>.</p>
<a name="ch03ex22"></a><h5 id="title-IDAHHEGL" class="docExampleTitle">Program 3.19. Adjacency-lists graph representation</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This program reads a set of edges that define a graph and builds an adjacency-matrix representation for the graph. An adjacency list for a graph is an array of lists, one for each vertex, where the <span class="docEmphasis">j</span>th list contains a linked list of the nodes connected to the <span class="docEmphasis">j</span>th vertex.</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
struct node
  { int v; node* next;
    node(int x, node* t)
      { v = x; next = t; }
  };
typedef node *link;
int main()
  { int i, j; link adj[V];
    for (i = 0; i &lt; V; i++) adj[i] = 0;
    while (cin &gt;&gt; i &gt;&gt; j)
      {
        adj[j] = new node(i, adj[j]);
        adj[i] = new node(j, adj[i]);
      }
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">Both the adjacency-matrix and the adjacency-lists graph representations can be extended straightforwardly to handle other types of graphs (see, for example, <a class="docLink" href="#ch03qa7q9">Exercise 3.70</a>). They serve as the basis for most of the graph-processing algorithms that we shall consider in Part 7.</p>
<p class="docText">To conclude this chapter, we consider an example that shows the use of compound data structures to provide an efficient solution to the simple geometric problem that we considered in <a class="docLink" href="ch03lev1sec2.html#ch03lev1sec2">Section 3.2</a>. Given <span class="docEmphasis">d</span>, we want to know how many pairs from a set of <span class="docEmphasis">N</span> points in the unit square can be connected by a straight line of length less than <span class="docEmphasis">d</span>. <a class="docLink" href="#ch03ex23">Program 3.20</a> uses a two-dimensional array of linked lists to improve the running time of <a class="docLink" href="ch03lev1sec2.html#ch03ex09">Program 3.8</a> by a factor of about 1/<span class="docEmphasis">d</span><sup>2</sup> when <span class="docEmphasis">N</span> is sufficiently large. It divides the unit square up into a grid of equal-sized smaller squares. Then, for each square, it builds a linked list of all the points that fall into that square. The two-dimensional array provides the capability to access immediately the set of points close to a given point; the linked lists provide the flexibility to store the points where they may fall without our having to know ahead of time how many points fall into each grid square.</p>
<p class="docText">The space used by <a class="docLink" href="#ch03ex23">Program 3.20</a> is proportional to 1/<span class="docEmphasis">d</span><sup>2</sup> + <span class="docEmphasis">N</span>, but the running time is <span class="docEmphasis">O</span>(<span class="docEmphasis">d</span><sup>2</sup><span class="docEmphasis">N</span><sup>2</sup>), which is a substantial improvement over the brute-force algorithm of <a class="docLink" href="ch03lev1sec2.html#ch03ex09">Program 3.8</a> for small <span class="docEmphasis">d</span>. For example, with <span class="docEmphasis">N</span> = 10<sup>6</sup> and <span class="docEmphasis">d</span> = 0.001, we can solve the problem in time and space that is effectively linear, whereas the brute-force algorithm would require a prohibitive amount of time. We can use this data structure as the basis for solving many other geometric problems, as well. For example, combined with a union-find algorithm from <a class="docLink" href="ch01.html#ch01">Chapter 1</a>, it gives a near-linear algorithm for determining whether a set of <span class="docEmphasis">N</span> random points in the plane can be connected together with lines of length <span class="docEmphasis">d</span>&mdash;a fundamental problem of interest in networking and circuit design.</p>
<p class="docText">As suggested by the examples that we have seen in this section, there is no end to the level of complexity that we can build up from the basic abstract constructs that we can use to structure data of differing types into objects and sequence the objects into compound objects, either implicitly or with explicit links. These examples still leave us one step away from full generality in structuring data, as we shall see in <a class="docLink" href="ch05.html#ch05">Chapter 5</a>. Before taking that step, however, we shall consider the important abstract data structures that we can build with linked lists and arrays&mdash;basic tools that will help us in developing the next level of generality.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa7q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.62</span> Write a version of <a class="docLink" href="#ch03ex19">Program 3.16</a> that handles <span class="docEmphasis">three</span>-dimensional arrays.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa7q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.63</span> Modify <a class="docLink" href="#ch03ex20">Program 3.17</a> to process input strings individually (allocate memory for each string after reading it from the input). You can assume that all strings have less than 100 characters.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa7q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.64</span> Write a program to fill in a two-dimensional array of 0&ndash;1 values by setting <tt>a[i][j]</tt> to 1 if the greatest common divisor of <tt>i</tt> and <tt>j</tt> is 1, and to 0 otherwise.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa7q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.65</span> Use <a class="docLink" href="#ch03ex23">Program 3.20</a> in conjunction with <a class="docLink" href="ch01lev1sec3.html#ch01ex07">Program 1.4</a> to develop an efficient program that can determine whether a set of <span class="docEmphasis">N</span> points can be connected with edges of length less than <span class="docEmphasis">d</span>.</p>
<p class="docText"></p><a name="ch03ex23"></a><h5 id="title-IDAHOEGL" class="docExampleTitle">Program 3.20. A two-dimensional array of lists</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This program illustrates the effectiveness of proper data-structure choice, for the geometric computation of <a class="docLink" href="ch03lev1sec2.html#ch03ex09">Program 3.8</a>. It divides the unit square into a grid, and maintains a two-dimensional array of linked lists, with one list corresponding to each grid square. The grid is chosen to be sufficiently fine that all points within distance <span class="docEmphasis">d</span> of any given point are either in the same grid square or an adjacent one. The function <tt>malloc2d</tt> is like the one in <a class="docLink" href="#ch03ex19">Program 3.16</a>, but for objects of type <tt>link</tt>instead of <tt>int</tt>.</p>
<div class="docText"><pre>#include &lt;math.h&gt;
#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
#include "Point.h"
struct node
  { point p; node *next;
    node(point pt, node* t) { p = pt; next = t; } };
typedef node *link;
static link **grid;
static int G, cnt = 0; static float d;
void gridinsert(float x, float y)
  { int X = x*G+1; int Y = y*G+1;
    point p; p.x = x; p.y = y;
    link s, t = new node(p, grid[X][Y]);
    for (int i = X-1; i &lt;= X+1; i++)
      for (int j = Y-1; j &lt;= Y+1; j++)
        for (s = grid[i][j]; s != 0; s = s-&gt;next)
          if (distance(s-&gt;p, t-&gt;p) &lt; d) cnt++;
    grid[X][Y] = t;
  }
int main(int argc, char *argv[])
 { int i, N = atoi(argv[1]);
   d = atof(argv[2]); G = 1[/]d;
   grid = malloc2d(G+2, G+2);
   for (i = 0; i &lt; G+2; i++)
     for (int j = 0; j &lt; G+2; j++)
       grid[i][j] = 0;
   for (i = 0; i &lt; N; i++)
     gridinsert(randFloat(), randFloat());
   cout &lt;&lt; cnt &lt;&lt; " pairs within " &lt;&lt; d &lt;&lt; endl;
 }</pre></div><br />
</td></tr></table></p>
</td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa7q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.66</span> Write a program to convert a sparse matrix from a two-dimensional array to a multilist with nodes for only nonzero values.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa7q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095009249" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">3.67</span> Implement matrix multiplication for matrices represented with multi-lists.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa7q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095009249" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">3.68</span> Show the adjacency matrix that is built by <a class="docLink" href="#ch03ex21">Program 3.18</a> given the input pairs 0-2, 1-4, 2-5, 3-6, 0-4, 6-0, and 1-3.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa7q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095009249" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">3.69</span> Show the adjacency lists that are built by <a class="docLink" href="#ch03ex22">Program 3.19</a> given the input pairs 0-2, 1-4, 2-5, 3-6, 0-4, 6-0, and 1-3.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa7q9"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095009249" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">3.70</span> A <span class="docEmphasis">directed</span> graph is one where vertex connections have orientations: edges go <span class="docEmphasis">from</span> one vertex <span class="docEmphasis">to</span> another. Do <a class="docLink" href="#ch03qa7q7">Exercises 3.68</a> and <a class="docLink" href="#ch03qa7q8">3.69</a> under the assumption that the input pairs represent a directed graph, with <tt>i-j</tt> signifying that there is an edge from <tt>i</tt> to <tt>j</tt>. Also, draw the graph, using arrows to indicate edge orientations.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa7q10"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.71</span> Modify <a class="docLink" href="#ch03ex21">Program 3.18</a> to take the number of vertices as a command-line argument, then dynamically allocate the adjacency matrix.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa7q11"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.72</span> Modify <a class="docLink" href="#ch03ex22">Program 3.19</a> to take the number of vertices as a command-line argument, then dynamically allocate the array of lists.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa7q12"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095009249" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">3.73</span> Write a function that uses the adjacency matrix of a graph to calculate, given vertices <span class="docEmphasis">a</span> and <span class="docEmphasis">b</span>, the number of vertices <span class="docEmphasis">c</span> with the property that there is an edge from <span class="docEmphasis">a</span> to <span class="docEmphasis">c</span> and from <span class="docEmphasis">c</span> to <span class="docEmphasis">b</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa7q13"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095009249" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">3.74</span> Answer <a class="docLink" href="#ch03qa7q12">Exercise 3.73</a>, but use adjacency lists.</p></td></tr></table></p>
<ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="16051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03lev1sec6.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch04.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>