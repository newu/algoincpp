<html><head><title>3.5. Memory Allocation for Lists</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch03lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch03lev1sec5"></a>
<h3 id="title-IDAOXCGL" class="docSection1Title">3.5. Memory Allocation for Lists</h3>
<p class="docText">An advantage of linked lists over arrays is that linked lists gracefully grow and shrink during their lifetime. In particular, their maximum <a name="iddle1347"></a><a name="iddle1508"></a><a name="iddle1827"></a><a name="iddle1943"></a><a name="iddle1951"></a>size does not need to be known in advance. One important practical ramification of this observation is that we can have several data structures share the same space, without paying particular attention to their relative size at any time.</p>
<p class="docText">The crux of the matter is to consider how the operator <tt>new</tt> might be implemented. For example, when we remove a node from a list, it is one thing for us to rearrange the links so that the node is no longer hooked into the list, but what does the system do with the space that the node occupied? And how does the system recycle space such that it can always find space for a node when <tt>new</tt> is invoked and more space is needed? The mechanisms behind these questions provide another example of the utility of elementary list processing.</p>
<p class="docText">Operator <tt>delete</tt> is the counterpart to <tt>new</tt>. When we are done using a chunk of allocated memory, we invoke <tt>delete</tt> to inform the system that the chunk is available for later use. <span class="docEmphasis">Dynamic memory allocation</span> is the process of managing memory and responding to invocations of <tt>new</tt> and <tt>delete</tt> from client programs.</p>
<p class="docText">When we are invoking <tt>new</tt> directly in applications such as <a class="docLink" href="ch03lev1sec3.html#ch03ex11">Program 3.9</a> or <a class="docLink" href="ch03lev1sec4.html#ch03ex14">Program 3.11</a>, all the calls request memory blocks of the same size. This case is typical, and an alternate method of keeping track of memory available for allocation immediately suggests itself: Simply use a linked list! All nodes that are not on any list that is in use can be kept together on a single linked list. We refer to this list as the <span class="docEmphasis">free list</span>. When we need to allocate space for a node, we get it by <span class="docEmphasis">removing</span> it from the free list; when we remove a node from any of our lists, we dispose of it by <span class="docEmphasis">inserting</span> it onto the free list.</p>
<p class="docText"><a class="docLink" href="#ch03ex17">Program 3.14</a> is an implementation of the interface defined in <a class="docLink" href="ch03lev1sec4.html#ch03ex15">Program 3.12</a>, including the memory-allocation functions. When compiled with <a class="docLink" href="ch03lev1sec4.html#ch03ex16">Program 3.13</a>, it produces the same result as the direct implementation with which we began in <a class="docLink" href="ch03lev1sec3.html#ch03ex11">Program 3.9</a>. Maintaining the free list for fixed-size nodes is a trivial task, given the basic operations for inserting nodes onto and deleting nodes from a list.</p>
<p class="docText"><a class="docLink" href="#ch03fig11">Figure 3.11</a> illustrates how the free list grows as nodes are freed, for <a class="docLink" href="ch03lev1sec4.html#ch03ex16">Program 3.13</a>. For simplicity, the figure assumes a linked-list implementation (no head node) based on array indices.</p>
<a name="ch03fig11"></a><p><center>
<h5 class="docFigureTitle">Figure 3.11. Array representation of a linked list, with free list</h5>
<h5></h5><h5></h5></center></p><p class="docText">This version of <a class="docLink" href="ch03lev1sec3.html#ch03fig06">Figure 3.6</a> shows the result of maintaining a free list with the nodes deleted from the circular list, with the index of first node on the free list given at the left. At the end of the process, the free list is a linked list containing all the items that were deleted. Following the links, starting at <span class="docEmphasis">1</span>, we see the items in the order <span class="docEmphasis">2 9 6 3 4 7 1 5</span>, which is the reverse of the order in which they were deleted.</p>
<p class="docText">
<img border="0" alt="" width="175" height="332" src="03fig11.gif" /></p>
<br />
<p class="docText">Implementing a general-purpose memory allocator in a C++ environment is much more complex than is suggested by our simple examples, and the implementation of <tt>new</tt> in the standard library is <a name="iddle1831"></a><a name="iddle1952"></a><a name="iddle1090"></a><a name="iddle1348"></a><a name="iddle1539"></a><a name="iddle1786"></a><a name="iddle1944"></a>certainly not as simple as is indicated by <a class="docLink" href="#ch03ex17">Program 3.14</a>. One primary difference between the two is that <tt>new</tt> has to handle storage-allocation requests for nodes of varying sizes, ranging from tiny to huge. Several clever algorithms have been developed for this purpose. Another approach that is used by some modern systems is to relieve the user of the need to <tt>delete</tt> nodes explicitly by using <span class="docEmphasis">garbage-collection</span> algorithms to remove automatically any nodes not referenced by any link. Several clever storage management algorithms have also been developed along these lines. We will not consider them in further detail because their performance characteristics are dependent on properties of specific systems and machines.</p>
<a name="ch03ex17"></a><h5 id="title-IDAY5CGL" class="docExampleTitle">Program 3.14. Implementation of list-processing interface</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This program gives implementations of the functions declared in <a class="docLink" href="ch03lev1sec4.html#ch03ex15">Program 3.12</a>, and illustrates a standard approach to allocating memory for fixed-size nodes. We build a free list that is initialized to the maximum number of nodes that our program will use, all linked together. Then, when a client program allocates a node, we remove that node from the free list; when a client program frees a node, we link that node in to the free list.</p>
<p class="docText">By convention, client programs do not refer to list nodes except by declaring variables of type <tt>Node</tt> and using them as arguments to functions defined in the interface, and nodes returned to client programs have self-links. These conventions provide a measure of protection against referencing undefined pointers and provide some assurance that the client is using the interface as intended. In C++, we enforce such conventions by using classes with constructors (see <a class="docLink" href="ch04.html#ch04">Chapter 4</a>).</p>
<div class="docText"><pre>#include &lt;stdlib.h&gt;
#include "list.h"
link freelist;
void construct(int N)
  {
    freelist = new node[N+1];
    for (int i = 0; i &lt; N; i++)
      freelist[i].next = &amp;freelist[i+1];
    freelist[N].next = 0;
  }
link newNode(int i)
  { link x = remove(freelist);
    x-&gt;item = i; x-&gt;next = x;
    return x;
  }
void deleteNode(link x)
  { insert(freelist, x); }
void insert(link x, link t)
  { t-&gt;next = x-&gt;next; x-&gt;next = t; }
link remove(link x)
  { link t = x-&gt;next; x-&gt;next = t-&gt;next; return t; }
link next(link x)
  { return x-&gt;next; }
Item item(link x)
  { return x-&gt;item; }</pre></div><br />
</td></tr></table></p>
<p class="docText">Programs that can take advantage of specialized knowledge about an application often are more efficient than general-purpose programs for the same task. Memory allocation is no exception to this maxim. An algorithm that has to handle storage requests of varying sizes cannot know that we are always going to be making requests for blocks of one fixed size, and therefore cannot take advantage of that fact. Paradoxically, another reason to avoid general-purpose library functions is that doing so makes programs more portable&mdash;we can protect ourselves against unexpected performance changes when the library changes or when we move to a different system. Many programmers have found that using a simple memory allocator like the one illustrated in <a class="docLink" href="#ch03ex17">Program 3.14</a> is an effective way to develop efficient and portable programs that use linked lists. This approach applies to a number of the algorithms that we will consider throughout this book, which make similar kinds of demands on the memory-management system. That said, we shall use the standard C++ facilities <tt>new</tt> and <tt>delete</tt> for memory allocation throughout the rest of the book.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa5q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">3.46</span> Write a program that frees (invokes <tt>delete</tt> with a pointer to) all the nodes on a given linked list.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa5q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.47</span> Write a program that frees the nodes in positions that are divisible by 5 in a linked list (the fifth, tenth, fifteenth, and so forth).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa5q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">3.48</span> Write a program that frees the nodes in even positions in a linked list (the second, fourth, sixth, and so forth).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa5q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.49</span> Implement the interface in <a class="docLink" href="ch03lev1sec4.html#ch03ex15">Program 3.12</a> using <tt>new</tt> and <tt>delete</tt> directly in <tt>newNode</tt> and <tt>deleteNode</tt>, respectively.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa5q5"></a><b></b></td><td><p class="docText"><a name="iddle1775"></a><a name="iddle2442"></a><span class="docEmphStrong">3.50</span> Run empirical studies comparing the running times of the memory-allocation functions in <a class="docLink" href="#ch03ex17">Program 3.14</a> with <tt>new</tt> and <tt>delete</tt> (see <a class="docLink" href="#ch03qa5q4">Exercise 3.49</a>) for <a class="docLink" href="ch03lev1sec4.html#ch03ex16">Program 3.13</a> with <span class="docEmphasis">M</span> = 2 and <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa5q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">3.51</span> Implement the interface in <a class="docLink" href="ch03lev1sec4.html#ch03ex15">Program 3.12</a> using array indices (and no head node) rather than pointers, in such a way that <a class="docLink" href="#ch03fig11">Figure 3.11</a> is a trace of the operation of your program.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa5q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">3.52</span> Suppose that you have a set of nodes with no null pointers (each node points to itself or to some other node in the set). Prove that you ultimately get into a cycle if you start at any given node and follow links.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa5q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">3.53</span> Under the conditions of <a class="docLink" href="#ch03qa5q7">Exercise 3.52</a>, write a code fragment that, given a pointer to a node, finds the number of different nodes that it ultimately reaches by following links from that node, <span class="docEmphasis">without</span> modifying any nodes. Do not use more than a constant amount of extra memory space.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch03qa5q9"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">3.54</span> Under the conditions of <a class="docLink" href="#ch03qa5q8">Exercise 3.53</a>, write a function that determines whether or not two given links, if followed, eventually end up on the same cycle.</p></td></tr></table></p>
<a href="16051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch03lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch03lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>