<html><head><title>Chapter Thirteen. Balanced Trees</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12lev1sec9.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch13lev1sec1.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch13"></a>
<h2 id="title-IDALJS3B" class="docChapterTitle">Chapter Thirteen. Balanced Trees</h2>
<p class="docText"><a name="iddle1115"></a><a name="iddle1168"></a><a name="iddle1199"></a>The BST algorithms in the previous chapter work well for a wide variety of applications, but they do have the problem of bad worst-case performance. What is more, it is embarrassingly true that the bad worst case for the standard BST algorithm, like that for quicksort, is one that is likely to occur in practice if the user of the algorithm is not watching for it. Files already in order, files with large numbers of duplicate keys, files in reverse order, files with alternating large and small keys, or files with any large segment having a simple structure can all lead to quadratic BST construction times and linear search times.</p>
<p class="docText">In the ideal case, we could keep our trees perfectly balanced, like the tree depicted in <a class="docLink" href="#ch13fig01">Figure 13.1</a>. This structure corresponds to binary search and therefore allows us to guarantee that all searches can be completed in less than <tt>lg</tt> <span class="docEmphasis">N</span> + 1 comparisons, but is expensive to maintain for dynamic insertions and deletions. The search performance guarantee holds for any BST for which all the external nodes are on the bottom one or at most two levels, and there are many such BSTs, so we have some flexibility in arranging for our tree to be balanced. If we are satisfied with near-optimal trees, then we can have even more flexibility. For example, there are a great many BSTs of height less than <tt>2lg</tt> <span class="docEmphasis">N</span>. If we relax our standard but can guarantee that our algorithms build only such BSTs, then we can provide the protection against bad worst-case performance that we would like to have in practical applications in a dynamic data structure. As a side benefit, we get better average-case performance, as well.</p>
<a name="ch13fig01"></a><p><center>
<h5 class="docFigureTitle">Figure 13.1. A large BST that is perfectly balanced</h5>
<h5></h5><h5></h5></center></p><p class="docText">The external nodes in this BST all fall on one of two levels, and the number of comparisons for any search is the same as the number of comparisons that would be used by binary search for the same key (if the items were in an ordered array). The goal of a balanced-tree algorithm is to keep a BST as close as possible to being as well balanced as this one, while still supporting efficient dynamic insertion, deletion, and other dictionary ADT operations.</p>
<p class="docText">
<img border="0" alt="" width="500" height="103" src="13fig01.gif" /></p>
<br />
<p class="docText"><a name="iddle1053"></a><a name="iddle2222"></a>One approach to producing better balance in BSTs is periodically to rebalance them explicitly. Indeed, we can balance most BSTs completely in linear time, using the recursive method shown in <a class="docLink" href="#ch13ex01">Program 13.1</a> (see <a class="docLink" href="#ch13qa1q4">Exercise 13.4</a>). Such rebalancing is likely to improve performance for random keys, but does not provide guarantees against quadratic worst-case performance in a dynamic symbol table. On the one hand, the insertion time for a sequence of keys between rebalancing operations can grow quadratic in the length of the sequence; on the other hand, we do not want to rebalance huge trees frequently, because each rebalancing operation costs at least linear time in the size of the tree. This tradeoff makes it difficult to use global rebalancing to guarantee fast performance in dynamic BSTs. All the algorithms that we will consider, as they walk through the tree, do incremental, local operations that collectively improve the balance of the whole tree, yet they never have to walk through all the nodes in the way that <a class="docLink" href="#ch13ex01">Program 13.1</a> does.</p>
<p class="docText">The problem of providing guaranteed performance for symbol-table implementations based on BSTs gives us an excellent forum for examining precisely what we mean when we ask for performance guarantees. We shall see solutions to this problem that are prime examples of each of the three general approaches to providing performance guarantees in algorithm design: we can <span class="docEmphasis">randomize</span>, <span class="docEmphasis">amortize</span>, or <span class="docEmphasis">optimize</span>. We now consider each of these approaches briefly, in turn.</p>
<p class="docText">A <span class="docEmphasis">randomized</span> algorithm introduces random decision making into the algorithm itself, to reduce dramatically the chance of a worst-case scenario (no matter what the input). We have already seen a prime example of this arrangement, when we used a random element as the partitioning element in quicksort. In <a class="docLink" href="ch13lev1sec1.html#ch13lev1sec1">Sections 13.1</a> and <a class="docLink" href="ch13lev1sec5.html#ch13lev1sec5">13.5</a>, we shall examine <span class="docEmphasis">randomized BSTs</span> and <span class="docEmphasis">skip lists</span>&mdash;two simple ways <a name="iddle1061"></a><a name="iddle1169"></a><a name="iddle2007"></a>to use randomization in symbol-table implementations to give efficient implementations of all the symbol-table ADT operations. These algorithms are simple and are broadly applicable, but went undiscovered for decades(<span class="docEmphasis">see reference section</span>). The analysis that proves these algorithms to be effective is not elementary, but the algorithms are simple to understand, to implement, and to put to practical use.</p>
<a name="ch13ex01"></a><h5 id="title-IDA0OS3B" class="docExampleTitle">Program 13.1. Balancing a BST</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This recursive function puts a BST into perfect balance in linear time, using the partitioning function <tt>partR</tt> from <a class="docLink" href="ch12lev1sec9.html#ch12ex25">Program 12.15</a>. We partition to put the median node at the root, then (recursively) do the same for the subtrees.</p>
<div class="docText"><pre>  void balanceR(link&amp; h)
    {
      if ((h == 0) || (h-&gt;N == 1)) return;
      partR(h, h-&gt;N/2);
      balanceR(h-&gt;l);
      balanceR(h-&gt;r);
   }</pre></div><br />
</td></tr></table></p>
<p class="docText">An <span class="docEmphasis">amortization</span> approach is to do extra work at one time to avoid more work later, to be able to provide guaranteed upper bounds on the average per-operation cost (the total cost of all operations divided by the number of operations). In <a class="docLink" href="ch13lev1sec2.html#ch13lev1sec2">Section 13.2</a>, we shall examine <span class="docEmphasis">splay BSTs</span>, a variant of BSTs that we can use to provide such guarantees for symbol-table implementations. The development of this method was one impetus for the development of the concept of amortization (<span class="docEmphasis">see reference section</span>). The algorithm is a straightforward extension of the root insertion method that we discussed in <a class="docLink" href="ch12.html#ch12">Chapter 12</a>, but the analysis that proves the performance bounds is sophisticated.</p>
<p class="docText">An <span class="docEmphasis">optimization</span> approach is to take the trouble to provide performance guarantees for every operation. Various methods have been developed that take this approach, some dating back to the 1960s. These methods require that we maintain some structural information in the trees, and programmers typically find the algorithms cumbersome to implement. In this chapter, we shall examine two simple abstractions that not only make the implementation straightforward, but also lead to near-optimal upper bounds on the costs.</p>
<p class="docText">After examining implementations of symbol-table ADTs with guaranteed fast performance using each of these three approaches, we conclude the chapter with a comparison of performance characteristics. Beyond the differences suggested by the differing natures of the performance guarantees that each of the algorithms provides, the methods each carry a (relatively slight) cost in time or space to provide those guarantees; the development of a truly optimal balanced-tree ADT is still a research goal. Still, the algorithms that we consider in this chapter are all important ones that can provide fast implementations of <span class="docEmphasis">search</span> and <span class="docEmphasis">insert</span> (and several other symbol-table ADT operations) in dynamic symbol tables for a variety of applications.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa1q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" />
<span class="docEmphStrong">13.1</span> Implement an efficient function that rebalances BSTs that do not have a count field in their nodes.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa1q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.2</span> Modify the standard BST insertion function in <a class="docLink" href="ch12lev1sec5.html#ch12ex15">Program 12.8</a> to use <a class="docLink" href="#ch13ex01">Program 13.1</a> to rebalance the tree each time that the number of items in the symbol table reaches a power of 2. Compare the running time of your program with that of <a class="docLink" href="ch12lev1sec5.html#ch12ex15">Program 12.8</a> for the tasks of (<span class="docEmphasis">i</span>) building a tree from <span class="docEmphasis">N</span> random keys and (<span class="docEmphasis">ii</span>) searching for <span class="docEmphasis">N</span> random keys in the resulting tree, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup></tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa1q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.3</span> Estimate the number of comparisons used by your program from <a class="docLink" href="#ch13qa1qe2q2">Exercise 13.2</a> when inserting an increasing sequence of <span class="docEmphasis">N</span> keys into a symbol table.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa1q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">13.4</span> Show that <a class="docLink" href="#ch13ex01">Program 13.1</a> runs in time proportional to <tt>NlogN</tt> for a degenerate tree. Then give as weak a condition on the tree as you can that implies that the program runs in linear time.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa1q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.5</span> Modify the standard BST insertion function in <a class="docLink" href="ch12lev1sec5.html#ch12ex15">Program 12.8</a> to partition about the median any node encountered that has less than one-quarter of its nodes in one of its subtrees. Compare the running time of your program with that of <a class="docLink" href="ch12lev1sec5.html#ch12ex15">Program 12.8</a> for the tasks of (<span class="docEmphasis">i</span>) building a tree from <span class="docEmphasis">N</span> random keys, and (<span class="docEmphasis">ii</span>) searching for <span class="docEmphasis">N</span> random keys in the resulting tree, for <span class="docEmphasis"><tt>N</tt></span> <tt>= 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, and 10<sup>6</sup></tt>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa1q6"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">13.6</span> Estimate the number of comparisons used by your program from <a class="docLink" href="#ch13qa1q5">Exercise 13.5</a> when inserting an increasing sequence of <span class="docEmphasis">N</span> keys into a symbol table.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch13qa1q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" />
<span class="docEmphStrong">13.7</span> Extend your implementation in <a class="docLink" href="#ch13qa1q5">Exercise 13.5</a> to rebalance in the same way while performing the <span class="docEmphasis">remove</span> function. Run experiments to determine whether the height of the tree grows as a long sequence of alternating random insertions and deletions are made in a random tree of <span class="docEmphasis">N</span> nodes, for <span class="docEmphasis">N</span> <tt>= 10, 100, and 1000,</tt> and for <span class="docEmphasis">N</span><sup>2</sup> insertion&ndash;deletion pairs for each <span class="docEmphasis">N</span>.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch12lev1sec9.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch13lev1sec1.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>