<html><head><title>11.2. Sorting Networks</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch11lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch11lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch11lev1sec2"></a>
<h3 id="title-IDAUX5HF" class="docSection1Title">11.2. Sorting Networks</h3>
<p class="docText">The simplest model for studying nonadaptive sorting algorithms is an abstract machine that can access the data <span class="docEmphasis">only</span> through compare&ndash;exchange operations. Such a machine is called a <span class="docEmphasis">sorting network</span>. A sorting network comprises atomic <span class="docEmphasis">compare&ndash;exchange modules</span>, or <span class="docEmphasis">comparators</span>, which are wired together so as to implement the capability to perform fully general sorting.</p>
<p class="docText"><a class="docLink" href="#ch11fig04">Figure 11.4</a> shows a simple sorting network for four keys. Customarily, we draw a sorting network for <span class="docEmphasis">N</span> items as a sequence of <span class="docEmphasis">N</span> horizontal lines, with comparators connecting pairs of lines. We imagine that the keys to be sorted pass from right to left through the network, with a pair of numbers exchanged if necessary to put the smaller on top whenever a comparator is encountered.</p>
<a name="ch11fig04"></a><p><center>
<h5 class="docFigureTitle">Figure 11.4. A sorting network</h5>
<h5></h5><h5></h5></center></p><p class="docText">The keys move from left to right on the lines in the network. The comparators that they encounter exchange the keys if necessary to put the smaller one on the higher line. In this example, <span class="docEmphasis"><tt>B</tt></span> and <span class="docEmphasis"><tt>C</tt></span> are exchanged on the top two lines, then <span class="docEmphasis"><tt>A</tt></span> and <span class="docEmphasis"><tt>D</tt></span> are exchanged on the bottom two, then <span class="docEmphasis"><tt>A</tt></span> and <span class="docEmphasis"><tt>B</tt></span>, and so forth, leaving the keys in sorted order from top to bottom at the end. In this example, all the comparators do exchanges except the fourth one. This network sorts any permutation of four keys.</p>
<p class="docText">
<img border="0" alt="" width="200" height="44" src="11fig04.gif" /></p>
<br />
<p class="docText">Many details must be worked out before an actual sorting machine based on this scheme could be built. For example, the method of encoding the inputs is left unspecified. One approach would be to think of each wire in <a class="docLink" href="#ch11fig04">Figure 11.4</a> as a group of lines, each holding 1 bit of data, so that all the bits of a key flow through a line simultaneously. Another approach would be to have the comparators read their inputs 1 bit at a time along a single line (most significant bit first). Also left unspecified is the timing: mechanisms must be included to ensure that no comparator performs its operation before its input is ready. Sorting networks are a good abstraction because they allow us to separate such implementation considerations from higher-level design considerations, such as minimizing the number of comparators. Moreover, <a name="iddle1133"></a><a name="iddle1942"></a>as we shall see in <a class="docLink" href="ch11lev1sec5.html#ch11lev1sec5">Section 11.5</a>, the sort network abstraction is useful for applications other than direct circuit realizations.</p>
<p class="docText">Another important application of sorting networks is as a model for parallel computation. If two comparators do not use the same input lines, we assume that they can operate at the same time. For example, the network in <a class="docLink" href="#ch11fig04">Figure 11.4</a> shows that four elements can be sorted in three parallel steps. The 0&ndash;1 comparator and the 2&ndash; 3 comparator can operate simultaneously in the first step, then the 0&ndash;2 comparator and the 1&ndash;3 comparator can operate simultaneously in the second step, and then the 2&ndash;3 comparator finishes the sort in the third step. Given any network, it is not difficult to classify the comparators into a sequence of <span class="docEmphasis">parallel stages</span> that consist of groups of comparators that can operate simultaneously (see <a class="docLink" href="#ch11qa2q2">Exercise 11.17</a>). For efficient parallel computation, our challenge is to design networks with as few parallel stages as possible.</p>
<p class="docText"><a class="docLink" href="ch11lev1sec1.html#ch11ex03">Program 11.2</a> corresponds directly to a merging network for each <span class="docEmphasis">N</span>, but it is also instructive for us to consider a direct bottom-up construction, which is illustrated in <a class="docLink" href="#ch11fig05">Figure 11.5</a>. To construct a merging network of size <span class="docEmphasis">N</span>, we use two copies of the network of size <span class="docEmphasis">N</span>/2; one for the even-numbered lines and one for the odd-numbered lines. Because the two sets of comparators do not interfere, we can rearrange them to interleave the two networks. Then, at the end, we complete the network with comparators between lines 1 and 2, 3 and 4, and so forth. The odd&ndash;even interleaving replaces the perfect shuffle in <a class="docLink" href="ch11lev1sec1.html#ch11ex03">Program 11.2</a>. The proof that these networks merge properly is <a name="iddle1724"></a><a name="iddle1937"></a><a name="iddle2450"></a>the same as that given for Properties 11.1 and 11.2, using the 0&ndash;1 principle. <a class="docLink" href="#ch11fig06">Figure 11.6</a> shows an example of the merge in operation.</p>
<a name="ch11fig05"></a><p><center>
<h5 class="docFigureTitle">Figure 11.5. Batcher's odd&ndash;even merging networks</h5>
<h5></h5><h5></h5></center></p><p class="docText">These different representations of the networks for four (top), eight (center), and 16 (bottom) lines expose the network's basic recursive structure. On the left are direct representations of the construction of the networks of size <span class="docEmphasis">N</span> with two copies of the networks of size <span class="docEmphasis">N</span>/2 (one for the even-numbered lines and one for the odd-numbered lines), plus a stage of comparators between lines 1 and 2, 3 and 4, 5 and 6, and so forth. On the right are simpler networks that we derive from those on the left by grouping comparators of the same length; grouping is possible because we can move comparators on odd lines past those on even lines without interference.</p>
<p class="docText">
<img border="0" alt="" width="300" height="154" src="11fig05.gif" /></p>
<br />
<a name="ch11fig06"></a><p><center>
<h5 class="docFigureTitle">Figure 11.6. Bottom-up Batcher's merge example</h5>
<h5></h5><h5></h5></center></p><p class="docText">When all the shuffling is removed, Batcher's merge for our example amounts to the 25 compare&ndash;exchange operations depicted here. They divide into four phases of independent compare&ndash;exchange operations at a fixed offset for each phase.</p>
<p class="docText">
<img border="0" alt="" width="175" height="321" src="11fig06.gif" /></p>
<br />
<a name="ch11ex06"></a><h5 id="title-IDATHWRE" class="docExampleTitle">Program 11.3. Batcher's odd-even merge (nonrecursive version)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This implementation of Batcher's odd&ndash;even merge (which assumes that the file size <span class="docEmphasis">N</span> is a power of 2) is compact but mysterious. We can understand how it accomplishes the merge by examining how it corresponds to the recursive version (see <a class="docLink" href="ch11lev1sec1.html#ch11ex03">Program 11.2</a> and <a class="docLink" href="#ch11fig05">Figure 11.5</a>). It accomplishes the merge in lg <span class="docEmphasis">N</span> passes consisting of uniform and independent compare&ndash;exchange instructions.</p>
<div class="docText"><pre>template &lt;class Item&gt;
void merge(Item a[], int l, int m, int r)
  { int N = r-l+1; // assuming N/2 is m-l+1
    for (int k = N[/]2; k &gt; 0; k /= 2)
      for (int j = k % (N/2); j+k &lt; N; j += k+k)
        for (int i = 0; i &lt; k; i++)
          compexch(a[l+j+i], a[l+j+i+k]);
  }</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch11ex06">Program 11.3</a> is a bottom-up implementation of Batcher's merge, with no shuffling, that corresponds to the networks in <a class="docLink" href="#ch11fig05">Figure 11.5</a>. This program is a compact and elegant in-place merging function that is perhaps best understood as just an alternate representation of the networks, although direct proofs that it accomplishes the merging task correctly are also interesting to contemplate. We shall examine one such proof at the end of this section.</p>
<p class="docText"><a class="docLink" href="#ch11fig07">Figure 11.7</a> shows Batcher's odd&ndash;even sorting network, built from the merging networks in <a class="docLink" href="#ch11fig05">Figure 11.5</a> using the standard recursive mergesort construction. The construction is doubly recursive: once for the merging networks and once for the sorting networks. Although they are not optimal&mdash;we shall discuss optimal networks shortly&mdash;these networks are efficient.</p>
<a name="ch11fig07"></a><p><center>
<h5 class="docFigureTitle">Figure 11.7. Batcher's odd&ndash;even sorting networks</h5>
<h5></h5><h5></h5></center></p><p class="docText">This sorting network for 32 lines contains two copies of the network for 16 lines, four copies of the network for eight lines, and so forth. Reading from right to left, we see the structure in a top-down manner: A sorting network for 32 lines consists of a 16-by-16 merging network following two copies of the sorting network for 16 lines (one for the top half and one for the bottom half). Each network for 16 lines consists of an 8-by-8 merging network following two copies of the sorting network for 8 lines, and so forth. Reading from left to right, we see the structure in a bottom-up manner: The first column of comparators creates sorted subfiles of size 2; then, we have 2-by-2 merging networks that create sorted subfiles of size 4; then, 4-by-4 merging networks that create sorted subfiles of size 8, and so forth.</p>
<p class="docText">
<img border="0" alt="" width="500" height="175" src="11fig07.gif" /></p>
<br />
<a name="ch11ex07"></a><h5 id="title-IDAYKWRE" class="docExampleTitle">Property 11.3. Batcher's odd&ndash;even sorting networks have about <span class="docEmphasis">N</span>(lg <span class="docEmphasis">N</span>)<sup>2</sup>/4 comparators and can run in (lg<span class="docEmphasis">N</span>)<sup>2</sup>/2 parallel steps</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The merging networks need about lg<span class="docEmphasis">N</span> parallel steps, and the sorting networks need <tt>1</tt> + 2 + . . . + lg <span class="docEmphasis">N</span>, or about (lg <span class="docEmphasis">N)<sup>2</sup>/2</span> parallel steps. Comparator counting is left as an exercise (see <a class="docLink" href="#ch11qa2q8">Exercise 11.23</a>).</p>
</td></tr></table></p>
<p class="docText">Using the merge function in <a class="docLink" href="#ch11ex06">Program 11.3</a> within the standard recursive mergesort in <a class="docLink" href="ch08lev1sec3.html#ch08ex03">Program 8.3</a> gives a compact in-place sorting method that is nonadaptive and uses <span class="docEmphasis">O(N(lgN)<sup>2</sup>)</span> compare&ndash;exchange operations. Alternatively, we can remove the recursion from the mergesort and implement a bottom-up version of the whole sort directly, as shown in <a class="docLink" href="#ch11ex08">Program 11.4</a>. As was <a class="docLink" href="#ch11ex06">Program 11.3</a>, this program is perhaps best understood as an alternate representation of the network in <a class="docLink" href="#ch11fig07">Figure 11.7</a>. The implementation involves adding one loop and adding one test in <a class="docLink" href="#ch11ex06">Program 11.3</a>, because the merge and the sort have similar recursive structure. To perform the bottom-up pass of merging a sequence of sorted files of length 2<sup><span class="docEmphasis">k</span></sup> into a sequence of sorted files of length 2<sup><span class="docEmphasis">k</span>+1</sup>, we use the full merging network, but include only those comparators that fall completely within subfiles. This program perhaps wins the prize as the most compact nontrivial sort implementation that we have seen, and it is likely to be the method of choice when we want to take advantage of high-performance architectural features to develop a high-speed sort for small files (or to build a sorting network). Understanding how and why the program sorts would be a formidable task if we did not have the perspective of the recursive implementations and network constructions that we have been considering.</p>
<p class="docText">As usual with divide-and-conquer methods, we have two basic choices when <span class="docEmphasis">N</span> is not a power of 2 (see <a class="docLink" href="#ch11qa2q9">Exercises 11.24</a> and <a class="docLink" href="#ch11qa2q6">11.21</a>). We can divide in half (top-down) or divide at the largest power of 2 less than <span class="docEmphasis">N</span> (bottom-up). The latter is somewhat simpler for sorting <a name="iddle1134"></a><a name="iddle1938"></a><a name="iddle1939"></a><a name="iddle2352"></a>networks, because it is equivalent to building a full network for the smallest power of 2 greater than or equal to <span class="docEmphasis">N</span>, then using only the first <span class="docEmphasis">N</span> lines and only comparators with both ends connected to those lines. The proof that this construction is valid is simple. Suppose that the lines that are not used have sentinel keys that are greater than any other keys on the network. Then, comparators on those lines never exchange, so removing them has no effect. Indeed, we could use <span class="docEmphasis">any</span> contiguous set of <span class="docEmphasis">N</span> lines from the larger network: Consider ignored lines at the top to have small sentinels and ignored lines at the bottom to have large sentinels. All these networks have about <span class="docEmphasis">N</span>(lg <span class="docEmphasis">N</span>)<sup>2</sup>/4 comparators.</p>
<a name="ch11ex08"></a><h5 id="title-IDAZPWRE" class="docExampleTitle">Program 11.4. Batcher's odd&ndash;even sort (nonrecursive version)</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This implementation of Batcher's odd&ndash;even sort corresponds directly to the network representation in <a class="docLink" href="#ch11fig07">Figure 11.7</a>. It divides into phases, indexed by the variable <tt>p</tt>. The last phase, when <tt>p</tt> is <tt>N</tt>, is Batcher's odd&ndash;even merge. The next-to-last phase, when <tt>p</tt> is <tt>N/2</tt>, is the odd&ndash;even merge with the first stage and all comparators that cross <tt>N/2</tt> eliminated; the third-to-last phase, when <tt>p</tt> is <tt>N/4</tt>, is the odd&ndash;even merge with the first two stages and all comparators that cross any multiple of <tt>N/4</tt> eliminated, and so forth.</p>
<div class="docText"><pre>template &lt;class Item&gt;
void batchersort(Item a[], int l, int r)
  { int N = r-l+1;
    for (int p = 1; p &lt; N; p += p)
      for (int k = p; k &gt; 0; k /= 2)
        for (int j = k%p; j+k &lt; N; j += (k+k))
          for (int i = 0; i &lt; N-j-k; i++)
            if ((j+i)/(p+p) == (j+i+k)/(p+p))
             compexch(a[l+j+i], a[l+j+i+k]);
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">The theory of sorting networks has an interesting history (<span class="docEmphasis">see reference section</span>). The problem of finding networks with as few comparators as possible was posed by Bose before 1960, and is called the <span class="docEmphasis">Bose&mdash;Nelson</span> problem. Batcher's networks were the first good solution to the problem, and for some time people conjectured that they were optimal. Batcher's <span class="docEmphasis">merging</span> networks <span class="docEmphasis">are</span> optimal, so any sorting network with substantially fewer comparators has to be constructed <a name="iddle1031"></a><a name="iddle1247"></a><a name="iddle1750"></a><a name="iddle1916"></a><a name="iddle1936"></a><a name="iddle1940"></a><a name="iddle2500"></a>with an approach other than recursive mergesort. The problem of finding optimal sorting networks eluded researchers until, in 1983, Ajtai, Komlos, and Szemeredi proved the existence of networks with <span class="docEmphasis">O(N log N)</span> comparators. However, the AKS networks are a mathematical construction that is not at all practical, and Batcher's networks are still among the best available for practical use.</p>
<p class="docText">The connection between perfect shuffling and Batcher's networks makes it amusing to complete our study of sorting networks by considering yet another version of the algorithm. If we shuffle the lines in Batcher's odd&ndash;even merge, we get networks where all the comparators connect adjacent lines. <a class="docLink" href="#ch11fig08">Figure 11.8</a> illustrates a network that corresponds to the shuffling implementation corresponding to <a class="docLink" href="ch11lev1sec1.html#ch11ex03">Program 11.2</a>. This interconnection pattern is sometimes called a <span class="docEmphasis">butterfly network</span>. Also shown in the figure is another representation of the same straight-line program that provides an even more uniform pattern; it involves only full shuffles.</p>
<a name="ch11fig08"></a><p><center>
<h5 class="docFigureTitle">Figure 11.8. Shuffling in Batcher's odd&ndash; even merge</h5>
<h5></h5><h5></h5></center></p><p class="docText">A direct implementation of <a class="docLink" href="ch11lev1sec1.html#ch11ex03">Program 11.2</a> as a sorting network gives a network replete with recursive unshuffling and shuffling <span class="docEmphasis">(top)</span>. An equivalent implementation <span class="docEmphasis">(bottom)</span> involves only full shuffles.</p>
<p class="docText">
<img border="0" alt="" width="165" height="221" src="11fig08.gif" /></p>
<br />
<p class="docText"><a class="docLink" href="#ch11fig09">Figure 11.9</a> shows yet another interpretation of the method that illustrates the underlying structure. First, we write one file below the other; then, we compare those elements that are vertically adjacent and exchange them if necessary to put the larger one below the smaller one. Next, we split each row in half and interleave the halves, then perform the same compare&ndash;exchange operations on the numbers in the second and third lines. Comparisons involving other pairs of rows are not necessary because of the previous sorting. The split-interleave operation keeps both the rows and the columns of the table sorted. This property is preserved in general by the same operation: Each step doubles the number of rows, halves the number of columns, and still keeps the rows and the columns sorted; eventually we end up with 1 column of <span class="docEmphasis">N</span> rows, which is therefore completely sorted. The connection between the tableaux in <a class="docLink" href="#ch11fig09">Figure 11.9</a> and the network at the bottom in <a class="docLink" href="#ch11fig08">Figure 11.8</a> is that, when we write down the tables in column-major order (the elements in the first column followed by the elements in the second column, and so forth), we see that the permutation required to go from one step to the next is none other than the perfect shuffle.</p>
<a name="ch11fig09"></a><p><center>
<h5 class="docFigureTitle">Figure 11.9. Split-interleave merging</h5>
<h5></h5><h5></h5></center></p><p class="docText">Starting with two sorted files in one row, we merge them by iterating the following operation: split each row in half and interleave the halves <span class="docEmphasis">(left)</span>, and do compare-exchanges between items now vertically adjacent that came from different rows <span class="docEmphasis">(right)</span>. At the beginning we have 16 columns and one row, then eight columns and two rows, then four columns and four rows, then two columns and eight rows, and finally 16 rows and one column, which is sorted.</p>
<p class="docText">
<img border="0" alt="" width="165" height="422" src="11fig09.gif" /></p>
<br />
<p class="docText">Now, with an abstract parallel machine that has the perfect-shuffle interconnection built in, as shown in <a class="docLink" href="#ch11fig10">Figure 11.10</a>, we would be able to implement directly networks like the one at the bottom of <a name="iddle2050"></a><a class="docLink" href="#ch11fig08">Figure 11.8</a>. At each step, the machine does compare&ndash;exchange operations between some pairs of adjacent processors, as indicated by the algorithm, then performs a perfect shuffle of the data. Programming the machine amounts to specifying which pairs of processors should do compare&ndash;exchange operations at each cycle.</p>
<a name="ch11fig10"></a><p><center>
<h5 class="docFigureTitle">Figure 11.10. A perfect shuffling machine</h5>
<h5></h5><h5></h5></center></p><p class="docText">A machine with the interconnections drawn here could perform Batcher's algorithm (and many others) efficiently. Some parallel computers have connections like these.</p>
<p class="docText">
<img border="0" alt="" width="275" height="110" src="11fig10.gif" /></p>
<br />
<p class="docText"><a class="docLink" href="#ch11fig11">Figure 11.11</a> shows the dynamic characteristics of both the bottom-up method and this full-shuffling version of Batcher's odd-even merge.</p>
<a name="ch11fig11"></a><p><center>
<h5 class="docFigureTitle">Figure 11.11. Dynamic characteristics of odd&ndash;even merging</h5>
<h5></h5><h5></h5></center></p><p class="docText">The bottom-up version of the odd&ndash;even merge <span class="docEmphasis">(left)</span> involves a sequence of stages where we compare&ndash;exchange the large half of one sorted subfile with the small half of the next. With full shuffling <span class="docEmphasis">(right)</span>, the algorithm has an entirely different appearance.</p>
<p class="docText">
<img border="0" alt="" width="165" height="537" src="11fig11.gif" /></p>
<br />
<p class="docText">Shuffling is an important abstraction for describing data movement in divide-and-conquer algorithms, and it arises in a variety of problems other than sorting. For example, if a 2<span class="docEmphasis"><sup>n</sup></span>-by-2<span class="docEmphasis"><sup>n</sup></span> square matrix is kept in row-major order, then <span class="docEmphasis">n</span> perfect shuffles will transpose the matrix (convert the matrix to column-major order). More important examples include the fast Fourier transform and polynomial evaluation (see Part 8). We can solve each of these problems using a cycling perfect-shuffle machine like the one shown in <a class="docLink" href="#ch11fig10">Figure 11.10</a> but with more powerful processors. We might even contemplate having general-purpose processors that can shuffle and unshuffle (some real machines of this type have been built); we return to the discussion of such parallel machines in <a class="docLink" href="ch11lev1sec5.html#ch11lev1sec5">Section 11.5</a>.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">11.16</span> Give sorting networks for four (see <a class="docLink" href="ch11lev1sec1.html#ch11qa1q6">Exercise 11.6</a>), five, and six elements. Use as few comparators as possible.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q2"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">11.17</span> Write a program to compute the number of parallel steps required for any given straight-line program. <span class="docEmphasis">Hint</span>: Use the following labeling strategy. Label the input lines as belonging to stage 0, then do the following for each comparator: Label both output lines as inputs to stage <span class="docEmphasis">i</span>+ <tt>1</tt> if the label on one of the input lines is <span class="docEmphasis">i</span> and the label on the other is not greater than <span class="docEmphasis">i</span>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q3"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">11.18</span> Compare the running time of <a class="docLink" href="#ch11ex08">Program 11.4</a> with that of <a class="docLink" href="ch08lev1sec3.html#ch08ex03">Program 8.3</a>, for randomly ordered keys with <span class="docEmphasis">N</span> = 10<sup>3</sup>, 10<span class="docEmphasis"><sup>4</sup></span>, 10<sup>5</sup>, and 10<sup>6</sup>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q4"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">11.19</span> Draw Batcher's network for doing a 10-by-11 merge.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">11.20</span> Prove the relationship between recursive unshuffling and shuffling that is suggested by <a class="docLink" href="#ch11fig08">Figure 11.8</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">11.21</span> From the argument in the text, there are 11 networks for sorting 21 elements hidden in <a class="docLink" href="#ch11fig07">Figure 11.7</a>. Draw the one among these that has the fewest comparators.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q7"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">11.22</span> Give the number of comparators in Batcher's odd&ndash;even sorting networks for 2 <img src="U2264.GIF" border="0" /> <span class="docEmphasis">N</span> <img src="U2264.GIF" border="0" /> 32, where networks when <span class="docEmphasis">N</span> is not a power of 2 are derived from the first <span class="docEmphasis">N</span> lines of the network for the next largest power of 2.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q8"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">11.23</span> For <span class="docEmphasis">N</span> = 2<span class="docEmphasis"><sup>n</sup></span>, derive an exact expression for the number of comparators used in Batcher's odd&ndash;even sorting networks. <span class="docEmphasis">Note</span>: Check your answer against <a class="docLink" href="#ch11fig07">Figure 11.7</a>, which shows that the networks have <span class="docEmphasis">1</span>, <span class="docEmphasis">3</span>, <span class="docEmphasis">9</span>, <span class="docEmphasis">25</span>, and <span class="docEmphasis">65</span> comparators for <span class="docEmphasis">N</span> equal to <span class="docEmphasis">2</span>, <span class="docEmphasis">4</span>, <span class="docEmphasis">8</span>, <span class="docEmphasis">16</span>, and <span class="docEmphasis">32</span>, respectively.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q9"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">11.24</span> Construct a sorting network for sorting 21 elements using a top-down recursive style, where a network of size <span class="docEmphasis">N</span> is a composition of networks of sizes <img src="U230A.GIF" border="0" /><span class="docEmphasis">N</span>/2<img src="U230B.GIF" border="0" /> and <img src="U2308.GIF" border="0" /><span class="docEmphasis">N</span>/2<img src="U2309.GIF" border="0" /> followed by a merging network. (Use your answer from <a class="docLink" href="#ch11qa2q4">Exercise 11.19</a> as the final part of the network.)</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q10"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">11.25</span> Use recurrence relations to compute the number of comparators in sorting networks constructed as described in <a class="docLink" href="#ch11qa2q9">Exercise 11.24</a> for 2 <img src="U2264.GIF" border="0" /> <span class="docEmphasis">N</span> <img src="U2264.GIF" border="0" /> 32. Compare your results with those that you obtained in <a class="docLink" href="#ch11qa2q7">Exercise 11.22</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q11"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">11.26</span> Find a 16-line sorting network that uses fewer comparators than Batcher's network does.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q12"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">11.27</span> Draw the merging networks corresponding to <a class="docLink" href="#ch11fig08">Figure 11.8</a> for bitonic sequences, using the scheme described in <a class="docLink" href="ch11lev1sec1.html#ch11qa1q14">Exercise 11.14</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q13"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">11.28</span> Draw the sorting network corresponding to shellsort with Pratt's increments (see <a class="docLink" href="ch06lev1sec6.html#ch06lev1sec6">Section 6.6</a>), for <span class="docEmphasis">N</span> = 32.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q14"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">11.29</span> Give a table containing the number of comparators in the networks described in <a class="docLink" href="#ch11qa2q13">Exercise 11.28</a> and the number of comparators in Batcher's networks, for <span class="docEmphasis">N</span> = 16, 32, 64, 128, and 256.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q15"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">11.30</span> Design sorting networks that will sort files of <span class="docEmphasis">N</span> elements that are 3-and 4-sorted.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q16"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">11.31</span> Use your networks from <a class="docLink" href="#ch11qa2q15">Exercise 11.30</a> to design a Pratt-like scheme based on multiples of 3 and 4. Draw your network for <span class="docEmphasis">N</span> = 32, and answer <a class="docLink" href="#ch11qa2q14">Exercise 11.29</a> for your networks.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q17"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">11.32</span> Draw a version of Batcher's odd&ndash;even sorting network for <span class="docEmphasis">N</span> = 16 that has perfect shuffles between stages of independent comparators connecting <a name="iddle1875"></a><a name="iddle2380"></a><a name="iddle2398"></a><a name="iddle2406"></a>adjacent lines. (The final four stages of the network should be those from the merging network at the bottom of <a class="docLink" href="#ch11fig08">Figure 11.8</a>.)</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q18"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">11.33</span> Write a merging program for the machine in <a class="docLink" href="#ch11fig10">Figure 11.10</a>, using the following conventions. An instruction is a sequence of 15 bits, where the <span class="docEmphasis">i</span>th bit, for 1 <img src="U2264.GIF" border="0" /> <span class="docEmphasis">i</span> <img src="U2264.GIF" border="0" /> 15, indicates (if it is <tt>1</tt>) that processor <span class="docEmphasis">i</span> and processor <span class="docEmphasis">i</span> - 1 should do a compare&ndash;exchange. A program is a sequence of instructions, and the machine executes a perfect shuffle between each instruction.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch11qa2q19"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">11.34</span> Write a sorting program for the machine in <a class="docLink" href="#ch11fig10">Figure 11.10</a>, using the conventions described in <a class="docLink" href="#ch11qa2q18">Exercise 11.33</a>.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch11lev1sec1.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch11lev1sec3.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>