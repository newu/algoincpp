<html><head><title>4.5. Creation of a New ADT</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch04lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch04lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top"><a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a>C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch04lev1sec5"></a>
<h3 id="title-IDAMNDZH" class="docSection1Title">4.5. Creation of a New ADT</h3>
<p class="docText"><a class="docLink" href="ch04lev1sec2.html#ch04lev1sec2">Sections 4.2</a> through <a class="docLink" href="ch04lev1sec4.html#ch04lev1sec4">4.4</a> present a complete example of C++ code that captures one of our most important abstractions: the pushdown stack. The <span class="docEmphasis">interface</span> in <a class="docLink" href="ch04lev1sec2.html#ch04lev1sec2">Section 4.2</a> defines the basic operations; <span class="docEmphasis">client programs</span> such as those in <a class="docLink" href="ch04lev1sec3.html#ch04lev1sec3">Section 4.3</a> can use those operations without dependence on how the operations are implemented; and <span class="docEmphasis">implementations</span> such as those in <a class="docLink" href="ch04lev1sec4.html#ch04lev1sec4">Section 4.4</a> provide the necessary concrete representation and program code to realize the abstraction.</p>
<p class="docText"><a name="iddle1276"></a><a name="iddle1292"></a><a name="iddle1685"></a>To design a new ADT, we often enter into the following process. Starting with the task of developing a client program to solve an applications problem, we identify operations that seem crucial: What would we <span class="docEmphasis">like</span> to be able to do with our data? Then, we define an interface and write client code to test the hypothesis that the existence of the ADT would make it easier for us to implement the client program. Next, we consider the idea of whether or not we <span class="docEmphasis">can</span> implement the operations in the ADT with reasonable efficiency. If we cannot, we perhaps can seek to understand the source of the inefficiency and to modify the interface to include operations that are better suited to efficient implementation. These modifications affect the client program, and we modify it accordingly. After a few iterations, we have a working client program and a working implementation, so we freeze the interface: We adopt a policy of not changing it. At this moment, the development of client programs and the development of implementations are separable: We can write other client programs that use the same ADT (perhaps we write some driver programs that allow us to test the ADT), we can write other implementations, and we can compare the performance of multiple implementations.</p>
<p class="docText">In other situations, we might define the ADT first. This approach might involve asking questions such as these: What basic operations would client programs want to perform on the data at hand? Which operations do we know how to implement efficiently? After we develop an implementation, we might test its efficacy on client programs. We might modify the interface and do more tests, before eventually freezing the interface.</p>
<p class="docText">In <a class="docLink" href="ch01.html#ch01">Chapter 1</a>, we considered a detailed example where thinking on an abstract level helped us to find an efficient algorithm for solving a complex problem. We consider next the use of the general approach that we are discussing in this chapter to encapsulate the specific abstract operations that we exploited in <a class="docLink" href="ch01.html#ch01">Chapter 1</a>.</p>
<p class="docText"><a class="docLink" href="#ch04ex12">Program 4.9</a> defines the interface, in terms of two operations (in addition to <span class="docEmphasis">construct</span>) that seem to characterize the algorithms that we considered in <a class="docLink" href="ch01.html#ch01">Chapter 1</a> for connectivity, at a high abstract level. Whatever the underlying algorithms and data structures, we want to be able to check whether or not two nodes are known to be connected, and to declare that two nodes are connected.</p>
<p class="docText"></p><a name="ch04ex12"></a><h5 id="title-IDAKRDZH" class="docExampleTitle">Program 4.9. Equivalence-relations ADT interface</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1007"></a><a name="iddle2602"></a>Our ADT interface mechanism makes it convenient for us to encode precisely our decision to consider the connectivity algorithm in terms of a class that suppports three abstract operations: <span class="docEmphasis">initialize</span> an abstract data structure to keep track of connections among the given number of nodes, <span class="docEmphasis">find</span> whether two given nodes are connected, and <span class="docEmphasis">unite</span> two given nodes to consider them connected henceforth.</p>
<div class="docText"><pre> class UF
   {
     private:
       // Implementation-dependent code
     public:
       UF(int);
       int find(int, int);
       void unite(int, int);
   };</pre></div><br />
</td></tr></table></p>
<p class="docText"><a class="docLink" href="#ch04ex13">Program 4.10</a> is a client program that uses the ADT defined in the interface of <a class="docLink" href="#ch04ex12">Program 4.9</a> to solve the connectivity problem. One benefit of using the ADT is that this program is easy to understand, because it is written in terms of abstractions that allow the computation to be expressed in a natural way.</p>
<p class="docText"><a class="docLink" href="#ch04ex14">Program 4.11</a> is an implementation of the union&ndash;find interface defined in <a class="docLink" href="#ch04ex12">Program 4.9</a> that uses a forest of trees represented by two arrays as the underlying representation of the known connectivity information, as described in <a class="docLink" href="ch01lev1sec3.html#ch01lev1sec3">Section 1.3</a>. The different algorithms that we considered in <a class="docLink" href="ch01.html#ch01">Chapter 1</a> represent different implementations of this ADT, and we can test them as such without changing the client program at all.</p>
<p class="docText">This ADT leads to programs that are slightly less efficient than those in <a class="docLink" href="ch01.html#ch01">Chapter 1</a> for the connectivity application, because it does not take advantage of the property of that client that every <span class="docEmphasis">union</span> operation is immediately preceded by a <span class="docEmphasis">find</span> operation. We sometimes incur extra costs of this kind as the price of moving to a more abstract representation. In this case, there are numerous ways to remove the inefficiency, perhaps at the cost of making the interface or the implementation more complicated (see <a class="docLink" href="#ch04qa6q2">Exercise 4.30</a>). In practice, the paths are extremely short (particularly if we use path compression), so the extra cost is likely to be negligible in this case.</p>
<a name="ch04ex13"></a><h5 id="title-IDAYUDZH" class="docExampleTitle">Program 4.10. Equivalence-relations ADT client</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The ADT of <a class="docLink" href="#ch04ex12">Program 4.9</a> separates the connectivity algorithm from the union&ndash;find implementation, making that algorithm more accessible.</p>
<div class="docText"><pre>#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
#include "UF.cxx"
int main(int argc, char *argv[])
  { int p, q, N = atoi(argv[1]);
    UF info(N);
    while (cin &gt;&gt; p &gt;&gt; q)
      if (!info.find(p, q))
        {
          info.unite(p, q);
          cout &lt;&lt; " " &lt;&lt; p &lt;&lt; " " &lt;&lt; q &lt;&lt; endl;
        }
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">The combination of <a class="docLink" href="#ch04ex13">Programs 4.10</a> and <a class="docLink" href="#ch04ex14">4.11</a> is operationally equivalent to <a class="docLink" href="ch01lev1sec3.html#ch01ex05">Program 1.3</a>, but splitting the program into two parts is a more effective approach because it</p>
<ul><li><p class="docList">Separates the task of solving the high-level (connectivity) problem from the task of solving the low-level (union&ndash;find) problem, allowing us to work on the two problems independently</p></li><li><p class="docList">Gives us a natural way to compare different algorithms and data structures for solving the problem</p></li><li><p class="docList">Defines, through the interface, a way to check that the software is operating as expected</p></li><li><p class="docList">Provides a mechanism that allows us to upgrade to new representations (new data structures or new algorithms) without changing the client program at all</p></li><li><p class="docList">Gives us an abstraction that we can use to build other algorithms These benefits are widely applicable to many tasks that we face when developing computer programs, so the basic tenets underlying ADTs are widely used.</p></li></ul>
<p class="docText"></p><a name="ch04ex14"></a><h5 id="title-IDACXDZH" class="docExampleTitle">Program 4.11. Equivalence-relations ADT implementation</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText"><a name="iddle1275"></a><a name="iddle1628"></a><a name="iddle2622"></a>This code for the weighted-quick-union code from <a class="docLink" href="ch01.html#ch01">Chapter 1</a>, implements the interface of <a class="docLink" href="#ch04ex12">Program 4.9</a>, packaging the code in a form that makes it convenient for use in other applications. The implementation overloads the name <tt>find</tt> in a private member function that implements the traversal up to the root in the tree.</p>
<div class="docText"><pre>class UF
  {
    private:
      int *id, *sz;
      int find(int x)
        { while (x != id[x]) x = id[x]; return x; }
    public:
      UF(int N)
        {
          id = new int[N]; sz = new int[N];
          for (int i = 0; i &lt; N; i++)
            { id[i] = i; sz[i] = 1; }
        }
      int find(int p, int q)
        { return (find(p) == find(q)); }
      void unite(int p, int q)
        { int i = find(p), j = find(q);
          if (i == j) return;
          if (sz[i] &lt; sz[j])
               { id[i] = j; sz[j] += sz[i]; }
          else { id[j] = i; sz[i] += sz[j]; }
        }
  };</pre></div><br />
</td></tr></table></p>
<p class="docText">Our code in <a class="docLink" href="#ch04ex14">Program 4.11</a> mixes the interface with the implementation and therefore does not provide for separate compilation of clients and implementations. To ensure that different implementations use the same interface, we could, as in <a class="docLink" href="ch03lev1sec1.html#ch03lev1sec1">Section 3.1</a>, separate the program into three files as follows.</p>
<p class="docText">Make a header file&mdash;called, say, <tt>UF.h</tt>&mdash;containing the class declaration, data representation, and function declarations, but not the function definitions. For the example that we have been considering, this would consist of the code in <a class="docLink" href="#ch04ex12">Program 4.9</a>, but with the data representation (the <tt>private</tt> declarations in <a class="docLink" href="#ch04ex14">Program 4.11</a>) also included. Then, keep the function definitions in a separate <tt>.cxx</tt> file that contains an <tt>include</tt> directive for <tt>UF.h</tt> (as do any clients). With this arrangement, we can separately compile clients and implementations. Indeed, we can put any class member function definition into a separate file, so long as the class declares the member function and we prepend the class name and <tt>::</tt> to the function name in the definition. For example, the definition of <tt>find</tt> for our example would be written as follows:</p>
<div class="docText"><pre>int UF::find(int p, int q)
  { return (find(p) == find(q)); }</pre></div><br />
<p class="docText">Unfortunately, different compilers impose different requirements for template instantiation under separate compilation. The problem is that the compiler cannot produce code for the member functions without knowing the type of the template parameter, which is inaccessible since it is specified in the main program. Defining the member functions inside the class declarations avoids these compiler conundrums.</p>
<p class="docText">This 3-file convention is still not ideal, however, because the data representation, though it is really a part of the implementation, is kept in a file with the interface. With <tt>private</tt>, we can keep client programs from reading it, but if we make changes in the implementation that require changes in the data representation, we have to change the <tt>.h</tt> file, and recompile all the clients. In many software engineering scenarios, we may have no information about the clients, so this would be an onerous requirement. In other scenarios, this arrangement does make sense. For a huge and complex ADT, we might settle on a data representation and an interface, then have multiple programmers working on different parts of the implementation. In this case, the public part of the interface serves as a contract between the programmers and the clients, and the private part of the interface serves as a contract among programmers. This strategy also often provides precisely what we need in this book, when we want to find the best way to solve a given problem, under the constraint that we have to use a particular data structure. We might be able to realize performance gains by changing a small part of a huge system, in this way.</p>
<p class="docText">The C++ language does provide a mechanism that is specifically designed to allow us to write programs with a well-defined interface <a name="iddle1003"></a><a name="iddle1262"></a><a name="iddle1266"></a><a name="iddle1351"></a><a name="iddle1532"></a><a name="iddle1537"></a><a name="iddle1684"></a><a name="iddle1856"></a><a name="iddle2128"></a><a name="iddle2614"></a>that completely separates clients from implementations. It is based on the concept of the <span class="docEmphasis">derived class</span>, through which we can augment or redefine some members of an existing class. Including <tt>virtual</tt> in a member function declaration means that the function <span class="docEmphasis">may</span> be redefined in a derived class; including <tt>= 0</tt> at the end of a member function declaration indicates that it is a <span class="docEmphasis">pure virtual function</span>, which <span class="docEmphasis">must</span> be redefined in any derived class. Derived classes provide a convenient way for programmers to build upon the work of others and are an essential component of object-oriented programming systems.</p>
<a name="ch04ex15"></a><h5 id="title-IDA53DZH" class="docExampleTitle">Program 4.12. Abstract class for equivalence-relations ADT</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This code constitutes an interface for the equivalence-relations ADT that provides complete separation between client and implementation (<span class="docEmphasis">see text</span>).</p>
<div class="docText"><pre>class uf
  {
    public:
      virtual uf(int) = 0;
      virtual int find(int, int) = 0;
      virtual void unite(int, int) = 0;
  };</pre></div><br />
</td></tr></table></p>
<p class="docText">An <span class="docEmphasis">abstract class</span> is one whose members are all pure virtual functions. Any class derived from an abstract class must define all of the member functions and any necessary private data members; so, in our terminology, the abstract class is an interface and any class derived from it is an implementation. Clients can use the interface and the C++ system can enforce the contract between clients and implementations, even when clients and function implementations are compiled separately. For example, <a class="docLink" href="#ch04ex15">Program 4.12</a> shows an abstract class <tt>uf</tt> for equivalence relations; changing the first line of <a class="docLink" href="#ch04ex14">Program 4.11</a> to</p>
<div class="docText"><pre>class UF : public class uf</pre></div><br />
<p class="docText">would indicate that <tt>UF</tt> is derived from <tt>uf</tt>, so it defines (at least) all of the member functions in <tt>uf</tt>&mdash;that is, it is an implementation of interface <tt>uf</tt>.</p>
<p class="docText">Unfortunately, using abstract classes incurs significant runtime costs, because every call to a virtual function requires following a pointer through a table of pointers to member functions. Furthermore, compilers are far more restricted in their ability to produce optimized code for abstract classes. Since the algorithms and data structures that we consider in this book are often in performance-critical parts of systems, we may not wish to pay these penalties to gain the flexibility that abstract classes provide.</p>
<p class="docText">Yet another way to proceed is to adopt a 4-file strategy, where we keep the private parts in a separate file, not in the interface. For our example, we could add</p>
<div class="docText"><pre>private:
#include "UFprivate.h"</pre></div><br />
<p class="docText">as the first two lines of the class in <a class="docLink" href="#ch04ex12">Program 4.9</a>, and then put</p>
<div class="docText"><pre>int *id, *sz;
int find(int);</pre></div><br />
<p class="docText">in the file <tt>UFprivate.h</tt>. This strategy does cleanly separate the four components (client, implementation, data representation, and interface) and gives us maximum flexibility in experimenting with data structures and algorithms.</p>
<p class="docText">The kind of flexibility that we can achieve with derived classes and the 4-file strategy leaves open the possibility that the implied contract between clients and implementations about what an ADT is to be may be broken, perhaps unwittingly, at some future time. All of these mechanisms ensure that client programs and implementations link up properly, but they also depend on one another to <span class="docEmphasis">do</span> things, in ways that we generally cannot specify formally. For example, suppose that some uninformed programmer finds our weighted quick-find algorithm too difficult to understand and decides to replace it with a quick-union algorithm (or worse, an implementation that does not even give the right answer). We have insisted on allowing such a change to be made easily, but, in this case, it might cripple a client in a critical application that depends upon the implementation having good performance for huge problems implementation. Programming lore is filled with tales of such problems, and it is quite difficult to protect against them.</p>
<p class="docText">Such considerations, however, are drawing us into considering properties of languages, compilers, linkers, and run-time systems, and rather far afield from algorithms. Accordingly, we will most often stick to our simple 2-file convention where we implement ADTs with <a name="iddle1008"></a><a name="iddle1480"></a>C++ classes, the public member functions constituting the interface, and the interface-implementation mix in a separate file that is included by clients (and recompiled whenever the clients are recompiled). Our primary reason for doing so is that the class implementation is a convenient and compact expression of our data structures and algorithms. If, for a particular application, we need the extra flexibility afforded by the other approaches just mentioned, we can restructure our classes along these lines.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa6q1"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.29</span> Modify <a class="docLink" href="#ch04ex14">Program 4.11</a> to use path compression by halving.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa6q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.30</span> Remove the inefficiency mentioned in the text by adding an operation to <a class="docLink" href="#ch04ex12">Program 4.9</a> that combines <span class="docEmphasis">union</span> and <span class="docEmphasis">find</span>, providing an implementation in <a class="docLink" href="#ch04ex14">Program 4.11</a>, and modifying <a class="docLink" href="#ch04ex13">Program 4.10</a> accordingly.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa6q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">4.31</span> Modify our equivalence-relations interface (<a class="docLink" href="#ch04ex12">Program 4.9</a>) and implementation (<a class="docLink" href="#ch04ex14">Program 4.11</a>) to provide a function that will return the number of nodes known to be connected to a given node.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa6q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">4.32</span> Modify <a class="docLink" href="#ch04ex14">Program 4.11</a> to use an array of structures instead of parallel arrays for the underlying data structure.</p>
</td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa6q5"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">4.33</span> Build a 3-file solution to the postfix-expression evaluation problem, using a stack of integers (no templates). Make sure that your client program (your version of <a class="docLink" href="ch04lev1sec3.html#ch04ex07">Program 4.5</a> can be compiled separately from your stack implementation (your version of <a class="docLink" href="ch04lev1sec4.html#ch04ex09">Program 4.7</a>).</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa6q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="9" src="circle.jpg" /> <span class="docEmphStrong">4.34</span> Modify your solution to the previous exercise to separate the data representation from the member function implementations (a 4-file solution). Test your answer by substituting a linked-list stack implementation (a version of <a class="docLink" href="ch04lev1sec4.html#ch04ex10">Program 4.8</a>) without recompiling the client.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch04qa6q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">4.35</span> Create a full implementation of the equivalence-relations ADT based on an abstract class with virtual functions, and compare its performance against <a class="docLink" href="#ch04ex14">Program 4.11</a> on huge connectivity problems, in the style of <a class="docLink" href="ch01lev1sec3.html#ch01table01">Table 1.1</a>.</p></td></tr></table></p>
<a href="17051538.html"><img src="pixel.gif" alt="" width="1" height="1" border="0" /></a><ul></ul></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch04lev1sec4.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch04lev1sec6.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="top" align="right"><span style="white-space:nowrap"><a target="_self" href="#toppage" title="Top"></a></span></td></tr></table></div><!--IP User 2--></td></tr></table></td></body></head></html>