<html><head><title>6.6. Shellsort</title><title>TeamUnknown</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/globalstyle.css" /><link href="includes/searchResults.css" rel="stylesheet" type="text/css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/style.css" /><link rel="STYLESHEET" type="text/css" href="portals/bvdep/xsltemplates/docsafari.css" /><body><table width="100%" border="0" cellspacing="0" cellpadding="0"><td class="docBookTitle"><a href="toc.html"><b>[ Team Unknown ]</b></a></td></table><td align="center"><a name="MainContent"></a><table width="95%"><tr><td align="left" class="v2"><!--Copyright (c) 2002 Safari Tech Books Online--><table width="100%" border="0" cellspacing="0" cellpadding="2"><tr><td valign="middle" class="v2" height="5"><img src="pixel.gif" width="1" height="5" alt="" border="0" /></td></tr><tr><td valign="middle" class="v2"><table cellpadding="0" cellspacing="0" border="0" width="100%"><tr><td align="left"><span style="white-space:nowrap">&nbsp;</span>
                  &nbsp;
                  <span style="white-space:nowrap"> &nbsp;&nbsp;</span>
            &nbsp;<span style="white-space:nowrap">&nbsp;</span></td></tr></table></td><td></td><td valign="middle" class="v2" align="right"><a href="17051538.html"><img src="btn_next_.gif" width="1" height="1" alt="Next" border="0" /></a> 
          &nbsp;
          <span style="white-space:nowrap"><a target="_self" href="ch06lev1sec5.html" title="Previous section"><img border="0" align="absmiddle" src="btn_prev.gif" alt="Previous section" id="btn_prev" /></a></span>
				
				&nbsp;
				
				<span style="white-space:nowrap"><a target="_self" href="ch06lev1sec7.html" title="Next section"><img border="0" align="absmiddle" src="btn_next.gif" alt="Next section" id="btn_next" /></a></span></td></tr></table><div id="section"><br /><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top">C++ Programming Robert Sedgewick - Princeton University Addison Wesley Professional Algorithms in C++, Parts 1&ndash;4: Fundamentals, Data Structure, Sorting, Searching, Third Edition<a name="ch06lev1sec6"></a>
<h3 id="643999-914" class="docSection1Title">6.6. Shellsort</h3>
<p class="docText">Insertion sort is slow because the only exchanges it does involve adjacent items, so items can move through the array only one place at a time. For example, if the item with the smallest key happens to be at the end of the array, <span class="docEmphasis">N</span> steps are needed to get it where it belongs. <span class="docEmphasis">Shellsort</span> is a simple extension of insertion sort that gains speed by allowing exchanges of elements that are far apart.</p>
<p class="docText">The idea is to rearrange the file to give it the property that taking every <span class="docEmphasis">h</span>th element (starting anywhere) yields a sorted file. Such a file is said to be <span class="docEmphasis">h</span><span class="docEmphasis">-sorted</span>. Put another way, an <span class="docEmphasis">h</span>-sorted file is <span class="docEmphasis">h</span> independent sorted files, interleaved together. By <span class="docEmphasis">h</span>-sorting for some large values of <span class="docEmphasis">h</span>, we can move elements in the array long distances and thus make it easier to <span class="docEmphasis">h</span>-sort for smaller values of <span class="docEmphasis">h</span>. Using such a procedure for any sequence of values of <span class="docEmphasis">h</span> that ends in 1 will produce a sorted file: that is the essence of shellsort.</p>
<p class="docText">One way to implement shellsort would be, for each <span class="docEmphasis">h</span>, to use insertion sort independently on each of the <span class="docEmphasis">h</span> subfiles. Despite the apparent simplicity of this process, we can use an even simpler approach, precisely because the subfiles are independent. When <span class="docEmphasis">h</span>-sorting the file, we simply insert it among the previous elements in its <span class="docEmphasis">h</span>-subfile by moving larger elements to the right (see <a class="docLink" href="#ch06fig08">Figure 6.8</a>). We accomplish this task by using the insertion-sort code, but modified to increment or decrement by <span class="docEmphasis">h</span> instead of 1 when moving through the file. This observation reduces the shellsort implementation to nothing more than an insertion-sort&ndash;like pass through the file for each increment, as in <a class="docLink" href="#ch06ex13">Program 6.5</a>. The operation of this program is illustrated in <a class="docLink" href="#ch06fig09">Figure 6.9</a>.</p>
<a name="ch06fig08"></a><p><center>
<h5 class="docFigureTitle">Figure 6.8. Interleaving 4-sorts</h5>
<h5></h5><h5></h5></center></p><p class="docText">The top part of this diagram shows the process of 4-sorting a file of 15 elements by first insertion sorting the subfile at positions 0, 4, 8, 12, then insertion sorting the subfile at positions 1, 5, 9, 13, then insertion sorting the subfile at positions 2, 6, 10, 14, then insertion sorting the subfile at positions 3, 7, 11. But the four subfiles are independent, so we can achieve the same result by inserting each element into position into its subfile, going back four at a time (bottom). Taking the first row in each section of the top diagram, then the second row in each section, and so forth, gives the bottom diagram.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="200" height="333" src="06fig08.gif" /></p>
<br />
<a name="ch06fig09"></a><p><center>
<h5 class="docFigureTitle">Figure 6.9. Shellsort example</h5>
<h5></h5><h5></h5></center></p><p class="docText">Sorting a file by 13-sorting (top), then 4-sorting (center), then 1-sorting (bottom) does not involve many comparisons (as indicated by the unshaded elements). The final pass is just insertion sort, but no element has to move far because of the order in the file due to the first two passes.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="185" height="375" src="06fig09.gif" /></p>
<br />
<p class="docText">How do we decide what increment sequence to use? In general, this question is a difficult one to answer. Properties of many different increment sequences have been studied in the literature, and some have been found that work well in practice, but no provably best sequence has been found. In practice, we generally use sequences that decrease roughly geometrically, so the number of increments is logarithmic in the size of the file. For example, if each increment is about one-half of the previous, then we need only about 20 increments <a name="iddle1744"></a>to sort a file of 1 million elements; if the ratio is about one-quarter, then 10 increments will suffice. Using as few increments as possible is an important consideration that is easy to respect&mdash;we also need to consider arithmetical interactions among the increments such as the size of their common divisors and other properties.</p>
<a name="ch06ex13"></a><h5 id="title-IDARFASE" class="docExampleTitle">Program 6.5. Shellsort</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">If we do not use sentinels and then replace every occurrence of &quot;1&quot; by &quot;<span class="docEmphasis">h</span>&quot; in insertion sort, the resulting program <span class="docEmphasis">h</span>-sorts the file. Adding an outer loop to change the increments leads to this compact shellsort implementation, which uses the increment sequence <tt>1 4 13 40 121 364 1093 3280 9841 . . . .</tt></p>
<div class="docText"><pre>template &lt;class Item&gt;
void shellsort(Item a[], int l, int r)
  { int h;
    for (h = 1; h &lt;= (r-l)[/]9; h = 3*h+1) ;
    for ( ; h &gt; 0; h [/]= 3)
      for (int i = l+h; i &lt;= r; i++)
        { int j = i; Item v = a[i];
          while (j &gt;= l+h &amp;&amp; v &lt; a[j-h])
            { a[j] = a[j-h]; j -= h; }
          a[j] = v;
        }
  }</pre></div><br />
</td></tr></table></p>
<p class="docText">The practical effect of finding a good increment sequence is limited to perhaps a 25% speedup, but the problem presents an intriguing puzzle that provides a good example of the inherent complexity in an apparently simple algorithm.</p>
<p class="docText">The increment sequence 1 4 13 40 121 364 1093 3280 9841 . . . that is used in <a class="docLink" href="#ch06ex13">Program 6.5</a>, with a ratio between increments of about one-third, was recommended by Knuth in 1969 (<span class="docEmphasis">see reference section</span>). It is easy to compute (start with 1, generate the next increment by multiplying by 3 and adding 1) and leads to a relatively efficient sort, even for moderately large files, as illustrated in <a class="docLink" href="#ch06fig10">Figure 6.10</a>.</p>
<a name="ch06fig10"></a><p><center>
<h5 class="docFigureTitle">Figure 6.10. Shellsorting a random permutation</h5>
<h5></h5><h5></h5></center></p><p class="docText">The effect of each of the passes in Shellsort is to bring the file as a whole closer to sorted order. The file is first 40-sorted, then 13-sorted, then 4-sorted, then 1-sorted. Each pass brings the file closer to sorted order.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="400" height="129" src="06fig10.gif" /></p>
<br />
<p class="docText">Many other increment sequences lead to a more efficient sort but it is difficult to beat the sequence in <a class="docLink" href="#ch06ex13">Program 6.5</a> by more than 20% even for relatively large <span class="docEmphasis">N</span>. One increment sequence that does so is 1 <a name="iddle2346"></a>8 23 77 281 1073 4193 16577 . . ., the sequence <tt>4<sup><span class="docEmphasis">i</span>+1</sup> + 3.2<sup><span class="docEmphasis">i</span></sup>+ 1</tt> for <span class="docEmphasis">i</span> &gt;0, which has provably faster worst-case behavior (see <a class="docLink" href="#ch06ex17">Property 6.10</a>). <a class="docLink" href="#ch06fig12">Figure 6.12</a> shows that this sequence and Knuth's sequence&mdash;and many other sequences&mdash;have similar dynamic characteristics for large files. The possibility that even better increment sequences exist is still real. A few ideas on improved increment sequences are explored in the exercises.</p>
<a name="ch06fig12"></a><p><center>
<h5 class="docFigureTitle">Figure 6.12. Dynamic characteristics of shellsort (two different increment sequences)</h5>
<h5></h5><h5></h5></center></p><p class="docText">In this representation of shellsort in operation, it appears as though a rubber band, anchored at the corners, is pulling the points toward the diagonal. Two increment sequences are depicted: 121 40 13 4 1 (left) and 209 109 41 19 5 1 (right). The second requires one more pass than the first, but is faster because each pass is more efficient.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="165" height="475" src="06fig12.gif" /></p>
<br />
<p class="docText">On the other hand, there are some bad increment sequences: for example 1 2 4 8 16 32 64 128 256 512 1024 2048 . . . (the original sequence suggested by Shell when he proposed the algorithm in 1959 (<span class="docEmphasis">see reference section</span>)) is likely to lead to bad performance because elements in odd positions are not compared against elements in even positions until the final pass. The effect is noticeable for random files, and is catastrophic in the worst case: The method degenerates to require quadratic running time if, for example, the half of the elements with the smallest values are in even positions and the half of the elements with the largest values are in the odd positions (See <a class="docLink" href="#ch06qa6q4">Exercise 6.36</a>.)</p>
<p class="docText"><a class="docLink" href="#ch06ex13">Program 6.5</a> computes the next increment by dividing the current one by 3, after initializing to ensure that the same sequence is always used. Another option is just to start with <tt>h = N/3</tt> or with some other function of <span class="docEmphasis">N</span>. It is best to avoid such strategies, because bad sequences of the type described in the previous paragraph are likely to turn up for some values of <span class="docEmphasis">N</span>.</p>
<p class="docText">Our description of the efficiency of shellsort is necessarily imprecise, because no one has been able to analyze the algorithm. This gap in our knowledge makes it difficult not only to evaluate different increment sequences, but also to compare shellsort with other methods analytically. Not even the functional form of the running time for shellsort is known (furthermore, the form depends on the increment sequence). Knuth found that the functional forms <span class="docEmphasis">N</span>(log <span class="docEmphasis">N</span>)<sup>2</sup> and <span class="docEmphasis">N</span><sup>1.25</sup> both fit the data reasonably well, and later research suggests that a more complicated function of the form <img border="0" alt="" id="118095012104" width="90" height="21" src="287inlineequ01.jpg" /> is involved for some sequences.</p>
<p class="docText">We conclude this section by digressing into a discussion of several facts about the analysis of shellsort that <span class="docEmphasis">are</span> known. Our primary purpose in doing so is to illustrate that even algorithms that are apparently simple can have complex properties, and that the analysis of algorithms is not just of practical importance but also can be intellectually <a name="iddle1493"></a><a name="iddle1624"></a><a name="iddle2350"></a>challenging. Readers intrigued by the idea of finding a new and improved shellsort increment sequence may find the information that follows useful; other readers may wish to skip to <a class="docLink" href="ch06lev1sec7.html#ch06lev1sec7">Section 6.7</a>.</p>
<a name="ch06ex14"></a><h5 id="title-IDA2MASE" class="docExampleTitle">Property 6.7. The result of <span class="docEmphasis">h</span>-sorting a file that is <span class="docEmphasis">k</span>-ordered is a file that is both <span class="docEmphasis">h</span>- and <span class="docEmphasis">k</span>-ordered</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">This fact seems obvious, but is tricky to prove (see <a class="docLink" href="#ch06qa6q15">Exercise 6.47</a>).</p>
</td></tr></table></p>
<a name="ch06ex15"></a><h5 id="title-IDA3NASE" class="docExampleTitle">Property 6.8. Shellsort does less than <span class="docEmphasis">N</span>(<span class="docEmphasis">h</span> &ndash; 1)(<span class="docEmphasis">k</span> &ndash; 1)/<span class="docEmphasis">g</span> comparisons to <span class="docEmphasis">g</span>-sort a file that is <span class="docEmphasis">h</span>- and <span class="docEmphasis">k</span>-ordered, provided that <span class="docEmphasis">h</span> and <span class="docEmphasis">k</span> are relatively prime</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The basis for this fact is illustrated in <a class="docLink" href="#ch06fig11">Figure 6.11</a>. No element farther than (<span class="docEmphasis">h</span> &ndash; 1)(<span class="docEmphasis">k</span> &ndash;1) positions to the left of any given element <span class="docEmphasis">x</span> can be greater than <span class="docEmphasis">x</span>, if <span class="docEmphasis">h</span> and <span class="docEmphasis">k</span> are relatively prime (see <a class="docLink" href="#ch06qa6q11">Exercise 6.43</a>). When <span class="docEmphasis">g</span>-sorting, we examine at most one out of every <span class="docEmphasis">g</span> of those elements.</p>
<a name="ch06fig11"></a><p><center>
<h5 class="docFigureTitle">Figure 6.11. A 4- and 13- ordered file</h5>
<h5></h5><h5></h5></center></p><p class="docText">The bottom row depicts an array, with shaded boxes depicting those items that must be smaller than or equal to the item at the far right, if the array is both 4- and 13-ordered. The four rows at top depict the origin of the pattern. If the item at right is at array position <span class="docEmphasis">i</span>, then 4-ordering means that items at array positions <span class="docEmphasis">i</span>&ndash;4, <span class="docEmphasis">i</span>&ndash;8, <span class="docEmphasis">i</span>&ndash;12, . . . are smaller or equal (top); 13-ordering means that the item at <span class="docEmphasis">i</span>&ndash;13, and, therefore, because of 4-ordering, the items at <span class="docEmphasis">i</span>&ndash;17, <span class="docEmphasis">i</span>&ndash;21, <span class="docEmphasis">i</span>&ndash;25, . . . are smaller or equal (second from top); also, the item at <span class="docEmphasis">i</span>&ndash;26, and, therefore, because of 4-ordering, the items at <span class="docEmphasis">i</span>&ndash;30, <span class="docEmphasis">i</span>&ndash;34, <span class="docEmphasis">i</span>&ndash;38, . . . are smaller or equal (third from top); and so forth. The white squares remaining are those that could be larger than the item at left; there are at most 18 such items (and the one that is farthest away is at <span class="docEmphasis">i</span>&ndash;36). Thus, at most 18<span class="docEmphasis">N</span> comparisons are required for an insertion sort of a 13-ordered and 4-ordered file of size <span class="docEmphasis">N</span>.</p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="500" height="80" src="06fig11.gif" /></p>
</td></tr></table></p><br />
</td></tr></table>
<a name="ch06ex16"></a><h5 id="title-IDAYRASE" class="docExampleTitle">Property 6.9. Shellsort does less than O(<span class="docEmphasis">N</span><sup>3/2</sup>) comparisons for the increments 1 4 13 40 121 364 1093 3280 9841 . . .</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">For large increments, there are <span class="docEmphasis">h</span> subfiles of size about <span class="docEmphasis">N/h</span>, for a worst-case cost about <span class="docEmphasis">N</span><sup>2</sup>/<span class="docEmphasis">h</span>. For small increments, <a class="docLink" href="#ch06ex15">Property 6.8</a> implies that the cost is about <span class="docEmphasis">Nh</span>. The result follows if we use the better of these bounds for each increment. It holds for any relatively prime sequence that grows exponentially.</p>
</td></tr></table></p>
<a name="ch06ex17"></a><h5 id="title-IDA5SASE" class="docExampleTitle">Property 6.10. Shellsort does less than O(<span class="docEmphasis">N</span><sup>4/3</sup>) comparisons for the increments 1 8 23 77 281 1073 4193 16577 . . .</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The proof of this property is along the lines of the proof of <a class="docLink" href="#ch06ex16">Property 6.9</a>. The property analogous to <a class="docLink" href="#ch06ex15">Property 6.8</a> implies that the cost for small increments is about <span class="docEmphasis">Nh</span><sup>1/2</sup>. Proof of this property requires number theory that is beyond the scope of this book (<span class="docEmphasis">see reference section</span>).</p>
</td></tr></table></p>
<p class="docText"><a name="iddle1630"></a><a name="iddle2088"></a><a name="iddle2349"></a>The increment sequences that we have discussed to this point are effective because successive elements are relatively prime. Another family of increment sequences is effective precisely because successive elements are <span class="docEmphasis">not</span> relatively prime.</p>
<p class="docText">In particular, the proof of <a class="docLink" href="#ch06ex15">Property 6.8</a> implies that, in a file that is 2-ordered and 3-ordered, each element moves at most one position during the final insertion sort. That is, such a file can be sorted with one bubble-sort pass (the extra loop in insertion sort is not needed). Now, if a file is 4-ordered and 6-ordered, then it also follows that each element moves at most one position when we are 2-sorting it (because each subfile is 2-ordered and 3-ordered); and if a file is 6-ordered and 9-ordered, each element moves at most one position when we are 3-sorting it. Continuing this line of reasoning, we are led to the following idea, which was developed by Pratt in 1971 (<span class="docEmphasis">see reference section</span>).</p>
<p class="docText">Pratt's method is based upon using the following triangle of increments, where each number in the triangle is two times the number above and to the right of it and also three times the number above and to the left of it.</p>
<div class="docText"><pre>           1
          2 3
         4 6 9
       8 12 18 27
     16 24 36 54 81
  32 48 72 108 162 243
64 96 144 216 324 486 729</pre></div><br />
<p class="docText">If we use these numbers from bottom to top and right to left as a shellsort increment sequence, then every increment <span class="docEmphasis">x</span> after the bottom <a name="iddle1426"></a>row is preceded by 2<span class="docEmphasis">x</span> and 3<span class="docEmphasis">x</span>, so every subfile is 2-ordered and 3-ordered, and no element moves more than one position during the entire sort!</p>
<a name="ch06ex18"></a><h5 id="title-IDAGWASE" class="docExampleTitle">Property 6.11. Shellsort does less than O(<span class="docEmphasis">N</span>(log <span class="docEmphasis">N</span>)<sup>2</sup>) comparisons for the increments 1 2 3 4 6 9 8 12 18 27 16 24 36 54 81 . . .</h5><p><table cellspacing="0" width="90%" border="1" cellpadding="5"><tr><td>
<p class="docText">The number of increments in the triangle that are less than <span class="docEmphasis">N</span> is certainly less than (log<sub>2</sub> <span class="docEmphasis">N</span>)<sup>2</sup>.</p>
</td></tr></table></p>
<p class="docText">Pratt's increments tend not to work as well as the others in practice, because there are too many of them. We can use the same principle to build an increment sequence from <span class="docEmphasis">any</span> two relatively prime numbers <span class="docEmphasis">h</span> and <span class="docEmphasis">k</span>. Such sequences do well in practice because the worst-case bounds corresponding to <a class="docLink" href="#ch06ex18">Property 6.11</a> overestimate the cost for random files.</p>
<p class="docText">The problem of designing good increment sequences for shellsort provides an excellent example of the complex behavior of a simple algorithm. We certainly will not be able to focus at this level of detail on all the algorithms that we encounter (not only do we not have the space, but also, as we did with shellsort, we might encounter mathematical analysis beyond the scope of this book, or even open research problems). However, many of the algorithms in this book are the product of extensive analytic and empirical studies by many researchers over the past several decades, and we can benefit from this work. This research illustrates that the quest for improved performance can be both intellectually challenging and practically rewarding, even for simple algorithms. <a class="docLink" href="#ch06table02">Table 6.2</a> gives empirical results that show that several approaches to designing increment sequences work well in practice; the relatively short sequence 1 8 23 77 281 1073 4193 16577 . . . is among the simplest to use in a shellsort implementation.</p>
<a name="ch06table02"></a><p><table cellspacing="0" frame="hsides" rules="none" cellpadding="5"><caption><h5 class="docTableTitle">Table 6.2. Empirical study of shellsort increment sequences</h5></caption><colgroup align="left" span="7"><col width="75"></col><col width="75"></col><col width="75"></col><col width="75"></col><col width="75"></col><col width="75"></col><col width="75"></col></colgroup><thead></thead><tr><td class="docTableCell" align="left" valign="top" colspan="7"><p class="docText">Shellsort is many times faster than the other elementary methods even when the increments are powers of 2, but some increment sequences can speed it up by another factor of 5 or more. The three best sequences in this table are totally different in design. Shellsort is a practical method even for large files, particularly by contrast with selection sort, insertion sort, and bubble sort (see <a class="docLink" href="ch06lev1sec5.html#ch06table01">Table 6.1</a>).</p></td></tr><tr><td class="bottomBorder" align="center" valign="top"><p class="docText"><span class="docEmphasis">N</span></p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">O</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">K</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">G</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">S</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">P</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">I</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">12500</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">16</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">6</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">6</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">5</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">6</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">6</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">25000</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">37</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">13</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">11</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">12</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">15</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">10</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">50000</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">102</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">31</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">30</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">27</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">38</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">26</p></td></tr><tr><td class="docTableCell" align="center" valign="top"><p class="docText">100000</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">303</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">77</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">60</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">63</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">81</p></td><td class="docTableCell" align="center" valign="top"><p class="docText">58</p></td></tr><tr><td class="bottomBorder" align="center" valign="top"><p class="docText">200000</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">817</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">178</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">137</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">139</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">180</p></td><td class="bottomBorder" align="center" valign="top"><p class="docText">126</p></td></tr><tr><td class="docTableCell" align="left" valign="top" colspan="7"><p class="docText"><span class="docEmphasis">Key</span>:</p>
<blockquote><p></p><p class="docList">O 1 2 4 8 16 32 64 128 256 512 1024 2048 . . .</p></blockquote></td></tr></table></p><p></p><p class="docList">K 1 4 13 40 121 364 1093 3280 9841 . . . (<a class="docLink" href="#ch06ex16">Property 6.9</a>)</p><p></p><p class="docList">G 1 2 4 10 23 51 113 249 548 1207 2655 5843 . . . (<a class="docLink" href="#ch06qa6q8">Exercise 6.40</a>)</p><p></p><p class="docList">S 1 8 23 77 281 1073 4193 16577 . . . (<a class="docLink" href="#ch06ex17">Property 6.10</a>)</p><p></p><p class="docList">P 1 7 8 49 56 64 343 392 448 512 2401 2744 . . . (<a class="docLink" href="#ch06qa6q12">Exercise 6.44</a>)</p><p></p><p class="docList">I 1 5 19 41 109 209 505 929 2161 3905 . . . (<a class="docLink" href="#ch06qa6q13">Exercise 6.45</a>)</p></div></td></tr></table><br />
<p class="docText"><a class="docLink" href="#ch06fig13">Figure 6.13</a> shows that shellsort performs reasonably well on a variety of kinds of files, rather than just on random ones. Indeed, constructing a file for which shellsort runs slowly for a given increment sequence is a challenging exercise (see <a class="docLink" href="#ch06qa6q10">Exercise 6.42</a>). As we have mentioned, there are some bad increment sequences for which shellsort may require a quadratic number of comparisons in the worst case (see <a class="docLink" href="#ch06qa6q4">Exercise 6.36</a>), but much lower bounds have been shown to hold for a wide variety of sequences.</p>
<a name="ch06fig13"></a><p><center>
<h5 class="docFigureTitle">Figure 6.13. Dynamic characteristics of shellsort for various types of files</h5>
<h5></h5><h5></h5></center></p><p class="docText"><span class="docEmphasis">These diagrams show shellsort, with the increments 209 109 41 19 5 1, in operation on files that are random, Gaussian, nearly ordered, nearly reverse-ordered, and randomly ordered with 10 distinct key values (left to right, on the top). The running time for each pass depends on how well ordered the file is when the pass begins. After a few passes, these files are similarly ordered; thus, the running time is not particularly sensitive to the input.</span></p>
<p class="docText">
<img border="0" alt="" id="118095012104" width="300" height="290" src="06fig13.gif" /></p>
<br />
<p class="docText">Shellsort is the method of choice for many sorting applications because it has acceptable running time even for moderately large files and requires a small amount of code that is easy to get working. In the next few chapters, we shall see methods that are more efficient, but they are perhaps only twice as fast (if that much) except for large <span class="docEmphasis">N</span>, and they are significantly more complicated. In short, if you need a quick solution to a sorting problem, and do not want to bother with interfacing to a system sort, you can <span class="docEmphasis">use shellsort</span>, then determine sometime later whether the extra work required to replace it with a more sophisticated method will be worthwhile.</p>
<p class="docQandasetTitle">Exercises</p><p><table border="0" cellspacing="16" cellpadding="0"><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa6q1"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">6.33</span> Is shellsort stable?</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa6q2"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.34</span> Show how to implement a shellsort with the increments 1 8 23 77 281 1073 4193 16577 . . ., with direct calculations to get successive increments in a manner similar to the code given for Knuth's increments.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa6q3"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="9" src="triangle.jpg" /> <span class="docEmphStrong">6.35</span> Give diagrams corresponding to <a class="docLink" href="#ch06fig08">Figures 6.8</a> and <a class="docLink" href="#ch06fig09">6.9</a> for the keys E A S Y Q U E S T I O N.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa6q4"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.36</span> Find the running time when you use shellsort with the increments 1 2 4 8 16 32 64 128 256 512 1024 2048 . . . to sort a file consisting of the integers 1,2,...,<span class="docEmphasis">N</span> in the odd positions and <span class="docEmphasis">N</span> +1,<span class="docEmphasis">N</span> +2,...,2<span class="docEmphasis">N</span> in the even positions.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa6q5"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.37</span> Write a driver program to compare increment sequences for shellsort. Read the sequences from standard input, one per line, then use them all to sort <tt>10</tt> random files of size <span class="docEmphasis">N</span> for <span class="docEmphasis">N</span> = 100, 1000, and 10,000. Count comparisons, or measure actual running times.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa6q6"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">6.38</span> Run experiments to determine whether adding or deleting an increment can improve the increment sequence 1 8 23 77 281 1073 4193 16577 . . . for <span class="docEmphasis">N</span> = 10,000.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa6q7"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">6.39</span> Run experiments to determine the value of x that leads to the lowest running time for random files when the 13 is replaced by x in the increment sequence <tt>1 4 13 40 121 364 1093 3280 9841 . . .;</tt> used for <span class="docEmphasis">N</span> = 10,000.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa6q8"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.40</span> Run experiments to determine the value of <span class="docEmphasis">&#945;</span> that leads to the lowest running time for random files for the increment sequence 1,<img src="U230A.GIF" border="0" />&#945;<img src="U230B.GIF" border="0" />,<img src="U230A.GIF" border="0" />&#945;<sup>2</sup><img src="U230B.GIF" border="0" />, <img src="U230A.GIF" border="0" />&#945;<sup>3</sup><img src="U230B.GIF" border="0" />, <img src="U230A.GIF" border="0" />&#945;<sup>4</sup><img src="U230B.GIF" border="0" />, . . .; for <span class="docEmphasis">N</span> = 10,000.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa6q9"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">6.41</span> Find the three-increment sequence that uses as small a number of comparisons as you can find for random files of 1000 elements.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa6q10"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="17" height="8" src="douleblackcircle.jpg" /> <span class="docEmphStrong">6.42</span> Construct a file of 100 elements for which shellsort, with the increments 1 8 23 77, uses as large a number of comparisons as you can find.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa6q11"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">6.43</span> Prove that any number greater than or equal to <tt>(h&ndash;1)(k&ndash;1)</tt> can be expressed as a linear combination (with nonnegative coefficients) of <span class="docEmphasis">h</span> and <span class="docEmphasis">k</span>, if <span class="docEmphasis">h</span> and <span class="docEmphasis">k</span> are relatively prime. <span class="docEmphasis">Hint</span>: Show that, if any two of the first <span class="docEmphasis">h</span>&ndash;1 multiples of <span class="docEmphasis">k</span> have the same remainder when divided by <span class="docEmphasis">h</span>, then <span class="docEmphasis">h</span> and <span class="docEmphasis">k</span> must have a common factor.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa6q12"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.44</span> Run experiments to determine the values of <span class="docEmphasis">h</span> and <span class="docEmphasis">k</span> that lead to the lowest running times for random files when a Pratt-like sequence based on <span class="docEmphasis">h</span> and <span class="docEmphasis">k</span> is used for sorting 10,000 elements.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa6q13"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.45</span> The increment sequence 1 5 19 41 109 209 505 929 2161 3905 . . . is based on merging the sequences 9.4<sup><span class="docEmphasis">i</span></sup>&ndash;9.2<sup><span class="docEmphasis">i</span></sup> +1 and 4<sup><span class="docEmphasis">i</span></sup>&ndash;3.2<sup><span class="docEmphasis">i</span></sup> +1 for <span class="docEmphasis">i</span> &gt; 0. Compare the results of using these sequences individually and using the merged result, for sorting 10,000 elements.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa6q14"></a><b></b></td><td><p class="docText"><span class="docEmphStrong">6.46</span> We derive the increment sequence <tt>1 3 7 21 48 112 336 861 1968 4592 13776 . . .</tt> by starting with a base sequence of relatively prime numbers, say <tt>1 3 7 16 41 101</tt>, then building a triangle, as in Pratt's sequence, this time generating the <span class="docEmphasis">i</span>th row in the triangle by multiplying the first element in the <span class="docEmphasis">i</span>&ndash;1st row by the <span class="docEmphasis">i</span>th element in the base sequence; and multiplying every element in the <span class="docEmphasis">i</span>&ndash;1st row by the <span class="docEmphasis">i</span>+1st element in the base sequence. Run experiments to find a base sequence that improves on the one given for sorting 10,000 elements.</p></td></tr><tr><td></td><td></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa6q15"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">6.47</span> Complete the proofs of <a class="docLink" href="#ch06ex14">Properties 6.7</a> and <a class="docLink" href="#ch06ex15">6.8</a>.</p></td></tr><tr valign="top"><td align="right" class="docText" width="50"><a name="ch06qa6q16"></a><b></b></td><td><p class="docText"><img border="0" alt="" id="118095012104" width="8" height="8" src="blackcircle.jpg" /> <span class="docEmphStrong">6.48</span> Implement a shellsort that is based on the shaker sort algorithm of <a class="docLink" href="ch06lev1sec5.html#ch06qa5q5">Exercise 6.30</a>, and compare with the standard algorithm. <span class="docEmphasis">Note</span>: Your increment sequences should be substantially different from those for the standard algorithm.</p></td></tr></table></p>
<ul></ul></td></body></head></html>